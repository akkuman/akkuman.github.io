<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>工具 on Akkuman 的博客</title>
    <link>//hacktech.cn/tags/%E5%B7%A5%E5%85%B7/</link>
    <description>Recent content in 工具 on Akkuman 的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 04 Mar 2022 07:56:00 +0000</lastBuildDate><atom:link href="//hacktech.cn/tags/%E5%B7%A5%E5%85%B7/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>将Shikata ga nai带到前端</title>
      <link>//hacktech.cn/2022/03/04/shikata-ga-nai-to-wasm/</link>
      <pubDate>Fri, 04 Mar 2022 07:56:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2022/03/04/shikata-ga-nai-to-wasm/</guid>
      <description>Shikata ga nai是什么 Metasploit-Framework是一个漏洞利用框架，里面有大量的漏洞库，针对shellcode一些混淆编码器可以让用户bypass一些安全软件，其中一个比较核心的编码器是Shikata Ga Nai (SGN)。
shellcode 主要是机器码，也可以看作一段汇编指令。Metasploit 在默认配置下就会对payload进行编码。虽然 Metasploit 有各种编码器，但最受欢迎的是 SGN。日语中的短语 SGN 的意思是“无能为力”，之所以这样说，是因为它在创建时传统的反病毒产品难以检测。
检测 SGN 编码的payload很困难，尤其是在严重依赖静态检测的情况下。任何基于规则的静态检测机制基本上都无法检测到用 SGN 编码的payload。而不断扫描内存的计算成本很高，因此不太可行。这使得大多数杀软依赖于行为指标和沙箱进行检测。
为什么说带到前端 首先介绍下 EgeBalci/sgn，这个项目将msf的Shikata Ga Nai编码器移植到了Golang，使得用户可以不通过msf即可享受到SGN的能力。
既然这个项目是非平台依赖的工具，那我们可以考虑将它移植到前端，这样用户只需要打开浏览器就能用了。
移植思路 首先我们可以考虑：sgn是一个golang项目，所以我们可以编译到wasm，然后暴露api给javascript来调用，这样就可以实现前端使用sgn了。
但是遇到了一些问题。
该项目并不是一个Pure Go项目，它依赖cgo，没办法编译到wasm。
但是我记得 github.com/therecipe/qt 可以编译到wasm，通过一些研究，发现它是采用了go-js-qt的桥接，qt是可以编译到wasm的，go也可以编译到wasm，然后两者之间再桥接起来。那我们可以尝试先将 github.com/keystone-engine/keystone 编译到wasm，然后将sgn项目里面调用cgo的地方全部使用 syscall/js 桥接到keystone上去，此时sgn变成了一个Pure Go项目，可以将其编译到wasm了，然后再暴露出一个接口就可以供js使用了
实现手段 cgo到桥接 sgn里面需要使用cgo是因为依赖 github.com/EgeBalci/keystone-go，看了一下这个项目，其实是keystone的包装，keystone是一个c++写的项目，所以我们可以考虑使用 emscripten 来将keystone编译到wasm，不过该项工作已经有人做了，我们在这边就不自己再花时间搭环境编译了，可以看看 alexaltea.github.io/keystone.js/
然后我们看看sgn里面依赖cgo的地方，主要是在 pkg/sgn.go
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package sgn import ( .</description>
    </item>
    
    <item>
      <title>自建bitwarden备份同步到坚果云</title>
      <link>//hacktech.cn/2021/12/10/selfhost-bitwarden-sync-nutstore/</link>
      <pubDate>Fri, 10 Dec 2021 09:00:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2021/12/10/selfhost-bitwarden-sync-nutstore/</guid>
      <description>因为bitwarden的氪金玩家才能使用双因子认证，恰好手上有个vps，搭建个bitwarden服务端来使用2fa
自建bitwarden vps比较垃圾，所以选用一个资源开销比较小的服务端比较有必要，我这里选择的是 https://github.com/mprasil/bitwarden_rs
这里采用 docker-compose 进行部署
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 version: &amp;#39;3&amp;#39; services: bitwarden: image: bitwardenrs/server:latest container_name: bitwarden restart: unless-stopped volumes: - ./bw-data:/data environment: - WEBSOCKET_ENABLED=true - SIGNUPS_ALLOWED=true - WEB_VAULT_ENABLED=true - ADMIN_TOKEN=xxxxxxxxxxxxxxxxxxxx ports: - &amp;#34;127.0.0.1:8889:80&amp;#34; - &amp;#34;127.0.0.1:8810:3012&amp;#34; 其中的3012是websocket通知端口
WEBSOCKET_ENABLED 代表启用 websocket
SIGNUPS_ALLOWED 代表是否启用注册
WEB_VAULT_ENABLED 代表是否启用web界面
ADMIN_TOKEN 是管理界面的密码，用来启用管理界面，启用后可通过 [https://你的域名/admin](https://你的域名/admin) 进行访问
然后我们需要创建一个反向代理，这里我使用的是 nginx，下面给出 nginx 配置
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 upstream bitwarden-default { server 127.</description>
    </item>
    
    <item>
      <title>notion实现自动发布到hugo github博客</title>
      <link>//hacktech.cn/2021/12/10/notion-to-github-blog/</link>
      <pubDate>Fri, 10 Dec 2021 07:51:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2021/12/10/notion-to-github-blog/</guid>
      <description>notion是用来记录笔记的，hugo是我用来作为github博客自动构建发布的
我目前设置了一个github action是：当我的博客仓库hugo分支有push事件时，自动构建文章发布到master分支，并且发布到博客园。
但是会有这样的不便：在notion中写了一篇笔记或文章，想要发布到github静态博客上，发现需要先将文章转化成markdown，图片需要上传到图床，然后贴入markdown，然后再推送到github，等待action自动构建静态博客
既然我使用notion记录笔记，何不继续All-in-one，将notion作为我的博客发布工具。
只需要在 notion 中建立一个用于博客发布的 database，然后写完笔记后填入这个 database，再使用一些手段触发 CI 即可完成博客文章的发布
工具介绍 说干就干，写了两个工具
https://github.com/akkuman/notiontomd
https://github.com/akkuman/notion_to_github_blog
notiontomd 是用来notion中的某个page转化为markdown的库，当然，当前支持的block是有限的，详细信息可以查看该仓库
notion_to_github_blog则是一个github action模板，用来自动从指定格式的database中拉取需要更新发布的文章，然后利用 notiontomd 转化为markdown，然后推送到github仓库，再触发另外的github aciton进行博客静态文件构建
使用 怎么建仓怎么自动从某分支拉取推到github pages所在分支我就不展开说明了，感兴趣的可以去网上搜索相关资料，本文所关注的流程是从notion database到博客源文件
基础环境 本文所涉及到的例子环境可以前往我的博客仓库 https://github.com/akkuman/akkuman.github.io 进行查看
hugo分支用来存放博客源文件，其中有一个github action的功能是push时触发，然后自动构建推送到master分支
master分支用来存放hugo构建之后生成的站点静态文件
博客相关的图片我会推送到 https://github.com/akkuman/pic 仓库
hugo作为主分支，master设置为github pages分支（原因后面描述）
workflows编写 要使用该action，首先你需要在 notion 中创建一个 database，这个 database 需要有几个字段，字段名如下:
Name (title): 文章标题
Article (text): 文章链接
MDFilename (text): 创建的 markdown 文件名
Category (select): 文章分类
Tags (multi_select): 文章标签
IsPublish (checkbox): 文章是否发布
NeedUpdate (checkbox): 文章是否有更新
CreateAt (Created time): 创建时间</description>
    </item>
    
    <item>
      <title>将newsletter转为rss</title>
      <link>//hacktech.cn/2021/12/06/newsletter2rss/</link>
      <pubDate>Mon, 06 Dec 2021 08:09:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2021/12/06/newsletter2rss/</guid>
      <description>相关的开源项目 https://github.com/leafac/kill-the-newsletter
作者提供了一个网站 https://kill-the-newsletter.com/ 来提供服务，截至20211119，至少已经提供了两年的服务了，所以稳定性还可
下面就是使用方法了
选择一个你要订阅的newsletter，比如 https://random-lab.ghost.io/
打开 https://kill-the-newsletter.com/ ，输入你要给该订阅取的名字，比如我输入 1000小食报 ，然后点击 create inbox
然后会提供给你一个邮箱和一个rss订阅地址
将邮箱地址填入第一步中的订阅邮箱
将rss订阅地址加到你的rss阅读器
一般情况下你会收到的第一个订阅消息是叫你确认订阅，点击确认地址即可
下面说下原理：
首先需要有个邮服，然后每次创建inbox的时候随机生成一个邮箱，并且将此邮箱的收件箱内容转为rss订阅暴露出来</description>
    </item>
    
    <item>
      <title>网络空间检索平台对比</title>
      <link>//hacktech.cn/2021/10/27/net-search-platform-compare/</link>
      <pubDate>Wed, 27 Oct 2021 09:40:45 +0000</pubDate>
      
      <guid>//hacktech.cn/2021/10/27/net-search-platform-compare/</guid>
      <description>&lt;p&gt;最近网络空间检索平台雨后春笋般涌现，本篇文章以一个使用者的视角来做一下对比&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>metasploit使用外部数据库（TODO）</title>
      <link>//hacktech.cn/2020/09/30/msf-use-external-db/</link>
      <pubDate>Wed, 30 Sep 2020 20:36:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/09/30/msf-use-external-db/</guid>
      <description>&lt;p&gt;metasploit不能使用外部的pgsql数据库搞得一直很蛋疼，这篇小记只是记录下如何一步步让metasploit使用外部的pgsql，本篇文章中使用pgsql的docker&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TODO 笔记：msf rpc console 不能同时对一个session进行操作</title>
      <link>//hacktech.cn/2020/09/21/msf-rpc-console-cannot-opera-same-session-on-same-time/</link>
      <pubDate>Mon, 21 Sep 2020 14:34:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/09/21/msf-rpc-console-cannot-opera-same-session-on-same-time/</guid>
      <description>&lt;p&gt;感觉可能是需要对 connect_session 改动一下&lt;/p&gt;
&lt;p&gt;后面有时间验证一下&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>msf stagers开发不完全指北(四): msf 中使用域前置技术隐藏流量</title>
      <link>//hacktech.cn/2020/07/17/msf-stagers-develop-4/</link>
      <pubDate>Fri, 17 Jul 2020 18:01:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/07/17/msf-stagers-develop-4/</guid>
      <description>&lt;p&gt;前几篇都是说了下如何采用不同的语言开发 reverse_tcp 第二阶段，接下来将慢慢分析 reverse_http，这篇文章并不会围绕 stagers 进行讲解，这篇文章只是半埋上我之前挖的一个坑，关于域前置技术如何在 msf 中进行应用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>msf stagers开发不完全指北(三)</title>
      <link>//hacktech.cn/2020/06/28/msf-stagers-develop-3/</link>
      <pubDate>Sun, 28 Jun 2020 13:43:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/06/28/msf-stagers-develop-3/</guid>
      <description>&lt;h1 id=&#34;采用-python-开发stagers&#34;&gt;采用 Python 开发stagers&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>msf stagers开发不完全指北(二)</title>
      <link>//hacktech.cn/2020/06/28/msf-stagers-develop-2/</link>
      <pubDate>Sun, 28 Jun 2020 13:40:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/06/28/msf-stagers-develop-2/</guid>
      <description>&lt;h1 id=&#34;采用-golang-开发stagers&#34;&gt;采用 Golang 开发stagers&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>msf stagers开发不完全指北(一)</title>
      <link>//hacktech.cn/2020/06/23/msf-stagers-develop-1/</link>
      <pubDate>Tue, 23 Jun 2020 18:19:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/06/23/msf-stagers-develop-1/</guid>
      <description>&lt;h1 id=&#34;采用c开发stagers&#34;&gt;采用c开发stagers&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>metasploit payload运行原理浅析(sockedi调用约定是什么)</title>
      <link>//hacktech.cn/2020/05/09/what-is-sockedi-call-convention-in-msf/</link>
      <pubDate>Sat, 09 May 2020 17:39:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/05/09/what-is-sockedi-call-convention-in-msf/</guid>
      <description>&lt;p&gt;本篇文章主要讨论一下msf官方文档中提到的sockedi调用约定到底是指什么?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>msf的rpc和json-rpc，我该选择哪个？</title>
      <link>//hacktech.cn/2020/05/07/msf-rpc-and-jsonrpc-compare/</link>
      <pubDate>Thu, 07 May 2020 18:59:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/05/07/msf-rpc-and-jsonrpc-compare/</guid>
      <description>&lt;p&gt;msf的rpc有两种调用方式，那么我们应该调用哪一个呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何用Golang写msf插件模块</title>
      <link>//hacktech.cn/2020/02/14/write-msf-module-in-go/</link>
      <pubDate>Fri, 14 Feb 2020 14:16:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/02/14/write-msf-module-in-go/</guid>
      <description>&lt;p&gt;最近有空在看msf，发现msf里面有模块的源码是golang的，去翻了翻wiki，wiki上面的编写日期是2018.12.13，搜了下国内，好像没有这方面的文章，那就自己跟着做做记个笔记&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python内存加载shellcode</title>
      <link>//hacktech.cn/2019/11/13/run-shellcode-in-py/</link>
      <pubDate>Wed, 13 Nov 2019 17:14:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2019/11/13/run-shellcode-in-py/</guid>
      <description>生成 首先生成一个测试的msf shellcode
1 msfvenom -p windows/x64/exec CMD=calc.exe -f python 把其中的shellcode复制出来留待待会使用
原理 大部分脚本语言加载 shellcode 其实都是通过 c 的 ffi 去调用操作系统的api，其实并没有太多的技巧在里面，明白了原理，只需要查一下对应的脚本语言怎么调用 c 即可。
那么我们只需要明白 c 通常是怎么加载 shellcode 的即可一通百通。
那么 c 是怎么加载 shellcode 呢，我们直接从汇编开始探究。
shellcode 这个东西我们明白是一串可执行的二进制（一般可执行文件的拥有可执行权限的section为.text），那么我们先通过其他的手段开辟一片拥有可读可写可执行权限的区域放入我们的 shellcode，然后跳转到 shellcode 首地址去执行就行了，汇编里面改变eip（即当前指令的下一条即将运行指令的虚拟地址）的方法有不少，最简单的就是直接 jmp 过去了。也就是写成伪码大概意思就是（动态申请内存就不写了）
1 2 lea eax, shellcode; jmp eax; 那么我们用 c 怎么表示呢？我这里也写一段伪码（因为本文的重点并不是在于 c 代码的编写）
那么按照刚才的思路，先申请一块可执行的内存，放入 shellcode 然后跳转过去执行即可。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // shellcode unsigned char shellcode[] = &amp;#34;\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9&amp;#34; &amp;#34;\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08&amp;#34; &amp;#34;\x8b\x7e\x20\x8b\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1&amp;#34; .</description>
    </item>
    
  </channel>
</rss>
