<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>红队 on Akkuman 的博客</title>
    <link>//hacktech.cn/tags/%E7%BA%A2%E9%98%9F/</link>
    <description>Recent content in 红队 on Akkuman 的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 22 Jul 2021 02:01:02 +0000</lastBuildDate><atom:link href="//hacktech.cn/tags/%E7%BA%A2%E9%98%9F/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>golang实现dll恶意劫持转发</title>
      <link>//hacktech.cn/2021/07/22/golang-evil-dll-proxy/</link>
      <pubDate>Thu, 22 Jul 2021 02:01:02 +0000</pubDate>
      
      <guid>//hacktech.cn/2021/07/22/golang-evil-dll-proxy/</guid>
      <description>&lt;p&gt;本文章将讲解如何使用恶意的 Golang 来实现 dll 劫持转发&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>metasploit使用外部数据库（TODO）</title>
      <link>//hacktech.cn/2020/09/30/msf-use-external-db/</link>
      <pubDate>Wed, 30 Sep 2020 20:36:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/09/30/msf-use-external-db/</guid>
      <description>&lt;p&gt;metasploit不能使用外部的pgsql数据库搞得一直很蛋疼，这篇小记只是记录下如何一步步让metasploit使用外部的pgsql，本篇文章中使用pgsql的docker&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TODO 笔记：msf rpc console 不能同时对一个session进行操作</title>
      <link>//hacktech.cn/2020/09/21/msf-rpc-console-cannot-opera-same-session-on-same-time/</link>
      <pubDate>Mon, 21 Sep 2020 14:34:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/09/21/msf-rpc-console-cannot-opera-same-session-on-same-time/</guid>
      <description>&lt;p&gt;感觉可能是需要对 connect_session 改动一下&lt;/p&gt;
&lt;p&gt;后面有时间验证一下&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>msf stagers开发不完全指北(四): msf 中使用域前置技术隐藏流量</title>
      <link>//hacktech.cn/2020/07/17/msf-stagers-develop-4/</link>
      <pubDate>Fri, 17 Jul 2020 18:01:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/07/17/msf-stagers-develop-4/</guid>
      <description>&lt;p&gt;前几篇都是说了下如何采用不同的语言开发 reverse_tcp 第二阶段，接下来将慢慢分析 reverse_http，这篇文章并不会围绕 stagers 进行讲解，这篇文章只是半埋上我之前挖的一个坑，关于域前置技术如何在 msf 中进行应用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>msf stagers开发不完全指北(三)</title>
      <link>//hacktech.cn/2020/06/28/msf-stagers-develop-3/</link>
      <pubDate>Sun, 28 Jun 2020 13:43:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/06/28/msf-stagers-develop-3/</guid>
      <description>&lt;h1 id=&#34;采用-python-开发stagers&#34;&gt;采用 Python 开发stagers&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>msf stagers开发不完全指北(二)</title>
      <link>//hacktech.cn/2020/06/28/msf-stagers-develop-2/</link>
      <pubDate>Sun, 28 Jun 2020 13:40:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/06/28/msf-stagers-develop-2/</guid>
      <description>&lt;h1 id=&#34;采用-golang-开发stagers&#34;&gt;采用 Golang 开发stagers&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>msf stagers开发不完全指北(一)</title>
      <link>//hacktech.cn/2020/06/23/msf-stagers-develop-1/</link>
      <pubDate>Tue, 23 Jun 2020 18:19:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/06/23/msf-stagers-develop-1/</guid>
      <description>&lt;h1 id=&#34;采用c开发stagers&#34;&gt;采用c开发stagers&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>metasploit payload运行原理浅析(sockedi调用约定是什么)</title>
      <link>//hacktech.cn/2020/05/09/what-is-sockedi-call-convention-in-msf/</link>
      <pubDate>Sat, 09 May 2020 17:39:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/05/09/what-is-sockedi-call-convention-in-msf/</guid>
      <description>&lt;p&gt;本篇文章主要讨论一下msf官方文档中提到的sockedi调用约定到底是指什么?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>msf的rpc和json-rpc，我该选择哪个？</title>
      <link>//hacktech.cn/2020/05/07/msf-rpc-and-jsonrpc-compare/</link>
      <pubDate>Thu, 07 May 2020 18:59:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/05/07/msf-rpc-and-jsonrpc-compare/</guid>
      <description>&lt;p&gt;msf的rpc有两种调用方式，那么我们应该调用哪一个呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何用Golang写msf插件模块</title>
      <link>//hacktech.cn/2020/02/14/write-msf-module-in-go/</link>
      <pubDate>Fri, 14 Feb 2020 14:16:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2020/02/14/write-msf-module-in-go/</guid>
      <description>&lt;p&gt;最近有空在看msf，发现msf里面有模块的源码是golang的，去翻了翻wiki，wiki上面的编写日期是2018.12.13，搜了下国内，好像没有这方面的文章，那就自己跟着做做记个笔记&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python内存加载shellcode</title>
      <link>//hacktech.cn/2019/11/13/run-shellcode-in-py/</link>
      <pubDate>Wed, 13 Nov 2019 17:14:00 +0000</pubDate>
      
      <guid>//hacktech.cn/2019/11/13/run-shellcode-in-py/</guid>
      <description>生成 首先生成一个测试的msf shellcode
1 msfvenom -p windows/x64/exec CMD=calc.exe -f python 把其中的shellcode复制出来留待待会使用
原理 大部分脚本语言加载 shellcode 其实都是通过 c 的 ffi 去调用操作系统的api，其实并没有太多的技巧在里面，明白了原理，只需要查一下对应的脚本语言怎么调用 c 即可。
那么我们只需要明白 c 通常是怎么加载 shellcode 的即可一通百通。
那么 c 是怎么加载 shellcode 呢，我们直接从汇编开始探究。
shellcode 这个东西我们明白是一串可执行的二进制（一般可执行文件的拥有可执行权限的section为.text），那么我们先通过其他的手段开辟一片拥有可读可写可执行权限的区域放入我们的 shellcode，然后跳转到 shellcode 首地址去执行就行了，汇编里面改变eip（即当前指令的下一条即将运行指令的虚拟地址）的方法有不少，最简单的就是直接 jmp 过去了。也就是写成伪码大概意思就是（动态申请内存就不写了）
1 2 lea eax, shellcode; jmp eax; 那么我们用 c 怎么表示呢？我这里也写一段伪码（因为本文的重点并不是在于 c 代码的编写）
那么按照刚才的思路，先申请一块可执行的内存，放入 shellcode 然后跳转过去执行即可。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // shellcode unsigned char shellcode[] = &amp;#34;\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9&amp;#34; &amp;#34;\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08&amp;#34; &amp;#34;\x8b\x7e\x20\x8b\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1&amp;#34; .</description>
    </item>
    
  </channel>
</rss>
